/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2012 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

bool __thiscall army::CanFit(army *this, int hex, int mayShiftTwoHexers, int *rearHex);
signed int __thiscall army::ValidFlight(army *this, int hex, int flag); // idb
signed int __thiscall army::FlyTo(int this);
signed int __thiscall army::FlyTo(void *this, signed int hexIdx);
void __thiscall soundManager::CDStop(soundManager *this); // idb
bool __thiscall soundManager::CDIsPlaying(soundManager *this); // idb
void __thiscall soundManager::CDStartup(soundManager *this); // idb
void __thiscall soundManager::CDShutdown(soundManager *this); // idb
void __thiscall soundManager::CDSetVolume(soundManager *this, int a2, int a3); // idb
void __thiscall soundManager::CDPlay(soundManager *this, int a2, signed int a3, int a4, int a5);
void __thiscall soundManager::CDPoll(int ecx0);
int __stdcall soundManager::ConvertVolume(int weight, int ifForMusicThen101); // idb
int __stdcall SetReady2Poll(unsigned __int32 a1);
int __stdcall UpdateTimers(unsigned __int32 a1);
soundManager *__thiscall soundManager::soundManager(soundManager *ecx0);
HDIGDRIVER __fastcall WAVE_init_driver(DWORD samplesPerSec, unsigned __int16 bitsPerSample, WORD nChannels, __int16 a4);
int __thiscall soundManager::Open(soundManager *this, int a2); // idb
void __thiscall soundManager::AllocateSampleHandles(soundManager *this); // idb
void __thiscall soundManager::Close(soundManager *this);
int __stdcall soundManager::Main(int a1);
int __stdcall sub_403580(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __thiscall soundManager::StopAllSamples(soundManager *this, int a2);
void __thiscall soundManager::StopSample(soundManager *this, HSAMPLE a2); // idb
void __thiscall soundManager::ModifySample(soundManager *this, HSAMPLE S, __int16 a3, int weight);
signed __int32 __thiscall soundManager::DigitalReport(soundManager *this, HSAMPLE samp, __int16 always4); // idb
void __thiscall soundManager::AdjustSoundVolumes(soundManager *ecx0);
void __thiscall soundManager::AdjustMusicVolumes(int this);
void __thiscall soundManager::ForcePollSound(int this);
char __thiscall soundManager::SetMusicQuality(int this, int a2);
char __thiscall soundManager::PlayAmbientMusic(int this, int track, signed int a3, int a4);
void __thiscall soundManager::PollSound(soundManager *this); // idb
void __thiscall soundManager::SwitchAmbientMusic(soundManager *this, int track);
HSAMPLE __thiscall soundManager::MemorySample(soundManager *this, sample *a2);
// void __cdecl unknown_libname_1();
void __cdecl soundManager::ServiceSound();
bool __thiscall soundManager::MusicPlaying(soundManager *this); // idb
signed int __stdcall dpEnumServiceProvider(int a1, const CHAR *prefix, int a3, int a4, int a5);
signed int __stdcall dpEnumSession(int a1, int a2, int a3, char a4);
__int16 __cdecl dpnet_init();
// void __cdecl _cfltcvt_init();
void __cdecl dpnet_term();
void __fastcall dpSendMessage(int a1, char a2, unsigned __int16 a3, const void *a4);
int __fastcall dpnet_snd(int a1, unsigned __int16 a2, const void *a3);
__int16 __stdcall dpnet_rcv(void *a1);
int __cdecl _ismbbkpunct(unsigned int);
__int16 __cdecl sub_404E80();
void __cdecl dpProcessMessages();
void __fastcall dpEvaluateMessage(int a1, int a2);
signed int __cdecl dpWaitForFirstGuest();
int __cdecl dpWaitForExtraGuests();
signed int __cdecl dpWaitForHost();
void __fastcall DPSD(signed int a1, int a2, int a3);
int __thiscall army::FindPath(army *this, int knownHex, int targHex, int speed, int flying, int flag); // idb
signed int __thiscall army::ValidPath(army *this, int hex, int flag); // idb
int __thiscall army::GetMoveMask(army *this, int targHex); // idb
int __thiscall army::GetAttackMask(army *this, int hex, int a3, int a4); // idb
int __cdecl _atoldbl(_LDOUBLE *Result, char *Str);
bool __thiscall army::ValidMove(army *this, int hexIdx, signed int neighborIdx);
signed int __thiscall army::ValidAttack(army *this, int knownHex, signed int neighborIdx, int focusLevel, int a5, int *neighbor); // idb
signed int __thiscall army::GetAdjacentCellIndex(army *this, int knownHex, signed int hexIdx); // idb
signed int __fastcall GetAdjacentCellIndexNoArmy(int hexIdx, signed int neighborIdx); // idb
bool __thiscall army::ValidRange(void *ecx0, int destHex);
int __stdcall loc_406BE3(int); // weak
int __fastcall OppositeDirection(signed int a1);
signed int __stdcall army::GetBestDirection(signed int curHex, signed int destHex, char mask); // idb
baseManager *__thiscall highScoreManager::highScoreManager(baseManager *ecx0);
int __thiscall highScoreManager::Open(int this, int a2);
void *__thiscall highScoreManager::Close(void *this);
signed int __thiscall highScoreManager::Main(void *this, int a2);
int __thiscall highScoreManager::Update(int this);
int __fastcall SetupRecruitWin(heroWindow *window, int creature, int goldCost, int specialResource, int resourceAmt, int numAvail); // idb
int __thiscall recruitUnit::Open(void *this, int a2);
void __thiscall recruitUnit::Close(int this);
int __thiscall recruitUnit::Update(int this);
signed int __thiscall recruitUnit::Main(int this, int a2);
recruitUnit *__thiscall recruitUnit::recruitUnit(recruitUnit *this, armyGroup *armyGrp, int creature, int available); // idb
recruitUnit *__thiscall recruitUnit::recruitUnit(recruitUnit *this, int a2, int a3, int a4);
void __fastcall QuickViewRecruit(town *castle, int dwellingIdx); // idb
strip *__thiscall strip::strip(strip *this, int x, int y, int a4, int portraitFileID, int portraitIconIdx, armyGroup *armyGrp, __int16 fieldIDStart, int redraw, int a10); // idb
void __thiscall strip::_strip(strip *this);
void __thiscall strip::Draw(int this);
void __thiscall strip::DrawIcons(strip *this, int updateScreen); // idb
int __thiscall strip::DrawFrame(strip *this);
bankBox *__thiscall bankBox::bankBox(bankBox *this, __int16 x, __int16 y, playerData *player);
BOOL __thiscall bankBox::_bankBox(bankBox *this);
void __thiscall bankBox::Update(bankBox *this, int updateScreen); // idb
void __thiscall townManager::SetupCastle(townManager *this, heroWindow *window, int a3); // idb
signed int __thiscall CastleHandler(void *this);
signed int __fastcall GetMapHeader(char *name, SMapHeader *hdr); // idb
// signed int __cdecl unknown_libname_2();
signed int __cdecl ShowThisMapGame();
// signed int __cdecl ShowThisMap();
int __thiscall fileRequester::InitializeFiles(void *this, int a2, int a3, int a4);
fileRequester *__thiscall fileRequester::fileRequester(fileRequester *this, int a2, int a3, int a4, char *a5, char *a6, char *a7);
bool __thiscall fileRequester::MapExistsForFilter(void *this, int a2);
int __thiscall fileRequester::SetupFiles(int this);
int __thiscall fileRequester::CleanUpData(int this);
int __thiscall fileRequester::Close(int this);
int __thiscall fileRequester::Open(void *this, int a2);
int __thiscall fileRequester::SetOK(int this, int a2);
signed int __thiscall fileRequester::Main(int this, int a2);
void __thiscall fileRequester::DoKnob(int this);
void __thiscall fileRequester::Update(int this, int a2);
int __thiscall fileRequester::GetFilename(int this);
char __cdecl InitNetHost();
char __cdecl InitNetGuest();
char __cdecl WaitForHost();
char __cdecl WaitForGuest();
int __cdecl nbnet_init();
BOOL __thiscall DoTradingPost(void *this, int a2);
void __thiscall UpdateTradingPost(void *this);
int __fastcall ComputeTradeRatios(int a1, int a2, int a3, int a4, int a5);
void __stdcall DoTradeKnob(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl SetupNewTrade();
signed int __thiscall TradingPostHandler(tag_message *this);
int __thiscall combatManager::ViewGeneral(combatManager *this, int a2, int a3, int a4);
signed int __thiscall HandleViewGeneral(tag_message *this);
int __thiscall combatManager::ViewArmy(void *this, int a2, int a3);
BuildingDisplay *__thiscall townObject::townObject(BuildingDisplay *this, int faction, int buildingCode, char *filename);
void __thiscall townObject::_townObject(BuildingDisplay *this);
void __thiscall townObject::Draw(BuildingDisplay *this, int advanceAnimations);
townManager *__thiscall townManager::townManager(townManager *this);
town *__thiscall townManager::SetupExtraStuff(townManager *this);
int __thiscall townManager::Open(townManager *this, int idx); // idb
void __thiscall townManager::ChangeTown(townManager *this);
void __thiscall townManager::SetupTown(townManager *this);
townManager *__thiscall townManager::UnloadTown(townManager *this);
void __thiscall townManager::Close(townManager *this);
void __thiscall townManager::SetArmyCommand(townManager *this, int a2);
void __thiscall townManager::SetCommandAndText(townManager *this, GUIMessage *evt);
void __thiscall townManager::ShowText(townManager *this, char *msg); // idb
signed int __thiscall townManager::Main(int ecx0, GUIMessage *evt);
int __thiscall townManager::DoCommand(townManager *this, int a2);
void __thiscall townManager::RedrawTownScreen(townManager *this);
heroWindowManager *__thiscall townManager::SplitArmy(void *this);
void __cdecl townManager::ShiftQualChange();
int __thiscall townManager::ResetStrips(int this);
int __thiscall sub_414980(int this, int a2);
void __thiscall townManager::DrawTown(townManager *this, int a2, int a3);
bool __thiscall townManager::BuyBuild(void *this, signed int a2, int a3, int a4);
void __thiscall townManager::BuildObj(townManager *this, signed int buildingCode); // idb
void __thiscall townManager::SetupMage(townManager *this, heroWindow *mageGuildWindow);
signed int __fastcall MageGuildHandler(tag_message *evt);
bool __thiscall townManager::RecruitHero(townManager *this, int a2, int a3);
signed int __fastcall TavernHandler(Event *this);
BOOL __thiscall townManager::DoTavern(townManager *this);
signed int __thiscall SplitArmyHandler(Event *this);
void __thiscall townManager::SetupWell(townManager *this, heroWindow *window);
int __stdcall townManager::SetupThievesGuild(heroWindow *window, int strength); // idb
void __fastcall GetCategoryStats(int row, int *playerStats, char *playerIndices);
int __fastcall SortStats(int *playerStats, char *playerIndices); // idb
signed int __thiscall playerData::Write(playerData *this, int fd); // idb
signed int __thiscall playerData::Read(playerData *this, int fd);
signed int __thiscall playerData::NextHero(playerData *this, int a2);
signed int __thiscall playerData::HasMobileHero(playerData *this);
int __fastcall GetNumObelisks(int playerIdx);
int __thiscall playerData::BuildingsOwned(int this, int a2, signed int a3, int a4);
int __thiscall playerData::NumOfGivenArtifact(playerData *this, ARTIFACT artifact); // idb
int __thiscall game::MineTypesOwned(game *this, int a2, int a3);
char __fastcall ComputeUALoc(int a1);
int __thiscall game::SetupPuzzlePieces(game *this, int playerNo, int isAi); // idb
bool __thiscall game::IsMobile(game *this, int a2);
fullMap *__thiscall game::GetWorldMapData(game *this);
signed int __thiscall game::CreateBoat(game *this, unsigned int x, unsigned int y, int doSend); // idb
signed int __thiscall game::Scan(game *this, signed __int8 *a1, int start, int len);
signed int __stdcall game::RandomScan(int a1, int a2, int a3, int a4, char a5);
int __thiscall game::GetNewHeroId(game *this, int playerIdx, signed int faction, int getPowerfulHero); // idb
signed int __thiscall game::GetTownId(game *this, int x, int y); // idb
signed int __thiscall game::GetMineId(game *this, int a2, int a3);
void __fastcall GenerateStandardFileName(char *a1, char *a2);
signed int __thiscall game::SaveGame(game *this, const char *saveFile, int autosave, char baseGame); // idb
int __thiscall game::SetupOrigData(game *this);
void __thiscall game::LoadGame(game *this, char *filnam, int isNewGame, int a4); // idb
void __thiscall game::GiveTroopsToNeutralTown(game *this, int castleIdx);
void __thiscall game::GiveTroopsToNeutralTowns(game *this);
void __thiscall game::NewMap(game *this, char *name);
int __thiscall game::RandomizeEvents(game *this);
void __cdecl game::InitializePasswords();
void __thiscall game::RandomizeBarrier(game *this, mapCell *cell);
unsigned int __cdecl game::RandomizePassword();
int __thiscall game::LoadMap(game *this, char *nam); // idb
void __thiscall game::ClaimTown(game *this, int castleIdx, int playerIdx, int a4); // idb
void __thiscall game::ClaimMine(game *this, int idx, int color);
int game::ViewSpells(...);
int __thiscall game::UpdateSpellWidgets(int this);
int __thiscall ViewSpellsHandler(tag_message *msg); // idb
signed int __thiscall ViewSpecialHandler(void *this);
BOOL __thiscall game::ViewArmy(game *this, int a2, int a3, CREATURES creat, signed int a5, int a6, int a7, unsigned int a8, int a9, hero *hro, int a11, armyGroup *a12, int a13);
signed int __thiscall ViewArmyHandler(void *this);
int __thiscall game::GetRandomNumTroops(game *, int creat);
void __cdecl game::TurnOnAIMusic();
void __cdecl game::TurnOffAIMusic();
void __thiscall game::NextPlayer(game *this);
int __thiscall game::ComputeDailyGold(game *this, int playerIdx); // idb
void __thiscall game::PerDay(game *this);
void __thiscall game::PerWeek(game *this);
__int16 __stdcall game::WeeklyRecruitSite(int a1);
unsigned __int16 __stdcall game::WeeklyGenericSite(mapCell *a1);
void __thiscall game::PerMonth(game *this);
void __thiscall game::ConvertObject(game *this, int x1, int y1, int x2, int y2, int fromObjTileset, signed int fromObjIndexLow, signed int fromObjIndexHigh, char toObjTileset, char toObjectIndexLow, int fromObjType, char toObjType);
int __thiscall game::RandomizeTown(void *this, int a2, int a3, int a4);
int __thiscall game::RandomizeMine(int this, int a2, int a3);
int __thiscall game::InitRandomArtifacts(game *this);
int __thiscall game::GetRandomArtifactId(game *this, char allowedLevels, int allowNegatives);
bool __fastcall IsCursedItem(int art);
void __thiscall game::RandomizeHeroPool(game *this);
int __thiscall game::SetRandomHeroArmies(void *this, _DWORD a2, unsigned int a3);
int __thiscall game::ProcessRandomObjects(game *this);
int __thiscall game::SetVisibility(game *, int x, int y, int playerIdx, signed int radius);
void __thiscall game::MakeAllWaterVisible(game *this, char playerIdx);
void __stdcall game::GiveArmy(armyGroup *arm, int creatureType, int amt, signed int slot);
int __stdcall game::ExperienceValueOfStack(int a1, int a2);
int __stdcall game::GetLuck(hero *hro, army *stack, town *castle); // idb
void __thiscall game::SetupAdjacentMons(game *);
void __cdecl game::CancelComputerScreen();
void __cdecl game::ShowComputerScreen();
void __cdecl game::ShowHeroesLogo();
void __stdcall game::WaitForPlayer(char *a1, int a2);
signed int __thiscall game::HasLateOverlay(game *this, int x, int y); // idb
void __thiscall game::ConvertFlagToLateOverlay(game *this, int x, int y);
signed int __thiscall game::HasObjectTilesetIndex(game *this, int x, int y, int tset, int index); // idb
void __thiscall game::ConvertAllToLateOverlay(game *this, int x, int y);
int __thiscall game::ProcessMapExtra(game *this);
void __thiscall game::SetupTowns(game *this);
void *__thiscall game::ProcessOnMapHeroes(game *this);
void __thiscall game::CheckHeroConsistency(game *this);
signed int __thiscall game::TransmitSaveGame(void *this, int a2, int a3, int a4);
signed int __stdcall game::ReceiveSaveGame(size_t a1, int a2, int a3, int a4);
void __thiscall game::DoNewTurn(game *this);
int __thiscall game::GetBoatsBuilt(game *this);
int __thiscall game::getNumberOfThievesGuilds(game *this, int playerIdx); // idb
signed int __thiscall game::CalcDifficultyRating(game *this);
int __fastcall CalcBaseScore(signed int a1);
__int16 __stdcall game::RestoreCell(int a1, int a, int a2, __int16 a3, int a4, int a5);
void *__thiscall game::SetMapSize(game *this, int w, int h);
int __fastcall WriteDiffHeaderInfo(char a1, signed int a2, int a3, int a4);
int __fastcall GetSkipCopyLen(int a1, int a2);
void __fastcall CreateDiffFile(int a1, int a2, int a3, int a4, int a5);
void __fastcall CreateJoinFile(int a1, int a2, int a3);
signed int __stdcall game::HeroIDToHeroPos(int a1, int a2);
signed int __stdcall getCastleOwnedIdx(playerData *player, int castleIdx); // idb
void __thiscall game::SetupNewRumour(game *this);
void *__fastcall GetMapEvent(int x, int y); // idb
game *__thiscall game::CheckForTimeEvent(game *this);
int __cdecl CheckValidAvailableHeroes();
int __thiscall CalcFileCRC(const char *this);
void __cdecl CompressTest2();
void __cdecl CompressTest();
void __cdecl CompressTest3();
int __thiscall game::CountShrines(game *this, int a2);
void __cdecl PollSound();
void __cdecl ForcePollSound();
void __fastcall InitMainClasses();
void *__cdecl DeleteMainClasses();
void __fastcall EarlyShutdown(const CHAR *a1, const CHAR *a2);
void __fastcall SetupCDRom();
signed int __cdecl EarlySetup();
int __cdecl oldmain();
char __fastcall toupper(char c); // idb
signed int __cdecl InterpretCommandLine();
signed int __thiscall InitMenuHandler(tag_message *msg);
// signed int __cdecl NullHandler();
signed int __fastcall RecruitHeroHandler(tag_message *msg);
char *__fastcall GetBuildingInfo(int faction, signed int building, int withTitle); // idb
char *__fastcall GetBuildingName(int faction, signed int building); // idb
void *__fastcall GetBuildingCost(int a1, signed int a2, void *a3, int a4);
char *__fastcall GetMonsterName(int creature); // idb
void __fastcall GetMonsterCost(int mon, int *const costs);
bool __fastcall CanBuild(unsigned int *a1, signed int a2);
signed int __fastcall CanBuy(int a1, signed int a2);
int __fastcall GetBuildingBaseResourceValue(int a1, signed int a2, int a3);
signed int __thiscall WaitHandler(tag_message *this);
signed int __fastcall EventWindowHandler(tag_message *this);
signed int __fastcall TrueFalseDialogHandler(tag_message *this);
void __fastcall PlayerDead(int playerNo); // idb
void __fastcall CheckEndGame(int a1, int a2);
void __cdecl QuickViewWait();
void __cdecl InitVars();
heroWindow *__stdcall game::ShowMoraleInfo(int a1, int a2);
heroWindow *__stdcall game::ShowLuckInfo(int a1, int a2);
void __cdecl ClearMapExtra();
_DWORD __fastcall GetMonType(signed int a1, _DWORD a2);
int __fastcall AddScoreToHighScore(int a1, int a2, int a3, int a4, const char *a5);
int __fastcall BVResMsg(const char *a1, int a2, int a3);
void __thiscall GOut(void *this);
signed int __thiscall NetPosToGamePos(void *this);
signed int __cdecl WaitForOtherPlayer();
void __fastcall PopNetBox(const char *a1, void *a2);
char __fastcall AddNetBoxLine(const char *a1, char a2);
void __thiscall ShutDown(char *this);
void __fastcall FileError(void *this);
void __fastcall SmackFade(const void *a1, void *a2);
void *__thiscall ShowCongrats(void *this);
const void *__cdecl CongratsWait();
__int64 __thiscall LoadPlaySample(const char *this);
void __thiscall WaitEndSample(void *this, resource *res, HSAMPLE samp);
void __cdecl MemError();
char *__fastcall GetTownName(int idx); // idb
icon *__cdecl LoadSystemwideIcons();
void __cdecl UnloadSystemwideIcons();
// void __cdecl EarlyShutDownSystem();
bool __cdecl GameUnsaved();
signed int __fastcall HandleAppSpecificMenuCommands(signed int a1, int a2);
void __cdecl UpdateSystemOptionsMenu();
BOOL __cdecl CleanUpMenus();
void __thiscall UpdateAppSpecificMenus(HMENU menu);
void __stdcall EarlyResizeWindow(int a1, int a2);
bool __fastcall InMapArea(signed int a1, signed int a2);
int __fastcall SetupDynamicWindow(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8, int *a9, int a10, int a11, int a12, int a13, int *a14, int a15);
BOOL __fastcall TestDynamicWindow(int a1, int a2);
void __fastcall HandleRemoteDeadPlayerExit(int a1);
void __cdecl HandleRemoteSuddenExit();
int __cdecl DropDownToOnePlayer();
heroWindow *__fastcall ReceiveHostReportsPlayerExit(int a1, int a2, int a3, int a4);
void __stdcall ReceiveRemotePlayerExit(int a1, int a2);
signed int __cdecl CheckMem();
int __fastcall GetManaCost(int spell, hero *hro);
void __fastcall SetWinText(heroWindow *window, int screenIdx);
void __cdecl CheckShingleUpdate();
heroWindow *__fastcall NormalDialog(char *msg, int a2, int x, int y, int img1Type, int img1Arg, int img2Type, int img2Arg, int writeOr, signed int a10);
void __thiscall UpdateNormalDialog(void *this);
signed int __thiscall combatManager::Main(combatManager *this, tag_message *evt);
bool __thiscall combatManager::ValidHexToStandOn(combatManager *this, signed int a2);
combatManager *__thiscall combatManager::SetCombatDirections(combatManager *this, int hexIdx);
void __thiscall combatManager::CheckSetMouseDirection(combatManager *this, int a2, int a3, signed int a4);
signed int __stdcall combatManager::GetPointer(signed int a1, int a2);
signed int __thiscall combatManager::ProcessCombatMsg(combatManager *this, tag_message *evt);
signed int __thiscall combatManager::IsNegationSphereInEffect(combatManager *this);
combatManager *__thiscall combatManager::ResetRound(combatManager *this);
signed int __thiscall combatManager::CheckWin(combatManager *this, tag_message *evt); // idb
signed int __thiscall combatManager::GetCommand(combatManager *this, int hex);
int __thiscall combatManager::RightClick(int this, signed int a2);
void __thiscall combatManager::DoCommand(int this, __int32 a2);
signed int __thiscall WinCombatHandler(tag_message *this);
signed int __thiscall combatManager::ClearWinLoseBottom(void *this, void *a2);
void __thiscall combatManager::ShowWinLoseArtifact(combatManager *this, int a2, int a3);
void __thiscall combatManager::ShowSkeletons(combatManager *this, int a2);
void __thiscall combatManager::ShowEagleEyeSpell(int this, int a2);
void __thiscall combatManager::ShowDeadArmies(combatManager *this, heroWindow *window); // idb
int __thiscall combatManager::DoVictory(combatManager *this, signed int side); // idb
void __thiscall combatManager::DoLoseWindow(combatManager *this);
bool __thiscall combatManager::DoSurrender(combatManager *this);
void __thiscall combatManager::CheckChangeSelector(combatManager *this);
void __thiscall combatManager::CheckCastleAttack(combatManager *this);
void __thiscall combatManager::CheckGetAIMove(combatManager *this);
void __thiscall combatManager::GetControl(combatManager *this);
void __thiscall combatManager::ResetMouse(combatManager *this);
int __thiscall combatManager::ProcessNextAction(combatManager *this, tag_message *a2);
void __thiscall combatManager::ResetCyclingCreatures(combatManager *this);
void __thiscall combatManager::ResetCycleTimers(combatManager *this);
bool __fastcall InCombatArea(signed int x, signed int y); // idb
signed __int64 __thiscall combatManager::CycleCombatScreen(combatManager *this);
void __thiscall combatManager::SetCombatViewArmySmallLevel(combatManager *this, int level); // idb
void __thiscall combatManager::SetCombatGrid(combatManager *this, int a2, int a3, LONG a4);
void __thiscall combatManager::AddArmy(combatManager *this, int side, int creat, int num, int hex, int attrs, int a7);
void __thiscall combatManager::SetupSmallView(combatManager *this);
heroWindow *__thiscall combatManager::ViewBallista(combatManager *this, unsigned int a2);
advManager *__thiscall advManager::advManager(advManager *this);
int __thiscall advManager::Open(advManager *this, int idx);
void *__thiscall advManager::Close(void *this);
void __thiscall advManager::GetCursorSampleSet(advManager *this, signed int speed); // idb
mapCell *__thiscall advManager::DoAdvCommand(advManager *this);
void __thiscall advManager::CheckSetEvilInterface(void *this, int a2, int a3);
signed int __thiscall advManager::Main(advManager *this, tag_message *evt);
int __stdcall loc_444C90(tag_message *evt); // weak
void __stdcall advManager::Reseed(int a1, int a2);
signed int __thiscall advManager::ProcessSelect(int this, tag_message *evt, int a3); // idb
signed int __thiscall advManager::ProcessDeSelect(advManager *this, GUIMessage *evt, int a3, int a4);
signed int __thiscall advManager::ProcessSearch(advManager *this, __int64 a2);
signed int __thiscall advManager::ProcessHover(void *this, signed int a2, signed int a3);
void __thiscall advManager::UpdateScreen(advManager *this, int a2, int a3);
void __thiscall advManager::CompleteDraw(advManager *ecx0, int left, int top, int a6, int a5);
void __thiscall advManager::CompleteDraw(advManager *this, int a4);
_DWORD __stdcall advManager::GetCloudLookup(_DWORD, _DWORD); // weak
void __thiscall advManager::DrawCell(advManager *this, int x, int y, int a3, int a4, char a5, int a6);
mapCell *__thiscall advManager::GetCell(advManager *this, int col, int row);
void __thiscall advManager::UpdateRadar(advManager *this, int a2, int a3);
BOOL __thiscall advManager::QuickInfo(advManager *ecx0, int a2, int a3);
void __thiscall advManager::UpdateHeroLocator(advManager *this, int a2, int a3, int a4);
void __thiscall advManager::UpdateHeroLocators(advManager *this, int a2, int a3);
void __thiscall advManager::UpdateTownLocators(void *this, int a2, int a3);
int __thiscall advManager::UpdBottomView(advManager *this, int a2, int a3, int a4);
signed int __thiscall advManager::ClearBottomView(advManager *this);
int __thiscall advManager::UpdBottomViewEnemyTurn(void *this);
signed int __thiscall advManager::UpdBottomViewNewTurn(advManager *this);
signed int __thiscall advManager::UpdBottomViewResMsg(advManager *this);
signed int __thiscall advManager::UpdBottomViewKingdom(advManager *this);
signed int __thiscall advManager::UpdBottomViewHero(advManager *this);
void __thiscall advManager::HeroQuickView(advManager *this, int a2, int a3, int a4, int a5);
char *__stdcall advManager::GetArmySizeName(signed int amt, int queryType); // idb
void __thiscall advManager::TownQuickView(void *this, int a2, int a3, int a4, int a5);
void __thiscall advManager::RedrawAdvScreen(advManager *this, int a2, int a3);
playerData *__cdecl advManager::DeactivateCurrTown();
playerData *__thiscall advManager::DeactivateCurrHero(advManager *this);
void __thiscall advManager::MobilizeCurrHero(advManager *this, int a2);
void __thiscall advManager::DemobilizeCurrHero(advManager *thisa);
advManager *__thiscall advManager::SetTownContext(advManager *this, int a2);
void __thiscall advManager::SetHeroContext(advManager *this, int heroIdx, int a3); // idb
void __thiscall advManager::DoHeroKnob(void *this);
void __thiscall advManager::DoTownKnob(void *this);
void __thiscall advManager::CastSpell(advManager *this, int spell);
int __cdecl SaveGame();
void __thiscall advManager::CheckCastSpell(advManager *this);
int loc_4519B1(); // weak
signed int __thiscall DimensionDoorHandler(void *this);
signed int __thiscall advManager::ComboDraw(advManager *this, int a2, int a3, int a4);
signed int __thiscall advManager::ComboDraw(advManager *this, int a2);
void __thiscall advManager::SetEnvironmentOrigin(advManager *this, int a2, int a3, int a4);
void __thiscall advManager::CheckLoadSample(advManager *this, int n);
signed int __thiscall advManager::GetSoundId(advManager *this, int x, int y);
void __thiscall advManager::InsertSound(advManager *this, int a2, int, int a3, int a4);
signed int __thiscall advManager::TeleportTo(advManager *this, hero *hro, int x, int y, int a5, int a6);
void __thiscall advManager::DimensionDoor(advManager *this);
signed int __thiscall TownPortalHandler(void *this);
void __thiscall advManager::TownGate(advManager *this, int spell); // idb
void __thiscall advManager::SummonBoat(advManager *this);
void __thiscall advManager::ShowRoute(void *this, int a2, int a3, int a4);
void __thiscall advManager::HideRoute(advManager *this, int a2, int a3, int a4);
int __thiscall advManager::CheckDimHero(void *this);
int __cdecl advManager::CheckDimNextHeroBut();
char __thiscall advManager::SeedTo(int this, __int64 a2);
signed int __thiscall advManager::ForceNewHover(void *this);
void __thiscall advManager::ScreenScroll(advManager *this, int a2, int a3);
void __thiscall advManager::CheckScreenScroll(void *this);
bool __cdecl advManager::MouseInScrollZone();
int __thiscall advManager::SetInitialMapOrigin(advManager *this);
heroWindow *__thiscall advManager::LoadRemote(void *this);
int __fastcall advManager::CheckHandleNet(advManager *this, int a2);
signed int __thiscall advManager::CheckHandleNetPlayerWait(void *this, int a2, int a3);
void __thiscall advManager::TrimLoopingSounds(advManager *this, signed int a2);
advManager *__thiscall advManager::DisableButtons(advManager *this);
advManager *__thiscall advManager::EnableButtons(advManager *this);
void *__thiscall advManager::SaveAdventureBorder(int this);
void *__fastcall advManager::DrawAdventureBorder(int this, int a2);
signed int __thiscall advManager::FindAdjacentMonster(void *this, int a2, int, int a3, int a4, int a5, int a6);
int __cdecl ComputeAdvNetControl();
signed int __fastcall MapExtraPosAndAdjacentsSet(int x, int y, unsigned __int8 a3); // idb
void __thiscall advManager::ViewPuzzle(advManager *this);
int __thiscall advManager::PuzzleDraw(advManager *this, int a2, int a3, int a4, int a5);
void __thiscall advManager::AdvPanel(void *this);
signed int __thiscall APanelHandler(void *this);
signed int __thiscall advManager::ControlPanel(void *this);
signed int __thiscall CPanelHandler(void *this);
void __thiscall advManager::SystemOptions(void *this);
void __thiscall UpdateSystemOptions(void *this);
signed int __thiscall SystemOptionsHandler(void *this);
int __fastcall GetMobilityFrame(int a1);
int __fastcall GetManaFrame(signed int a1);
signed int __thiscall advManager::DoVisions(void *this, hero *hro); // idb
signed int __stdcall advManager::IsCrystalBallInEffect(int a1, int a2, signed int a3);
char __thiscall StopOnTrigger(int this);
signed int __thiscall ConvertSmackerPalette(void *this);
int __fastcall DoAdvance(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl SmackManagerMain();
int __cdecl ShutDownSmacker();
int __fastcall PlaySmacker(int x);
signed int __fastcall ExpansionCampaignRect(int a1, int a2);
char __fastcall PointInRect(int a1, int a2, int a3);
void __fastcall PrintSummaryInfo(int *metrics);
void __thiscall game::GetMap(game *this);
void __thiscall game::ProcessNewMap(game *this, const void *a2);
game *__thiscall game::InitNewGame(game *this, const void *a2);
int __cdecl game::SetupNetPlayerNames();
bool __thiscall game::NewGame(game *this);
void __thiscall game::CleanUpNewGameWindow(void *this);
int __thiscall game::InitNewGameWindow(int this);
void __thiscall game::UpdateNewGameWindow(int this);
signed int __fastcall NewGameHandler(void *this, game *a2);
signed int __stdcall game::ProcessNGKeyPress(int a1);
void __stdcall game::NGKPSetupDisplayString(const char *a1, unsigned __int16 a2);
void __stdcall game::DrawNGKPDisplayString(int a1);
BOOL __thiscall game::ShowScenInfo(void *this);
char *__thiscall game::GetLossConditionText(game *this, char *a2);
void __thiscall game::GetVictoryConditionText(game *thisa, char *buf); // idb
bool __thiscall game::GetSideDesc(game *this, char *a2, int sideStart, int sideEnd); // idb
__int16 __cdecl wsnet_init();
void __cdecl wsnet_term();
void __fastcall wsSendMessage(int a1, char a2, unsigned __int16 a3, const void *a4);
int __fastcall wsnet_snd(int a1, unsigned __int16 a2, const void *a3);
__int16 __stdcall wsnet_rcv(void *a1);
int __cdecl wsProcessMessages();
void __fastcall wsEvaluateMessage(int a1, int a2);
bool __cdecl wsWaitForFirstGuest();
signed int __cdecl wsWaitForExtraGuests();
signed int __cdecl wsWaitForHost();
void __thiscall game::SetupDynamicStuff(void *this, int a2, int a3, int a4);
void __thiscall game::SetupNewOverviewType(void *this, int a2, int a3);
int __cdecl game::SetupResources();
void __thiscall game::Overview(void *this);
void __thiscall game::DoKnob(void *this);
signed int __thiscall OverviewHandler(void *this);
signed int __thiscall game::ProcessIconSelect(void *this, signed int a2, unsigned int a3);
int __cdecl DoArenaDialog();
signed int __thiscall ArenaWindowHandler(void *this);
void __cdecl UpdateArenaIcons();
void __thiscall ModemSetup(void *this);
bool __cdecl Dial();
bool __cdecl Wait();
void __fastcall GUIModemCommand(const char *a1, const char *a2);
char __cdecl GUIModemCommandExec();
signed int __thiscall ModemCommand(const char *this);
char __fastcall GUIModemResponse(const char *a1, const char *a2);
char __cdecl GUIModemResponseExec();
signed int __fastcall write_buffer(const void *a1, int a2);
signed int __cdecl read_byte();
int __cdecl _atoflt(_CRT_FLOAT *Result, char *Str);
char __cdecl Connect();
signed int __cdecl WaitForDirectConnect();
char __cdecl ReadPacket();
void __fastcall WriteModemPacket(int a1, signed int a2);
searchArray *__thiscall searchArray::searchArray(searchArray *this);
void __thiscall searchArray::_searchArray(searchArray *this);
void __thiscall searchArray::Init(searchArray *this);
void __thiscall searchArray::Close(searchArray *this);
int __thiscall searchArray::Clear(searchArray *this);
int __stdcall searchArray::QuickDistance(int x1, int y1, int x2, int y2); // idb
int __fastcall CalcTerrainCost(signed int terrain, char a2, int mobility, int pathfinding, int fromRoad, int toRoad);
char __thiscall searchArray::PushPoint(searchArray *this, int a2, int a3, int a4, signed int a5, signed int a6, char a7, int a8, char a9, char a10, int a11, char a12, char a13);
int __thiscall searchArray::TestPossibleDirections(searchArray *this, __int64 a2, int a3, int a4, int a5, int a6);
signed int __stdcall searchArray::SeedCombatPosition(army *stack);
int __thiscall searchArray::FindCombatPath(searchArray *this, int sourceHex, int targHex, army *stack, int a5, int twoHexer); // idb
void __thiscall searchArray::PushCombatPoint(searchArray *this, int sourceHex, char neighborIdx, signed int a4, signed int speed);
signed int __thiscall combatManager::DoSpellAI(combatManager *this, int i, int a3);
void __thiscall combatManager::DetermineEffectOfSpell(combatManager *this, Spell spell, int *value, int *target);
int __thiscall combatManager::EffectSpellCreateCreature(combatManager *this, int hex, Spell spell);
int __thiscall combatManager::RawEffectSpellInfluence(combatManager *this, army *stack, STACK_MODIFYING_EFFECT eff);
int __cdecl combatManager::ClearEffects();
void __stdcall combatManager::NextPos(int *hexIdx);
signed int __thiscall combatManager::FirstArmy(combatManager *this, int startHex, int side, int *resultHex); // idb
signed int __thiscall combatManager::FirstResurrectable(combatManager *this, int startHex, int *resultHex, Spell spell); // idb
void __thiscall combatManager::EffectSpellCure(combatManager *this, int *val, int side, int hex, int isCure);
signed __int64 __thiscall combatManager::EffectSpellResurrect(combatManager *this, int *val, int hexIdx, Spell spell);
int __thiscall combatManager::EffectSpellDamage(combatManager *this, int *val, Spell spell, int hexIdx);
int __thiscall searchArray::BuildPath(searchArray *this, int a2, int a3, int a4, int a5, signed int a6);
char __thiscall searchArray::SeedPosition(searchArray *this, int a2, int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, __int64 a10, int a11, int a12);
town *__thiscall town::town(town *this);
int __thiscall town::HasGarrison(town *this);
void __thiscall town::GiveSpells(town *this, hero *captain);
void __thiscall town::XformToCastle(town *this);
void __thiscall town::View(town *this, int a2);
town *__thiscall town::Deallocate(town *this);
void __thiscall town::BuildBuilding(town *this, signed int buildingCode);
bool __thiscall town::CanBuildDock(town *this);
void __thiscall town::CalcNumLevelArchers(town *this, int *numArchers, int *attack);
bool __thiscall combatManager::AICheckRetreat(int ecx0);
void __thiscall combatManager::DoCompAI(combatManager *this, int side);
double __stdcall combatManager::GetModLichDamage(int a1, float a2);
int __thiscall combatManager::DoLichShot(void *this, int a2);
int __thiscall combatManager::GetShooterMask(void *this, int a2);
int __thiscall combatManager::GetMirrorImageMask(combatManager *this, int a2);
int __thiscall combatManager::GetFlyerMask(void *this, int a2);
int __thiscall combatManager::GetAllMask(combatManager *this, int side); // idb
int __thiscall combatManager::GetWalkerMask(void *this, int a2);
int __thiscall combatManager::GetOutOfItMask(void *this, int a2);
int __thiscall combatManager::GetTraitorMask(void *this, int a2);
signed int __thiscall combatManager::GetBestArmy(void *this, int a2, int a3);
signed int __thiscall combatManager::GetWorstArmy(void *this, int a2, int a3);
signed int __thiscall combatManager::GetClosestArmy(combatManager *this, army *stack, int side, int stackBmask);
int __thiscall combatManager::GetStrength(void *this, int a2, int a3);
signed int __thiscall combatManager::AttemptAttack(combatManager *this, int a2, int a3, int a4);
signed int __thiscall combatManager::AttemptAdjacentAttack(void *this, int a2);
signed int __thiscall combatManager::WalkTowardArmyFront(void *this, int a2, int a3, int a4);
signed int __thiscall combatManager::WalkTowardArmy(combatManager *this, army *stack, int side, int stackBmask); // idb
void __cdecl RemoteCleanup();
void __thiscall RemoteMain(void *this);
void __fastcall UnloadRemoteDriver(__int16 a1);
int __fastcall calc_crc_long(int a1, int a2);
int __fastcall calc_crc(int a1, int a2, int a3);
unsigned int __fastcall EncodePacket(const void *a1, int a2, char a3, size_t a4);
signed int __thiscall DecodePacket(void *this);
signed int __thiscall SendRemoteData(int a1, int a2, size_t a3); // idb
signed int __fastcall ReceiveRemoteData(int a1, void *a2, int a3);
int __fastcall TransmitRemoteData(const void *a1, int a2, size_t a3, char a4, char a5, char a6, char a7);
void *__fastcall GetRemoteData(char relinquish, int a2);
void __cdecl PollRemote();
signed int __fastcall TransmitAndWait(const void *a1, int a2, size_t a3, char a4, char a5, int a6);
armyGroup *__thiscall armyGroup::armyGroup(armyGroup *this);
// void __stdcall unknown_libname_6(int a1);
signed int __thiscall armyGroup::HasAllUndead(armyGroup *this); // idb
signed int __thiscall armyGroup::HasSomeUndead(armyGroup *this); // idb
signed int __thiscall armyGroup::GetMorale(armyGroup *this, hero *hro, town *castle, char *enemyCreaturesList); // idb
void __thiscall armyGroup::Dismiss(armyGroup *this, int idx);
signed int __thiscall armyGroup::IsMember(armyGroup *this, int creatureType); // idb
signed int __thiscall armyGroup::IsHomogeneous(armyGroup *this, int a2);
bool __thiscall armyGroup::CanJoin(armyGroup *this, int creatureType);
int __thiscall armyGroup::GetNumArmies(armyGroup *this);
signed int __thiscall armyGroup::Add(armyGroup *this, int creatureType, __int16 quantity, signed int stackIdx); // idb
void __thiscall armyGroup::Swap(armyGroup *this, int idx, armyGroup *oth, int othIdx);
void __thiscall armyGroup::DamageGroup(armyGroup *this, float chance); // idb
fullMap *__thiscall fullMap::fullMap(fullMap *this);
void __thiscall fullMap::_fullMap(mapCell **this);
void __thiscall fullMap::Close(fullMap *this);
void __thiscall fullMap::Init(fullMap *this, int width, int height);
void __thiscall fullMap::ClearCellExtra(fullMap *this, int i);
int __thiscall fullMap::GetNewCellExtraIndex(fullMap *this);
mapCellExtra *__thiscall fullMap::GetNewCellExtraOverlay(fullMap *this, int col, int row);
mapCellExtra *__thiscall fullMap::GetNewCellExtraObject(fullMap *this, int col, int row);
void __thiscall fullMap::Write(fullMap *this, int fd);
BOOL __thiscall fullMap::Read(fullMap *this, UINT fd, int isNewGame); // idb
void __thiscall fullMap::ChangeTilesetIndex(fullMap *this, mapCell *cell, int x, int y, int a5, int a6, int a7, int a8);
int __thiscall ExpCampaign::ExpCampaign(int this);
// int __thiscall sub_470420(int x);
void *__thiscall ExpCampaign::ResetMapChoices(int this);
void *__thiscall ExpCampaign::ResetMapsPlayed(int this);
void *__thiscall ExpCampaign::ResetAwards(int this);
void *__thiscall ExpCampaign::ResetBonusChoices(int this);
int __cdecl _ismbbprint(unsigned int);
int __cdecl _ismbbpunct(unsigned int);
char __thiscall ExpCampaign::HasAward(void *this, int a2);
int __cdecl _finite(double);
void *__thiscall ExpCampaign::InitNewCampaign(int this, int a2);
void __thiscall ExpCampaign::InitMap(int this);
void __thiscall ExpCampaign::ShowInfo(int this, int a2, int a3);
void __thiscall ExpCampaign::UpdateInfo(void *this, int a2);
bool __thiscall ExpCampaign::HandleVictory(int this);
int __thiscall ExpCampaign::HandleVictory1(int this);
int __thiscall ExpCampaign::HandleVictory2(int this);
int __thiscall ExpCampaign::HandleVictory3(int this);
int __thiscall ExpCampaign::HandleVictory4(int this);
heroWindowManager *__thiscall ExpCampaign::ReplaySmacker(void *this);
int __thiscall ExpCampaign::ReplaySmacker1(int this);
int __thiscall ExpCampaign::ReplaySmacker2(int this);
int __thiscall ExpCampaign::ReplaySmacker3(int this);
int __thiscall ExpCampaign::ReplaySmacker4(int this);
char __thiscall ExpCampaign::IsCompleted(int this);
char __thiscall ExpCampaign::IsThisMapCompleted(int this);
signed int __thiscall ExpCampaign::MessageHandler(void *this);
signed int __thiscall ExpCampaign::Autosave(signed int this);
int __cdecl ExpCampaign::Choose();
int __thiscall ExpCampaign::Days(int this);
int __thiscall ExpCampaign::CampaignID(void *this);
char *__thiscall ExpCampaign::JosephName(int this);
char *__thiscall ExpCampaign::IvanName(int this);
char __thiscall ExpCampaign::IsSpecialGoldenBow(int this, int a2, int a3);
char __thiscall ExpCampaign::IsSpecialUA(int this);
char __thiscall ExpCampaign::IsSpecialLossCondition(int this, int a2);
signed int __cdecl is_netbios_avail();
signed __int16 __fastcall nb_init(int a1, char a2);
void __cdecl nb_term();
__int16 __fastcall nb_rcv(unsigned __int16 a1, void *a2);
signed __int16 __fastcall nb_snd(__int16 a1, __int16 a2, const void *a3);
signed __int16 __cdecl nb_sess(__int16 a1, int a2);
char __fastcall nb_stat(__int16 a1);
void __cdecl nb_thr_ctl();
UCHAR __cdecl sub_4738A0();
UCHAR __stdcall sub_473960(int pncb);
int __fastcall sub_473B30(int a1);
void __stdcall sub_473BF0(void *a1);
int __fastcall sub_473D40(int a1, const void *a2);
int __fastcall sub_473E10(int a1, const void *a2);
char __stdcall sub_473EE0(char *a1);
UCHAR __fastcall sub_474010(int a1);
int __fastcall sub_474160(int a1);
char __fastcall sub_474230(int a1);
char __fastcall sub_4743B0(int a1, void *a2);
combatManager *__thiscall combatManager::combatManager(combatManager *this);
void __stdcall combatManager::CombineGroups(armyGroup *a1, armyGroup *a2);
combatManager *__thiscall combatManager::SetupCombat(combatManager *this, __int64 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
void __thiscall combatManager::InitNonVisualVars(combatManager *this);
char __thiscall combatManager::SetupAdjacencyArray(combatManager *this);
int __thiscall combatManager::Open(combatManager *this, int a2);
combatManager *__thiscall combatManager::Close(combatManager *this);
void __thiscall combatManager::UpdateArmyGroup(combatManager *this, signed int side);
int __thiscall combatManager::GenerateMap(combatManager *this);
char *__thiscall combatManager::GetBackgroundName(combatManager *this);
bool __thiscall combatManager::MoreTreesNear(combatManager *this);
void __thiscall combatManager::LoadIcons(combatManager *this);
void __thiscall combatManager::FreeIcons(combatManager *this);
void __thiscall combatManager::LoadArmies(combatManager *this);
void __thiscall combatManager::FreeArmies(combatManager *this);
int __thiscall combatManager::GetGridIndex(combatManager *this, signed int x, signed int y); // idb
void __thiscall combatManager::CheckApplyGoodMorale(combatManager *this, int side, int stackIdx);
signed int __thiscall combatManager::CheckApplyBadMorale(combatManager *this, int side, int stackIdx); // idb
signed int __thiscall combatManager::GetNextArmy(combatManager *this, int a2);
signed int __thiscall combatManager::IsWinner(combatManager *this, int side);
void __thiscall combatManager::CatAttack(combatManager *this, int side); // idb
void __thiscall combatManager::KeepAttack(combatManager *this, int towerIdx);
int __thiscall combatManager::ExperienceValueOfStack(combatManager *this, int side);
void __thiscall combatManager::ResetHitByCreature(combatManager *this);
bool __fastcall ValidHex(int a1); // idb
// void __cdecl combatManager::SaveCombatBorder();
// void __cdecl unknown_libname_9();
void __thiscall combatManager::SetupAndLoadObstacles(combatManager *this);
void __thiscall combatManager::MakeCreaturesVanish(combatManager *this);
void __thiscall combatManager::LowerDoor(combatManager *this);
int loc_479A1D(); // weak
void __thiscall combatManager::RaiseDoor(combatManager *this);
void __fastcall combatManager::TestRaiseDoor(combatManager *a1);
bool __stdcall combatManager::InCastle(signed int hex); // idb
signed int __thiscall combatManager::ShotIsThroughWall(combatManager *this, int side, signed int occupiedHex, signed int targHex); // idb
void __stdcall combatManager::ShootMissile(int xFrom, int yFrom, int xTarg, int yTarg, float *anglesOfImgIdxs, icon *icn);
void __thiscall combatManager::CombatSystemOptions(void *this);
void __thiscall UpdateCombatSystemOptions(void *this);
signed int __thiscall CombatSystemOptionsHandler(void *this);
int __thiscall army::army(army *this);
void __stdcall army::WaitSample(int a1);
void __thiscall army::InitClean(army *this);
void __thiscall army::Init(army *this, int creatureIdx, int quantity, int owner, int stackIdx, int startHex, int armyIdx);
void __thiscall army::LoadResources(army *this);
army *__thiscall army::FreeResources(army *this);
void __thiscall army::DrawToBuffer(army *this, int centX, int standingBotY, int a4);
void __thiscall army::Wince(army *this);
int loc_47BF08(); // weak
void __thiscall army::Walk(army *this, signed int dir, int a3, int a4); // idb
void __thiscall army::SpecialAttack(army *this);
void __thiscall army::DirDoAttack(int this, int a2);
void __thiscall army::DoHydraAttack(army *this, int a2);
void __thiscall army::DoAttack(army *this, int isRetaliationOrSecondAttack);
void __cdecl army::ResetPath();
signed int __thiscall army::WalkTo(army *this);
signed int __thiscall army::WalkTo(army *this, int hex); // idb
signed int __thiscall army::AttackTo(army *this);
signed int __thiscall army::AttackTo(army *this, signed int targetHex);
void __thiscall army::CheckLuck(army *this);
void __thiscall army::DamageEnemy(army *this, army *targ, int *damageDone, int *creaturesKilled, int isRanged, int a6); // idb
int __thiscall army::Damage(army *this, signed int baseDam, Spell spell); // idb
void __thiscall army::PowEffect(army *this, int animIdx, int a3, int a4, int a5);
unsigned __int32 __thiscall army::Strength(army *this);
bool __thiscall army::LeaveNoBody(army *this);
void __thiscall army::ProcessDeath(army *this, int a2);
void __thiscall army::SpellEffect(army *this, int animationIdx, signed int a3, int a4); // idb
void __thiscall army::CancelSpellType(army *this, CREATURE_EVENT_CODE code);
void __thiscall army::CancelIndividualSpell(army *this, STACK_MODIFYING_EFFECT effect);
signed int __thiscall army::SetSpellInfluence(army *this, STACK_MODIFYING_EFFECT effectType, signed int strength); // idb
void __thiscall army::DecrementSpellRounds(army *this);
void __thiscall army::GoBerserk(army *this);
void __thiscall army::MoveAttack(army *this, int hexIdx, int a3);
double __thiscall army::SpellCastWorkChance(army *this, Spell spell); // idb
bool __thiscall army::SpellCastWorks(army *this, Spell spell);
void __fastcall BuildTempWalkSeq(SMonFrameInfo *this, int last, int notFirst);
void __thiscall army::DispelGood(army *this);
void __thiscall army::Cure(army *this, int spellpower);
int __thiscall army::MidX(army *this);
int __thiscall army::MidY(army *this);
int __thiscall army::TopY(army *this);
int __thiscall army::RightX(army *this);
int __thiscall army::LeftX(army *this);
signed int __thiscall army::OtherArmyAdjacent(army *this, int side, int idx);
void __fastcall ModifyFrameInfo(SMonFrameInfo *form, CREATURES creature); // idb
int __thiscall army::GetPowBaseY(army *this);
WPARAM __stdcall WinMain(HINSTANCE instance, HINSTANCE prevInstance, LPSTR lpCmdnLine, int nCmdShow); // idb
signed int __fastcall AppInit(HINSTANCE instance, HINSTANCE prevInstance, int nCmdShow, LPSTR lpCmdLine);
signed int __cdecl AppIdle();
signed int __stdcall AppWndProc(HWND hWnd, unsigned int Msg, int wParam, unsigned int lParam);
signed int __stdcall AppAbout(HWND hDlg, int a2, unsigned __int16 a3, int a4);
// BOOL __cdecl AppExit();
void __cdecl Process1WindowsMessage();
void __fastcall ResizeWindow(int x, int y, unsigned int width, unsigned int heightNeededToDisplay);
signed int __fastcall AppCommand(HWND this, int edx0, unsigned __int16 a2, int a3);
void __thiscall UpdateDfltMenu(HMENU hMenua);
void __thiscall KBChangeMenu(HMENU menu);
void __thiscall SetMenuStatus(BOOL this);
int __fastcall SetNoDialogMenus(int a1);
void __fastcall SetMenus(HMENU a1, unsigned int a2);
int __cdecl KBTickCount();
// void __cdecl InitVideo();
void __thiscall advManager::DoEvent(advManager *this, mapCell *loc, int locX, int locY);
void __thiscall advManager::EraseObj(advManager *this, mapCell *cell, int a3, int a4); // idb
void __thiscall advManager::HeroSwap(void *this, int a2, int a3);
signed int __thiscall advManager::BarrierEvent(advManager *this, mapCell *cell, hero *hero);
char __fastcall StrEqNoCase(int *a1, int *a2);
void __thiscall advManager::PasswordEvent(advManager *this, mapCell *tile, hero *hero);
void __thiscall advManager::GenericSiteEvent(advManager *ecx0, mapCell *cell, hero *this);
void __thiscall advManager::RecruitSiteEvent(advManager *this, int a1, int a2);
BOOL __stdcall advManager::ExpansionRecruitEvent(int a1, int a2, int a3);
void __thiscall advManager::JailEvent(void *this, int a2, int a3, int a4, int a5);
void __thiscall advManager::TownEvent(int this, int a2, __int64 a3);
void __thiscall advManager::EventSound(advManager *this, int, int, SAMPLE2 *);
void __stdcall advManager::EventWindow(signed int eventID, int a2, const char *msg, int a4, int a5, int resource2Type, int resource2Amt, int a8);
signed int __fastcall GiveArtifact(hero *hero, ARTIFACT a2, int a3, char scrollSpell); // idb
int __thiscall advManager::GiveRandomArtifact(void *ecx0, hero *hro);
int __stdcall advManager::GiveExperience(hero *hro, int xp, int a3); // idb
void __thiscall advManager::GiveResource(advManager *this, hero *hro, signed int type, int amt);
void __thiscall advManager::RecruitEvent(advManager *this, hero *hro, int creature, mapCell *loc);
signed int __thiscall advManager::SkeletonEvent(int this, int a2, int a3, const char *a4, __int64 a5);
signed int __thiscall advManager::ZombieEvent(advManager *this, hero *h, mapCell *a3, const char *a4, int a5, int a6);
signed int __thiscall advManager::GhostEvent(advManager *this, hero *hro, mapCell *a5, char *a4, __int64 a8); // idb
void __stdcall advManager::HouseEvent(int a1, int a2);
int __thiscall advManager::CombatMonsterEvent(advManager *this, hero *a2, int creat, signed int a4, mapCell *cell, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16);
void __fastcall GiveTakeArtifactStat(hero *this, ARTIFACT a2, int losing); // idb
void __stdcall advManager::TransferArtifacts(int a1, int a2);
void __thiscall advManager::HeroLoses(int this, int a2);
int __thiscall advManager::DoWhirlpool(advManager *a1, hero *hro);
void __thiscall advManager::FizzleCenter(void *this, int a2);
void __thiscall advManager::DoAIEvent(int this, mapCell *cell, hero *hro, __int64 x);
bool __stdcall advManager::BarrierAIEvent(int a1, int a2);
char __stdcall advManager::PasswordAIEvent(int a1, int a2);
char __stdcall advManager::GenericSiteAIEvent(int a1, int a2);
void __stdcall advManager::RecruitSiteAIEvent(int a1, int a2);
void __thiscall advManager::JailAIEvent(int this, int a2, int a3, int a4, int a5);
heroWindow *__thiscall advManager::PlayerMonsterInteract(void *this, mapCell *cell, mapCell *a5, hero *a2, heroWindow *argC, __int64 a6, int a8, __int64 a9);
__int16 __stdcall advManager::ComputerMonsterInteract(int a1, int a2, int a3);
signed int __thiscall advManager::DoNetCombat(advManager *this, int a1);
int __thiscall advManager::DoCombat(void *this, __int64 a2, int a3, const void *a4, int a5, int a6, const void *a7, char a8, char a9, int a10, int a11);
void __stdcall advManager::SendHeroTownData(char a1, char a2, int a3, const void *a4, const void *a5, int a6, const void *a7, char a8, char a9, int a10, int a11, char a12, char a13, char a14);
void *__stdcall advManager::ReceiveHeroTownData(int a1, int a2, int a3, int a4, void **a5, void **a6, void **a7, void **a8, void **a9, int a10, int a11, int a12, int a13, int a14, int a15);
int __thiscall advManager::AutoResolveCombat(void *this, __int64 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
bool __fastcall RiddleStringsEqual(const char *a1, const char *a2);
hero *__thiscall hero::hero(hero *this);
int __thiscall hero::Read(hero *this, int fd, char expansion);
void __thiscall hero::Write(hero *this, int fd, signed __int8 expansion);
void __stdcall sub_494B30(int a1);
int __thiscall hero::HasArtifact(hero *this, int artifact);
int __thiscall hero::CalcMobility(hero *this);
int __thiscall hero::HasSpell(hero *this, int spell);
int __thiscall hero::GetNthSpell(hero *this, int type, int n); // idb
int __thiscall hero::GetNumSpells(hero *this, int type);
void __thiscall hero::UseSpell(hero *this, int spell); // idb
void __thiscall hero::AddSpell(hero *this, int spell, int knowledge);
void __thiscall HeroMessageUpdate(char *this);
void __thiscall hero::HeroScreenUpdate(hero *this);
int __thiscall hero::UpdateArmies(hero *this);
void __thiscall hero::ViewStat(hero *hro, int skill, int a2);
heroWindow *__stdcall hero::ViewArtifact(int art, unsigned int a2, int spell);
signed int __thiscall hero::Dismiss(hero *this);
void __thiscall hero::Deallocate(hero *this, int a2);
int __stdcall hero::GetExperience(signed int level); // idb
int __stdcall hero::GetLevel(signed int a1);
int __thiscall hero::ApplyBattleWinTemps(hero *this);
int __thiscall hero::ApplyBattleLossTemps(hero *this);
void __thiscall hero::CheckLevel(hero *this);
int __thiscall hero::NumArtifacts(hero *this);
void __thiscall UpdateHeroScreenStatusBar(tag_message *this);
signed int __fastcall HeroHandler(tag_message *msg);
void __cdecl RedrawHeroScreen();
signed int __fastcall HeroView(int heroIdx, int noDismiss, int dontFade); // idb
void __cdecl SetupHeroView();
void *__fastcall DoHeroSplit(int a1, int a2);
void __thiscall hero::SetSS(hero *this, int skill, int level);
int __thiscall hero::TakeSS(hero *this, int skill, char levelsLost); // idb
int __thiscall hero::GiveSS(hero *this, int skill, int levels); // idb
int __thiscall hero::CreatureTypeCount(hero *this, int type); // idb
char __thiscall hero::UpgradeCreatures(hero *this, int fromType, char toType); // idb
signed int __thiscall hero::GetNthSS(hero *this, int a2);
town *__thiscall hero::GetOccupiedTown(hero *this);
char __thiscall hero::Stats(hero *this, PRIMARY_SKILL skill); // idb
char __thiscall hero::GetSSLevel(hero *this, SECONDARY_SKILL skill); // idb
void __thiscall hero::DoSSLevelDialog(hero *this, int skill, unsigned int rightClick);
void __thiscall hero::CheckAnduranPieces(hero *this, int a2);
void __fastcall advManager::ViewWorld(advManager *this, int edx0, int a2, int a3, int a4);
void __cdecl advManager::VWCleanup();
void __thiscall advManager::VWInit(void *this, int a2, int a3);
void __thiscall advManager::VWCompleteDraw(void *this);
signed int __thiscall ViewWorldDialogHandler(void *this);
void __cdecl DDRestoreDisplayMode();
signed int __cdecl DDQueryNewPalette();
int __cdecl CreatePrimary();
void __cdecl SetupClipper();
void __cdecl DDInitGraphics();
signed int __thiscall DDAppPaint(HWND this);
void __cdecl DDInitializePalette();
signed int __cdecl DDSetPalette();
int __fastcall DDCreateSurface(int a1, int a2, int a3);
void __fastcall DDSD(MACRO_DDERR errorCode, char *file, int lineno);
void __thiscall DDUpdatePalette(RGB *this);
void __cdecl DDCleanUpWinGraphics();
void __thiscall DDSetFullScreenStatus(void *this);
signed int __cdecl WGQueryNewPalette();
void __cdecl WGInitGraphics();
void __thiscall WGUpdatePalette(#72 *this);
void __cdecl WGInitializePalette();
signed int __thiscall WGAppPaint(HWND this);
void __cdecl WGCleanUpWinGraphics();
void __cdecl ConnectToDLLs();
BOOL __cdecl DisconnectDLLs();
void __cdecl RestoreDisplayMode();
signed int __cdecl SetPalette();
void __cdecl GetGraphicsInfo();
void __cdecl InitGraphics();
signed int __thiscall AppPaint(HWND this);
void __cdecl InitializePalette();
void __thiscall UpdatePalette(#72 *this);
BOOL __cdecl CleanUpWinGraphics();
void __thiscall SetFullScreenStatus(void *this);
signed int __cdecl QueryNewPalette();
signed int __thiscall SetGraphicsType(void *this);
signed int __thiscall combatManager::HasValidSpellTarget(combatManager *this, Spell spellID);
signed int __thiscall combatManager::ViewSpells(combatManager *ths, int a2); // idb
signed int __thiscall CombatSpecialHandler(Event *this);
signed int __thiscall HandleCastSpell(Event *this); // idb
signed int __thiscall combatManager::FindResurrectArmyIndex(combatManager *this, int side, Spell spell, int hexIdx);
bool __thiscall combatManager::ValidSpellTarget(combatManager *this, Spell spell, int hexIdx);
void __thiscall combatManager::SpellMessage(combatManager *this, int spell, int hex);
void __thiscall combatManager::CastSpell(combatManager *this, Spell proto_spell, int hexIdx, int isCreatureAbility, int a5);
void __thiscall combatManager::DefaultSpell(combatManager *this, int hexIdx);
void __thiscall combatManager::Fireball(combatManager *this, int hexIdx, Spell spell);
// void __userpurge combatManager::MeteorShower(combatManager *this<ecx>, int ebx0<ebx>, int hexIdx);
void __thiscall combatManager::ElementalStorm(combatManager *this);
// void __usercall combatManager::Armageddon(combatManager *this<ecx>, int a2<ebx>);
void __thiscall combatManager::TurnToStone(combatManager *this, army *stack);
void __thiscall combatManager::BloodLustEffect(combatManager *this, army *a2, int flagAdditions); // idb
void __fastcall combatManager::Ripple(combatManager *a1, int a2, int strength);
combatManager *__fastcall combatManager::Blur(combatManager *this, int edx0, char a2, char a3, char a4);
// void __userpurge combatManager::ResetBoltAngle(char bl0<bl>, double a2<st1>, int a1);
int __stdcall combatManager::DrawBolt(int a1, int a2);
// void __userpurge combatManager::AddBolt(int a1<ebx>, double a2<st1>, int *a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
// heroWindowManager *__userpurge combatManager::DoBolt<eax>(combatManager *ecx0<ecx>, int a2<ebx>, double a3<st1>, double st7_0<st0>, int clearAfterwards, signed int startX, signed int startY, signed int endX, signed int endY, int forkControl1, int forkControl2, int startWidth, int endWidth, int colorController, int minRandomDiverge, int maxRandomDiverge, int divergeFreq, int a17, int a13, signed int a19, int a20);
signed int __thiscall combatManager::GetNextChainLightningTarget(combatManager *this, army *creat, int forChainLightning); // idb
void __thiscall combatManager::ChainLightning(combatManager *this, int targetHex, int power);
void __thiscall combatManager::VaporizeCreature(combatManager *this, int a2, int a3);
void __thiscall combatManager::RippleCreature(combatManager *this, int side, int stackIdx, int a4); // idb
void __thiscall combatManager::ShowMassSpell(combatManager *this, char (*stackAffected)[2][20], int animIdx, int isDamageSpell);
void __thiscall combatManager::CastMassSpell(combatManager *this, Spell spell, signed int spellpower);
void __thiscall combatManager::MirrorImage(combatManager *this, int hex);
void __thiscall combatManager::SummonElemental(combatManager *this, CREATURES creatureId, int strength);
// heroWindowManager *__userpurge combatManager::DoLuck<eax>(combatManager *this<ecx>, double a2<st1>, double a3<st0>, int side, int stackIdx);
// void __userpurge combatManager::DoBlast(combatManager *this<ecx>, char a2<bl>, int hexIdx, Spell spell);
void __thiscall combatManager::Resurrect(combatManager *this, int spell, int hex, int spellpower);
bool __thiscall combatManager::SpaceForElementalExists(combatManager *this);
void __stdcall combatManager::ShowSpellCastFailure(army *a1, int a2);
void __stdcall combatManager::ModifyDamageForArtifacts(int *damage, Spell spell, hero *thisHero, hero *enemyHero);
void __thiscall combatManager::Earthquake(combatManager *this);
void __thiscall combatManager::ShowSpellMessage(combatManager *this, int a2, Spell spell, army *stack);
int __cdecl sub_4A7750();
int __cdecl sub_4A7770();
int __cdecl sub_4A7790();
char *__cdecl sub_4A77B0(unsigned __int32, char *, int);
void __fastcall DelayTil(int *tick);
void __thiscall DelayMilli(int x);
void __fastcall DelayTilMilli(int tick);
signed int __thiscall game::HandleCampaignWin(game *this);
heroWindowManager *__thiscall game::PlayPreScenarioSmacker(int this, int a2, int a3);
void __thiscall game::ShowCampaignInfo(void *this, int a2, int a3);
void __thiscall game::CampaignInfoUpdate(void *this, int a2);
signed int __thiscall CampaignHandler(void *this);
void __thiscall game::InitEntireCampaign(game *this, char a2);
game *__thiscall game::InitCampaignMap(game *this);
bool __cdecl CDTest_Init();
void __cdecl CDTest_Cleanup();
int __cdecl CDTest_VerifyCDQuick(unsigned int);
signed int __cdecl CDTest_VerifyCDThorough();
bool __fastcall CDTest_VerifyTrack(signed int a1);
int __thiscall CDTest_GenerateTable(void *this, const char *a2);
int __cdecl _unlink(const char *);
// int __cdecl unknown_libname_18();
// int __cdecl unknown_libname_248();
// void __cdecl unknown_libname_19();
// searchArray *__cdecl unknown_libname_20();
void __fastcall ResetHeroRVs(int a1, int a2, int a3);
int __fastcall CheckDoMain(int a1, int a2);
// void __cdecl ShowStatus();
void *__thiscall philAI::philAI(void *this);
int __thiscall philAI::DoAllHeroInteractions(int this);
int __cdecl philAI::CheckForCreatureUpgrades();
void __thiscall philAI::CheckBuyStuff(void *this);
signed int __thiscall philAI::GoodAdjacent(void *this, int a1);
void __cdecl philAI::CheckReload();
int __cdecl philAI::CheckBerserk();
void __stdcall philAI::DimensionDoorTo(__int64 a1);
signed int __thiscall philAI::DoAnywhereDDoorTownGate(void *this, signed int a1);
signed int __stdcall philAI::DoDimensionDoor(int a1);
int __cdecl philAI::SetupRelativeHeroStrengths();
int __thiscall ValidateHero(hero *this);
mouseManager *__thiscall philAI::DoAI(void *this, int a2);
int __thiscall philAI::GetGameAIVars(int this);
playerData *__stdcall philAI::GetTurnAIVars(int a1);
void __thiscall philAI::GetBestBHC(void *this, int a2, int a3);
char *__stdcall philAI::DetermineHeroToMove(int a1);
signed int __thiscall philAI::DetermineTargetPosition(void *this, int *a2, int *a3, signed int a4, int a5);
void __stdcall philAI::ProbableOutcomeOfBattle(int a1, int a2, __int64 a3, int a4, int a5, int a6, int a7, int a8, int a9, int *a10, int *a11, int *a12, int *a13);
double __stdcall sub_4AFB90(int a1);
int __stdcall philAI::ValueOfBuyingBuilding(int a1, signed int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15);
int __thiscall philAI::GetBestBuilding(void *this, int a2, int a3, int a4);
int __stdcall philAI::ValueOfBuyingCreature(int a1, int a2, int a3, int a4, int a5);
int __thiscall philAI::GetBestCreature(void *this, int a1, int a2, int a3);
int __thiscall philAI::CreaturesToBuy(int, town *, int);
int __stdcall philAI::CreaturesToBuy(int a1, int a2);
int __stdcall philAI::MaxBuyableCreatures(int a1);
signed __int64 __stdcall philAI::ValueOfBuyingHero(int a1, int a2, int a3, int a4);
int __stdcall philAI::GetBestHero(int a1, int a2, int a3);
int __stdcall philAI::LikelihoodOfEnemyAttacking(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall philAI::MeanRVOfUnexploredTerritory(int a1);
char *__stdcall philAI::GetGameAttentionValue(int a1);
char *__stdcall philAI::GetTurnAttentionValue(int a1);
signed __int64 __stdcall philAI::RVConversion(int a1);
double __stdcall philAI::TurnsToBuy(int a1);
int philAI::RVOfPosition(...);
int philAI::StrategicValueOfPosition(...);
int __stdcall philAI::ValueOfTown(town *twn); // idb
int __stdcall philAI::TurnCostResource(int a1);
double __stdcall philAI::TurnValueOfObelisk(int a1);
double __stdcall philAI::FutureDeflator(int a1);
int __stdcall philAI::FightValueOfStack(armyGroup *arm, hero *hro, int a3, int a4, int a5, int a6); // idb
int __stdcall philAI::EvaluateOneTimeCreaturePurchase(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall philAI::QuickCombat(int a1, int a2, __int64 a3, int a4, int a5, float *a6, float *a7);
void __stdcall philAI::HeroInteractionAtHero(int a1, int a2, int a3, int a4);
void __stdcall philAI::HeroInteractionAtTown(int a1, signed int a2, int a3, int a4);
void __stdcall philAI::RedistributeTroops(int a1, void *a2, int a3, int a4, int a5, int a6, signed int a7);
bool __stdcall philAI::ChooseGoldOrExperience(int a1, int a2);
int __stdcall philAI::ChooseEvaluateBattle(int a1, int a2, __int64 a3, int a4, int a5, signed int a6, int a7, int a8);
bool __stdcall philAI::ChooseToFightForArtifact(int a1, char a2, int a3);
signed __int64 __stdcall philAI::NetValueOfArtifact(int a1, signed int a2, int a3, signed int a4);
int __cdecl philAI::ChooseToPayRansomOnHero(unsigned int);
void __stdcall philAI::BuildBuilding(signed int a1, signed int a2);
void __stdcall philAI::BuildHero(signed int a1, int a2);
void __stdcall philAI::BuildCreature(int a1, int a2, int a3);
signed int __stdcall philAI::CanBuyBHC(int a1);
bool __stdcall philAI::CombatMonsterEvent(int a1, char a2, int a3, int a4);
int __stdcall philAI::FightEvent(int a1, int a2, int a3);
signed int __stdcall philAI::DamageGroup(void *a1, int a2, int a3, float a4);
playerData *__cdecl philAI::IncrementHourGlass();
void __stdcall philAI::TownEvent(int a1, int a2, __int64 a3);
signed int __stdcall philAI::ComputeUpgradeValue(int a1, int a2);
signed int __stdcall philAI::ComputeValueOfSS(int a1, int a2, int a3);
signed int __stdcall philAI::ComputeValueOfFreeSS(int a1, int a2);
int __stdcall philAI::ManaRefreshValue(int a1, int a2);
int __thiscall philAI::ValueOfEventAtPosition(void *this, __int64 a1, int a2, int a3);
signed int __stdcall philAI::EvaluateGenericSite(int a1);
signed int __stdcall philAI::EvaluateBarrier(int a1);
signed int __stdcall philAI::EvaluatePassword(int a1);
int __stdcall philAI::EvaluateRecruitSite(int a1);
int __cdecl philAI::EvaluateJail(unsigned int);
void *__cdecl InitAIMapVars();
void __cdecl CloseAIMapVars();
bool __fastcall OnMySide(int a1);
int __stdcall philAI::EvaluateArtifactEvent(int a1, int a2);
int __stdcall philAI::EvaluateMineEvent(int a1, int a2, int a3, int a4);
int __stdcall philAI::EvaluateMonsterEvent(int creat, __int16 a2, int a3); // idb
int __stdcall philAI::EvaluateHeroEvent(int a1, int a2, int a3, int a4, int a5);
int __stdcall philAI::EvaluateTownEvent(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl game::SetupCampaignGame();
signed int __cdecl game::SetupBaud();
signed int __cdecl game::SetupComPort();
signed int __cdecl game::SetupHotSeatGame();
signed int __cdecl game::SetupNetworkGame();
bool __cdecl game::SetupNetworkGame2();
signed int __cdecl game::SetupModemGame();
signed int __cdecl game::SetupMultiPlayerGame();
int __thiscall game::SetupGame(game *this);
signed int __cdecl game::PickLoadGame();
signed int __thiscall SetupCampaignGameHandler(void *this);
signed int __thiscall SetupComPortHandler(void *this);
signed int __thiscall SetupBaudHandler(void *this);
signed int __thiscall SetupHotSeatGameHandler(void *this);
signed int __thiscall SetupModemGameHandler(void *this);
signed int __thiscall SetupMultiPlayerGameHandler(void *this);
signed int __thiscall SetupNetworkGameHandler(void *this);
signed int __thiscall SetupNetworkGame2Handler(void *this);
signed int __thiscall SetupGameHandler(void *this);
signed int __thiscall ExpNewCampaignHandler(int this);
signed int __thiscall ExpLoadCampaignHandler(void *this);
signed int __thiscall ExpStdGameHandler(void *this);
signed int __thiscall BaseSetupHandler(void *this);
int __fastcall add_node(int a1, int a2);
int __thiscall pop_node(int this);
int __thiscall init_anchor(int this, int a2);
void __thiscall ShutdownComError(void *this);
signed __int16 __fastcall com_init(unsigned __int8 a1, DWORD a2, int a3);
int __fastcall com_term(__int16 a1);
__int16 __fastcall com_rcv(__int16 a1, unsigned __int16 a2, LPVOID lpBuffer);
signed __int16 __thiscall com_snd(__int16 this, unsigned __int16 a2, const void *a3, int a4);
__int16 __cdecl sub_4BD2F0();
char __fastcall com_stat(__int16 a1);
int __cdecl comm_wrt_task();
hexcell *__thiscall hexcell::hexcell(hexcell *this);
// void __cdecl unknown_libname_22();
void __thiscall hexcell::DrawLowerDeadOccupants(hexcell *this);
void __thiscall hexcell::DrawUpperDeadOccupant(hexcell *this);
void __thiscall hexcell::DrawOccupant(hexcell *this, int a2, int a3);
int __thiscall hexcell::DrawTower(hexcell *this, int a2);
// void __cdecl unknown_libname_23();
void __thiscall hexcell::DrawObstacle(hexcell *this);
int __thiscall swapManager::swapManager(int this);
int __thiscall swapManager::swapManager(tag_message *this);
int __thiscall swapManager::Reset(int this);
int __thiscall swapManager::DrawSwapWin(int this);
int __thiscall swapManager::Open(void *this, int a2);
int __thiscall swapManager::Close(int this);
void __thiscall swapManager::DrawSelector(int this);
signed int __thiscall swapManager::Main(int this, int a2);
BOOL __thiscall swapManager::ViewMon(int this);
void __thiscall swapManager::SwapArtifacts(int this);
void __thiscall swapManager::SwapMons(int this);
void __thiscall swapManager::Update(void *this);
heroWindowManager *__thiscall swapManager::SplitMons(int this);
int __thiscall advManager::StartCursor(int this, signed int a2);
void __thiscall advManager::StopCursor(advManager *this, int a2);
void __thiscall advManager::DrawCursor(advManager *this);
int __thiscall advManager::DrawCursorShadow(advManager *this);
int __stdcall advManager::GetCursorBaseFrame(signed int a1);
void __thiscall advManager::TurnTo(int this, int a2);
bool __stdcall advManager::GetMoveShowIt(int a1, int a2);
mapCell *__thiscall advManager::MoveHero(advManager *this, int a2, signed int a3, int *trigX, int *trigY, int a6, int a7, signed int a8, int a9); // idb
signed int __thiscall advManager::CheckAdjacentMon(void *this, signed int a2);
signed int __thiscall advManager::ValidMoveWithEvent(int this, int a2, int a3);
signed int __thiscall advManager::ValidMove(advManager *this, int a2, int a3);
int __thiscall advManager::MoveOrigin(int this, int a2, int a3);
void __thiscall advManager::ProcessMapChange(void *ecx0, unsigned int arg0, __int64 a3);
int __thiscall advManager::ProcessIncomingSingleMapChange(void *this, int a2);
void __thiscall advManager::ProcessIncomingGroupMapChange(void *this, const void *a2);
int __thiscall advManager::PurgeMapChangeQueue(advManager *this);
int __thiscall advManager::UnwindMapChangeQueue(void *this, int a2, int a3);
void __fastcall SendMapChange(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4, int a5, char a6, char a7);
void __stdcall combatManager::NoShowCombatLog(char *msg); // idb
void __thiscall combatManager::ClearCombatMessages(combatManager *this, int a2);
void __thiscall combatManager::CheckUpdateCombatMessages(combatManager *this);
void __thiscall combatManager::CombatMessage(combatManager *this, char *message, int a3, int a4, int a5);
void __thiscall combatManager::CombatMessage(combatManager *this, int a2);
void __thiscall combatManager::ResetLimitCreature(combatManager *this);
void __thiscall combatManager::UpdateCombatArea(combatManager *this);
void __thiscall combatManager::SetupGridForArmy(combatManager *this, army *stack); // idb
signed int __fastcall combatManager::UpdateGrid(combatManager *this, int edx0, int a2, int a3);
void __thiscall combatManager::DrawBackground(combatManager *this);
void __thiscall combatManager::UpdateMouseGrid(combatManager *this, signed int hexIdx, int a3);
void __thiscall combatManager::DrawFrame(combatManager *this, int redrawAll, int a3, int a4, int a5, signed int delay, int a7, int waitUntilItIsTime); // idb
void __thiscall combatManager::DrawSmallView(combatManager *this, int a2, int a3);
// unsigned __int32 __stdcall thunk_inet_addr(const char *cp); idb
// char *__stdcall thunk_inet_ntoa(struct in_addr in); idb
// struct hostent *__stdcall thunk_gethostbyname(const char *name); idb
// int __cdecl thunk_WSAGetLastError();
// int __stdcall thunk_gethostname(char *name, int namelen); idb
// int __stdcall thunk_ioctlsocket(SOCKET s, __int32 cmd, u_long *argp); idb
// int __stdcall thunk_bind(SOCKET s, const struct sockaddr *name, int namelen); idb
// u_long __stdcall thunk_htonl(u_long hostlong); idb
// u_short __stdcall thunk_htons(u_short hostshort); idb
// SOCKET __stdcall thunk_socket(int af, int type, int protocol); idb
// int __stdcall thunk_WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); idb
// int __cdecl thunk_WSACleanup();
// int __stdcall thunk_closesocket(SOCKET s); idb
// int __stdcall thunk_sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen); idb
// int __stdcall thunk_recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); idb
// UCHAR __stdcall thunk_Netbios(PNCB pncb); idb
// int __stdcall thunk_WinGCreateBitmap(int a1, int a2, int a3);
// int __cdecl thunk_WinGCreateDC();
// int __stdcall thunk_WinGRecommendDIBFormat(int a1);
// int __stdcall thunk_WinGSetDIBColorTable(int a1, int a2, int a3, int a4);
// int __stdcall thunk_WinGStretchBlt(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// int __stdcall thunk_WinGBitBlt(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __thiscall CycleColors(int a1); // idb
heroWindowManager *__thiscall heroWindowManager::heroWindowManager(heroWindowManager *this);
int __thiscall heroWindowManager::Open(heroWindowManager *this, int a2);
void __thiscall heroWindowManager::Close(heroWindowManager *this);
int __thiscall heroWindowManager::Main(heroWindowManager *this, tag_message *evt); // idb
int __thiscall heroWindowManager::ConvertToHover(heroWindowManager *this, tag_message *a2);
int __thiscall heroWindowManager::BroadcastMessage(heroWindowManager *this, INPUT_EVENT_CODE code, int messageType, int fieldID, int payload);
void __thiscall heroWindowManager::AddWindow(heroWindowManager *this, heroWindow *window, int idx, int redraw);
void __thiscall heroWindowManager::RemoveWindow(heroWindowManager *this, heroWindow *window);
int __thiscall heroWindowManager::DoDialog(heroWindowManager *this, heroWindow *window, int (__fastcall *a3)(tag_message *), int a4);
void __thiscall heroWindowManager::UpdateScreen(heroWindowManager *this);
void __thiscall heroWindowManager::UpdateScreenRegion(heroWindowManager *this, int offsetX, int offsetY, unsigned int width, int height);
void __thiscall heroWindowManager::FadeScreen(heroWindowManager *this, int flag, signed int a3, palette *pal); // idb
int __thiscall heroWindowManager::ScreenShot(heroWindowManager *this);
void __thiscall heroWindowManager::SaveFizzleSource(heroWindowManager *this, int x, int y, int width, int height); // idb
void __thiscall heroWindowManager::FizzleForward(heroWindowManager *this, int x, int y, int width, int height, int delay, const void *a7, int a8);
int __thiscall heroWindowManager::ReleaseFizzleSource(heroWindowManager *this);
DWORD __stdcall CreateColorTables(LPCSTR lpFileName);
bitmap *__thiscall bitmap::bitmap(bitmap *this);
int __thiscall bitmap::_scalar_deleting_destructor_(bitmap *this, char a2);
bitmap *__thiscall bitmap::bitmap(bitmap *this, __int16 a2, __int16 width, __int16 height);
bitmap *__thiscall bitmap::bitmap(bitmap *this, int fileID);
void __thiscall bitmap::DrawToBufferCareful(bitmap *from, __int16 x, __int16 y);
void __thiscall bitmap::DrawToBuffer(bitmap *from, __int16 x, __int16 y);
void __thiscall bitmap::GrabScreen(bitmap *to, __int16 xOff, __int16 yOff);
void __thiscall bitmap::GrabBitmap(bitmap *this, bitmap *a2, __int16 x, __int16 y); // idb
void __thiscall bitmap::GrabBitmapCareful(bitmap *this, bitmap *fromBMP, __int16 x, __int16 y); // idb
void __thiscall bitmap::CopyTo(bitmap *this, bitmap *buf, int xTarg, int yTarg, int xFrom, int yFrom, unsigned int width, int height); // idb
void __thiscall bitmap::CopyToCareful(bitmap *this, bitmap *target, int targX, int targY, int offX, int offY, int width, int height); // idb
LPVOID __fastcall BaseAlloc(size_t a1, char *a2, int caller_lineno);
void __fastcall BaseFree(void *a1, int a2, int caller_lineno);
void __cdecl PrintMemoryLeaks();
unsigned int __thiscall MAKEFILEID(const char *this);
void __fastcall FadeIn(int a1);
int __fastcall FadeOut(signed int a1);
int __fastcall Random(int a1, int a2);
void __fastcall ProcessAssert(int a1, char *a2, int lineno);
int __fastcall FindStringInString(const char *a1, const char *a2);
char *__fastcall FindToken(const char *str, char chr);
int __fastcall FindLastToken(const char *a1, char a2);
int __cdecl SetGameDefaults();
void __cdecl ReadPrefsFromRegistry();
int __cdecl ReadPrefs();
void __cdecl WritePrefsToRegistry();
void __cdecl WritePrefs();
signed int __cdecl SetupCDDrive();
void __thiscall BitmapToScreen(bitmap *this);
void __fastcall SetPalette(char *a1, int a2);
void __fastcall BlitBitmapToScreenNoMouseCheck(int a1, int a2, int a3, unsigned int a4, int a5, int a6, signed int a7);
void __fastcall BlitBitmapToScreen(bitmap *bmp, int xOff, int yOff, unsigned int width, int height, int screenX, int screenY); // idb
void __cdecl LogTruncate();
void __thiscall LogStr(void *msg); // idb
void __fastcall LogInt(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __thiscall AiPrint(void *this);
void __fastcall FadeTo(const void *a1, void *a2, signed int a3);
void __fastcall CreatePCXFile(const char *filename, _BYTE *bmpContents, int width, int height, _BYTE *palContents);
int __thiscall FileSize(const char *this);
IconEntry *__fastcall GetIconEntry(icon *a1, int idx);
int __fastcall SRandom(int low, int high); // idb
LPVOID __thiscall SRand(unsigned int this);
void __fastcall GetDataEntry(const char *a1, int a2, int a3, const char *a4, unsigned int a5, int a6);
signed int __thiscall DataEntryWindowHandler(tag_message *evt);
baseManager *__thiscall baseManager::baseManager(baseManager *this);
void __thiscall soundManager::MIDIStartup(soundManager *this); // idb
void __thiscall soundManager::MIDIShutdown(soundManager *this); // idb
void __thiscall soundManager::MIDIPlay(soundManager *this, signed int track);
signed int __thiscall soundManager::MIDIStop(int this);
bool __thiscall soundManager::MIDIIsPlaying(soundManager *this); // idb
void __thiscall soundManager::MIDISetVolume(soundManager *this); // idb
heroWindow *__thiscall heroWindow::heroWindow(heroWindow *this, int x, int y, int width, int height, int flags);
heroWindow *__thiscall heroWindow::heroWindow(heroWindow *this, int xOff, int yOff, char *filnam); // idb
signed int __thiscall heroWindow::Open(heroWindow *this, int idx, int redraw); // idb
void __thiscall heroWindow::RemoveAndDeleteWidget(heroWindow *this, int id);
heroWindow *__thiscall heroWindow::Close(heroWindow *this);
void __thiscall heroWindow::AddWidget(heroWindow *this, widget *guiObj, int index);
void __thiscall heroWindow::RemoveWidget(heroWindow *this, widget *comp);
int __thiscall heroWindow::BroadcastMessage(heroWindow *this, tag_message *evt);
void __thiscall heroWindow::DrawWindow(heroWindow *this);
void __thiscall heroWindow::DrawWindow(heroWindow *this, int updateScreen); // idb
void __thiscall heroWindow::DrawWindow(heroWindow *this, int updateScreen, signed int lowID, signed int highID);
int __thiscall heroWindow::SaveBackground(heroWindow *this);
heroWindow *__thiscall heroWindow::RestoreBackground(heroWindow *this);
void __thiscall heroWindow::MoveWindow(heroWindow *this, int deltaX, int deltaY); // idb
resourceManager *__thiscall resourceManager::resourceManager(resourceManager *this);
void __thiscall resourceManager::GetBackdrop(resourceManager *this, const char *filename, bitmap *screenBuf, int isICN); // idb
resource *__thiscall resourceManager::GetPalette(resourceManager *this, char *filename);
bitmap *__thiscall resourceManager::GetBitmap(resourceManager *this, const char *filename);
icon *__thiscall resourceManager::GetIcon(resourceManager *this, const char *filename);
icon *__thiscall resourceManager::GetIcon(resourceManager *this, int fileID);
tileset *__thiscall resourceManager::GetTileset(resourceManager *this, const char *filename);
font *__thiscall resourceManager::GetFont(resourceManager *this, const char *filename);
sample *__thiscall resourceManager::GetSample(resourceManager *this, const char *filename);
MIDIWrap *__thiscall resourceManager::GetMIDIWrap(resourceManager *this, const char *filename);
void __thiscall resourceManager::Dispose(resourceManager *this, resource *res);
void __thiscall resourceManager::AddResource(resourceManager *this, resource *res);
void __thiscall resourceManager::Expunge(resourceManager *this);
resource *__thiscall resourceManager::Query(resourceManager *this, unsigned int hash);
int __thiscall resourceManager::Main(resourceManager *this, tag_message *a1);
MANAGER_RETURN_CODE __thiscall resourceManager::Open(resourceManager *this, int idx);
void __thiscall resourceManager::RemoveResource(resourceManager *this, resource *res);
void __thiscall resourceManager::Close(resourceManager *this);
MANAGER_RETURN_CODE __thiscall resourceManager::LoadAggregateHeader(resourceManager *this, const char *filename);
signed int __thiscall resourceManager::PointToFile(resourceManager *this, int id);
unsigned __int32 __thiscall resourceManager::GetFileSize(resourceManager *this, int fileHash);
void __thiscall resourceManager::SavePosition(resourceManager *this);
void __thiscall resourceManager::RestorePosition(resourceManager *this);
__int16 __thiscall resourceManager::ReadWord(resourceManager *this);
int __thiscall resourceManager::ReadLong(resourceManager *this);
unsigned int __thiscall resourceManager::MakeId(resourceManager *this, const char *filename, int useEvilersion);
void __thiscall resourceManager::Read13(resourceManager *this, char *buf);
void __thiscall resourceManager::ReadBlock(resourceManager *this, void *buf, DWORD ntoread);
mouseManager *__thiscall mouseManager::mouseManager(mouseManager *this);
int __thiscall mouseManager::Open(mouseManager *this, int a2);
void __thiscall mouseManager::Close(mouseManager *this);
int __stdcall mouseManager::Main(int a1);
void __thiscall mouseManager::SetPointer(mouseManager *this, char *mse, int spriteIdx, signed int protoCategory);
void __thiscall mouseManager::SetPointer(mouseManager *this, int spriteIdxArg);
void __thiscall mouseManager::NewUpdate(mouseManager *this, int a2);
void __stdcall mouseManager::MouseCoords(int *x, int *y);
int __thiscall mouseManager::SaveAndDraw(mouseManager *this);
void __thiscall mouseManager::RestoreUnderlying(mouseManager *this);
void __thiscall mouseManager::ReallyHidePointer(mouseManager *this);
int __thiscall mouseManager::ReallyShowPointer(mouseManager *this);
void __thiscall mouseManager::HideColorPointer(mouseManager *this);
void __thiscall mouseManager::ShowColorPointer(mouseManager *this);
bool __thiscall mouseManager::IsVis(mouseManager *this);
int __thiscall mouseManager::SetColorMice(mouseManager *this, int a2);
border *__thiscall border::border(border *this);
border *__thiscall border::_scalar_deleting_destructor_(border *this, char a2);
border *__thiscall border::border(border *this, __int16 x, __int16 y, __int16 width, __int16 height, __int16 fieldID, __int16 a7, __int16 color, const char *filename); // idb
void __thiscall border::Read(border *this);
signed int __thiscall border::Main(border *this, tag_message *evt);
void __thiscall border::Draw(border *this);
icon *__thiscall icon::icon(icon *this, int fileID);
icon *__thiscall icon::_scalar_deleting_destructor_(icon *this, char shouldDelete); // idb
int __thiscall icon::DrawToBuffer(icon *this, int x, int y, int spriteIdx, int mirror); // idb
signed int __thiscall icon::CombatClipDrawToBuffer(icon *this, int offsetX, int offsetY, int imageIdx, H2RECT *rect, int mirrored, int a11, char *paletteSubstitution, int a12); // idb
int __thiscall icon::ClipFillToBuffer(icon *this, int a2, int a3, int a4, char a5, int a6, int a7, int a8, unsigned int a9, int a10);
int __thiscall icon::FillToBuffer(icon *this, int x, int y, int idx, char a6, int mirror, int a7); // idb
font *__thiscall font::font(font *ecx0, int fileID);
int __thiscall font::_scalar_deleting_destructor_(int this, char a2);
void __thiscall font::_font(font *this);
int __thiscall font::DrawStringExecute(font *this, char *a2, int a3, int a4, int a5, int a6, int a7, unsigned int regionWidth, int regionHeight); // idb
int __thiscall font::GetCharacterWidth(font *this, char chr);
void __thiscall font::DrawBoundedString(font *this, char *str, int x, int y, signed int regionWidth, int regionHeight, int a7, int alignType);
int __thiscall font::LineLength(font *this, const char *msg, int maxWidth); // idb
int __thiscall font::LineWidth(font *this, const char *str);
iconWidget *__thiscall iconWidget::iconWidget(iconWidget *this);
iconWidget *__thiscall iconWidget::_scalar_deleting_destructor_(iconWidget *this, char a2);
iconWidget *__thiscall iconWidget::iconWidget(iconWidget *this, __int16 x, __int16 y, __int16 width, __int16 height, const char *filename, __int16 imgIdx, char mirror, __int16 fieldID, __int16 a10, __int16 a11);
void __thiscall iconWidget::Read(iconWidget *this);
signed int __thiscall iconWidget::Main(iconWidget *this, tag_message *evt);
void __thiscall iconWidget::Draw(iconWidget *this);
bool __cdecl BitTest(char *bits, unsigned int i); // idb
void __cdecl BitSet(char *bits, unsigned int i);
signed int __fastcall KeyboardMessageHandler(HWND a1, int a2, int a3, unsigned int a4);
bool __fastcall MouseMessageHandler(HWND hWnd, int msg, int wParam, int lParam); // idb
inputManager *__thiscall inputManager::inputManager(int this);
int __thiscall inputManager::Open(inputManager *this, int a2);
int __thiscall inputManager::Close(int this);
int __cdecl _getmbcp();
int __thiscall inputManager::Flush(inputManager *this);
tag_message *__thiscall inputManager::GetEvent(tag_message *this, inputManager *retstr);
void *__thiscall inputManager::PeekEvent(inputManager *this, void *a2);
int __thiscall inputManager::SetKeyCodeType(inputManager *this, int a2);
void __thiscall inputManager::AsciiConvert(inputManager *this, tag_message *evt);
signed int __thiscall inputManager::MakeScanCodeTable(inputManager *this);
int __fastcall CheckChangeCursor(signed int a1, signed int a2, int a3);
void __cdecl inputManager::ForceMouseMove();
executive *__thiscall executive::executive(executive *this);
int __thiscall executive::InitSystem(executive *this);
void __thiscall executive::ShutDownSystem(executive *this);
int __thiscall executive::DoDialog(executive *this, baseManager *a2);
signed int __thiscall executive::AddManager(executive *this, baseManager *mgr, int argIdx); // idb
void __thiscall executive::RemoveManager(executive *this, baseManager *mgr);
void __thiscall executive::CallManager(executive *this, baseManager *man); // idb
void __thiscall executive::MainLoop(executive *this);
textWidget *__thiscall textWidget::textWidget(textWidget *this);
textWidget *__thiscall textWidget::_scalar_deleting_destructor_(textWidget *this, char a2);
textWidget *__thiscall textWidget::textWidget(textWidget *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char *content, const char *fontName, __int16 a8, __int16 a9, __int16 a10, char a11); // idb
__int16 __thiscall textWidget::Read(textWidget *this);
void __thiscall textWidget::_textWidget(textWidget *this);
signed int __thiscall textWidget::Main(textWidget *this, tag_message *evt); // idb
void __thiscall textWidget::Draw(textWidget *this);
__int16 __thiscall textWidget::SetText(textWidget *this, const char *str); // idb
int __fastcall IconToBitmap(icon *icn, bitmap *bmp, int a3, int a4, int spriteIdx, signed int a6, int a7, int a8, unsigned int a9, int a10, int a11); // idb
void __cdecl initialiseCRC();
signed int __cdecl getFinalCRC();
int __cdecl getGlobalCRC();
void *__thiscall setGlobalCRC(void *this);
_UNKNOWN *__thiscall bsOpenReadStream(void *this);
_UNKNOWN *__thiscall bsOpenWriteStream(void *this);
int __fastcall bsPutBit(int a1, char a2);
int __thiscall bsGetBit(int this);
char __thiscall bsGetUChar(void *this);
int __fastcall bsPutUChar(int a1, unsigned __int8 a2);
void __thiscall bsClose(void *this);
unsigned int __fastcall minUInt32(unsigned int a1, unsigned int a2);
int __fastcall arithCodeBitPlusFollow(int a1, char a2);
void __cdecl arithCodeStartEncoding();
int __thiscall arithCodeDoneEncoding(void *this);
void __thiscall arithCodeStartDecoding(void *this);
// void __cdecl arithCodeDoneDecoding();
int __thiscall arithCodeRenormalise_Encode(void *this);
void __fastcall arithCodeSymbol(void *a1, int a2, signed int a3);
int __fastcall arithDecodeSymbol(int a1, int a2);
int __fastcall initModel(int a1, int a2, signed int a3, int a4, int a5);
void __thiscall dumpModelStats(void *this);
int __fastcall updateModel(int a1, int a2);
int __fastcall putSymbol(int a1, signed int a2, void *a3);
int __fastcall getSymbol(int a1, int a2);
int __cdecl initBogusModel();
int __fastcall putUChar(void *a1, unsigned __int8 a2);
int __fastcall putInt32(void *a1, unsigned int a2);
int __fastcall putUInt32(void *a1, unsigned int a2);
char __thiscall getUChar(int this);
int __thiscall getInt32(int this);
int __thiscall getUInt32(int this);
int __cdecl initModels();
void __cdecl dumpAllModelStats();
int __thiscall getMTFVal(int this);
void __fastcall sendMTFVal(void *a1, signed int a2);
void __cdecl FreeCompressStructures();
void __cdecl allocateCompressStructures();
void __cdecl FreeDecompressStructures();
void __fastcall setDecompressStructureSizes(int a1);
int __fastcall GETALL(int a1);
int __fastcall SETREST16(int a1, unsigned __int16 a2);
int __fastcall SETFIRST(int a1, unsigned __int8 a2);
int __fastcall SETSECOND(int a1, unsigned __int8 a2);
int __fastcall SETTHIRD(int a1, unsigned __int8 a2);
int __fastcall SETFOURTH(int a1, unsigned __int8 a2);
int __fastcall NORMALISEHI(int a1);
int __fastcall NORMALISELO(int a1);
void __fastcall sendZeroes(void *a1, signed int a2);
void __fastcall moveToFrontCodeAndSend(void *a1, int a2);
bool __thiscall getAndMoveToFrontDecode(int this);
int __cdecl stripe();
int __cdecl copyOffsetWords();
bool __fastcall fullGt(int a1, int a2);
int __fastcall qsortFull(int a1, int a2);
bool __fastcall trivialGt(int a1, int a2);
int __cdecl shellTrivial();
void __cdecl sortIt();
void __cdecl doReversibleTransformation();
int __cdecl undoReversibleTransformation();
int __thiscall spotBlock(void *this);
int __thiscall getRLEpair(FILE *this);
bool __thiscall loadAndRLEsource(void *this);
void __fastcall unRLEandDump(FILE *a1, int a2);
void __fastcall compressStream(int a1, void *a2);
signed int __fastcall uncompressStream(void *a1, int a2);
// void __cdecl showFileNames();
// void __cdecl cleanUpAndFail();
// void __cdecl panic();
void __fastcall crcError(int a1, int a2);
void __cdecl compressedStreamEOF();
void __cdecl ioError();
void __cdecl blockOverrun();
void __cdecl unblockError();
void __cdecl bitStreamEOF();
void __fastcall uncompressOutOfMemory(int a1, int a2);
void __fastcall compressOutOfMemory(int a1, int a2);
bool __thiscall endsInBz(const char *this);
int __thiscall compress(const char *this);
void __thiscall uncompress(const char *this);
int __fastcall EncodeData(void *a1, const void *a2, unsigned int a3);
int __fastcall DecodeData(void *a1, const void *a2, unsigned int a3);
palette *__thiscall palette::palette(palette *this);
int __thiscall palette::_scalar_deleting_destructor_(int this, char a2);
palette *__thiscall palette::palette(palette *this, int fileID);
#72 *__thiscall palette::Data(palette *this);
void __fastcall FillBitmapArea(bitmap *bmp, int x, int y, unsigned int width, int height, char a6); // idb
void __fastcall BlitBitmap(bitmap *from, int x1, int y1, unsigned int width, int height, bitmap *to, unsigned int x2, int y2);
void __fastcall DimBitmapArea(bitmap *bmp, int x, int y, int width, int height, int substitutionIdx); // idb
int __fastcall FlipIconToBitmap(icon *icn, bitmap *buf, int x, int y, int spriteIdx, signed int flag, int a7, int a8, int width, int height, int a11); // idb
char __cdecl TileToBitmap(tileset *tiles, int idx, bitmap *targ, int x, int y); // idb
int __fastcall IconToBitmapColorTable(icon *a1, bitmap *buf, int a3, int a4, int a5, signed int a6, int a7, int a8, unsigned int a9, int a10, int a11, char *paletteSubstitution, int a13); // idb
int __fastcall IconToBitmapScale(icon *ikon, bitmap *a2, int a3, int a4, int spriteIdx, signed int a6, int a7, int a8, unsigned int a9, int a10, signed int a11);
void __fastcall DoRipple(bitmap *bmp1, bitmap *bmp2, int height, int rippleStrengt); // idb
void __fastcall DoBlur(bitmap *fromBmp, bitmap *toBmp, int height, char a4, char a5, char a6); // idb
int __fastcall MonoIconToBitmap(icon *a1, bitmap *a2, int x, int y, int idx, char color, signed int a7, int a8, int a9, unsigned int a10, int a11); // idb
int __fastcall DimIconToBitmap(icon *a1, int a2, int a3, int a4, int a5, int a6, signed int a7, int a8, int a9, int a10, int a11);
resource *__thiscall resource::resource(resource *this, RESOURCE_TYPE type, int fileID, __int16 referenceCount, resource *next);
void __thiscall resource::_resource(void *this);
void __fastcall BlitBitmapToScreenVesa(bitmap *bmp, int x, int y, unsigned int width, int height, int screenX, signed int screenY); // idb
textEntryWidget *__thiscall textEntryWidget::textEntryWidget(int this);
textEntryWidget *__thiscall textEntryWidget::_scalar_deleting_destructor_(textEntryWidget *this, char a2);
int __thiscall textEntryWidget::textEntryWidget(int this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, unsigned __int16 a6, int a7, const char *a8, __int16 a9, const char *filename, __int16 a11, __int16 a12, __int16 a13, __int16 a14, __int16 a15, __int16 a16);
__int16 __thiscall textEntryWidget::Read(textEntryWidget *this, int type); // idb
void __thiscall textEntryWidget::Draw(int this);
void *__thiscall textEntryWidget::SetupDisplayString(textEntryWidget *this, const char *a2, unsigned __int16 a3);
listBox *__thiscall listBoxWidget::listBoxWidget(listBox *this);
int __thiscall listBoxWidget::_scalar_deleting_destructor_(int this, char a2);
void __thiscall listBoxWidget::_listBoxWidget(int this);
__int16 __thiscall listBoxWidget::Read(listBox *this);
void __thiscall listBoxWidget::DeleteItem(int this, int a2);
void __thiscall listBoxWidget::Draw(listBox *this);
void __thiscall listBoxWidget::DrawLBStuff(listBox *this, int a2);
signed int __thiscall listBoxWidget::ProcessMouseMessage(listBox *this, int a2);
int __thiscall dropListWidget::dropListWidget(int this);
int __thiscall dropListWidget::_scalar_deleting_destructor_(int this, char a2);
void __thiscall dropListWidget::_dropListWidget(int this);
__int16 __thiscall dropListWidget::Read(int this);
void __thiscall dropListWidget::DeleteItem(int this, int a2);
int __thiscall dropListWidget::Main(int this, tag_message *a2);
void __thiscall dropListWidget::Draw(int this);
void __thiscall dropListWidget::DrawDropStuff(int this);
void __thiscall dropListWidget::ProcessSelectDialog(int this);
int __thiscall dimmerWidget::dimmerWidget(int this);
__int16 __thiscall dimmerWidget::Read(int this);
signed int __thiscall dimmerWidget::Main(int this, int a2);
void __thiscall dimmerWidget::Draw(int this);
void *__thiscall dimmerWidget::_scalar_deleting_destructor_(void *this, char a2);
button *__thiscall button::button(button *this);
void __thiscall button::_scalar_deleting_destructor_(button *this, char a2);
__int16 __thiscall button::Read(button *this);
signed __int16 __thiscall button::Main(button *this, tag_message *e);
signed __int16 __thiscall button::Select(button *this, tag_message *evt);
int __thiscall button::Draw(button *this);
widget *__thiscall widget::widget(widget *this, __int16 offsetX, __int16 offsetY, __int16 width, __int16 height, __int16 fieldID, __int16 a7); // idb
void __thiscall widget::_widget(void *this);
int __thiscall widget::Open(widget *this, __int16 idx, heroWindow *parent);
void __cdecl widget::Close();
signed int __thiscall widget::Main(widget *this, Event *evt);
void __thiscall dimmerWidget::Draw(int this);
tileset *__thiscall tileset::tileset(tileset *this, int fileID);
tileset *__thiscall tileset::_scalar_deleting_destructor_(tileset *this, char a2);
sample *__thiscall sample::sample(sample *this, const char *filename, int a3, int a4, int a5);
sample *__thiscall sample::_scalar_deleting_destructor_(sample *this, char a2);
MIDIWrap *__thiscall MIDIWrap::MIDIWrap(MIDIWrap *this, const char *filename);
MIDIWrap *__thiscall MIDIWrap::_scalar_deleting_destructor_(MIDIWrap *this, char a2);
char __fastcall FlipIconToBitmapColorTable(icon *icn, bitmap *bmp, int offX, int offY, int idx, signed int a6, int a7, int a8, int a9, int a10, int a11, char *paletteSubstitution); // idb
int __fastcall FlipIconToBitmapYModify(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __fastcall IconToBitmapYModify(icon *a1, bitmap *a2, int offX, int offY, int idx, int one, int zero1, int zero2, unsigned int width, int height, int a11, int a12); // idb
int __fastcall FlipMonoIconToBitmap(int a1, int a2, int a3, int a4, int a5, char a6, signed int a7, int a8, int a9, int a10, int a11);
// __int64 __usercall _ftol<edx:eax>(double<st0>); weak
// double __stdcall sqrt(double x);
unsigned int __cdecl _fpmath();
void __cdecl _rttosnpop();
// void *(__cdecl *__cdecl _cfltcvt_init_0())(int, int, int, int, int);
// void *__cdecl memset(void *a1, unsigned __int8 a2, unsigned int a3);
// void __cdecl strcpy(char *a1, char *a2);
// char *__cdecl strcat(char *a1, char *a2);
// int __cdecl loc_4DE071(int, int); weak
// int __cdecl ftell(int a1);
// _DWORD __cdecl _ftell_lk(_DWORD); weak
// LPCSTR __cdecl _strupr(LPCSTR lpMultiByteStr);
// int sprintf(char *, const char *, ...); idb
// int memcpy(...);
// LPVOID __cdecl operator new(signed int a1);
// BOOL __cdecl operator delete(void *a1);
// int __cdecl atol(int *a1);
// int __cdecl atoi(int *a1);
// unsigned int __cdecl strlen(char *a1);
// int __cdecl abs(int); idb
// void __cdecl _cinit();
// void __cdecl exit(UINT uExitCode);
// void __cdecl _exit(UINT uExitCode);
// void __cdecl doexit(UINT uExitCode, int a2, int a3);
// void __cdecl _lockexit();
// void __cdecl _unlockexit();
// void __cdecl _initterm(unsigned int a1, unsigned int a2);
// int __cdecl strcmp(int a1, int a2);
// BOOL __cdecl free(BOOL lpMem);
// char *__cdecl strerror(int); idb
// int *__cdecl _dosmaperr(unsigned __int32 a1);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// int __cdecl toupper(int); idb
// int __cdecl _toupper_lk(int); idb
// char *__cdecl strncpy(char *, const char *, size_t); idb
// signed int __cdecl strncmp(int a1, int a2, signed int a3);
// void *__fastcall memmove(void *a1, int a2, void *a3, const void *a4, unsigned int a5);
// unsigned int __cdecl memcmp(int a1, int a2, unsigned int a3);
// void __cdecl asin();
// int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd); idb
// void __cdecl acos();
// double __cdecl atan(double);
// void __usercall atan2(int a1<ebp>, char bl0<bl>, __int16 fps0<fpstat>, double st6_0<st1>, int c0_0, int a6, int a7, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5);
// void __usercall _CIasin(void *this<ecx>, double a1<st0>);
// LPVOID __cdecl srand(int a1);
// unsigned int __cdecl rand();
double __cdecl sin(double);
int loc_4DEFC5(); // weak
double __cdecl cos(double);
// int __cdecl _onexit(int a1);
// int __cdecl atexit(int a1);
// void *__cdecl __onexitinit();
// void __cdecl pow();
// void __cdecl log();
// int loc_4DF0EF(); weak
// void __cdecl log10();
// void __cdecl exp();
// void __usercall WinMainCRTStartup(int a1<eax>, int a2<ebx>, int a3<edi>, int a4<esi>);
// void __cdecl _amsg_exit(int a1);
// signed int __cdecl _close(UINT a1);
// _DWORD __cdecl _close_lk(_DWORD); weak
// signed int __cdecl _read(UINT fd, void *buf, DWORD nbytes);
// signed int __cdecl _read_lk(int a1, unsigned int lpBuffer, DWORD nNumberOfBytesToRead);
// int open(const char *, int, ...); idb
// int _sopen(const char *, int, int, ...); idb
// char __cdecl stricmp(char *a1, char *a2);
// signed int __cdecl _write(int a1, LPCVOID lpBuffer, int a3);
// int __cdecl _write_lk(int a1, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite);
// int __cdecl strnicmp(unsigned __int8 *a1, unsigned __int8 *a2, int a3);
// LPVOID __cdecl malloc(DWORD a1);
// LPVOID __cdecl _nh_malloc(signed int dwBytes, int a2);
// LPVOID __cdecl _heap_alloc(DWORD dwBytes);
// signed int __cdecl fclose(int a1);
// _DWORD __cdecl _fclose_lk(_DWORD); weak
// int __cdecl fputs(const char *a1, unsigned int a2);
// int __cdecl _fsopen(char *a1, int a2, int a3);
// int __cdecl fopen(char *a1, int a2);
// int __cdecl fread(int a1, int a2, int a3, FILE *a4);
// int __cdecl _fread_lk(void *a1, unsigned int a2, int a3, FILE *a4);
// signed int __cdecl _lseek(int a1, LONG lDistanceToMove, DWORD dwMoveMethod);
// signed int __cdecl _lseek_lk(UINT a1, LONG lDistanceToMove, DWORD dwMoveMethod);
// int __cdecl _chdir(const char *); idb
// int __cdecl fseek(int a1, int a2, int a3);
// _DWORD __cdecl _fseek_lk(_DWORD, _DWORD, _DWORD); weak
// void __cdecl _purecall();
// signed int __cdecl fputc(unsigned __int8 a1, int a2);
// signed int __cdecl putc(unsigned __int8 a1, int a2);
// signed int __cdecl fgetc(int a1);
// signed int __cdecl getc(int a1);
// int __cdecl fflush(int a1);
// _DWORD __cdecl _fflush_lk(_DWORD); weak
// _DWORD __cdecl _flush(_DWORD); weak
// int __cdecl _flushall();
// _DWORD __cdecl flsall(_DWORD); weak
// signed int __cdecl ungetc(int a1, int a2);
// signed int __cdecl _ungetc_lk(int a1, int a2);
// void __cdecl perror(LPCVOID lpBuffer);
// int __cdecl remove(const char *); idb
// double __usercall fFSQRT<st0>(char a1<cl>, double result<st0>, int a3<ebp>);
// void __usercall _cintrindisp2(double a1<st1>, double a2<st0>, int a3<edx>, __int16 a4<fpstat>, char c0_0b, char c2_0b, char c3_0b, char c0_0a, char c2_0a, char c3_0a, char c0_0, char c2_0, char c3_0, char a5, char a6, char a7);
// void __usercall _cintrindisp1(double a1<st0>);
// double unknown_libname_30(); weak
// double __usercall ctranexit<st0>(int a1<ebp>, double result<st0>);
// double __usercall cintrinexit<st0>(int a1<ebp>, double result<st0>);
// double unknown_libname_31(); weak
// double __cdecl _fload(double a1);
// unsigned int __cdecl _setdefaultprecision();
// signed int __cdecl _ms_p5_test_fdiv();
// signed int __cdecl _ms_p5_mp_test_fdiv();
// char __cdecl _forcdecpt(int *a1);
// int __cdecl _cropzeros(unsigned int a1);
// int __cdecl _positive(int); weak
// int __cdecl _fassign(int, int, int); weak
// int __cdecl _cftoe(int a1, int a2, int a3, int a4);
// int __cdecl _cftoe2(int a1, int a2, int a3, int a4, unsigned __int8 a5);
// void *__cdecl _cftof(int a1, void *a2, int a3);
// char *__cdecl _cftof2(char *a1, int a2, int a3, char a4);
// char *__cdecl _cftog(int a1, int a2, int a3, int a4);
// void *__cdecl _cfltcvt(int a1, int a2, int a3, int a4, int a5);
// void *__cdecl _shift(const char *a4, int a2);
// void __cdecl _mtinitlocks();
// void __cdecl _lock(int a1);
// void __cdecl _unlock(int a1);
// void __cdecl _lock_file(unsigned int a1);
// void __cdecl _lock_file2(signed int a1, int a2);
// void __cdecl _unlock_file(unsigned int a1);
// void __cdecl _unlock_file2(signed int a1, int a2);
// UINT __cdecl _ioinit();
int __cdecl sub_4E16E0();
// int __cdecl __crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cchMultiByte, CHAR *lpDestStr, int cchDest, UINT CodePage);
// _DWORD __cdecl strncnt(_DWORD, _DWORD); weak
// signed int __cdecl _flsbuf(unsigned __int8 a1, int a2);
// int __cdecl _output(FILE *a1, unsigned __int8 *a2, int a3);
// int __cdecl write_char(unsigned __int8 a1, int a2, int a3);
// int __cdecl write_multi_char(unsigned __int8 a1, int a2, int a3, int a4);
// int __cdecl write_string(int a1, int a2, int a3, int a4);
// _DWORD __cdecl get_int_arg(_DWORD); weak
// _DWORD __cdecl get_int64_arg(_DWORD); weak
// __int16 __cdecl get_short_arg(int a1);
// int __cdecl _isctype(int a1, int a2);
// HANDLE __cdecl _heap_init();
// signed int __cdecl _mtinit();
// _DWORD __cdecl _initptd(_DWORD); weak
// LPVOID __cdecl _getptd();
// double __usercall sub_4E2740<st0>(long double a1<st1>, long double a2<st0>);
// int sub_4E277C(void); weak
// void __cdecl unknown_libname_34();
// void __fastcall rtforatn20(__int16 a1);
// double __usercall sub_4E27D2<st0>(double result<st0>);
// double __usercall s_5___12<st0>(double result<st0>);
// double __usercall _fFCOS<st0>(long double a1<st0>);
// double __usercall _fFSIN<st0>(int a1<ebp>, long double a2<st0>);
// int unknown_libname_38(); weak
// LPVOID __cdecl realloc(BOOL lpMem, DWORD dwBytes);
// DWORD __cdecl _msize(LPCVOID lpMem);
// void __usercall fFYTOX(__int16 a1<cx>, int a2<ebp>, double a3<st1>, long double a4<st0>);
// int unknown_libname_50(); weak
// void __usercall unknown_libname_54(int a1<ebp>);
// void __usercall rtforloginf(char a1<cl>, int a2<ebp>);
// double __usercall fFLOGm<st0>(char a1<cl>, long double a2<st0>);
// void __cdecl rtforyto0();
// double __usercall rtfor0tox<st0>(int a1<ebp>, double a2<st0>);
// void __fastcall rtforexpinf(char a1);
// int __thiscall _ffexpm1(_DWORD); weak
// double __usercall isintTOS<st0>(double result<st0>);
// double __usercall usepowhlp<st0>(double a1<st1>, double a2<st0>, int a3<ebp>);
// void __cdecl _global_unwind2(PVOID TargetFrame);
// int __cdecl loc_4E2AD0(PVOID TargetFrame); weak
// signed int __cdecl _unwind_handler(int a1, int a2, int a3, int a4);
// int __usercall _local_unwind2<eax>(int ebp0<ebp>, int a1, int a2);
// signed int __thiscall _abnormal_termination(int this);
// int __userpurge _NLG_Notify<eax>(int result<eax>, int a2<ebp>, int a3);
// LONG __cdecl _XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo);
// _DWORD __cdecl xcptlookup(_DWORD, _DWORD); weak
// int __cdecl _ismbblead(char a1);
// signed int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3);
// BOOL __cdecl _setenvp();
// int __cdecl _setargv();
// _DWORD __cdecl parse_cmdline(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void *__cdecl __crtGetEnvironmentStringsA();
// int __cdecl _setmbcp(int); idb
// _DWORD __cdecl getSystemCP(_DWORD); weak
// _DWORD __cdecl CPtoLCID(_DWORD); weak
// int __cdecl setSBCS();
// int __cdecl __initmbctable();
// signed int __usercall _except_handler3<eax>(int a1<ebp>, int a2, int a3, int a4);
// int __stdcall unknown_libname_82(int a1);
// int __cdecl _FF_MSGBANNER();
// _DWORD __cdecl _NMSG_WRITE(_DWORD); weak
// int __cdecl _alloc_osfhnd();
// signed int __cdecl _set_osfhnd(UINT a1, HANDLE hHandle);
// _DWORD __cdecl _free_osfhnd(_DWORD); weak
// signed int __cdecl _get_osfhandle(UINT a1);
// void __cdecl _lock_fhandle(int a1);
// void __cdecl _unlock_fhandle(int a1);
// _DWORD __cdecl _chsize_lk(_DWORD, _DWORD); weak
// int __cdecl tolower(int); idb
// int __cdecl _tolower_lk(int); idb
// _DWORD __cdecl _callnewh(_DWORD); weak
// _DWORD __cdecl _freebuf(_DWORD); weak
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
// int __cdecl _fwrite_lk(const void *a1, unsigned int a2, int a3, int a4);
// int __cdecl _openfile(const char *a1, int a2, int a3, int a4);
// int __cdecl _getstream();
// signed int __cdecl _filbuf(int a1);
// int __cdecl _mbctoupper(signed int a1);
// signed int __cdecl _commit(UINT a1);
int __cdecl __initstdio();
// int __cdecl __endstdio();
// _DWORD __cdecl _getbuf(_DWORD); weak
// int __fastcall _trandisp1();
// int __usercall _trandisp2<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char c0_0c, char c2_0c, char c3_0c, char c0_0b, char c2_0b, char c3_0b, char c0_0a, char c2_0a, char c3_0a, char c0_0, char c2_0, char c3_0, char a6, char a7, char a8);
// void __cdecl unknown_libname_90();
// int unknown_libname_93(); weak
// int unknown_libname_94(); weak
// void __cdecl unknown_libname_95();
// double __usercall _tosnan1<st0>(int a1<ebp>, double a2<st0>);
// double __usercall _nosnan2<st0>(int a1<ebp>, double a2<st1>, double a3<st0>);
// double __usercall _tosnan2<st0>(int a1<ebp>, double a2<st1>, double a3<st0>);
// double __usercall _nan2<st0>(int a1<ebp>, double a2<st1>, double a3<st0>);
// void __usercall _rtindfpop(double a1<st0>, int a2<ebp>);
// void __usercall _rtindfnpop(int a1<ebp>);
// void __usercall _rttosnpopde(int a1<ebp>);
// int unknown_libname_108(); weak
// _DWORD __cdecl _87except(_DWORD, _DWORD, _DWORD); weak
// unsigned int __cdecl _control87(unsigned int, unsigned int); idb
// unsigned int __cdecl _controlfp(unsigned int a1, int a2);
// signed int __cdecl _abstract_cw(__int16 a1);
// char __cdecl _hw_cw(int a1);
// void __cdecl _fptrap();
// signed int __cdecl _ZeroTail(int a1, signed int a2);
// int __cdecl _IncMan(int a1, signed int a2);
// int __cdecl _RoundMan(int a1, signed int a2);
// int __cdecl _CopyMan(int a1, int a2);
// int __cdecl _FillZeroMan(int a1);
// signed int __cdecl _IsZeroMan(int a1);
// int __cdecl _ShrMan(unsigned int *a1, signed int a2);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl _ld12tof(int a1, int a2);
void __cdecl abort();
int __cdecl sub_4E5170(int a1, int a2);
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *Str);
// unsigned int __cdecl _fptostr(void *a1, unsigned int a2, int a3);
// int __cdecl _fltout2(int a1, int a2, int a3, char *a4);
// _DWORD __cdecl __dtold(_DWORD, _DWORD); weak
// signed int __cdecl __init_time();
// _DWORD __cdecl _get_lc_time(_DWORD); weak
// _DWORD __cdecl _free_lc_time(_DWORD); weak
// int __cdecl storeTimeFmt(LCID Locale, int); idb
// signed int __cdecl __init_numeric();
// _DWORD __cdecl fix_grouping(_DWORD); weak
// signed int __cdecl __init_monetary();
// _DWORD __cdecl _get_lc_lconv(_DWORD); weak
// double __cdecl _copysign(double, double);
// void __cdecl _fpreset();
signed int __cdecl sub_4E60B0();
int __cdecl sub_4E6360();
// signed int __cdecl strcspn(int a1, int a2);
// char __cdecl strpbrk(int a1, int a2);
// int __cdecl _isatty(UINT a1);
// int __cdecl wctomb(int a1, const WCHAR WideCharStr);
// int __cdecl _wctomb_lk(LPSTR lpMultiByteStr, const WCHAR WideCharStr);
// __int64 __stdcall _aulldiv(unsigned __int64 a1, unsigned int a2, unsigned int a3);
// int __stdcall _aullrem(unsigned __int64 a1, __int64 a2);
// void __cdecl __crtGetStringTypeW(DWORD dwInfoType, LPCWSTR lpWideCharStr, int cchWideChar, WORD *lpCharType, UINT CodePage, LCID Locale);
// BOOL __cdecl __crtGetStringTypeA(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cchMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale);
// LPVOID __cdecl calloc(int a1, int a2);
// signed int __cdecl _powhlp(long double a1, double a2, int a3);
// _DWORD __cdecl _d_inttype(double); weak
// double __cdecl fdiv_main_routine(_TBYTE a1, _TBYTE a2);
// void __usercall unknown_libname_187(double a1<st1>, double a2<st0>);
// void __usercall unknown_libname_188(double a1<st1>, double a2<st0>);
// int __usercall _safe_fdivr<eax>(int a1<eax>, double a2<st1>, double a3<st0>);
// void __fastcall _fprem_common(int a1, char a2, __int64 a3, int a5, int a6, _BYTE *a7, int argC_8, __int64 a8, __int16 a9);
// void __usercall _adj_fprem(int a1<ecx>, double a2<st0>);
// void __fastcall _fprem1_common(int a1, char a2, __int64 a3, int a5, int a6, _BYTE *a7, int argC_8, __int64 a8, __int16 a9);
// void __usercall _adj_fprem1(int a1<ecx>, double a2<st0>);
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD); weak
// _DWORD __cdecl _setmode_lk(_DWORD, _DWORD); weak
// void __usercall _alloca_probe(unsigned int a1<eax>, int a2);
// int __cdecl _fcloseall();
// int __cdecl _raise_exc(DWORD Arguments, int, int, int, int, int); idb
// bool __cdecl _handle_exc(char a1, int a2, __int16 a3);
// errno_t __cdecl _set_errno(int Value);
int __cdecl _matherr(struct _exception *);
// int __usercall _statfp<eax>(__int16 a1<fpstat>, char a2, char a3, char a4);
// int __usercall _clrfp<eax>(__int16 a1<fpstat>, char a2, char a3, char a4);
// int __cdecl _ctrlfp();
// void __cdecl _set_statfp();
// _DWORD __cdecl __addl(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __add_12(int a1, int a2);
// int __cdecl __shl_12(int a1);
// int __cdecl __shr_12(int a1);
// int __cdecl __mtold12(int a1, int a2, int a3);
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// signed int __cdecl _I10_OUTPUT(__int64 a1, __int16 a2, int a3, char a4, int a5);
// int __cdecl __getlocaleinfo(int, LCID Locale, LCTYPE LCType, int); idb
// int __cdecl __crtGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpWideCharStr, int cchWideChar, UINT CodePage);
// int __cdecl __crtGetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpMultiByteStr, int cchMultiByte, UINT CodePage);
// double __cdecl _set_exp(double a1, __int16 a2);
// signed int __cdecl _sptype(int a1, int a2);
// double __cdecl _decomp(double, _DWORD); weak
// double __cdecl _frnd(double); weak
// signed int __cdecl _fpclass(int a1, int a2);
// __int16 __cdecl __ld12mul(int a1, int a2);
// void __cdecl __multtenpow12(int a1, signed int a2, int a3);
// char *__cdecl _strdup(int a1);
// char *__cdecl strchr(const char *, int); idb
// void __stdcall thunk_RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// signed int __cdecl tell(int a1);
// unsigned int __cdecl _strrev(unsigned int a1);
// LONG __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData); idb
// LONG __stdcall RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); idb
// LONG __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); idb
// LONG __stdcall RegCloseKey(HKEY hKey); idb
// LONG __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData); idb
// HBITMAP __stdcall CreateBitmapIndirect(const BITMAP *); idb
// int __stdcall GetDeviceCaps(HDC, int); idb
// BOOL __stdcall DeleteDC(HDC); idb
// BOOL __stdcall DeleteObject(HGDIOBJ); idb
// HPALETTE __stdcall CreatePalette(const LOGPALETTE *); idb
// BOOL __stdcall AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY *); idb
// BOOL __stdcall PatBlt(HDC, int, int, int, int, DWORD); idb
// HPALETTE __stdcall SelectPalette(HDC, HPALETTE, BOOL); idb
// HGDIOBJ __stdcall SelectObject(HDC, HGDIOBJ); idb
// UINT __stdcall GetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY); idb
// DWORD __stdcall GdiSetBatchLimit(DWORD); idb
// UINT __stdcall RealizePalette(HDC); idb
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// BOOL __stdcall SetEvent(HANDLE hEvent); idb
// BOOL __stdcall ResetEvent(HANDLE hEvent); idb
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds); idb
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds); idb
// DWORD GetLastError(void); idb
// DWORD GetTickCount(void); idb
// BOOL __stdcall SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts); idb
// BOOL __stdcall SetCommState(HANDLE hFile, LPDCB lpDCB); idb
// BOOL __stdcall SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue); idb
// BOOL __stdcall GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts); idb
// BOOL __stdcall GetCommState(HANDLE hFile, LPDCB lpDCB); idb
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); idb
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped); idb
// BOOL __stdcall ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat); idb
// BOOL __stdcall ClearCommBreak(HANDLE hFile); idb
// BOOL __stdcall SetCommBreak(HANDLE hFile); idb
// BOOL __stdcall GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat); idb
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); idb
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType); idb
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType); idb
// BOOL __stdcall FlushFileBuffers(HANDLE hFile); idb
// BOOL __stdcall SetEndOfFile(HANDLE hFile); idb
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle); idb
// UINT GetOEMCP(void); idb
// UINT GetACP(void); idb
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// BOOL __stdcall FreeEnvironmentStringsW(LPWSTR); idb
// LPSTR GetEnvironmentStringsA(void); idb
// BOOL __stdcall FreeEnvironmentStringsA(LPSTR); idb
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData); idb
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation); idb
// DWORD __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem); idb
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes); idb
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex); idb
// void __stdcall SetLastError(DWORD dwErrCode); idb
// DWORD TlsAlloc(void); idb
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue); idb
// DWORD GetCurrentThreadId(void); idb
// HANDLE __stdcall HeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize); idb
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest); idb
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cchMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar); idb
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest); idb
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cchMultiByte, LPWSTR lpWideCharStr, int cchWideChar); idb
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle); idb
// UINT __stdcall SetHandleCount(UINT uNumber); idb
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName); idb
// BOOL __stdcall SetCurrentDirectoryA(LPCSTR lpPathName); idb
// DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer); idb
// BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue); idb
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod); idb
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes); idb
// DWORD __stdcall GetFileType(HANDLE hFile); idb
// DWORD GetVersion(void); idb
// LPSTR GetCommandLineA(void); idb
// void __stdcall Sleep(DWORD dwMilliseconds); idb
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName); idb
// BOOL __stdcall CloseHandle(HANDLE hObject); idb
// BOOL __stdcall FindClose(HANDLE hFindFile); idb
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData); idb
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData); idb
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); idb
// BOOL __stdcall FreeLibrary(HMODULE hLibModule); idb
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName); idb
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo); idb
// LPWSTR GetEnvironmentStringsW(void); idb
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData); idb
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo); idb
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName); idb
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); idb
// HANDLE GetCurrentProcess(void); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// void __stdcall ExitProcess(UINT uExitCode); idb
// DWORD GetLogicalDrives(void); idb
// int __stdcall lstrlenA(LPCSTR lpString); idb
// UINT __stdcall GetDriveTypeA(LPCSTR lpRootPathName); idb
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString); idb
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize); idb
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// UCHAR __stdcall Netbios(PNCB pncb); idb
// BOOL ReleaseCapture(void); idb
// int _wsprintfA(LPSTR, LPCSTR, ...); idb
// ATOM __stdcall RegisterClassA(const WNDCLASSA *lpWndClass); idb
// UINT __stdcall SetTimer(HWND hWnd, UINT nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc); idb
// BOOL __stdcall GetCursorPos(LPPOINT lpPoint); idb
// LRESULT __stdcall DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); idb
// BOOL __stdcall UpdateWindow(HWND hWnd); idb
// HWND __stdcall SetCapture(HWND hWnd); idb
// BOOL __stdcall DestroyWindow(HWND hWnd); idb
// BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint); idb
// HICON __stdcall CreateIconIndirect(PICONINFO piconinfo); idb
// BOOL __stdcall DestroyIcon(HICON hIcon); idb
// int __stdcall ShowCursor(BOOL bShow); idb
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect); idb
// BOOL __stdcall AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu); idb
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC); idb
// BOOL __stdcall EndDialog(HWND hDlg, int nResult); idb
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase); idb
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint); idb
// int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); idb
// SHORT __stdcall GetAsyncKeyState(int vKey); idb
// BOOL __stdcall MessageBeep(UINT uType); idb
// HMENU __stdcall LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName); idb
// BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); idb
// DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck); idb
// BOOL __stdcall DestroyMenu(HMENU hMenu); idb
// BOOL __stdcall SetMenu(HWND hWnd, HMENU hMenu); idb
// BOOL WaitMessage(void); idb
// LONG __stdcall DispatchMessageA(const MSG *lpMsg); idb
// BOOL __stdcall TranslateMessage(const MSG *lpMsg); idb
// BOOL __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg); idb
// HCURSOR __stdcall SetCursor(HCURSOR hCursor); idb
// HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName); idb
// LONG __stdcall SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong); idb
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow); idb
// HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName); idb
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); idb
// int __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam); idb
// HDC __stdcall GetDC(HWND hWnd); idb
// BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax); idb
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint); idb
// void __stdcall PostQuitMessage(int nExitCode); idb
// BOOL __stdcall DrawMenuBar(HWND hWnd); idb
// LONG __stdcall GetWindowLongA(HWND hWnd, int nIndex); idb
// HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos); idb
// UINT __stdcall GetMenuItemID(HMENU hMenu, int nPos); idb
// BOOL __stdcall WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, DWORD dwData); idb
// int __stdcall GetMenuItemCount(HMENU hMenu); idb
// BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable); idb
// BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint); idb
// BOOL __stdcall OffsetRect(LPRECT lprc, int dx, int dy); idb
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint); idb
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect); idb
// UINT auxGetNumDevs(void); idb
// MMRESULT __stdcall auxGetDevCapsA(UINT uDeviceID, LPAUXCAPSA pac, UINT cbac); idb
// MMRESULT __stdcall auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume); idb
// MMRESULT __stdcall auxSetVolume(UINT uDeviceID, DWORD dwVolume); idb
// UINT waveOutGetNumDevs(void); idb
// MMRESULT __stdcall waveOutGetDevCapsA(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc); idb
// MCIERROR __stdcall mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback); idb
// int __stdcall ioctlsocket(SOCKET s, __int32 cmd, u_long *argp); idb
// unsigned __int32 __stdcall inet_addr(const char *cp); idb
// char *__stdcall inet_ntoa(struct in_addr in); idb
// struct hostent *__stdcall gethostbyname(const char *name); idb
// int WSAGetLastError(void); idb
// int __stdcall gethostname(char *name, int namelen); idb
// int __stdcall sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen); idb
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen); idb
// u_long __stdcall htonl(u_long hostlong); idb
// u_short __stdcall htons(u_short hostshort); idb
// SOCKET __stdcall socket(int af, int type, int protocol); idb
// int WSACleanup(void); idb
// int __stdcall closesocket(SOCKET s); idb
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); idb
// int __stdcall recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen); idb
// void __stdcall AIL_end_sample(HSAMPLE S);
// void __stdcall AIL_set_sequence_loop_count(HSEQUENCE S, signed __int32 loop_count);
// void __stdcall AIL_start_sequence(HSEQUENCE S);
// void __stdcall AIL_set_XMIDI_master_volume(HMDIDRIVER mdi, signed __int32 master_volume);
// signed __int32 __stdcall AIL_init_sequence(HSEQUENCE S, void *start, signed __int32 sequence_num);
// HSEQUENCE __stdcall AIL_allocate_sequence_handle(HMDIDRIVER mdi);
// signed __int32 __stdcall AIL_get_preference(unsigned __int32 number);
// void __stdcall AIL_serve();
// void __stdcall AIL_init_sample(HSAMPLE S);
// void __stdcall AIL_set_sample_type(HSAMPLE S, signed __int32 format, unsigned __int32 flags);
// void __stdcall AIL_set_sample_playback_rate(HSAMPLE S, signed __int32 playback_rate);
// void __stdcall AIL_set_sample_loop_count(HSAMPLE S, signed __int32 loop_count);
// void __stdcall AIL_set_sample_address(HSAMPLE S, void *start, unsigned __int32 len);
// signed __int32 __stdcall AIL_sample_volume(HSAMPLE S);
// void __stdcall AIL_set_sample_volume(HSAMPLE S, signed __int32 volume);
// void __stdcall AIL_start_sample(HSAMPLE S);
// unsigned __int32 __stdcall AIL_sample_status(HSAMPLE S);
// void __stdcall AIL_resume_sequence(HSEQUENCE S);
// signed __int32 __stdcall AIL_digital_handle_release(HDIGDRIVER drvr);
// signed __int32 __stdcall AIL_digital_handle_reacquire(HDIGDRIVER drvr);
// void __stdcall AIL_shutdown();
// HSAMPLE __stdcall AIL_allocate_sample_handle(HDIGDRIVER dig);
// signed __int32 __stdcall AIL_startup();
// signed __int32 __stdcall AIL_set_preference(unsigned __int32 number, signed __int32 value);
// signed __int32 __stdcall AIL_waveOutOpen(HDIGDRIVER *drvr, LPHWAVEOUT *lphWaveOut, signed __int32 wDeviceID, LPWAVEFORMAT lpFormat);
// char *__stdcall AIL_last_error();
// unsigned __int32 __stdcall AIL_redbook_play(HREDBOOK hand, unsigned __int32 startmsec, unsigned __int32 endmsec);
// void __stdcall AIL_redbook_close(HREDBOOK hand);
// HREDBOOK __stdcall AIL_redbook_open(unsigned __int32 which);
// unsigned __int32 __stdcall AIL_redbook_tracks(HREDBOOK hand);
// void __stdcall AIL_redbook_track_info(HREDBOOK hand, unsigned __int32 tracknum, unsigned __int32 *startmsec, unsigned __int32 *endmsec);
// unsigned __int32 __stdcall AIL_redbook_position(HREDBOOK hand);
// unsigned __int32 __stdcall AIL_redbook_status(HREDBOOK hand);
// unsigned __int32 __stdcall AIL_redbook_stop(HREDBOOK hand);
// void __stdcall AIL_stop_sequence(HSEQUENCE S);
// unsigned __int32 __stdcall AIL_sequence_status(HSEQUENCE S);
// void __stdcall AIL_release_sequence_handle(HSEQUENCE S);
// void __stdcall AIL_midiOutClose(HMDIDRIVER mdi);
// signed __int32 __stdcall AIL_midiOutOpen(HMDIDRIVER *drvr, LPHMIDIOUT *lphMidiOut, signed __int32 dwDeviceID);
// int __stdcall SmackSummary(_DWORD, _DWORD); weak
// int __stdcall SmackSoundUseDirectSound(_DWORD); weak
// int __stdcall SmackSoundUseMSS(_DWORD); weak
// int __stdcall SmackToBufferRect(_DWORD, _DWORD); weak
// int __stdcall SmackNextFrame(_DWORD); weak
// int __stdcall SmackToBuffer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall SmackWait(_DWORD); weak
// int __stdcall SmackClose(_DWORD); weak
// int __stdcall SmackDoFrame(_DWORD); weak
// int __stdcall SmackOpen(_DWORD, _DWORD, _DWORD); weak
// int __stdcall _WinGBitBlt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall _WinGStretchBlt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall _WinGSetDIBColorTable(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall _WinGRecommendDIBFormat(_DWORD); weak
// int _WinGCreateDC(void); weak
// int __stdcall _WinGCreateBitmap(_DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

int (__stdcall *soundManager::_vftable_)(int) = &soundManager::Open; // weak
managerVtable highScoreManager::_vftable_ = { &highScoreManager::Open, &highScoreManager::Close, &highScoreManager::Main };
managerVtable recruitUnit::_vftable_ = { &recruitUnit::Open, &recruitUnit::Close, &recruitUnit::Main };
int (__stdcall *fileRequester::_vftable_)(int) = &fileRequester::Open; // weak
BUILDING_CODE byte_4EA068[6][32] =
{
  {
    11,
    5,
    6,
    13,
    8,
    9,
    15,
    12,
    10,
    1,
    20,
    25,
    23,
    28,
    2,
    0,
    24,
    29,
    17,
    18,
    16,
    3,
    14,
    19,
    21,
    26,
    22,
    27,
    7,
    4,
    255,
    255
  },
  {
    16,
    17,
    13,
    11,
    24,
    1,
    15,
    23,
    28,
    5,
    6,
    12,
    10,
    20,
    25,
    21,
    31,
    19,
    22,
    27,
    0,
    18,
    2,
    3,
    14,
    4,
    8,
    9,
    7,
    255,
    255,
    255
  },
  {
    13,
    24,
    23,
    5,
    6,
    8,
    9,
    12,
    15,
    21,
    26,
    19,
    0,
    3,
    14,
    22,
    27,
    4,
    10,
    20,
    25,
    1,
    2,
    17,
    11,
    7,
    16,
    255,
    255,
    255,
    255,
    255
  },
  {
    23,
    21,
    5,
    6,
    8,
    9,
    15,
    16,
    12,
    2,
    1,
    0,
    10,
    7,
    3,
    14,
    11,
    19,
    13,
    22,
    27,
    20,
    29,
    30,
    24,
    4,
    255,
    255,
    255,
    255,
    255,
    255
  },
  {
    29,
    24,
    1,
    15,
    16,
    23,
    28,
    5,
    6,
    12,
    21,
    26,
    19,
    22,
    0,
    2,
    3,
    14,
    4,
    20,
    13,
    10,
    8,
    9,
    7,
    11,
    255,
    255,
    255,
    255,
    255,
    255
  },
  {
    13,
    2,
    6,
    8,
    9,
    12,
    15,
    1,
    24,
    19,
    21,
    26,
    0,
    16,
    3,
    14,
    23,
    28,
    20,
    25,
    22,
    27,
    11,
    5,
    4,
    10,
    7,
    255,
    255,
    255,
    255,
    255
  }
};
managerVtable townManager::_vftable_ = { &townManager::Open, &townManager::Close, &townManager::Main };
int dword_4EA270[] = { 64 }; // weak
int (__stdcall *advManager::_vftable_)(int) = &advManager::Open; // weak
managerVtable combatManager_vtable = { &combatManager::Open, &combatManager::Close, &combatManager::Main };
int (__stdcall *swapManager::_vftable_)(int) = &swapManager::Open; // weak
managerVtable heroWindowManager::_vftable_ =
{
  &heroWindowManager::Open,
  &heroWindowManager::Close,
  &heroWindowManager::Main
};
resourceVtable bitmap::_vftable_ = { &bitmap::_scalar_deleting_destructor_ };
managerVtable baseManager::_vftable_ = { &_purecall, &_purecall, &_purecall }; // weak
managerVtable resourceManager::_vftable_ = { &resourceManager::Open, &resourceManager::Close, &resourceManager::Main }; // weak
managerVtable mouseManager::_vftable_ = { &mouseManager::Open, &mouseManager::Close, &mouseManager::Main };
widgetVtable border::_vftable_ = { &border::Draw, &border::_scalar_deleting_destructor_, &border::Main };
resourceVtable icon::_vftable_ = { &icon::_scalar_deleting_destructor_ };
resourceVtable font::_vftable_ = { &font::_scalar_deleting_destructor_ };
widgetVtable iconWidget::_vftable_ =
{
  &iconWidget::Draw,
  &iconWidget::_scalar_deleting_destructor_,
  &iconWidget::Main
}; // weak
managerVtable inputManager::_vftable_ = { &inputManager::Open, &inputManager::Close, &_getmbcp };
widgetVtable textWidget::_vftable_ =
{
  &textWidget::Draw,
  &textWidget::_scalar_deleting_destructor_,
  &textWidget::Main
};
int (__stdcall *palette::_vftable_)(int) = &palette::_scalar_deleting_destructor_; // weak
int (*resource::_vftable_[2])() = { &_purecall, &textEntryWidget::Draw }; // weak
widgetVtable textEntryWidget::_vftable_ =
{
  &textEntryWidget::Draw,
  &textEntryWidget::_scalar_deleting_destructor_,
  &textEntryWidget::Main
}; // weak
widgetVtable listBoxWidget::_vftable_ =
{
  &listBoxWidget::Draw,
  &listBoxWidget::_scalar_deleting_destructor_,
  &listBoxWidget::Main
}; // weak
widgetVtable dropListWidget::_vftable_ =
{
  &dropListWidget::Draw,
  &dropListWidget::_scalar_deleting_destructor_,
  &dropListWidget::Main
}; // weak
int (*dimmerWidget::_vftable_)() = &dimmerWidget::Draw; // weak
widgetVtable button::_vftable_ = { &button::Draw, &button::_scalar_deleting_destructor_, &button::Main };
widgetVtable widget::_vftable_ = { &_purecall, &_purecall, &_purecall };
int (__thiscall *tileset::_vftable_[3])(void *, int) =
{
  &tileset::_scalar_deleting_destructor_,
  &sample::_scalar_deleting_destructor_,
  &MIDIWrap::_scalar_deleting_destructor_
}; // weak
resourceVtable sample::_vftable_ = { &sample::_scalar_deleting_destructor_ };
resourceVtable MIDIWrap::_vftable_ = { &MIDIWrap::_scalar_deleting_destructor_ };
double maxdouble1 =  1.797693134862316e308;
double mindouble1 =  2.225073858507201e-308;
double maxdouble2 =  1.797693134862316e308;
_UNKNOWN SCS; // weak
int CDPlaying = 0; // weak
void *ptr = NULL; // idb
void *dword_4ED0B4 = NULL; // idb
void *dword_4ED0B8 = NULL; // idb
HREDBOOK aStatusCdPositi = NULL; // idb
DWORD pdwVolume = 0u; // idb
__int16 word_4ED168 = 96; // weak
__int16 word_4ED1C0 = 160; // weak
int iCalibrateLoop = 0; // weak
__int16 word_4ED28C = 826; // weak
__int16 word_4ED2AC = 1021; // weak
int lpIDC = 0; // weak
int dcoID = 0; // weak
int IPXGuid = 0; // weak
int TCPGuid = 0; // weak
int dword_4ED2DC = 0; // weak
int iDPRcvBufferHead = 0; // weak
int iDPRcvBufferTail = 0; // weak
void *ppDPRcvBuffer = NULL; // idb
void *piDPRcvBufferSize = NULL; // idb
int bStartUpInfoReceived = 0; // weak
HMODULE hinstDplayx = NULL; // idb
int iDPWaitForFirstGuestStatus = 0; // weak
int iDPWaitForHostStatus = 0; // weak
int iWaitForHostWaitCount = 0; // weak
int iEnumCount = 0; // weak
int iLastHereIAmTickCount = 0; // weak
int bInDPSD = 0; // weak
int giNumHumanPlayers = 1; // weak
void *off_4ED330 = (void *)0x504354; // weak
__int16 word_4ED340 = 95; // weak
__int16 word_4ED4E0 = 219; // weak
__int16 word_4ED524 = 254; // weak
__int16 word_4ED588 = 284; // weak
__int16 word_4ED5AC = 312; // weak
__int16 word_4ED5D0 = 355; // weak
__int16 word_4ED61C = 426; // weak
__int16 word_4ED6E0 = 510; // weak
char byte_4EDB4C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDB50[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDB60[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDB64[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDB70[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDB74[] = { '\0', '\0', '\0', '\0' }; // idb
char aRecruit0_bin[13] = "recruit0.bin"; // weak
char aRecruiq0_bin[13] = "recruiq0.bin"; // weak
char castleSlotsBase[] = { '\x13' }; // weak
char byte_4EDCF0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDCF8[] = { '\0', '\0', '\0', '\0' }; // idb
int giMapSizeFilter = 4; // weak
char byte_4EDEAC[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDEB0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDEC4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDF2C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EDFCC[] = { '\0', '\0', '\0', '\0' }; // idb
void *off_4EE0E0 = &unk_4EE100; // weak
char iInitNetHostStatus = '\0'; // weak
char iInitNetGuestStatus = '\0'; // weak
int iNameRetryCount = 0; // weak
char iWaitForHostStatus = '\0'; // weak
char iWaitForGuestStatus = '\0'; // weak
int iLastBroadcastTime = 0; // weak
__int16 coreRatio[] = { 250 }; // weak
char aUnits[6] = "units"; // weak
char aUnits_0[6] = "units"; // weak
char aMarketplace[12] = "Marketplace"; // weak
char aMarketplace_0[12] = "Marketplace"; // weak
char aMarketplace_1[12] = "Marketplace"; // weak
char byte_4EE4A0[] = { '\0', '\0', '\0', '\0' }; // idb
int iViewGeneralWhichSide = 0; // weak
SBuildingInfo sBuildingInfo[6][32] =
{
  {
    { '\0', 397, 46, 84, 138 },
    { '\x05', 0, 130, 53, 63 },
    { '\x05', 345, 114, 83, 62 },
    { '\x05', 531, 214, 113, 42 },
    { '\0', 188, 214, 39, 42 },
    { '\0', 69, 108, 67, 55 },
    { '\x05', 0, 49, 286, 116 },
    { '\0', 478, 193, 46, 63 },
    { '\x05', 7, 33, 0, 0 },
    { '\x05', 134, 37, 0, 0 },
    { '\0', 219, 138, 120, 30 },
    { '\0', 286, 102, 88, 22 },
    { '\0', 0, 146, 311, 30 },
    { '\0', 0, 78, 251, 22 },
    { '\t', 531, 211, 113, 45 },
    { '\0', 293, 107, 59, 35 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\x05', 192, 163, 69, 52 },
    { '\0', 135, 149, 73, 32 },
    { '\x05', 240, 166, 91, 66 },
    { '\0', 323, 174, 102, 69 },
    { '\a', 48, 176, 104, 80 },
    { '\0', 445, 50, 195, 157 },
    { '\0', 135, 149, 73, 32 },
    { '\x05', 240, 166, 91, 66 },
    { '\0', 323, 174, 102, 69 },
    { '\a', 48, 176, 104, 80 },
    { '\0', 445, 50, 195, 157 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 }
  },
  {
    { '\b', 346, 22, 54, 120 },
    { '\0', 466, 94, 87, 47 },
    { '\0', 0, 161, 136, 85 },
    { '\x05', 505, 199, 138, 56 },
    { '\0', 268, 189, 50, 66 },
    { '\0', 44, 109, 87, 52 },
    { '\x06', 0, 0, 214, 175 },
    { '\0', 463, 154, 38, 81 },
    { '\0', 10, 58, 0, 0 },
    { '\0', 118, 45, 0, 0 },
    { '\0', 217, 166, 67, 43 },
    { '\0', 240, 106, 73, 34 },
    { '\x05', 115, 138, 182, 42 },
    { '\0', 210, 80, 197, 61 },
    { '\t', 505, 199, 138, 56 },
    { '\x05', 206, 99, 46, 42 },
    { '\x05', 0, 0, 0, 0 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 290, 138, 58, 45 },
    { '\0', 145, 195, 76, 52 },
    { '\0', 557, 48, 83, 83 },
    { '\x05', 496, 136, 138, 64 },
    { '\x05', 318, 174, 131, 54 },
    { '\x05', 407, 0, 113, 106 },
    { '\0', 145, 195, 76, 52 },
    { '\0', 0, 0, 0, 0 },
    { '\x05', 496, 136, 138, 64 },
    { '\x05', 318, 174, 131, 54 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 }
  },
  {
    { '\0', 279, 0, 63, 168 },
    { '\x05', 423, 167, 87, 50 },
    { '\x05', 490, 141, 148, 91 },
    { '\x05', 0, 208, 178, 48 },
    { '\0', 335, 205, 45, 29 },
    { '\0', 104, 130, 59, 42 },
    { '\x05', 0, 0, 201, 179 },
    { '\0', 152, 163, 28, 65 },
    { '\0', 98, 99, 0, 0 },
    { '\0', 151, 98, 0, 0 },
    { '\0', 404, 122, 69, 45 },
    { '\x05', 131, 185, 71, 53 },
    { '\0', 0, 171, 272, 23 },
    { '\0', 152, 0, 236, 84 },
    { '\t', 0, 208, 178, 48 },
    { '\x05', 223, 122, 37, 52 },
    { '\x05', 0, 0, 0, 0 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\x05', 472, 59, 111, 92 },
    { '\x05', 338, 146, 93, 61 },
    { '\0', 51, 164, 106, 40 },
    { '\0', 198, 178, 143, 71 },
    { '\0', 263, 226, 296, 30 },
    { '\0', 179, 0, 84, 119 },
    { '\x05', 338, 146, 93, 61 },
    { '\0', 51, 164, 106, 40 },
    { '\0', 198, 178, 143, 71 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 }
  },
  {
    { '\0', 586, 18, 54, 150 },
    { '\0', 520, 103, 64, 54 },
    { '\0', 476, 96, 82, 55 },
    { '\x05', 517, 200, 123, 56 },
    { '\0', 342, 205, 67, 51 },
    { '\0', 298, 135, 72, 31 },
    { '\x05', 241, 18, 181, 150 },
    { '\0', 478, 161, 37, 63 },
    { '\0', 311, 84, 0, 0 },
    { '\0', 359, 83, 0, 0 },
    { '\0', 386, 171, 71, 40 },
    { '\x06', 60, 32, 63, 186 },
    { '\x05', 211, 166, 301, 21 },
    { '\0', 0, 160, 59, 96 },
    { '\t', 517, 200, 123, 56 },
    { '\x05', 418, 83, 53, 84 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\x06', 0, 64, 48, 50 },
    { '\0', 237, 168, 78, 87 },
    { '\0', 492, 50, 53, 39 },
    { '\0', 139, 163, 190, 83 },
    { '\0', 82, 92, 178, 68 },
    { '\0', 92, 0, 64, 257 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 139, 163, 190, 83 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 92, 0, 64, 257 },
    { '\0', 92, 0, 64, 257 },
    { '\0', 0, 0, 0, 0 }
  },
  {
    { '\0', 570, 0, 70, 126 },
    { '\x05', 505, 50, 51, 49 },
    { '\x06', 0, 149, 118, 76 },
    { '\x05', 0, 206, 206, 50 },
    { '\0', 249, 139, 28, 33 },
    { '\0', 58, 60, 49, 42 },
    { '\x05', 0, 0, 200, 99 },
    { '\0', 464, 45, 24, 72 },
    { '\0', 30, 17, 0, 0 },
    { '\0', 128, 17, 0, 0 },
    { '\0', 255, 163, 108, 53 },
    { '\0', 237, 208, 137, 49 },
    { '\0', 0, 90, 223, 14 },
    { '\0', 297, 95, 109, 78 },
    { '\t', 0, 206, 206, 50 },
    { '\0', 210, 52, 28, 35 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\x05', 467, 181, 38, 30 },
    { '\0', 231, 68, 192, 36 },
    { '\x05', 152, 130, 96, 60 },
    { '\0', 593, 184, 51, 31 },
    { '\0', 411, 0, 49, 167 },
    { '\0', 160, 0, 178, 67 },
    { '\0', 0, 0, 0, 0 },
    { '\x05', 152, 130, 96, 60 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 411, 0, 49, 167 },
    { '\0', 160, 0, 178, 67 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 }
  },
  {
    { '\x05', 557, 17, 85, 191 },
    { '\0', 275, 124, 62, 77 },
    { '\0', 455, 39, 51, 103 },
    { '\x05', 500, 220, 141, 36 },
    { '\0', 215, 213, 29, 41 },
    { '\0', 333, 115, 47, 70 },
    { '\x05', 289, 10, 134, 164 },
    { '\0', 365, 154, 41, 93 },
    { '\0', 330, 47, 0, 0 },
    { '\0', 360, 46, 0, 0 },
    { '\0', 412, 193, 98, 61 },
    { '\x06', 263, 181, 90, 65 },
    { '\0', 258, 171, 193, 19 },
    { '\0', 0, 0, 640, 63 },
    { '\t', 500, 220, 141, 36 },
    { '\0', 441, 77, 22, 99 },
    { '\x05', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 396, 177, 71, 35 },
    { '\0', 110, 174, 141, 45 },
    { '\x05', 0, 28, 241, 142 },
    { '\0', 20, 107, 124, 129 },
    { '\0', 221, 127, 66, 84 },
    { '\x06', 464, 72, 105, 124 },
    { '\0', 110, 174, 141, 45 },
    { '\x05', 0, 28, 241, 142 },
    { '\0', 0, 107, 144, 129 },
    { '\0', 223, 45, 65, 166 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 },
    { '\0', 0, 0, 0, 0 }
  }
};
char aHeroSArmy[12] = "Hero's Army"; // weak
char aHeroSArmy_0[12] = "Hero's Army"; // weak
__int16 word_4EEF50 = 2390; // weak
char byte_4EF150[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_4EF178 = 3620; // weak
char byte_4EF1F4[] = { '\0', '\0', '\0', '\0' }; // idb
int gbGameOver = 0; // weak
__int16 word_4EF26C = 660; // weak
char byte_4EF30C[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_4EF318 = 1103; // weak
__int16 word_4EF3C0 = 2808; // weak
__int16 word_4EF4B0 = 3582; // weak
char byte_4EF4EC[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_4EF660[] = { '\0' }; // weak
__int16 word_4EF67C = 6196; // weak
__int16 word_4EF69C = 6442; // weak
__int16 word_4EF6BC = 6793; // weak
__int16 word_4EF850 = 7016; // weak
char bMapInitialized = '\0'; // weak
__int16 word_4EFA44 = 7496; // weak
__int16 word_4EFA80 = 7585; // weak
__int16 word_4EFB9C = 7754; // weak
__int16 word_4EFDCC = 8094; // weak
__int16 word_4EFE08 = 8114; // weak
__int16 word_4EFEB4 = 8149; // weak
char giGroundToTerrain[] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b'
}; // idb
char giGroundShape[] = { '\x10' }; // weak
char gColorTableTan[] = { '' }; // weak
char gColorTableGray[256] =
{
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  '!',
  '\"',
  '#',
  '$',
  '\n',
  '\v',
  '\f',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x12',
  '\x13',
  '\x14',
  '\x14',
  '\x15',
  '\x16',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1F',
  '\x0E',
  '\x10',
  '\x11',
  '\x12',
  '\x14',
  '\x15',
  '\x16',
  '\x18',
  '\x19',
  '\x1A',
  '\x1C',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  ' ',
  '!',
  '!',
  '!',
  '\"',
  '\"',
  '\x10',
  '\x11',
  '\x12',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1E',
  '\x1F',
  ' ',
  ' ',
  '!',
  '\"',
  '#',
  '#',
  '$',
  '$',
  '$',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\f',
  '\r',
  '\x0E',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x18',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1F',
  ' ',
  ' ',
  '!',
  '\v',
  '\f',
  '\f',
  '\r',
  '\x0E',
  '\x0E',
  '\x10',
  '\x10',
  '\x11',
  '\x12',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1D',
  '\x1E',
  ' ',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x1A',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\x0E',
  '\x10',
  '\x11',
  '\x12',
  '\x14',
  '\x16',
  '\x18',
  '\x11',
  '\n',
  '\f',
  '\x0F',
  '\x13',
  '\n',
  '\n',
  '\x0F',
  '\x11',
  '\x12',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x18',
  '\x15',
  '\x16',
  '\x1A',
  '\x1A',
  '\x1B',
  '$',
  '\f',
  '\x12',
  '\x19',
  '\x13',
  '\x15',
  '\x18',
  '\x1A',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$',
  '$'
}; // weak
char gColorTableYellow[10] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char gColorTableScenWin[10] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char gColorTableDarkGray[10] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char gColorTableRed[] =
{
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  ''
}; // idb
char gColorTableDarkBrown[256] =
{
  '2',
  '*',
  '*',
  '*',
  '*',
  '2',
  '2',
  '2',
  '2',
  '5',
  '*',
  '+',
  '+',
  ',',
  ',',
  '-',
  '.',
  '.',
  '/',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  '<',
  '>',
  '>',
  '>',
  '>',
  '%',
  '&',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '<',
  '=',
  '>',
  '-',
  '.',
  '/',
  '0',
  '2',
  '3',
  '4',
  '6',
  '7',
  '8',
  ':',
  ':',
  ';',
  '<',
  '<',
  '=',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '9',
  ':',
  ':',
  '<',
  '<',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '+',
  '+',
  ',',
  ',',
  ',',
  '-',
  '-',
  '-',
  '.',
  '/',
  '0',
  '0',
  '1',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '<',
  ',',
  ',',
  '-',
  '.',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  '<',
  '>',
  '>',
  '+',
  '+',
  ',',
  ',',
  '-',
  '-',
  '.',
  '/',
  '/',
  '0',
  '1',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  '<',
  '=',
  '+',
  ',',
  '.',
  '/',
  '0',
  '1',
  '2',
  '4',
  '5',
  '6',
  '7',
  '9',
  ':',
  '<',
  '<',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  '>',
  ',',
  ',',
  '-',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '5',
  '6',
  '7',
  '9',
  ':',
  ';',
  '6',
  ':',
  '>',
  '>',
  '*',
  '-',
  '1',
  '7',
  '/',
  '1',
  '2',
  '3',
  '4',
  '5',
  '7',
  '8',
  ':',
  '3',
  '4',
  '7',
  '9',
  '6',
  '9',
  '8',
  ',',
  '0',
  '6',
  '>',
  '1',
  '3',
  '6',
  '9',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '2',
  '*'
};
int MAP_WIDTH = 72; // weak
int MAP_HEIGHT = 72; // weak
char *mapRevealed = NULL;
int gbClosingApp = 0; // weak
int gbForegroundApp = 0; // weak
int giMainVideoModeColorDepth = 8; // weak
int giMainVideoModeWidth = 640; // weak
int giMainVideoModeHeight = 480; // weak
int glMilliCounter = 0; // weak
char byte_4F0A28[] = { 'M' }; // weak
char byte_4F0A48[] = { 'I' }; // weak
char *gTilesetFiles[] =
{
  &unk_4F74C0,
  &unk_4F74C4,
  &unk_4F74C8,
  &unk_4F74CC,
  &unk_4F74D0,
  &unk_4F74D4,
  &unk_4F74D8,
  &unk_4F74DC,
  &unk_4F74E0,
  &unk_4F74E4,
  "objnhaun.icn",
  "objnarti.icn",
  "mons32.icn",
  "art32.icn",
  "flag32.icn",
  "ressmall.icn",
  "hourglas.icn",
  "route.icn",
  &unk_4F7558,
  "stonback.icn",
  "minimon.icn",
  "minihero.icn",
  "mtnsnow.icn",
  "mtnswmp.icn",
  "mtnlava.icn",
  "mtndsrt.icn",
  "mtndirt.icn",
  "mtnmult.icn",
  &unk_4F75D0,
  "extraovr.icn",
  "road.icn",
  "mtncrck.icn",
  "mtngras.icn",
  "trejngl.icn",
  "treevil.icn",
  "objntown.icn",
  "objntwba.icn",
  "objntwsh.icn",
  "objntwrd.icn",
  "objnxtra.icn",
  "objnwat2.icn",
  "objnmul2.icn",
  "tresnow.icn",
  "trefir.icn",
  "trefall.icn",
  "stream.icn",
  "objnrsrc.icn",
  "dummy.icn",
  "objngra2.icn",
  "tredeci.icn",
  "objnwatr.icn",
  "objngras.icn",
  "objnsnow.icn",
  "objnswmp.icn",
  "objnlava.icn",
  "objndsrt.icn",
  "objndirt.icn",
  "objncrck.icn",
  "objnlav3.icn",
  "objnmult.icn",
  "objnlav2.icn",
  "x_loc1.icn",
  "x_loc2.icn",
  "x_loc3.icn"
};
char bPuzzleDraw[] = { '\0' }; // weak
unsigned __int8 uDimPal[12][256] =
{
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    36u,
    36u,
    36u,
    36u,
    36u,
    36u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    62u,
    62u,
    62u,
    62u,
    62u,
    62u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    84u,
    84u,
    84u,
    84u,
    84u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    107u,
    107u,
    107u,
    107u,
    107u,
    107u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    127u,
    128u,
    129u,
    130u,
    130u,
    130u,
    130u,
    130u,
    130u,
    130u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    151u,
    151u,
    151u,
    151u,
    151u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    174u,
    174u,
    174u,
    174u,
    174u,
    174u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    197u,
    197u,
    197u,
    197u,
    197u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    213u,
    213u,
    213u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    230u,
    230u,
    230u,
    73u,
    75u,
    77u,
    79u,
    81u,
    76u,
    78u,
    74u,
    76u,
    78u,
    80u,
    244u,
    245u,
    245u,
    245u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    36u,
    36u,
    36u,
    36u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    62u,
    62u,
    62u,
    62u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    84u,
    84u,
    84u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    107u,
    107u,
    107u,
    107u,
    112u,
    113u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    127u,
    128u,
    129u,
    130u,
    130u,
    130u,
    130u,
    130u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    151u,
    151u,
    151u,
    156u,
    157u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    174u,
    174u,
    174u,
    174u,
    178u,
    179u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    197u,
    197u,
    197u,
    201u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    213u,
    213u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    224u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    230u,
    230u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    78u,
    244u,
    245u,
    245u,
    245u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    36u,
    36u,
    39u,
    40u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    62u,
    62u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    84u,
    84u,
    87u,
    88u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    107u,
    107u,
    110u,
    111u,
    112u,
    113u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    127u,
    128u,
    129u,
    130u,
    130u,
    130u,
    133u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    151u,
    151u,
    154u,
    155u,
    156u,
    157u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    174u,
    174u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    197u,
    197u,
    200u,
    201u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    213u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    223u,
    224u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    230u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    76u,
    243u,
    244u,
    245u,
    245u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    36u,
    38u,
    39u,
    40u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    62u,
    64u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    84u,
    86u,
    87u,
    88u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    107u,
    109u,
    110u,
    111u,
    112u,
    113u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    127u,
    128u,
    129u,
    130u,
    130u,
    132u,
    133u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    151u,
    153u,
    154u,
    155u,
    156u,
    157u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    174u,
    176u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    197u,
    199u,
    200u,
    201u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    223u,
    224u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    230u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    75u,
    243u,
    244u,
    245u,
    245u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    10u,
    11u,
    11u,
    11u,
    12u,
    13u,
    13u,
    13u,
    14u,
    14u,
    15u,
    15u,
    15u,
    16u,
    17u,
    17u,
    17u,
    18u,
    18u,
    19u,
    19u,
    20u,
    20u,
    20u,
    21u,
    21u,
    11u,
    37u,
    37u,
    37u,
    38u,
    38u,
    39u,
    39u,
    39u,
    40u,
    40u,
    41u,
    41u,
    41u,
    41u,
    42u,
    42u,
    19u,
    42u,
    20u,
    20u,
    20u,
    20u,
    20u,
    20u,
    21u,
    12u,
    131u,
    63u,
    63u,
    63u,
    64u,
    64u,
    64u,
    65u,
    65u,
    65u,
    65u,
    65u,
    242u,
    242u,
    242u,
    242u,
    242u,
    242u,
    242u,
    242u,
    242u,
    13u,
    14u,
    15u,
    15u,
    16u,
    85u,
    17u,
    85u,
    85u,
    85u,
    85u,
    19u,
    86u,
    20u,
    20u,
    20u,
    21u,
    21u,
    21u,
    21u,
    21u,
    21u,
    21u,
    10u,
    108u,
    108u,
    109u,
    109u,
    109u,
    110u,
    110u,
    110u,
    110u,
    199u,
    40u,
    41u,
    41u,
    41u,
    41u,
    41u,
    42u,
    42u,
    42u,
    42u,
    20u,
    20u,
    11u,
    11u,
    131u,
    131u,
    132u,
    132u,
    132u,
    133u,
    133u,
    134u,
    134u,
    134u,
    135u,
    135u,
    18u,
    136u,
    19u,
    19u,
    20u,
    20u,
    20u,
    10u,
    11u,
    11u,
    11u,
    12u,
    12u,
    13u,
    13u,
    13u,
    14u,
    15u,
    15u,
    15u,
    16u,
    17u,
    17u,
    17u,
    18u,
    18u,
    19u,
    19u,
    20u,
    20u,
    11u,
    175u,
    175u,
    176u,
    176u,
    38u,
    177u,
    177u,
    178u,
    178u,
    178u,
    179u,
    179u,
    179u,
    179u,
    180u,
    180u,
    180u,
    180u,
    180u,
    180u,
    21u,
    21u,
    108u,
    108u,
    38u,
    109u,
    38u,
    109u,
    39u,
    40u,
    40u,
    41u,
    41u,
    41u,
    42u,
    42u,
    42u,
    20u,
    199u,
    179u,
    180u,
    180u,
    110u,
    110u,
    40u,
    42u,
    110u,
    110u,
    86u,
    86u,
    86u,
    86u,
    18u,
    18u,
    19u,
    65u,
    65u,
    65u,
    66u,
    65u,
    66u,
    65u,
    152u,
    155u,
    65u,
    242u,
    15u,
    16u,
    17u,
    19u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    11u,
    12u,
    12u,
    13u,
    13u,
    14u,
    15u,
    15u,
    16u,
    16u,
    17u,
    17u,
    18u,
    19u,
    20u,
    20u,
    21u,
    21u,
    22u,
    22u,
    23u,
    24u,
    24u,
    25u,
    25u,
    37u,
    37u,
    38u,
    38u,
    39u,
    39u,
    40u,
    41u,
    41u,
    41u,
    42u,
    42u,
    43u,
    43u,
    44u,
    44u,
    45u,
    45u,
    46u,
    46u,
    23u,
    24u,
    24u,
    24u,
    24u,
    24u,
    131u,
    63u,
    63u,
    64u,
    64u,
    65u,
    65u,
    66u,
    66u,
    242u,
    67u,
    67u,
    68u,
    68u,
    243u,
    243u,
    243u,
    243u,
    243u,
    243u,
    243u,
    243u,
    15u,
    15u,
    85u,
    85u,
    85u,
    85u,
    86u,
    86u,
    87u,
    87u,
    88u,
    88u,
    88u,
    88u,
    89u,
    24u,
    90u,
    25u,
    25u,
    25u,
    25u,
    25u,
    25u,
    37u,
    108u,
    109u,
    109u,
    110u,
    110u,
    111u,
    111u,
    200u,
    200u,
    201u,
    201u,
    42u,
    43u,
    43u,
    44u,
    44u,
    44u,
    45u,
    45u,
    46u,
    46u,
    46u,
    11u,
    131u,
    132u,
    132u,
    132u,
    133u,
    133u,
    134u,
    135u,
    135u,
    136u,
    242u,
    137u,
    137u,
    138u,
    243u,
    243u,
    243u,
    243u,
    243u,
    24u,
    152u,
    152u,
    153u,
    153u,
    154u,
    154u,
    155u,
    156u,
    156u,
    157u,
    158u,
    158u,
    159u,
    18u,
    19u,
    19u,
    20u,
    20u,
    21u,
    22u,
    22u,
    23u,
    24u,
    37u,
    175u,
    176u,
    176u,
    177u,
    177u,
    178u,
    179u,
    179u,
    180u,
    180u,
    180u,
    181u,
    181u,
    181u,
    182u,
    182u,
    182u,
    46u,
    47u,
    47u,
    48u,
    25u,
    108u,
    109u,
    109u,
    109u,
    198u,
    199u,
    199u,
    201u,
    201u,
    42u,
    43u,
    43u,
    44u,
    45u,
    46u,
    46u,
    201u,
    181u,
    182u,
    183u,
    111u,
    111u,
    202u,
    45u,
    111u,
    111u,
    87u,
    88u,
    88u,
    88u,
    88u,
    21u,
    22u,
    66u,
    66u,
    68u,
    68u,
    67u,
    68u,
    68u,
    152u,
    157u,
    66u,
    69u,
    16u,
    18u,
    20u,
    21u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    11u,
    12u,
    13u,
    14u,
    14u,
    15u,
    16u,
    17u,
    17u,
    18u,
    19u,
    20u,
    20u,
    21u,
    22u,
    23u,
    24u,
    24u,
    25u,
    26u,
    26u,
    27u,
    28u,
    29u,
    29u,
    37u,
    37u,
    38u,
    39u,
    40u,
    40u,
    41u,
    42u,
    42u,
    43u,
    44u,
    44u,
    45u,
    46u,
    46u,
    47u,
    47u,
    48u,
    48u,
    49u,
    50u,
    50u,
    27u,
    28u,
    28u,
    28u,
    63u,
    63u,
    64u,
    65u,
    65u,
    66u,
    67u,
    67u,
    68u,
    69u,
    69u,
    69u,
    70u,
    70u,
    70u,
    244u,
    71u,
    244u,
    244u,
    244u,
    244u,
    245u,
    16u,
    85u,
    85u,
    86u,
    87u,
    87u,
    88u,
    88u,
    89u,
    90u,
    90u,
    91u,
    91u,
    91u,
    92u,
    93u,
    93u,
    93u,
    29u,
    29u,
    29u,
    29u,
    29u,
    37u,
    109u,
    109u,
    110u,
    111u,
    111u,
    112u,
    113u,
    112u,
    112u,
    203u,
    203u,
    203u,
    44u,
    45u,
    46u,
    47u,
    47u,
    47u,
    48u,
    48u,
    49u,
    50u,
    131u,
    131u,
    132u,
    133u,
    133u,
    134u,
    135u,
    136u,
    136u,
    137u,
    137u,
    139u,
    139u,
    139u,
    141u,
    141u,
    141u,
    143u,
    143u,
    245u,
    245u,
    152u,
    152u,
    153u,
    154u,
    155u,
    155u,
    156u,
    157u,
    158u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    163u,
    164u,
    165u,
    165u,
    166u,
    26u,
    26u,
    27u,
    175u,
    13u,
    176u,
    177u,
    178u,
    178u,
    179u,
    180u,
    181u,
    181u,
    182u,
    182u,
    183u,
    183u,
    183u,
    184u,
    184u,
    185u,
    185u,
    50u,
    50u,
    52u,
    52u,
    109u,
    109u,
    198u,
    199u,
    200u,
    201u,
    201u,
    202u,
    202u,
    44u,
    45u,
    46u,
    47u,
    48u,
    48u,
    49u,
    204u,
    205u,
    185u,
    185u,
    112u,
    112u,
    204u,
    47u,
    112u,
    113u,
    88u,
    89u,
    91u,
    92u,
    93u,
    93u,
    25u,
    66u,
    68u,
    69u,
    69u,
    68u,
    69u,
    69u,
    153u,
    159u,
    68u,
    71u,
    18u,
    242u,
    243u,
    24u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    12u,
    13u,
    13u,
    14u,
    15u,
    16u,
    17u,
    17u,
    19u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    24u,
    26u,
    26u,
    27u,
    28u,
    28u,
    30u,
    30u,
    31u,
    32u,
    37u,
    38u,
    39u,
    39u,
    40u,
    41u,
    42u,
    43u,
    43u,
    44u,
    45u,
    46u,
    46u,
    47u,
    48u,
    49u,
    50u,
    50u,
    51u,
    52u,
    52u,
    53u,
    54u,
    54u,
    30u,
    31u,
    63u,
    64u,
    64u,
    65u,
    66u,
    67u,
    68u,
    69u,
    69u,
    70u,
    71u,
    71u,
    71u,
    72u,
    72u,
    72u,
    73u,
    73u,
    73u,
    168u,
    168u,
    168u,
    85u,
    85u,
    86u,
    87u,
    88u,
    88u,
    89u,
    90u,
    91u,
    91u,
    92u,
    93u,
    93u,
    94u,
    95u,
    95u,
    96u,
    96u,
    96u,
    31u,
    32u,
    32u,
    32u,
    108u,
    109u,
    198u,
    110u,
    111u,
    112u,
    113u,
    113u,
    113u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    47u,
    48u,
    50u,
    50u,
    51u,
    51u,
    52u,
    52u,
    131u,
    132u,
    132u,
    133u,
    134u,
    135u,
    136u,
    137u,
    137u,
    138u,
    139u,
    140u,
    141u,
    141u,
    143u,
    143u,
    144u,
    145u,
    146u,
    147u,
    30u,
    152u,
    153u,
    153u,
    154u,
    155u,
    156u,
    157u,
    158u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    165u,
    166u,
    167u,
    168u,
    169u,
    28u,
    29u,
    175u,
    176u,
    177u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    182u,
    183u,
    184u,
    185u,
    185u,
    185u,
    186u,
    186u,
    187u,
    50u,
    52u,
    52u,
    54u,
    55u,
    109u,
    198u,
    199u,
    200u,
    201u,
    202u,
    202u,
    204u,
    204u,
    205u,
    207u,
    47u,
    49u,
    50u,
    51u,
    52u,
    206u,
    206u,
    187u,
    188u,
    113u,
    113u,
    118u,
    49u,
    222u,
    222u,
    223u,
    224u,
    225u,
    226u,
    95u,
    227u,
    228u,
    67u,
    68u,
    70u,
    71u,
    69u,
    71u,
    70u,
    153u,
    65u,
    69u,
    73u,
    242u,
    22u,
    243u,
    244u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    11u,
    12u,
    12u,
    13u,
    14u,
    14u,
    15u,
    16u,
    16u,
    17u,
    18u,
    18u,
    19u,
    20u,
    242u,
    242u,
    22u,
    22u,
    23u,
    243u,
    243u,
    25u,
    244u,
    244u,
    244u,
    11u,
    37u,
    38u,
    38u,
    39u,
    40u,
    40u,
    41u,
    178u,
    18u,
    19u,
    20u,
    20u,
    21u,
    21u,
    22u,
    22u,
    22u,
    22u,
    22u,
    23u,
    23u,
    23u,
    23u,
    24u,
    244u,
    63u,
    63u,
    64u,
    64u,
    65u,
    65u,
    66u,
    66u,
    67u,
    67u,
    68u,
    68u,
    68u,
    69u,
    69u,
    69u,
    69u,
    69u,
    69u,
    70u,
    70u,
    70u,
    15u,
    15u,
    16u,
    85u,
    86u,
    18u,
    19u,
    19u,
    20u,
    159u,
    21u,
    21u,
    161u,
    22u,
    163u,
    163u,
    163u,
    23u,
    23u,
    165u,
    165u,
    244u,
    244u,
    37u,
    108u,
    38u,
    109u,
    109u,
    110u,
    199u,
    200u,
    199u,
    40u,
    41u,
    42u,
    42u,
    42u,
    43u,
    43u,
    44u,
    22u,
    22u,
    23u,
    23u,
    23u,
    23u,
    131u,
    131u,
    132u,
    132u,
    133u,
    133u,
    134u,
    134u,
    135u,
    135u,
    136u,
    136u,
    137u,
    137u,
    138u,
    138u,
    139u,
    139u,
    140u,
    141u,
    244u,
    152u,
    152u,
    153u,
    153u,
    154u,
    154u,
    155u,
    155u,
    156u,
    156u,
    157u,
    158u,
    158u,
    159u,
    242u,
    159u,
    161u,
    161u,
    243u,
    243u,
    243u,
    243u,
    164u,
    11u,
    175u,
    176u,
    176u,
    177u,
    177u,
    178u,
    179u,
    179u,
    180u,
    180u,
    181u,
    181u,
    182u,
    182u,
    182u,
    182u,
    183u,
    22u,
    23u,
    23u,
    23u,
    23u,
    108u,
    38u,
    38u,
    39u,
    39u,
    40u,
    40u,
    41u,
    178u,
    180u,
    42u,
    44u,
    45u,
    23u,
    23u,
    23u,
    180u,
    181u,
    181u,
    183u,
    110u,
    200u,
    42u,
    45u,
    85u,
    86u,
    87u,
    87u,
    87u,
    21u,
    22u,
    22u,
    23u,
    66u,
    66u,
    67u,
    68u,
    67u,
    68u,
    68u,
    153u,
    158u,
    67u,
    70u,
    64u,
    65u,
    242u,
    243u,
    159u,
    159u,
    159u,
    159u,
    159u,
    159u,
    159u,
    159u,
    159u,
    10u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    11u,
    12u,
    13u,
    14u,
    14u,
    15u,
    16u,
    16u,
    17u,
    18u,
    19u,
    19u,
    20u,
    242u,
    22u,
    22u,
    243u,
    243u,
    243u,
    244u,
    244u,
    244u,
    244u,
    245u,
    245u,
    37u,
    37u,
    38u,
    176u,
    39u,
    177u,
    41u,
    41u,
    42u,
    179u,
    20u,
    180u,
    45u,
    22u,
    23u,
    23u,
    24u,
    24u,
    24u,
    24u,
    25u,
    25u,
    25u,
    25u,
    26u,
    26u,
    63u,
    63u,
    64u,
    64u,
    65u,
    66u,
    67u,
    67u,
    68u,
    68u,
    69u,
    69u,
    70u,
    70u,
    70u,
    70u,
    70u,
    71u,
    71u,
    71u,
    71u,
    71u,
    15u,
    85u,
    85u,
    86u,
    86u,
    87u,
    20u,
    88u,
    89u,
    22u,
    161u,
    162u,
    163u,
    163u,
    164u,
    164u,
    165u,
    165u,
    166u,
    166u,
    167u,
    167u,
    167u,
    37u,
    108u,
    109u,
    109u,
    110u,
    199u,
    111u,
    111u,
    200u,
    201u,
    41u,
    43u,
    43u,
    43u,
    44u,
    44u,
    46u,
    46u,
    24u,
    24u,
    25u,
    25u,
    25u,
    131u,
    131u,
    132u,
    132u,
    133u,
    134u,
    135u,
    135u,
    136u,
    136u,
    137u,
    138u,
    138u,
    139u,
    139u,
    140u,
    140u,
    141u,
    141u,
    142u,
    143u,
    152u,
    152u,
    153u,
    153u,
    154u,
    155u,
    155u,
    156u,
    156u,
    157u,
    158u,
    158u,
    159u,
    159u,
    161u,
    161u,
    162u,
    162u,
    163u,
    164u,
    244u,
    244u,
    244u,
    175u,
    175u,
    176u,
    177u,
    177u,
    178u,
    179u,
    179u,
    180u,
    181u,
    181u,
    182u,
    182u,
    183u,
    183u,
    183u,
    184u,
    184u,
    184u,
    25u,
    25u,
    25u,
    25u,
    108u,
    109u,
    109u,
    39u,
    40u,
    41u,
    41u,
    42u,
    42u,
    43u,
    43u,
    45u,
    46u,
    47u,
    25u,
    25u,
    181u,
    182u,
    183u,
    185u,
    111u,
    111u,
    42u,
    46u,
    111u,
    87u,
    88u,
    88u,
    88u,
    22u,
    23u,
    24u,
    25u,
    66u,
    67u,
    68u,
    69u,
    68u,
    69u,
    69u,
    153u,
    0u,
    68u,
    71u,
    65u,
    242u,
    242u,
    243u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    11u,
    13u,
    13u,
    14u,
    15u,
    16u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    21u,
    22u,
    23u,
    243u,
    25u,
    244u,
    244u,
    244u,
    28u,
    245u,
    245u,
    245u,
    31u,
    37u,
    38u,
    38u,
    39u,
    40u,
    41u,
    41u,
    42u,
    42u,
    180u,
    45u,
    46u,
    46u,
    47u,
    47u,
    25u,
    26u,
    26u,
    26u,
    26u,
    27u,
    27u,
    27u,
    27u,
    27u,
    245u,
    63u,
    63u,
    64u,
    65u,
    66u,
    66u,
    67u,
    68u,
    69u,
    69u,
    70u,
    70u,
    71u,
    71u,
    72u,
    72u,
    72u,
    72u,
    72u,
    73u,
    73u,
    73u,
    16u,
    85u,
    85u,
    86u,
    87u,
    88u,
    88u,
    90u,
    90u,
    91u,
    91u,
    163u,
    164u,
    164u,
    165u,
    166u,
    166u,
    167u,
    167u,
    168u,
    169u,
    169u,
    170u,
    37u,
    108u,
    109u,
    198u,
    199u,
    111u,
    112u,
    112u,
    201u,
    202u,
    202u,
    43u,
    44u,
    45u,
    45u,
    46u,
    46u,
    47u,
    48u,
    26u,
    27u,
    27u,
    27u,
    131u,
    131u,
    132u,
    133u,
    134u,
    135u,
    135u,
    136u,
    137u,
    137u,
    138u,
    139u,
    139u,
    140u,
    141u,
    141u,
    142u,
    143u,
    143u,
    144u,
    145u,
    152u,
    152u,
    153u,
    154u,
    155u,
    155u,
    156u,
    156u,
    158u,
    158u,
    159u,
    160u,
    160u,
    161u,
    162u,
    163u,
    164u,
    164u,
    165u,
    166u,
    166u,
    167u,
    167u,
    175u,
    176u,
    176u,
    177u,
    178u,
    178u,
    179u,
    180u,
    181u,
    182u,
    182u,
    183u,
    184u,
    184u,
    184u,
    185u,
    186u,
    186u,
    50u,
    51u,
    27u,
    27u,
    27u,
    109u,
    109u,
    109u,
    40u,
    40u,
    41u,
    42u,
    43u,
    43u,
    44u,
    45u,
    46u,
    47u,
    49u,
    27u,
    27u,
    182u,
    183u,
    184u,
    187u,
    112u,
    112u,
    43u,
    47u,
    112u,
    87u,
    89u,
    90u,
    91u,
    91u,
    24u,
    26u,
    26u,
    67u,
    68u,
    69u,
    70u,
    69u,
    70u,
    70u,
    153u,
    0u,
    0u,
    73u,
    65u,
    242u,
    243u,
    244u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u
  },
  {
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u,
    11u,
    12u,
    13u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    21u,
    23u,
    243u,
    24u,
    25u,
    244u,
    244u,
    27u,
    245u,
    245u,
    31u,
    170u,
    149u,
    149u,
    37u,
    38u,
    38u,
    39u,
    40u,
    41u,
    42u,
    42u,
    44u,
    45u,
    46u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    28u,
    28u,
    28u,
    29u,
    29u,
    29u,
    29u,
    29u,
    30u,
    63u,
    64u,
    65u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    70u,
    71u,
    72u,
    72u,
    73u,
    73u,
    74u,
    74u,
    75u,
    75u,
    76u,
    76u,
    76u,
    85u,
    85u,
    86u,
    87u,
    88u,
    89u,
    90u,
    91u,
    91u,
    92u,
    93u,
    93u,
    166u,
    166u,
    96u,
    168u,
    168u,
    169u,
    170u,
    170u,
    171u,
    171u,
    171u,
    37u,
    109u,
    109u,
    110u,
    200u,
    111u,
    112u,
    113u,
    202u,
    202u,
    203u,
    44u,
    45u,
    46u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    29u,
    29u,
    131u,
    132u,
    133u,
    133u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    139u,
    140u,
    141u,
    142u,
    142u,
    144u,
    144u,
    145u,
    145u,
    146u,
    147u,
    152u,
    153u,
    153u,
    154u,
    155u,
    156u,
    157u,
    158u,
    159u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    164u,
    165u,
    166u,
    167u,
    168u,
    168u,
    168u,
    169u,
    175u,
    176u,
    177u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    182u,
    183u,
    184u,
    185u,
    186u,
    186u,
    187u,
    187u,
    189u,
    189u,
    193u,
    193u,
    146u,
    146u,
    109u,
    109u,
    198u,
    199u,
    201u,
    201u,
    201u,
    44u,
    205u,
    45u,
    46u,
    47u,
    48u,
    50u,
    52u,
    29u,
    183u,
    185u,
    186u,
    189u,
    112u,
    112u,
    205u,
    49u,
    222u,
    88u,
    89u,
    91u,
    92u,
    93u,
    26u,
    27u,
    28u,
    67u,
    68u,
    70u,
    71u,
    69u,
    71u,
    71u,
    154u,
    0u,
    0u,
    75u,
    242u,
    242u,
    243u,
    244u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    10u
  }
};
char gColorTableLighten[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  '%',
  '%',
  '%',
  '%',
  '%',
  '&',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  '?',
  '?',
  '?',
  '?',
  '?',
  '@',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'U',
  'U',
  'U',
  'U',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  '[',
  '\\',
  ']',
  '^',
  '_',
  '`',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f',
  'g',
  'l',
  'l',
  'l',
  'l',
  'l',
  'm',
  'n',
  'o',
  'p',
  'q',
  'r',
  's',
  't',
  'u',
  'v',
  'w',
  'x',
  'y',
  'z',
  '{',
  '|',
  '}',
  '~',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '',
  '\xFF'
}; // weak
char gColorTableNoCycle[] = { '\0' }; // weak
font *smallFont = NULL;
font *bigFont = NULL;
int gbReturnAfterComputeExtent = 0; // weak
int gbAllowTextEntryEscape = 1; // weak
int giCycleType = 0; // weak
int giScreenScroll = 1; // weak
int giMenuCommand = 4294967295; // weak
int gbSendMouseMoveMessages = 0; // weak
int gbColorMice = 1; // weak
int gTownEligibleBuildMask[] = { 1073266591, 469286815, 267960223, 1777909663, 905494431, 536395675 }; // idb
char giMapSizes[] = { '$' }; // weak
int gbUseEvilInterface = 0; // weak
char *cEvilTranslate[37][2] =
{
  { "advbord.icn", "advborde.icn" },
  { "heroextg.icn", "heroexte.icn" },
  { "buybuild.icn", "buybuile.icn" },
  { "advbtns.icn", "advebtns.icn" },
  { "herologo.icn", "herologe.icn" },
  { "sunmoon.icn", "sunmoone.icn" },
  { "stonback.icn", "stonbake.icn" },
  { "scroll.icn", "scrolle.icn" },
  { "locators.icn", "locatore.icn" },
  { "system.icn", "systeme.icn" },
  { "CPANBKG.ICN", "CPANBKGE.ICN" },
  { "CPANEL.ICN", "CPANELE.ICN" },
  { "APANBKG.ICN", "APANBKGE.ICN" },
  { "APANEL.ICN", "APANELE.ICN" },
  { "VIEWWRLD.ICN", "EVIWWRLD.ICN" },
  { "VIEWRSRC.ICN", "EVIWRSRC.ICN" },
  { "VIEWRTFX.ICN", "EVIWRTFX.ICN" },
  { "VIEWTWNS.ICN", "EVIWTWNS.ICN" },
  { "VIEWHROS.ICN", "EVIWHROS.ICN" },
  { "VIEW_ALL.ICN", "EVIW_ALL.ICN" },
  { "VIEWMINE.ICN", "EVIWMINE.ICN" },
  { "VIEWDDOR.ICN", "EVIWDDOR.ICN" },
  { "VIEWPUZL.ICN", "EVIWPUZL.ICN" },
  { "LGNDXTRA.ICN", "LGNDXTRE.ICN" },
  { "SPANBKG.ICN", "SPANBKGE.ICN" },
  { "SPANBTN.ICN", "SPANBTNE.ICN" },
  { "CSPANBKG.ICN", "CSPANBKE.ICN" },
  { "CSPANBTN.ICN", "CSPANBTE.ICN" },
  { "TRADPOST.ICN", "TRADPOSE.ICN" },
  { "VIEWARMY.ICN", "VIEWARME.ICN" },
  { "WINLOSE.ICN", "WINLOSEE.ICN" },
  { "WINCMBTB.ICN", "WINCMBBE.ICN" },
  { "SURRENDR.ICN", "SURRENDE.ICN" },
  { "SURDRBKG.ICN", "SURDRBKE.ICN" },
  { "VGENBKG.ICN", "VGENBKGE.ICN" },
  { "campbkgg.ICN", "campbkge.ICN" },
  { "campxtrg.ICN", "campxtre.ICN" }
};
int gbPutzingWithMouseCtr = 0; // weak
int gbDontTryRedbook = 0; // weak
int gbDontTryMIDI = 0; // weak
int gbDontTryDigital = 0; // weak
float gfCombatSpeedMod[3] = {  1.0,  0.69999999,  0.34999999 };
icon *gShingleAnim = NULL; // idb
int iNextShingleAnim = 0; // weak
int giDialogTimeout = 0; // weak
int giNewMonsterCycleFrame = 0; // weak
int gbNoCDRom = 0; // weak
int dword_4F1CC0 = 0; // weak
int gbDrawWindowBackground = 1; // weak
int gbCheatMenus = 0; // weak
int gbUseWaveout = 0; // weak
char *gCombatFxNames[32] =
{
  &unk_4F7C28,
  "magic01.icn",
  "magic02.icn",
  "magic03.icn",
  "magic04.icn",
  "magic05.icn",
  "magic06.icn",
  "magic07.icn",
  "magic08.icn",
  "rainbluk.icn",
  "cloudluk.icn",
  "moraleg.icn",
  "moraleb.icn",
  "reddeath.icn",
  "redfire.icn",
  "sparks.icn",
  "electric.icn",
  "physical.icn",
  "bluefire.icn",
  "icecloud.icn",
  "lichclod.icn",
  "bless.icn",
  "berzerk.icn",
  "shield.icn",
  "haste.icn",
  "paralyze.icn",
  "hypnotiz.icn",
  "dragslay.icn",
  "blind.icn",
  "curse.icn",
  "stonskin.icn",
  "stelskin.icn"
};
__int16 horseFrameFlip[] = { 45 }; // weak
__int16 boatFrameFlip[] = { 0 }; // weak
int gHeroGoldCost = 2500; // weak
char normalDirTable[] = { '\0' }; // weak
char byte_4F1DC1[] = { '\xFF' }; // weak
int dword_4F1DE0[] = { 200 }; // weak
void unk_4F1E00; // idb
void unk_4F1E90; // idb
int gMineCharacteristics[] = { 2 }; // weak
int dword_4F1F38 = 1000; // weak
int dword_4F1F3C[] = { 0 }; // weak
int gSSValues[] =
{
  400,
  750,
  1000,
  200,
  450,
  850,
  450,
  1000,
  1675,
  1,
  2,
  3,
  50,
  100,
  150,
  150,
  275,
  375,
  300,
  550,
  800,
  300,
  600,
  900,
  250,
  425,
  650,
  300,
  550,
  800,
  100,
  200,
  300,
  50,
  100,
  150,
  100,
  450,
  950,
  445,
  950,
  1500
}; // idb
_BYTE gArtifactLevel[] =
{
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  4,
  4,
  2,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  2,
  4,
  2,
  4,
  2,
  4,
  2,
  2,
  2,
  2,
  2,
  4,
  2,
  2,
  8,
  8,
  8,
  8,
  2,
  4,
  4,
  8,
  4,
  4,
  8,
  8,
  8,
  4,
  4,
  4,
  8,
  4,
  4,
  4,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  2,
  8,
  8,
  8,
  2,
  4,
  4,
  8,
  8,
  2,
  2,
  2,
  4,
  4,
  2,
  4,
  2,
  4,
  2,
  16,
  32,
  32,
  32,
  32,
  2,
  8,
  2,
  8,
  2,
  2,
  8,
  8,
  2,
  2,
  2,
  4,
  2,
  2,
  2,
  2,
  4,
  0
};
int gArtifactBaseRV[] =
{
  13600,
  22000,
  18000,
  14000,
  19000,
  18500,
  22200,
  25000,
  6000,
  4000,
  4000,
  5600,
  1200,
  1200,
  1200,
  1200,
  4294966096,
  2000,
  1800,
  1800,
  2000,
  1000,
  3600,
  5600,
  4000,
  5040,
  3060,
  4420,
  5610,
  6630,
  7000,
  6000,
  4000,
  4500,
  2250,
  1200,
  1200,
  1200,
  1200,
  3500,
  1500,
  500,
  1000,
  750,
  500,
  750,
  750,
  750,
  750,
  750,
  750,
  500,
  1500,
  1000,
  1000,
  750,
  750,
  750,
  750,
  750,
  750,
  750,
  1250,
  750,
  150,
  250,
  3500,
  1250,
  250,
  4294967295,
  4294967295,
  4000,
  4000,
  4000,
  2000,
  2000,
  4000,
  3800,
  7600,
  3700,
  7400,
  0,
  0,
  0,
  0,
  0,
  2500,
  4800,
  9000,
  4294964046,
  36200,
  2000,
  4294966246,
  4294966246,
  10000,
  10000,
  15000,
  720,
  7500,
  10000,
  9200,
  10000,
  1500
}; // idb
int gUltArtifactAvgValue = 16500; // weak
int giDebugLevel = 0; // weak
char byte_4F21F4 = '\x05'; // weak
tag_monsterInfo gMonsterDatabase[66] =
{
  {
    20,
    33,
    '\x11',
    '\f',
    1,
    '\0',
    '\x02',
    '\x01',
    '\x01',
    '\x01',
    '\x01',
    '\0',
    "psnt",
    0,
    0
  },
  {
    150,
    312,
    '\x15',
    '\b',
    10,
    '\0',
    '\x02',
    '\x05',
    '\x03',
    '\x02',
    '\x03',
    '\f',
    "arch",
    4,
    0
  },
  {
    200,
    463,
    '\x17',
    '\b',
    10,
    '\0',
    '\x04',
    '\x05',
    '\x03',
    '\x02',
    '\x03',
    '\x18',
    "arch",
    4,
    0
  },
  {
    200,
    639,
    ' ',
    '\x05',
    15,
    '\0',
    '\x04',
    '\x05',
    '\t',
    '\x03',
    '\x04',
    '\0',
    "pike",
    0,
    0
  },
  {
    250,
    824,
    '!',
    '\x05',
    20,
    '\0',
    '\x05',
    '\x05',
    '\t',
    '\x03',
    '\x04',
    '\0',
    "pike",
    0,
    0
  },
  {
    250,
    1130,
    '-',
    '\x04',
    25,
    '\0',
    '\x04',
    '\a',
    '\t',
    '\x04',
    '\x06',
    '\0',
    "swdm",
    0,
    0
  },
  {
    300,
    1350,
    '-',
    '\x04',
    30,
    '\0',
    '\x05',
    '\a',
    '\t',
    '\x04',
    '\x06',
    '\0',
    "swdm",
    0,
    0
  },
  {
    300,
    1830,
    '=',
    '\x03',
    30,
    '\0',
    '\x06',
    '\n',
    '\t',
    '\x05',
    '\n',
    '\0',
    "cavl",
    1,
    0
  },
  {
    375,
    2273,
    '=',
    '\x03',
    40,
    '\0',
    '\a',
    '\n',
    '\t',
    '\x05',
    '\n',
    '\0',
    "cavl",
    1,
    0
  },
  {
    600,
    4704,
    'N',
    '\x02',
    50,
    '\0',
    '\x05',
    '\v',
    '\f',
    '\n',
    '\x14',
    '\0',
    "pldn",
    0,
    0
  },
  {
    1000,
    5822,
    ':',
    '\x02',
    65,
    '\0',
    '\x06',
    '\v',
    '\f',
    '\n',
    '\x14',
    '\0',
    "pldn",
    0,
    0
  },
  {
    40,
    109,
    '\x1B',
    '\n',
    3,
    '\x01',
    '\x04',
    '\x03',
    '\x01',
    '\x01',
    '\x02',
    '\0',
    "gbln",
    0,
    0
  },
  {
    140,
    299,
    '\x15',
    '\b',
    10,
    '\x01',
    '\x02',
    '\x03',
    '\x04',
    '\x02',
    '\x03',
    '\b',
    "elf_",
    4,
    0
  },
  {
    175,
    512,
    '\x1D',
    '\b',
    15,
    '\x01',
    '\x03',
    '\x03',
    '\x04',
    '\x03',
    '\x04',
    '\x10',
    "elf_",
    4,
    0
  },
  {
    200,
    865,
    '+',
    '\x05',
    20,
    '\x01',
    '\x06',
    '\x06',
    '\x02',
    '\x03',
    '\x05',
    '\0',
    "wolf",
    1,
    0
  },
  {
    300,
    1065,
    '$',
    '\x04',
    40,
    '\x01',
    '\x02',
    '\t',
    '\x05',
    '\x04',
    '\x06',
    '\0',
    "ogre",
    0,
    0
  },
  {
    500,
    2070,
    ')',
    '\x04',
    60,
    '\x01',
    '\x04',
    '\t',
    '\x05',
    '\x05',
    '\a',
    '\0',
    "ogre",
    0,
    0
  },
  {
    600,
    1921,
    ' ',
    '\x03',
    40,
    '\x01',
    '\x04',
    '\n',
    '\x05',
    '\x05',
    '\a',
    '\b',
    "trll",
    4,
    0
  },
  {
    700,
    2337,
    '!',
    '\x03',
    40,
    '\x01',
    '\x05',
    '\n',
    '\x05',
    '\a',
    '\t',
    '\x10',
    "trll",
    4,
    0
  },
  {
    750,
    6074,
    ':',
    '\x02',
    80,
    '\x01',
    '\x05',
    '\f',
    '\t',
    '\f',
    '\x18',
    '\0',
    "cycl",
    8,
    0
  },
  {
    50,
    129,
    '\x1A',
    '\b',
    2,
    '\x02',
    '\x04',
    '\x04',
    '\x02',
    '\x01',
    '\x02',
    '\0',
    "sprt",
    2,
    0
  },
  {
    200,
    500,
    '\x19',
    '\x06',
    20,
    '\x02',
    '\x02',
    '\x06',
    '\x05',
    '\x02',
    '\x04',
    '\0',
    "dwrf",
    0,
    0
  },
  {
    250,
    716,
    '\x1D',
    '\x06',
    20,
    '\x02',
    '\x04',
    '\x06',
    '\x06',
    '\x02',
    '\x04',
    '\0',
    "dwrf",
    0,
    0
  },
  {
    250,
    554,
    '\x16',
    '\x04',
    15,
    '\x02',
    '\x04',
    '\x04',
    '\x03',
    '\x02',
    '\x03',
    '\x18',
    "elf_",
    4,
    0
  },
  {
    300,
    658,
    '\x16',
    '\x04',
    15,
    '\x02',
    '\x06',
    '\x05',
    '\x05',
    '\x02',
    '\x03',
    '\x18',
    "elf_",
    4,
    0
  },
  {
    350,
    1290,
    '%',
    '\x03',
    25,
    '\x02',
    '\x05',
    '\a',
    '\x05',
    '\x05',
    '\b',
    '\b',
    "drui",
    4,
    0
  },
  {
    400,
    1428,
    '$',
    '\x03',
    25,
    '\x02',
    '\x06',
    '\a',
    '\a',
    '\x05',
    '\b',
    '\x10',
    "drui",
    4,
    0
  },
  {
    500,
    2702,
    '6',
    '\x02',
    40,
    '\x02',
    '\x05',
    '\n',
    '\t',
    '\a',
    '\x0E',
    '\0',
    "unic",
    1,
    0
  },
  {
    1500,
    10114,
    '8',
    '\x01',
    100,
    '\x02',
    '\a',
    '\f',
    '\n',
    '\x14',
    '(',
    '\0',
    "phoe",
    11,
    0
  },
  {
    60,
    154,
    '\x1A',
    '\b',
    5,
    '\x03',
    '\x04',
    '\x03',
    '\x01',
    '\x01',
    '\x02',
    '\b',
    "cntr",
    5,
    0
  },
  {
    200,
    579,
    '\x1D',
    '\x06',
    15,
    '\x03',
    '\x06',
    '\x04',
    '\a',
    '\x02',
    '\x03',
    '\0',
    "garg",
    2,
    0
  },
  {
    300,
    1101,
    '%',
    '\x04',
    25,
    '\x03',
    '\x04',
    '\x06',
    '\x06',
    '\x03',
    '\x05',
    '\0',
    "grif",
    3,
    0
  },
  {
    400,
    1751,
    ',',
    '\x03',
    35,
    '\x03',
    '\x04',
    '\t',
    '\b',
    '\x05',
    '\n',
    '\0',
    "mino",
    0,
    0
  },
  {
    500,
    2252,
    '-',
    '\x03',
    45,
    '\x03',
    '\x06',
    '\t',
    '\b',
    '\x05',
    '\n',
    '\0',
    "mino",
    0,
    0
  },
  {
    800,
    2878,
    '$',
    '\x02',
    75,
    '\x03',
    '\x02',
    '\b',
    '\t',
    '\x06',
    '\f',
    '\0',
    "hydr",
    1,
    0
  },
  {
    3000,
    18153,
    '7',
    '\x01',
    200,
    '\x03',
    '\x04',
    '\f',
    '\f',
    '\x19',
    '2',
    '\0',
    "drgn",
    11,
    0
  },
  {
    3500,
    22962,
    'D',
    '\x01',
    250,
    '\x03',
    '\x05',
    '\r',
    '\r',
    '\x19',
    '2',
    '\0',
    "drgn",
    11,
    0
  },
  {
    4000,
    28144,
    'J',
    '\x01',
    300,
    '\x03',
    '\x06',
    '\x0E',
    '\x0E',
    '\x19',
    '2',
    '\0',
    "drgn",
    11,
    0
  },
  {
    50,
    134,
    '\x1B',
    '\b',
    3,
    '\x04',
    '\x03',
    '\x02',
    '\x01',
    '\x01',
    '\x03',
    '\f',
    "half",
    4,
    0
  },
  {
    150,
    493,
    '!',
    '\x06',
    15,
    '\x04',
    '\x06',
    '\x05',
    '\x04',
    '\x02',
    '\x03',
    '\0',
    "boar",
    1,
    0
  },
  {
    300,
    951,
    '\x13',
    '\x04',
    30,
    '\x04',
    '\x02',
    '\x05',
    '\n',
    '\x04',
    '\x05',
    '\0',
    "golm",
    0,
    0
  },
  {
    350,
    1324,
    '\x18',
    '\x04',
    35,
    '\x04',
    '\x03',
    '\a',
    '\n',
    '\x04',
    '\x05',
    '\0',
    "golm",
    0,
    0
  },
  {
    400,
    1739,
    '+',
    '\x03',
    40,
    '\x04',
    '\x04',
    '\a',
    '\a',
    '\x04',
    '\b',
    '\0',
    "roc_",
    3,
    0
  },
  {
    600,
    1935,
    ' ',
    '\x02',
    30,
    '\x04',
    '\x05',
    '\v',
    '\a',
    '\a',
    '\t',
    '\f',
    "mage",
    4,
    0
  },
  {
    700,
    2469,
    '#',
    '\x02',
    35,
    '\x04',
    '\x06',
    '\f',
    '\b',
    '\a',
    '\t',
    '\x18',
    "mage",
    4,
    0
  },
  {
    2000,
    9589,
    '*',
    '\x01',
    150,
    '\x04',
    '\x04',
    '\r',
    '\n',
    '\x14',
    '\x1E',
    '\0',
    "titn",
    0,
    0
  },
  {
    5000,
    22933,
    'O',
    '\x01',
    300,
    '\x04',
    '\x06',
    '\x0F',
    '\x0F',
    '\x14',
    '\x1E',
    '\x18',
    "titn",
    4,
    0
  },
  {
    75,
    203,
    '\x1B',
    '\b',
    4,
    '\x05',
    '\x04',
    '\x04',
    '\x03',
    '\x02',
    '\x03',
    '\0',
    "skel",
    1024,
    0
  },
  {
    150,
    310,
    '\x15',
    '\x06',
    15,
    '\x05',
    '\x02',
    '\x05',
    '\x02',
    '\x02',
    '\x03',
    '\0',
    "zomb",
    1024,
    0
  },
  {
    200,
    506,
    '\x19',
    '\x06',
    20,
    '\x05',
    '\x04',
    '\x05',
    '\x02',
    '\x02',
    '\x03',
    '\0',
    "zomb",
    1024,
    0
  },
  {
    250,
    868,
    '#',
    '\x04',
    25,
    '\x05',
    '\x04',
    '\x06',
    '\x06',
    '\x03',
    '\x04',
    '\0',
    "mumy",
    1024,
    0
  },
  {
    300,
    1056,
    '#',
    '\x04',
    30,
    '\x05',
    '\x05',
    '\x06',
    '\x06',
    '\x03',
    '\x04',
    '\0',
    "mumy",
    1024,
    0
  },
  {
    500,
    1685,
    '*',
    '\x03',
    30,
    '\x05',
    '\x04',
    '\b',
    '\x06',
    '\x05',
    '\a',
    '\0',
    "vamp",
    1026,
    0
  },
  {
    650,
    2461,
    '-',
    '\x03',
    40,
    '\x05',
    '\x05',
    '\b',
    '\x06',
    '\x05',
    '\a',
    '\0',
    "vamp",
    1026,
    0
  },
  {
    750,
    2069,
    '\x1C',
    '\x02',
    25,
    '\x05',
    '\x05',
    '\a',
    '\f',
    '\b',
    '\n',
    '\f',
    "lich",
    1028,
    0
  },
  {
    900,
    2625,
    '\x1D',
    '\x02',
    35,
    '\x05',
    '\x06',
    '\a',
    '\r',
    '\b',
    '\n',
    '\x18',
    "lich",
    1028,
    0
  },
  {
    1500,
    11744,
    'N',
    '\x01',
    150,
    '\x05',
    '\x04',
    '\v',
    '\t',
    '\x19',
    '-',
    '\0',
    "drgn",
    1027,
    0
  },
  {
    50,
    177,
    '#',
    '\f',
    4,
    '\x06',
    '\x05',
    '\x06',
    '\x01',
    '\x01',
    '\x02',
    '\0',
    "rogu",
    0,
    0
  },
  {
    200,
    805,
    '(',
    '\x04',
    20,
    '\x06',
    '\x06',
    '\a',
    '\x06',
    '\x02',
    '\x05',
    '\0',
    "nmad",
    1,
    0
  },
  {
    1000,
    1545,
    '>',
    '\x03',
    20,
    '\x06',
    '\x05',
    '\b',
    '\a',
    '\x04',
    '\x06',
    '\0',
    "ghst",
    1026,
    0
  },
  {
    650,
    5692,
    '<',
    '\x02',
    50,
    '\x06',
    '\x06',
    '\n',
    '\t',
    '\x14',
    '\x1E',
    '\0',
    "geni",
    2,
    0
  },
  {
    500,
    1979,
    '(',
    '\x05',
    35,
    '\x06',
    '\x04',
    '\b',
    '\t',
    '\x06',
    '\n',
    '\0',
    "meds",
    1,
    0
  },
  {
    500,
    1732,
    '#',
    '\x03',
    50,
    '\x06',
    '\x03',
    '\b',
    '\b',
    '\x04',
    '\x05',
    '\0',
    "eelm",
    0,
    0
  },
  {
    500,
    1412,
    '\x1C',
    '\x03',
    35,
    '\x06',
    '\x06',
    '\a',
    '\a',
    '\x02',
    '\b',
    '\0',
    "aelm",
    0,
    0
  },
  {
    500,
    1501,
    '\x1E',
    '\x03',
    40,
    '\x06',
    '\x05',
    '\b',
    '\x06',
    '\x04',
    '\x06',
    '\0',
    "felm",
    0,
    0
  },
  {
    500,
    1690,
    '\"',
    '\x03',
    45,
    '\x06',
    '\x04',
    '\x06',
    '\b',
    '\x03',
    '\a',
    '\0',
    "welm",
    0,
    0
  }
};
float gfStatPower[] = {  0.5 }; // weak
int dword_4F2950 = 1072064102; // weak
float gfBattleStat[] =
{
   0.2,
   0.2,
   0.2,
   0.2,
   0.2,
   0.25,
   0.30000001,
   0.34999999,
   0.40000001,
   0.44999999,
   0.5,
   0.55000001,
   0.60000002,
   0.64999998,
   0.69999999,
   0.75,
   0.80000001,
   0.85000002,
   0.89999998,
   0.94999999,
   1.0,
   1.1,
   1.2,
   1.3,
   1.4,
   1.5,
   1.6,
   1.7,
   1.8,
   1.9,
   2.0,
   2.0999999,
   2.2,
   2.3,
   2.4000001,
   2.5,
   2.5999999,
   2.7,
   2.8,
   2.9000001,
   3.0
};
char byte_4F29FF[] = { '\0' }; // idb
char gSpellLimits[] = { '\x03', '\x03', '\x02', '\x02', '\x01' }; // idb
float gfSpellCastableCombatMod[] =
{
   0.27000001,
   0.40000001,
   0.47999999,
   0.56,
   0.63999999,
   0.73000002,
   0.81,
   0.88,
   0.93000001,
   0.97000003,
   1.0
}; // idb
float gfSpellCastNumMod[] = {  0.0 }; // weak
int gfPhilAISpellPowerMod[] = { 0 }; // weak
int dword_4F2A90 = 1086639309; // weak
int gfPhilAIDurationMod[] = { 0 }; // weak
int dword_4F2AC0 = 1071560786; // weak
float gfSpellTypeNumMod[] = {  1.0 }; // weak
int gbDrawSavedCursor = 0; // weak
char byte_4F2AE8[] = { '\b' }; // weak
char giCloudType[] = { '\v' }; // weak
__int16 giScoreMon[] = { 0 }; // weak
_UNKNOWN word_4F2C2A; // idb
__int16 giScoreCampaignMon[] = { 9999 }; // weak
__int16 word_4F2D32[] = { 0 }; // weak
char townTheme[] = { '\b', '\t', '\x05', '\x06', '\n', '\a' }; // idb
signed __int8 gHeroSkillBonus[6][2][4] =
{
  { { '#', '-', '\n', '\n' }, "\x19\x19\x19\x19" },
  { "7#\x05\x05", "\x19\x19\x19\x19" },
  { "\n\n\x1E2", "\x14\x14\x1E\x1E" },
  { "\n\n2\x1E", "\x14\x14\x1E\x1E" },
  { "\n\n((", "\x14\x14\x1E\x1E" },
  { "\x0F\x0F##", "\x19\x19\x19\x19" }
};
int gbLoadingMonoIcon = 0; // weak
int giMonoIconSkip = 4294967295; // weak
int giScrollX = 0; // weak
int giScrollY = 0; // weak
int dword_4F2E80 = 0; // weak
int gbEnlargeScreenBlit = 1; // weak
int giCurExe = 0; // weak
int gbInDialog = 0; // weak
int gsMenuEnableStatus = 0; // weak
char byte_4F2E94[] = { '\0' }; // weak
char byte_4F2E95[] = { '\0' }; // weak
int gbInSetupDialog = 0; // weak
int gbMinimized = 0; // weak
int gbHeroMoving = 0; // weak
int gbInSmackMgr = 0; // weak
int gbGotFirstHeartbeat = 0; // weak
HMENU hmnuDflt = NULL; // idb
HMENU hmnuCmbt = NULL; // idb
HMENU hmnuAdv = NULL; // idb
HMENU hmnuTown = NULL; // idb
char *cMonFilename[] =
{
  "peasant.icn",
  "archer.icn",
  "archer2.icn",
  "pikeman.icn",
  "pikeman2.icn",
  "swordsmn.icn",
  "swordsm2.icn",
  "cavalryr.icn",
  "cavalryb.icn",
  "paladin.icn",
  "paladin2.icn",
  "goblin.icn",
  "orc.icn",
  "orc2.icn",
  "wolf.icn",
  "ogre.icn",
  "ogre2.icn",
  "troll.icn",
  "troll2.icn",
  "cyclops.icn",
  "sprite.icn",
  "dwarf.icn",
  "dwarf2.icn",
  "elf.icn",
  "elf2.icn",
  "druid.icn",
  "druid2.icn",
  "unicorn.icn",
  "phoenix.icn",
  "centaur.icn",
  "gargoyle.icn",
  "griffin.icn",
  "minotaur.icn",
  "minotau2.icn",
  "hydra.icn",
  "draggree.icn",
  "dragred.icn",
  "dragblak.icn",
  "halfling.icn",
  "boar.icn",
  "golem.icn",
  "golem2.icn",
  "roc.icn",
  "mage1.icn",
  "mage2.icn",
  "titanblu.icn",
  "titanbla.icn",
  "skeleton.icn",
  "zombie.icn",
  "zombie2.icn",
  "mummyw.icn",
  "mummy2.icn",
  "vampire.icn",
  "vampire2.icn",
  "lich.icn",
  "lich2.icn",
  "dragbone.icn",
  "rogue.icn",
  "nomad.icn",
  "ghost.icn",
  "genie.icn",
  "medusa.icn",
  "eelem.icn",
  "aelem.icn",
  "felem.icn",
  "welem.icn"
};
int gbProcessingCombatAction = 0; // weak
int iMPNetProtocol = 0; // weak
int iLastDiffSendTo = 4294967294; // weak
SSpellInfo gsSpellInfo[48] =
{
  {
    { 'f', 'i', 'r', 'e', 'b', 'a', 'l', 'l', '\0' },
    '\x03',
    '\b',
    '\0',
    500,
    '\t',
    '\n',
    168430090,
    '\n',
    3u
  },
  { "fireball", '\x04', '\t', '\0', 750, '\x0F', '\n', 168430090, '\n', 3u },
  { "lightblt", '\x02', '\x04', '\x0F', 450, '\a', '\n', 168430090, '\n', 3u },
  { "chainlte", '\x04', '\x05', '\x0F', 650, '\x0F', '\n', 168430090, '\n', 3u },
  { "telptout", '\x03', '\n', '\0', 30, '\t', '\n', 168430090, '\n', 2u },
  { "cure", '\x01', '\x06', '\x01', 250, '\x06', '\n', 168430090, '\n', 2u },
  { "masscure", '\x04', '\x06', '\x01', 700, '\x0F', '\n', 168430090, '\n', 2u },
  { "resurect", '\x04', '\r', '\x01', 400, '\f', '\n', 168430090, '\n', 3u },
  { "resurtru", '\x05', '\f', '\x01', 550, '\x0F', '\n', 168430090, '\n', 3u },
  { "haste", '\x01', '\x0E', '\x18', 300, '\x03', '\n', 168430090, '\n', 11u },
  { "masshast", '\x03', '\x0E', '\x18', 950, '\n', '\n', 168430090, '\n', 11u },
  { "slow", '\x01', '\x01', '\x02', 350, '\x03', '\n', 168430090, '\n', 11u },
  {
    "massslow",
    '\x04',
    '\x01',
    '\x02',
    1000,
    '\x0F',
    '\n',
    168430090,
    '\n',
    11u
  },
  { "blind", '\x02', '\x15', '\x1C', 500, '\x06', '\n', 168430090, '\n', 11u },
  { "bless", '\x01', '\a', '\x15', 200, '\x03', '\n', 168430090, '\n', 11u },
  { "massbles", '\x03', '\a', '\x15', 650, '\f', '\n', 168430090, '\n', 11u },
  {
    "stonskin",
    '\x01',
    '\x1F',
    '\x1E',
    300,
    '\x03',
    '\n',
    168430090,
    '\n',
    11u
  },
  {
    "stelskin",
    '\x02',
    '\x1E',
    '\x1F',
    575,
    '\x06',
    '\n',
    168430090,
    '\n',
    11u
  },
  { "curse", '\x01', '\x03', '\x1D', 200, '\x03', '\n', 168430090, '\n', 11u },
  { "masscurs", '\x03', '\x03', '\x1D', 500, '\f', '\n', 168430090, '\n', 11u },
  { "masscurs", '\x03', '\x16', '\b', 300, '\t', '\n', 168430090, '\0', 3u },
  { "masscurs", '\x04', '\x17', '\b', 450, '\f', '\n', 168430090, '\0', 3u },
  { "antimagk", '\x03', '\x11', '\x06', 100, '\a', '\n', 168430090, '\n', 11u },
  { "dipmagk", '\x01', '\x12', '\a', 275, '\x05', '\n', 168430090, '\n', 2u },
  { "dipmagk", '\x03', '\x12', '\a', 450, '\f', '\n', 168430090, '\n', 2u },
  { "magcarow", '\x01', '&', '\0', 200, '\x03', '\n', 168430090, '\n', 3u },
  { "berzerk", '\x04', '\x13', '\x16', 1000, '\f', '\n', 168430090, '\n', 11u },
  { "armgedn", '\x05', '\x10', '\0', 2000, '\x14', '\n', 168430090, '\n', 3u },
  { "storm", '\x04', '\v', '\0', 1300, '\x0F', '\n', 168430090, '\n', 3u },
  { "meteor~1", '\x04', '\x18', '\0', 1000, '\x0F', '\n', 168430090, '\n', 3u },
  { "paralize", '\x03', '\x14', '\x19', 700, '\t', '\n', 168430090, '\n', 11u },
  { "hypnotiz", '\x05', '%', '\x1A', 1300, '\x0F', '\n', 168430090, '\n', 11u },
  { "coldray", '\x02', '$', '\x13', 375, '\x06', '\n', 168430090, '\n', 3u },
  { "coldring", '\x03', '#', '\0', 500, '\t', '\n', 168430090, '\n', 3u },
  { "disruptr", '\x02', '\"', '\0', 500, '\a', '\n', 168430090, '\n', 3u },
  { "mnrdeath", '\x02', '\x1D', '\r', 300, '\x06', '\0', 0, '\n', 3u },
  { "mnrdeath", '\x03', '\x1C', '\r', 450, '\n', '\0', 0, '\n', 3u },
  { "drgnslay", '\x02', ' ', '\x1B', 100, '\x06', '\n', 168430090, '\n', 11u },
  { "bloodlus", '\x01', '\x1B', '\0', 300, '\x03', '\n', 168430090, '\n', 11u },
  { "resurect", '\x03', '\x19', '\x06', 400, '\n', '\n', 168430090, '\n', 3u },
  { "mirrorim", '\x05', '\x1A', '\0', 800, '\x19', '\n', 168430090, '\n', 11u },
  { "shield", '\x01', '\x0F', '\x17', 150, '\x03', '\n', 168430090, '\n', 11u },
  { "shield", '\x04', '\x0F', '\x17', 375, '\a', '\n', 168430090, '\n', 11u },
  { "sumnelm", '\x05', '8', '\0', 1000, '\x1E', '\0', 0, '\0', 3u },
  { "sumnelm", '\x05', '9', '\0', 1000, '\x1E', '\0', 0, '\0', 3u },
  { "sumnelm", '\x05', ':', '\0', 1000, '\x1E', '\0', 0, '\0', 3u },
  { "sumnelm", '\x05', ';', '\0', 1000, '\x1E', '\0', 0, '\0', 3u },
  { "erthquak", '\x03', '!', '\0', 300, '\x0F', '\n', 168430090, '\n', 3u }
};
const char *cArmyFrameFileNames[66] =
{
  "peas_frm.bin",
  "archrfrm.bin",
  "archrfrm.bin",
  "pikmnfrm.bin",
  "pikmnfrm.bin",
  "swrdsfrm.bin",
  "swrdsfrm.bin",
  "cvlryfrm.bin",
  "cvlr2frm.bin",
  "paladfrm.bin",
  "paladfrm.bin",
  "goblnfrm.bin",
  "orc__frm.bin",
  "orc__frm.bin",
  "wolf_frm.bin",
  "ogre_frm.bin",
  "ogre_frm.bin",
  "trollfrm.bin",
  "trollfrm.bin",
  "cyclofrm.bin",
  "spritfrm.bin",
  "dwarffrm.bin",
  "dwarffrm.bin",
  "elf__frm.bin",
  "elf__frm.bin",
  "druidfrm.bin",
  "druidfrm.bin",
  "unicofrm.bin",
  "phoenfrm.bin",
  "centrfrm.bin",
  "garglfrm.bin",
  "grifffrm.bin",
  "minotfrm.bin",
  "minotfrm.bin",
  "hydrafrm.bin",
  "draggfrm.bin",
  "dragrfrm.bin",
  "dragbfrm.bin",
  "halflfrm.bin",
  "boar_frm.bin",
  "golemfrm.bin",
  "golemfrm.bin",
  "roc__frm.bin",
  "mage1frm.bin",
  "mage1frm.bin",
  "titanfrm.bin",
  "tita2frm.bin",
  "skel_frm.bin",
  "zomb_frm.bin",
  "zomb_frm.bin",
  "mummyfrm.bin",
  "mummyfrm.bin",
  "vampifrm.bin",
  "vampifrm.bin",
  "lich_frm.bin",
  "lich_frm.bin",
  "drabnfrm.bin",
  "roguefrm.bin",
  "nomadfrm.bin",
  "ghostfrm.bin",
  "geniefrm.bin",
  "medusfrm.bin",
  "felemfrm.bin",
  "felemfrm.bin",
  "felemfrm.bin",
  "felemfrm.bin"
};
byte giSpellInfluenceToSpell[] = { 9u, 11u, 13u, 14u, 18u, 26u, 30u, 31u, 37u, 38u, 41u, 101u, 22u, 16u, 17u };
unsigned __int8 giNumPowFrames[32] =
{
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  10u,
  8u,
  8u,
  10u,
  10u,
  10u,
  10u,
  15u,
  10u,
  10u,
  10u,
  10u,
  10u,
  16u,
  16u,
  14u,
  19u,
  22u,
  10u,
  17u,
  10u,
  12u,
  11u,
  16u
};
int giSpellEffectShowType = 2; // weak
char gcColorToPlayerPos[] = { '\0' }; // weak
char *cCombatBkgNames[] = { "CBKGWATR.icn" };
SCmbtObstacle sCmbtObstacles[32] =
{
  { 512, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 512, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 66, '\x03', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 1, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 0, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 330, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 8, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 72, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 10, '\x02', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 160, '\x03', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 1, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 330, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 10, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 160, '\x02', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 72, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 10, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 8, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 8, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 128, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 322, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 128, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 128, '\x02', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 4, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 1, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 160, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 512, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 4, '\x02', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 74, '\x03', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 2, '\x03', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 16, '\x01', '\x01', { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 0, '\x01', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } },
  { 16, '\x02', '\x02', { '\0', '\x01', '\0', '\0', '\0', '\0', '\0', '\0' } }
};
char byte_4F3904[] = { '\x01' }; // idb
char byte_4F3905[] = { '\x01' }; // idb
char byte_4F3906[] = { '\0' }; // idb
int gEstatesGoldLevel[] = { 0, 100, 250, 500 }; // idb
float gfSSLogisticsMod[] = {  1.0,  1.1,  1.2,  1.3 }; // idb
float gfSSNavigationMod[4] = {  1.0,  1.33,  1.66,  2.0 };
float gfSSArcheryMod[] = {  1.0,  1.1,  1.25,  1.5 }; // idb
float gfSSAIArcheryMod[] = {  1.0 }; // weak
char giVisRange[] = { '\x04' }; // weak
primary_skills gStartingHeroStats[] = { { '\x02', '\x02', '\x01', '\x01', '\x01' } }; // weak
int giTerrainCost[20][4] =
{
  { 100, 150, 100, 150 },
  { 100, 150, 100, 150 },
  { 100, 150, 100, 150 },
  { 100, 150, 100, 150 },
  { 150, 225, 125, 187 },
  { 100, 150, 100, 150 },
  { 175, 262, 150, 225 },
  { 125, 187, 100, 150 },
  { 100, 150, 100, 150 },
  { 100, 150, 100, 150 },
  { 200, 300, 175, 262 },
  { 150, 225, 100, 150 },
  { 100, 150, 100, 150 },
  { 100, 150, 100, 150 },
  { 125, 187, 100, 150 },
  { 100, 150, 100, 150 },
  { 125, 187, 100, 150 },
  { 100, 150, 100, 150 },
  { 75, 112, 75, 112 },
  { 75, 112, 75, 112 }
};
char bStopOnTrigger[] = { '\0' }; // weak
char *gTownPrefixNames[6] = { "twnk", "twnb", "twns", "twnw", "twnz", "twnn" }; // weak
char *gTownObjNames[32] =
{
  "mage",
  "thie",
  "tvrn",
  "dock",
  "well",
  "tent",
  "cstl",
  "stat",
  "ltur",
  "rtur",
  "mark",
  "wel2",
  "moat",
  "spec",
  "boat",
  "capt",
  "ext0",
  "ext1",
  "ext2",
  "dw_0",
  "dw_1",
  "dw_2",
  "dw_3",
  "dw_4",
  "dw_5",
  "up_1",
  "up_2",
  "up_3",
  "up_4",
  "up_5",
  "up5b",
  "ext3"
}; // weak
char gDwellingType[6][12] =
{
  {
    '\0',
    '\x01',
    '\x03',
    '\x05',
    '\a',
    '\t',
    '\x02',
    '\x04',
    '\x06',
    '\b',
    '\n',
    '\xFF'
  },
  "\v\f\x0E\x0F\x11\x13\r\xFF\x10\x12\xFF\xFF",
  "\x14\x15\x17\x19\x1B\x1C\x16\x18\x1A\xFF\xFF\xFF",
  "\x1D\x1E\x1F \"#\xFF\xFF!\xFF$%",
  "&'(*+-\xFF)\xFF,.\xFF",
  "/024681357\xFF\xFF"
};
_DWORD gMageBuildingCosts[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
void gSpecialBuildingCosts; // idb
void gNeutralBuildingCosts; // idb
int gMageBaseResourceValues[] = { 0 }; // weak
int dword_4F4100[] = { 5000 }; // weak
int dword_4F411C[] = { 2500 }; // weak
int dword_4F4150[] = { 1500 }; // weak
building_cost gDwellingCosts[] = { { 0, 0, 0, 0, 0, 0, 200 } }; // weak
building_cost stru_4F4A14 = { 0, 0, 5, 0, 5, 0, 3000 }; // weak
int gHierarchyMask[] = { 0 }; // weak
int giDebugBuildingToBuild = 4294967295; // weak
char giTerrainToMusicTrack[] = { '\x10', '\x12', '\x0E', '\x0F', '\v', '\r', '\x11', '\f', '\x10' }; // idb
char *cHeroTypeShortName[6] = { "kngt", "barb", "sorc", "wrlk", "wzrd", "necr" }; // weak
char cHeroTypeInitial[] = { 'k', 'b', 's', 'w', 'z', 'n' }; // idb
int giDeferObjDrawX = 4294967295; // weak
int giDeferObjDrawY = 4294967295; // weak
heroWindow *gpInitWin = NULL; // idb
secondary_skill_chances iGetSSByAlignment[14] =
{
  { { '\x03', '\x04', '\x02', '\x02', '\x02', '\x03' } },
  { { '\x02', '\x03', '\x03', '\x01', '\x01', '\x01' } },
  { { '\x03', '\x03', '\x02', '\x02', '\x02', '\x02' } },
  { { '\x02', '\x04', '\x01', '\x04', '\x02', '\x01' } },
  { { '\x03', '\x02', '\x02', '\x02', '\x02', '\x02' } },
  { { '\x02', '\x03', '\x04', '\x02', '\x02', '\x02' } },
  { { '\x05', '\x03', '\x01', '\x01', '\x02', '\0' } },
  { { '\x02', '\x01', '\x04', '\x05', '\x05', '\x04' } },
  { { '\x01', '\x01', '\x03', '\x03', '\x04', '\x03' } },
  { { '\x01', '\x02', '\x03', '\x01', '\x02', '\x01' } },
  { { '\x04', '\x03', '\x03', '\x03', '\x03', '\x03' } },
  { { '\x01', '\x01', '\x02', '\x03', '\x03', '\x03' } },
  { { '\0', '\0', '\0', '\x01', '\0', '\a' } },
  { { '\x03', '\x02', '\x02', '\x02', '\x02', '\x02' } }
};
struct SCmbtHero sCmbtHero[6] =
{
  {
    18,
    8,
    65475,
    65487,
    '\x02',
    "\x01\t\t\x02\x01\x03\x02\x02\x01\x03\x02",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\b\t\b\t\b\a\x06",
      "\n\v\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\n\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\f\r\xFF\xFF\xFF\xFF\xFF\xFF",
      "\f\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x0E\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x0F\x10\x11\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x12\x13\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  },
  {
    13,
    9,
    65469,
    65480,
    '\x02',
    "\x01\t\b\x03\x02\x03\x02\x02\x01\x03\x01",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\b\t\t\b\a\x06\xFF",
      "\x06\n\v\xFF\xFF\xFF\xFF\xFF\xFF",
      "\n\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\f\r\xFF\xFF\xFF\xFF\xFF\xFF",
      "\f\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\x0E\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x0F\x10\x11\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x12\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  },
  {
    19,
    12,
    65474,
    65486,
    '\x02',
    "\x01\t\x05\x03\x02\x03\x02\x02\x01\x03\x01",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\b\a\x06\xFF\xFF\xFF\xFF",
      "\x06\a\t\xFF\xFF\xFF\xFF\xFF\xFF",
      "\a\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\n\v\xFF\xFF\xFF\xFF\xFF\xFF",
      "\n\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\f\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\r\x0E\x0F\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x10\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  },
  {
    18,
    7,
    65471,
    65486,
    '\x02',
    "\x01\t\t\x04\x02\x03\x01\x02\x01\x02\x01",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\b\t\n\t\b\a\x06",
      "\x06\a\v\f\xFF\xFF\xFF\xFF\xFF",
      "\v\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\a\r\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\x0E\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x0F\x10\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  },
  {
    25,
    22,
    65471,
    65489,
    '\x02',
    "\x01\t\a\x05\x04\x02\x01\x02\x01\x02\x01",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\b\t\b\a\x06\xFF\xFF",
      "\x06\n\v\f\r\xFF\xFF\xFF\xFF",
      "\f\v\n\x06\xFF\xFF\xFF\xFF\xFF",
      "\x06\x0E\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\x0F\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x06\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x10\x11\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x12\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  },
  {
    17,
    10,
    65475,
    65486,
    '\x02',
    "\x01\t\x06\x05\x03\x05\x01\x05\x01\x01\x02",
    {
      "\x01\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x02\x03\x04\x05\x04\x05\x04\x03\x02",
      "\x06\a\x06\a\x06\a\xFF\xFF\xFF",
      "\a\b\t\n\v\xFF\xFF\xFF\xFF",
      "\n\t\a\xFF\xFF\xFF\xFF\xFF\xFF",
      "\a\f\r\x0E\x0F\xFF\xFF\xFF\xFF",
      "\a\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\a\f\r\x0E\x10\xFF\xFF\xFF\xFF",
      "\a\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x11\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\x12\x13\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
      "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    }
  }
};
char byte_4F5234[] = { '\t' }; // idb
char byte_4F5238[] = { '\x16' }; // idb
Point16 wallPos[4] = { { 468, 58 }, { 421, 128 }, { 417, 291 }, { 498, 402 } };
Point16 towerPos[2] = { { 441, 61 }, { 398, 147 } };
Point16 doorPos = { 393, 192 };
int dword_4F5268[] = { 0 }; // weak
SElevationOverlay sElevationOverlay[25] =
{
  {
    0,
    {
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255
    }
  },
  { 2, { 30, 31, 32, 33, 47, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255 } },
  {
    2,
    { 56, 57, 58, 59, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  { 2, { 42, 55, 56, 57, 58, 59, 60, 48, 255, 255, 255, 255, 255, 255, 255 } },
  { 2, { 69, 70, 71, 72, 73, 60, 48, 255, 255, 255, 255, 255, 255, 255, 255 } },
  { 2, { 29, 30, 31, 32, 33, 34, 35, 81, 69, 70, 71, 72, 73, 74, 87 } },
  { 2, { 29, 17, 18, 19, 20, 21, 81, 95, 96, 97, 98, 99, 255, 255, 255 } },
  { 4, { 30, 31, 32, 33, 47, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255 } },
  {
    4,
    { 56, 57, 58, 59, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  { 4, { 42, 55, 56, 57, 58, 59, 47, 255, 255, 255, 255, 255, 255, 255, 255 } },
  { 4, { 69, 70, 71, 72, 73, 60, 48, 255, 255, 255, 255, 255, 255, 255, 255 } },
  { 4, { 18, 30, 43, 84, 85, 73, 60, 255, 255, 255, 255, 255, 255, 255, 255 } },
  { 4, { 21, 34, 48, 70, 83, 97, 98, 255, 255, 255, 255, 255, 255, 255, 255 } },
  {
    64,
    { 30, 31, 32, 33, 47, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  {
    64,
    { 56, 57, 58, 59, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  { 64, { 42, 55, 56, 57, 58, 59, 60, 48, 255, 255, 255, 255, 255, 255, 255 } },
  { 64, { 69, 70, 71, 72, 73, 60, 48, 255, 255, 255, 255, 255, 255, 255, 255 } },
  { 64, { 29, 30, 31, 32, 33, 34, 35, 81, 69, 70, 71, 72, 73, 74, 87 } },
  { 64, { 29, 17, 18, 19, 20, 21, 81, 95, 96, 97, 98, 99, 255, 255, 255 } },
  {
    128,
    { 30, 31, 32, 33, 47, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  {
    128,
    { 56, 57, 58, 59, 60, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  { 128, { 42, 55, 56, 57, 58, 59, 60, 48, 255, 255, 255, 255, 255, 255, 255 } },
  {
    128,
    { 69, 70, 71, 72, 73, 60, 48, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  {
    128,
    { 43, 30, 18, 84, 85, 73, 60, 255, 255, 255, 255, 255, 255, 255, 255 }
  },
  {
    128,
    { 21, 34, 48, 70, 83, 97, 98, 255, 255, 255, 255, 255, 255, 255, 255 }
  }
};
char captainStats[] = { '\x01' }; // weak
int gbDrawingPuzzle = 0; // weak
int giWalkingFrom = 4294967295; // weak
int giWalkingFrom2 = 4294967295; // weak
int giWalkingTo = 4294967295; // weak
int giWalkingTo2 = 4294967295; // weak
int giWalkingYMod = 0; // weak
unsigned __int8 moatCell[] = { 8u, 21u, 33u, 46u, 58u, 72u, 85u, 99u, 112u };
_UNKNOWN campaignChoices; // weak
char *congratsText = NULL; // idb
char *dword_4F55F4[104] =
{
  NULL,
  "Ultimate Book of Knowledge",
  "Ultimate Sword of Dominion",
  "Ultimate Cloak of Protection",
  "Ultimate Wand of Magic",
  "Ultimate Shield",
  "Ultimate Staff",
  "Ultimate Crown",
  "Golden Goose",
  "Arcane Necklace of Magic",
  "Caster's Bracelet of Magic",
  "Mage's Ring of Power",
  "Witch's Broach of Magic",
  "Medal of Valor",
  "Medal of Courage",
  "Medal of Honor",
  "Medal of Distinction",
  "Fizbin of Misfortune",
  "Thunder Mace of Dominion",
  "Armored Gauntlets of Protection",
  "Defender Helm of Protection",
  "Giant Flail of Dominion",
  "Ballista of Quickness",
  "Stealth Shield of Protection",
  "Dragon Sword of Dominion",
  "Power Axe of Dominion",
  "Divine Breastplate of Protection",
  "Minor Scroll of Knowledge",
  "Major Scroll of Knowledge",
  "Superior Scroll of Knowledge",
  "Foremost Scroll of Knowledge",
  "Endless Sack of Gold",
  "Endless Bag of Gold",
  "Endless Purse of Gold",
  "Nomad Boots of Mobility",
  "Traveler's Boots of Mobility",
  "Lucky Rabbit's Foot",
  "Golden Horseshoe",
  "Gambler's Lucky Coin",
  "Four-Leaf Clover",
  "True Compass of Mobility",
  "Sailor's Astrolabe of Mobility",
  "Evil Eye",
  "Enchanted Hourglass",
  "Gold Watch",
  "Skullcap",
  "Ice Cloak",
  "Fire Cloak",
  "Lightning Helm",
  "Evercold Icicle",
  "Everhot Lava Rock",
  "Lightning Rod ",
  "Snake-Ring",
  "Ankh",
  "Book of Elements",
  "Elemental Ring",
  "Holy Pendant",
  "Pendant of Free Will",
  "Pendant of Life",
  "Serenity Pendant",
  "Seeing-eye Pendant",
  "Kinetic Pendant",
  "Pendant of Death",
  "Wand of Negation",
  "Golden Bow",
  "Telescope",
  "Statesman's Quill",
  "Wizard's Hat",
  "Power Ring",
  "Ammo Cart",
  "Tax Lien",
  "Hideous Mask",
  "Endless Pouch of Sulfur",
  "Endless Vial of Mercury",
  "Endless Pouch of Gems",
  "Endless Cord of Wood",
  "Endless Cart of Ore",
  "Endless Pouch of Crystal",
  "Spiked Helm",
  "Spiked Shield",
  "White Pearl",
  "Black Pearl",
  "Magic Book",
  "ERROR : Artifact 82",
  "ERROR : Artifact 83",
  "ERROR : Artifact 84",
  "ERROR : Artifact 85",
  "Spell Scroll",
  "Arm of the Martyr",
  "Breastplate of Anduran",
  "Broach of Shielding",
  "Battle Garb of Anduran",
  "Crystal Ball",
  "Heart of Fire",
  "Heart of Ice",
  "Helmet of Anduran",
  "Holy Hammer",
  "Legendary Scepter",
  "Masthead",
  "Sphere of Negation",
  "Staff of Wizardry",
  "Sword Breaker",
  "Sword of Anduran",
  "Spade of Necromancy"
};
char *gArtifactNames[] =
{
  "Ultimate Book of Knowledge",
  "Ultimate Sword of Dominion",
  "Ultimate Cloak of Protection",
  "Ultimate Wand of Magic",
  "Ultimate Shield",
  "Ultimate Staff",
  "Ultimate Crown",
  "Golden Goose",
  "Arcane Necklace of Magic",
  "Caster's Bracelet of Magic",
  "Mage's Ring of Power",
  "Witch's Broach of Magic",
  "Medal of Valor",
  "Medal of Courage",
  "Medal of Honor",
  "Medal of Distinction",
  "Fizbin of Misfortune",
  "Thunder Mace of Dominion",
  "Armored Gauntlets of Protection",
  "Defender Helm of Protection",
  "Giant Flail of Dominion",
  "Ballista of Quickness",
  "Stealth Shield of Protection",
  "Dragon Sword of Dominion",
  "Power Axe of Dominion",
  "Divine Breastplate of Protection",
  "Minor Scroll of Knowledge",
  "Major Scroll of Knowledge",
  "Superior Scroll of Knowledge",
  "Foremost Scroll of Knowledge",
  "Endless Sack of Gold",
  "Endless Bag of Gold",
  "Endless Purse of Gold",
  "Nomad Boots of Mobility",
  "Traveler's Boots of Mobility",
  "Lucky Rabbit's Foot",
  "Golden Horseshoe",
  "Gambler's Lucky Coin",
  "Four-Leaf Clover",
  "True Compass of Mobility",
  "Sailor's Astrolabe of Mobility",
  "Evil Eye",
  "Enchanted Hourglass",
  "Gold Watch",
  "Skullcap",
  "Ice Cloak",
  "Fire Cloak",
  "Lightning Helm",
  "Evercold Icicle",
  "Everhot Lava Rock",
  "Lightning Rod ",
  "Snake-Ring",
  "Ankh",
  "Book of Elements",
  "Elemental Ring",
  "Holy Pendant",
  "Pendant of Free Will",
  "Pendant of Life",
  "Serenity Pendant",
  "Seeing-eye Pendant",
  "Kinetic Pendant",
  "Pendant of Death",
  "Wand of Negation",
  "Golden Bow",
  "Telescope",
  "Statesman's Quill",
  "Wizard's Hat",
  "Power Ring",
  "Ammo Cart",
  "Tax Lien",
  "Hideous Mask",
  "Endless Pouch of Sulfur",
  "Endless Vial of Mercury",
  "Endless Pouch of Gems",
  "Endless Cord of Wood",
  "Endless Cart of Ore",
  "Endless Pouch of Crystal",
  "Spiked Helm",
  "Spiked Shield",
  "White Pearl",
  "Black Pearl",
  "Magic Book",
  "ERROR : Artifact 82",
  "ERROR : Artifact 83",
  "ERROR : Artifact 84",
  "ERROR : Artifact 85",
  "Spell Scroll",
  "Arm of the Martyr",
  "Breastplate of Anduran",
  "Broach of Shielding",
  "Battle Garb of Anduran",
  "Crystal Ball",
  "Heart of Fire",
  "Heart of Ice",
  "Helmet of Anduran",
  "Holy Hammer",
  "Legendary Scepter",
  "Masthead",
  "Sphere of Negation",
  "Staff of Wizardry",
  "Sword Breaker",
  "Sword of Anduran",
  "Spade of Necromancy"
};
char *gArtifactDesc[103] =
{
  "{Ultimate Book\n(+12 Knowledge)}\n\nThe Ultimate Book of Knowledge increases your knowledge by 12.",
  "{Ultimate Sword\n(+12 Attack)}\n\nThe Ultimate Sword of Dominion increases your attack skill by 12.",
  "{Ultimate Cloak\n(+12 Defense)}\n\nThe Ultimate Cloak of Protection increases your defense skill by 12.",
  "{Ultimate Wand\n(+12 Spell Power)}\n\nThe Ultimate Wand of Magic increases your spell power by 12.",
  "{Ultimate Shield}\n\nThe Ultimate Shield increases your attack and defense skills by 6 each.",
  "{Ultimate Staff}\n\nThe Ultimate Staff increases your spell power and knowledge by 6 each.",
  "{Ultimate Crown}\n\nThe Ultimate Crown increases each of your basic skills by 4 points.",
  "{Golden Goose}\n\nThe Golden Goose brings in an income of 10,000 gold per turn.",
  "{Arcane Necklace\n(+4 Spell Power)}\n\nThe Arcane Necklace of Magic increases your spell power by 4.",
  "{Caster's Bracelet\n(+2 Spell Power)}\n\nThe Caster's Bracelet of Magic increases your spell power by 2.",
  "{Mage's Ring\n(+2 Spell Power)}\n\nThe Mage's Ring of Power increases your spell power by 2.",
  "{Witches Broach\n(+3 Spell Power)}\n\nThe Witch's Broach of Magic increases your spell power by 3.",
  "{Medal}\n\nThe Medal of Valor increases your morale.",
  "{Medal}\n\nThe Medal of Courage increases your morale.",
  "{Medal}\n\nThe Medal of Honor increases your morale.",
  "{Medal}\n\nThe Medal of Distinction increases your morale.",
  "{Fizbin}\n\nThe Fizbin of Misfortune greatly decreases your morale.",
  "{Thunder Mace\n(+1 Attack)}\n\nThe Thunder Mace of Dominion increases your attack skill by 1.",
  "{Armored Gauntlets\n(+1 Defense)}\n\nThe Armored Gauntlets of Protection increase your defense skill by 1.",
  "{Defender Helm\n(+1 Defense)}\n\nThe Defender Helm of Protection increases your defense skill by 1.",
  "{Giant Flail\n(+1 Attack)}\n\nThe Giant Flail of Dominion increases your attack skill by 1.",
  "{Ballista}\n\nThe Ballista of Quickness lets your catapult fire twice per combat round.",
  "{Stealth Shield\n(+2 Defense)}\n\nThe Stealth Shield of Protection increases your defense skill by 2.",
  "{Dragon Sword\n(+3 Attack)}\n\nThe Dragon Sword of Dominion increases your attack skill by 3.",
  "{Power Axe\n(+2 Attack)}\n\nThe Power Axe of Dominion increases your attack skill by 2.",
  "{Divine Breastplate\n(+3 Defense)}\n\nThe Divine Breastplate of Protection increases your defense skill by 3.",
  "{Minor Scroll\n(+2 Knowledge)}\n\nThe Minor Scroll of Knowledge increases your knowledge by 2.",
  "{Major Scroll\n(+3 Knowledge)}\n\nThe Major Scroll of Knowledge increases your knowledge by 3.",
  "{Superior Scroll\n(+4 Knowledge)}\n\nThe Superior Scroll of Knowledge increases your knowledge by 4.",
  "{Foremost Scroll\n(+5 Knowledge)}\n\nThe Foremost Scroll of Knowledge increases your knowledge by 5.",
  "{Endless Sack}\n\nThe Endless Sack of Gold provides you with 1000 gold per day.",
  "{Endless Bag}\n\nThe Endless Bag of Gold provides you with 750 gold per day.",
  "{Endless Purse}\n\nThe Endless Purse of Gold provides you with 500 gold per day.",
  "{Nomad Boots}\n\nThe Nomad Boots of Mobility increase your movement on land.",
  "{Traveler's Boots}\n\nThe Traveler's Boots of Mobility increase your movement on land.",
  "{Rabbit's Foot}\n\nThe Lucky Rabbit's Foot increases your luck in combat.",
  "{Horseshoe}\n\nThe Golden Horseshoe increases your luck in combat.",
  "{Coin}\n\nThe Gambler's Lucky Coin increases your luck in combat.",
  "{Clover}\n\nThe Four-Leaf Clover increases your luck in combat.",
  "{Compass}\n\nThe True Compass of Mobility increases your movement on land and sea.",
  "{Astrolabe}\n\nThe Sailors' Astrolabe of Mobility increases your movement on sea.",
  "{Evil Eye}\n\nThe Evil Eye reduces the casting cost of curse spells by half.",
  "{Enchanted hourglass}\n\nThe Enchanted Hourglass extends the duration of all your spells by 2 turns.",
  "{Gold watch}\n\nThe Gold Watch doubles the effectiveness of your hypnotize spells.",
  "{Skullcap}\n\nThe Skullcap halves the casting cost of all mind influencing spells.",
  "{Ice cloak}\n\nThe Ice Cloak halves all damage your troops take from cold spells.",
  "{Fire cloak}\n\nThe Fire Cloak halves all damage your troops take from fire spells.",
  "{Lightning helm}\n\nThe Lightning Helm halves all damage your troops take from lightning spells.",
  "{Evercold icicle}\n\nThe Evercold Icicle causes your cold spells to do 50% more damage to enemy troops.",
  "{Everhot lava rock}\n\nThe Everhot Lava Rock causes your fire spells to do 50% more damage to enemy troops.",
  "{Lightning rod }\n\nThe Lightning Rod causes your lightning spells to do 50% more damage to enemy troops.",
  "{Snake-ring}\n\nThe Snake Ring halves the casting cost of all your bless spells.",
  "{Ankh}\n\nThe Ankh doubles the effectiveness of all your resurrect and animate spells.",
  "{Book of Elements}\n\nThe Book of Elements doubles the effectiveness of all your summoning spells.",
  "{Elemental ring}\n\nThe Elemental Ring halves the casting cost of all summoning spells.",
  "{Holy Pendant}\n\nThe Holy Pendant makes all your troops immune to curse spells.",
  "{Pendant of free will}\n\nThe Pendant of Free Will makes all your troops immune to hypnotize spells.",
  "{Pendant of life}\n\nThe Pendant of Life makes all your troops immune to death spells.",
  "{Serenity pendant}\n\nThe Serenity Pendant makes all your troops immune to berserk spells.",
  "{Seeing-eye pendant}\n\nThe Seeing-eye Pendant makes all your troops immune to blindness spells.",
  "{Kinetic pendant}\n\nThe Kinetic Pendant makes all your troops immune to paralyze spells.",
  "{Pendant of death}\n\nThe Pendant of Death makes all your troops immune to holy spells.",
  "{Wand of negation}\n\nThe Wand of Negation protects your troops from the Dispel Magic spell.",
  "{Golden bow}\n\nThe Golden Bow eliminates the 50% penalty for your troops shooting past obstacles. (e.g. castle walls)",
  "{Telescope}\n\nThe Telescope increases the amount of terrain your hero reveals when adventuring by 1 extra square.",
  "{Statesman's quill}\n\nThe Statesman's Quill reduces the cost of surrender to 10% of the total cost of troops you have in your army.",
  "{Wizard's hat}\n\nThe Wizard's Hat increases the duration of your spells by 10 turns!",
  "{Power ring}\n\nThe Power Ring returns 2 extra spell points/turn to your hero.",
  "{Ammo cart}\n\nThe Ammo Cart provides endless ammunition for all your troops that shoot.",
  "{Tax lien}\n\nThe Tax Lien costs you 250 gold pieces/turn.",
  "{Hideous mask}\n\nThe Hideous Mask prevents all 'wandering' armies from joining your hero.",
  "{Endless pouch of sulfur}\n\nThe Endless Pouch of Sulfur provides 1 unit of sulfur per day.",
  "{Endless vial of mercury}\n\nThe Endless Vial of Mercury provides 1 unit of mercury per day.",
  "{Endless pouch of gems}\n\nThe Endless Pouch of Gems provides 1 unit of gems per day.",
  "{Endless cord of wood}\n\nThe Endless Cord of Wood provides 1 unit of wood per day.",
  "{Endless cart of ore}\n\nThe Endless Cart of Ore provides 1 unit of ore per day.",
  "{Endless pouch of crystal}\n\nThe Endless Pouch of Crystal provides 1 unit of crystal/day.",
  "{Spiked helm}\n\nThe Spiked Helm increases your attack and defense skills by 1 each.",
  "{Spiked shield}\n\nThe Spiked Shield increases your attack and defense skills by 2 each.",
  "{White pearl}\n\nThe White Pearl increases your spell power and knowledge by 1 each.",
  "{Black pearl}\n\nThe Black Pearl increases your spell power and knowledge by 2 each.",
  "{Magic Book}\n\nThe Magic Book enables you to cast spells.",
  "{ERROR}\n\nArtifact 82.",
  "{ERROR}\n\nArtifact 83.",
  "{ERROR}\n\nArtifact 84.",
  "{ERROR}\n\nArtifact 85.",
  "{Spell Scroll}\n\nThis Spell Scroll gives your hero the ability to cast the '%s' spell.",
  "{Arm of the Martyr}\n\nThe Arm of the Martyr increases your spell power by 3 but adds the undead morale penalty.",
  "{Breastplate of Anduran}\n\nThe Breastplate increases your defense by 5.",
  "{Broach of Shielding}\n\nThe Broach of Shielding provides 50% protection from Armageddon and Elemental Storm, but decreases spell power by 2.",
  "{Battle Garb}\n\nThe Battle Garb of Anduran combines the powers of the three Anduran artifacts.  It provides maximum luck and morale for your troops and gives you the Town Portal spell.",
  "{Crystal Ball}\n\nThe Crystal Ball lets you get more specific information about monsters, enemy heroes, and castles nearby the hero who holds it.",
  "{Heart of Fire}\n\nThe Heart of Fire provides 50% protection from fire, but doubles the damage taken from cold.",
  "{Heart of Ice}\n\nThe Heart of Ice provides 50% protection from cold, but doubles the damage taken from fire.",
  "{Helmet of Anduran}\n\nThe Helmet increases your spell power by 5.",
  "{Holy Hammer}\n\nThe Holy Hammer increases your attack skill by 5.",
  "{Legendary Scepter}\n\nThe Legendary Scepter adds 2 points to all attributes.",
  "{Masthead}\n\nThe Masthead boosts your luck and morale by 1 each in sea combat.",
  "{Sphere of Negation}\n\nThe Sphere of Negation disables all spell casting, for both sides, in combat.",
  "{Staff of Wizardry}\n\nThe Staff of Wizardry boosts your spell power by 5.",
  "{Sword Breaker}\n\nThe Sword Breaker increases your defense by 4 and attack by 1.",
  "{Sword of Anduran}\n\nThe Sword increases your attack skill by 5.",
  "{Spade of Necromancy}\n\nThe Spade gives you increased necromancy skill."
};
char *gArtifactEvents = &unk_4FB2A8; // idb
char *gStatNames[] = { "Attack Skill", "Defense Skill", "Spell Power", "Knowledge" };
char *gStatDesc[4] =
{
  "{Attack Skill}\n\nYour attack skill is a bonus added to each creature's attack skill.",
  "{Defense Skill}\n\nYour defense skill is a bonus added to each creature's defense skill.",
  "{Spell Power}\n\nYour spell power determines the length or power of a spell.",
  "{Knowledge}\n\nYour knowledge determines how many spell points your hero may have.  Under normal cirumstances, a hero is limited to 10 spell points per level of knowledge."
};
char *gAlignmentNames[] =
{
  "Knight",
  "Barbarian",
  "Sorceress",
  "Warlock",
  "Wizard",
  "Necromancer",
  "Multiple",
  "Random"
};
char *gArmyNames[66] =
{
  "peasant",
  "archer",
  "ranger",
  "pikeman",
  "veteran pikeman",
  "swordsman",
  "master swordsman",
  "cavalry",
  "champion",
  "paladin",
  "crusader",
  "goblin",
  "orc",
  "orc chief",
  "wolf",
  "ogre",
  "ogre lord",
  "troll",
  "war troll",
  "cyclops",
  "sprite",
  "dwarf",
  "battle dwarf",
  "elf",
  "grand elf",
  "druid",
  "greater druid",
  "unicorn",
  "phoenix",
  "centaur",
  "gargoyle",
  "griffin",
  "minotaur",
  "minotaur king",
  "hydra",
  "green dragon",
  "red dragon",
  "black dragon",
  "halfling",
  "boar",
  "iron golem",
  "steel golem",
  "roc",
  "mage",
  "archmage",
  "giant",
  "titan",
  "skeleton",
  "zombie",
  "mutant zombie",
  "mummy",
  "royal mummy",
  "vampire",
  "vampire lord",
  "lich",
  "power lich",
  "bone dragon",
  "rogue",
  "nomad",
  "ghost",
  "genie",
  "medusa",
  "earth elemental",
  "air elemental",
  "fire elemental",
  "water elemental"
};
char *gArmyNamesPlural[66] =
{
  "peasants",
  "archers",
  "rangers",
  "pikemen",
  "veteran pikemen",
  "swordsmen",
  "master swordsmen",
  "cavalries",
  "champions",
  "paladins",
  "crusaders",
  "goblins",
  "orcs",
  "orc chiefs",
  "wolves",
  "ogres",
  "ogre lords",
  "trolls",
  "war trolls",
  "cyclopes",
  "sprites",
  "dwarves",
  "battle dwarves",
  "elves",
  "grand elves",
  "druids",
  "greater druids",
  "unicorns",
  "phoenix",
  "centaurs",
  "gargoyles",
  "griffins",
  "minotaurs",
  "minotaur kings",
  "hydras",
  "green dragons",
  "red dragons",
  "black dragons",
  "halflings",
  "boars",
  "iron golems",
  "steel golems",
  "rocs",
  "magi",
  "archmagi",
  "giants",
  "titans",
  "skeletons",
  "zombies",
  "mutant zombies",
  "mummies",
  "royal mummies",
  "vampires",
  "vampire lords",
  "liches",
  "power liches",
  "bone dragons",
  "rogues",
  "nomads",
  "ghosts",
  "genies",
  "medusas",
  "earth elementals",
  "air elementals",
  "fire elementals",
  "water elementals"
};
char *terrainNames[9] =
{
  "Ocean",
  "Grass",
  "Snow",
  "Swamp",
  "Lava",
  "Desert",
  "Dirt",
  "Wasteland",
  "Beach"
};
char *gResourceNames[7] = { "Wood", "Mercury", "Ore", "Sulfur", "Crystal", "Gems", "Gold" };
char *adventureMapLocations = &unk_5003AC; // idb
char *gEventText[124] =
{
  "{Alchemist}\n\nYou have taken control of the local Alchemist shop. It will provide you with one unit of Mercury per day.",
  "{Signpost}\n\nA signpost reads:}\n\n%s is near.",
  "{Buoy}\n\nYour men spot a navigational buoy, confirming that you are on course.",
  "{Buoy}\n\nYour men spot a navigational buoy, confirming that you are on course and increasing their morale.",
  &unk_500B1C,
  &unk_500B20,
  &unk_500B24,
  &unk_500B28,
  &unk_500B2C,
  &unk_500B30,
  &unk_500B34,
  &unk_500B38,
  "{Faerie Ring}\n\nYou enter the faerie ring, but nothing happens.",
  "{Faerie Ring}\n\nUpon entering the mystical faerie ring, your army gains luck for its next battle.",
  "{Campfire}\n\nRansacking an enemy camp, you discover a hidden cache of treasures.",
  "{Fountain}\n\nYou drink from the enchanted fountain, but nothing happens.",
  "{Fountain}\n\nAs you drink the sweet water, you gain luck for your next battle.",
  "{Gazebo}\n\nAn old Knight appears on the steps of the gazebo. \"I am sorry, my liege, I have taught you all I can.\"",
  "{Gazebo}\n\nAn old Knight appears on the steps of the gazebo. \"My liege, I will teach you all that I know to aid you in your travels.\"",
  "{Genie Lamp}\n\nYou stumble upon a dented and tarnished lamp lodged deep in the earth. Do you wish to rub the lamp?",
  "{Graveyard}\n\nYou tentatively approach the burial ground of ancient warriors.  Do you want to search the graves?",
  "Upon defeating the Zombies you spend several hours searching the graves and find nothing.  Such a despicable act reduces your army's morale.",
  "Upon defeating the zomies you search the graves and find something!",
  "{Archer's House}\n\nA group of Archers with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Archer's House}\n\nAs you approach the dwelling, you notice that there is no one here.",
  "{Goblin Hut}\n\nA group of Goblins with a desire for greater glory wish to join you. Do you accept?",
  "You are unable to recruit at this time, your ranks are full.",
  "{Goblin Hut}\n\nAs you approach the dwelling, you notice that there is no one here.",
  "{Peasant Hut}\n\nA group of Peasants with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Peasant Hut}\n\nAs you approach the dwelling, you notice that there is no one here.",
  "{Dwarf Cottage}\n\nA group of Dwarves with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Dwarf Cottage}\n\nAs you approach the dwelling, you notice that there is no one here.",
  "{Thatched Hut}\n\nA group of Peasants with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Thatched Hut}\n\nAs you approach the Peasant dwelling you notice that there is no one here.",
  "{Tree House}\n\nA group of Sprites with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Tree House}\n\nAs you approach the Sprites' tree house you notice that there is no one here.",
  "{Halfling Hole}\n\nA group of Halflings with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Halfling Hole}\n\nAs you approach the habitat you notice that there is no one here.",
  "{Watch Tower}\n\nA group of Orcs with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Watch Tower}\n\nAs you approach the Orcs' watch tower you notice that there is no one here.",
  "{Snow Cave}\n\nA group of Centaurs with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Cave}\n\nAs you approach the Centaurs' cave you notice that there is no one here.",
  "{Excavation}\n\nA group of Skeletons with a desire for greater glory wish to join you. Do you accept? ",
  "You are unable to recruit at this time, your ranks are full.",
  "{Excavation}\n\nAs you approach the Skeletons' excavation you notice that there is no one here.",
  &unk_501970,
  &unk_501974,
  &unk_501978,
  &unk_50197C,
  &unk_501980,
  "{Lighthouse}\n\nThe lighthouse is now under your control, and all of your ships will now move further each turn.",
  "{Water Wheel}\n\nThe keeper of the mill announces: \"Milord, I am sorry, there is no gold currently available.  Please try again next week.\"",
  "{Water Wheel}\n\nThe keeper of the mill announces: \"Milord, I have been working very hard to provide you with this gold, come back next week for more.\"",
  "{Ore Mine}\n\nYou gain control of an ore mine. It will provide you with two units of ore per day.",
  "{Sulfur Mine}\n\nYou gain control of a sulfur mine. It will provide you with one unit of sulfur per day.",
  "{Crystal Mine}\n\nYou gain control of a crystal mine. It will provide you with one unit of crystal per day.",
  "{Gem Mine}\n\nYou gain control of a gem mine. It will provide you with one unit of gems per day.",
  "{Gold Mine}\n\nYou gain control of a gold mine. It will provide you with 1000 gold per day.",
  "{Followers}\n\nA group of %s with a desire for greater glory wish to join you. Do you accept? ",
  "Insulted by your refusal of their offer, the monsters attack!",
  "{Obelisk}\n\nYou come upon an obelisk made from a type of stone you have never seen before.  Staring at it intensely, the smooth surface suddenly changes to an inscription.  The inscription is a piece of a lost ancient map.  Quickly you copy down the piece and the inscription vanishes as abruptly as it had appeared.",
  "{Obelisk}\n\nYou have already been to this obelisk.",
  &unk_501F18,
  &unk_501F1C,
  "You find a small quantity of %s.",
  "{Sawmill}\n\nYou gain control of a sawmill. It will provide you with two units of wood per day.",
  "{Oracle}\n\nNestled among the trees sits a blind seer. After explaining the intent of your journey, the seer activates his crystal ball, allowing you to see the strengths and weaknesses of your opponents.",
  &unk_502070,
  &unk_502074,
  &unk_502078,
  &unk_50207C,
  &unk_502080,
  &unk_502084,
  "{Desert Tent}\n\nA group of tattered tents, billowing in the sandy wind, beckons you.  The tents are unoccupied.  Perhaps more Nomads will be here later.",
  "{Desert Tent}\n\nA group of tattered tents, billowing in the sandy wind, beckons you.  Do you wish to have any Nomads join you during your travels?",
  "{Wagon}\n\nA colorful Rogues' wagon stands empty here.  Perhaps more Rogues will be here later.",
  "{Wagon}\n\nDistant sounds of music and laughter draw you to a colorful wagon housing Rogues.  Do you wish to have any Rogues join your army?",
  "{Whirlpool}\n\nA whirlpool engulfs your ship.  Some of your army has fallen overboard.",
  "{Windmill}\n\nThe keeper of the mill announces: \"Milord, I am sorry, there are no resources currently available. Please try again next week.\"",
  "{Windmill}\n\nThe keeper of the mill announces: \"Milord, I have been working very hard to provide you with these resources, come back next week for more.\"",
  &unk_502420,
  &unk_502424,
  &unk_502428,
  &unk_50242C,
  &unk_502430,
  "{Skeleton}\n\nYou come upon the remains of an unfortunate adventurer.  Searching through the tattered clothing, you find nothing.",
  "{Skeleton}\n\nYou come upon the remains of an unfortunate adventurer.  Searching through the tattered clothing, you find ",
  NULL,
  "Start a single or multi-player game.",
  "Load a previously saved game.",
  "Save the current game.",
  "Quit out of Heroes of Might and Magic II.",
  "Exit this menu without doing anything.",
  NULL,
  "{OK}\n\nExit this menu.",
  "{Speed}\n\nSet the speed of combat actions and animations.",
  "{Monster Info}\n\nToggle the monster info window, which shows information on the active and targeted monsters.",
  "{Auto Combat\nSpell Casting}\n\nToggle whether or not the computer will cast spells for you when auto combat is on.  (Note: This does not affect spell casting for computer players in any way, nor does it affect quick combat.)",
  "{Grid}\n\nToggle the hex grid on or off.  The hex grid always underlies movement, even if turned off.  This switch only determines if the grid is visible.",
  "{Shadow Movement}\n\nToggle on or off a shadowing system showing where your creatures can move and attack.  When this is turned on, there is a slight performance cost, most noticeable on 486 computers.",
  "{Shadow Cursor}\n\nToggle on or off a shadowing system showing where the hex grid that the mouse cursor is currently over is shadowed.  When this is turned on, there is a slight performance cost, most noticeable on 486 computers.",
  NULL,
  "View the entire world.",
  "View the obelisk puzzle.",
  "View information on the scenario you are currently playing.",
  "Dig for the Ultimate Artifact.",
  "Exit this menu without doing anything.",
  NULL,
  "{New Game}\n\nStart a single or multi-player game.",
  "{Load Game}\n\nLoad a previously saved game.",
  "{High Scores}\n\nView the high score screen.",
  "{Credits}\n\nView the credits screen.",
  "{Quit}\n\nQuit Heroes of Might and Magic and return to the operating system.",
  NULL,
  "{Next Hero}\n\nSelect the next Hero.",
  "{Continue Movement}\n\nContinue the Hero's movement along the current path."
};
char *off_4F627C[4] = { "Normal", "Good", "Great", "Irish" }; // weak
char *off_4F629C[4] = { "Normal", "Good", "Great", "Blood!" }; // weak
char *onOffText[11] =
{
  "Off",
  "On",
  "On\nVolume 9",
  "On\nVolume 8",
  "On\nVolume 7",
  "On\nVolume 6",
  "On\nVolume 5",
  "On\nVolume 4",
  "On\nVolume 3",
  "On\nVolume 2",
  "On\nVolume 1"
}; // weak
char *walkSpeedText[5] = { "Walk", "Trot", "Canter", "Gallop", "Jump" }; // weak
char *gColors = "blue"; // idb
char *gMonthNames[25] =
{
  "Grasshopper",
  "Ant",
  "Dragonfly",
  "Spider",
  "Butterfly",
  "Bumblebee",
  "Locust",
  "Earthworm",
  "Hornet",
  "Beetle",
  "Squirrel",
  "Rabbit",
  "Gopher",
  "Badger",
  "Rat",
  "Eagle",
  "Weasel",
  "Raven",
  "Mongoose",
  "Dog",
  "Aardvark",
  "Lizard",
  "Tortoise",
  "Hedgehog",
  "Condor"
}; // weak
char *gWeekNames[15] =
{
  "Squirrel",
  "Rabbit",
  "Gopher",
  "Badger",
  "Rat",
  "Eagle",
  "Weasel",
  "Raven",
  "Mongoose",
  "Dog",
  "Aardvark",
  "Lizard",
  "Tortoise",
  "Hedgehog",
  "Condor"
}; // weak
char *off_4F637C = "View %s Info"; // idb
char *off_4F6380 = "Additional hero characteristics"; // idb
char *off_4F6384 = "View Good Morale Info"; // idb
char *off_4F6388 = "View Neutral Morale Info"; // idb
char *off_4F638C = "View Bad Morale Info"; // idb
char *off_4F6390 = "View Good Luck Info"; // idb
char *off_4F6394 = "View Neutral Luck Info"; // idb
char *off_4F6398 = "View Bad Luck Info"; // idb
char *off_4F639C = "View Experience Info"; // idb
char *off_4F63A0 = "Select %s"; // idb
char *off_4F63A4 = "Empty"; // idb
char *off_4F63A8 = "Move %s"; // idb
char *off_4F63AC = "Exchange %s with %s"; // idb
char *off_4F63B0 = "View Spells"; // idb
char *off_4F63B4 = "View %s Info"; // idb
char *off_4F63B8 = "Dismiss %s the %s"; // idb
char *off_4F63BC = "Exit Hero Screen"; // idb
char *off_4F63C0 = "Hero Screen"; // idb
char *off_4F63C4 = "Combine %s"; // idb
char *off_4F63C8 = "Split %s"; // idb
char *off_4F63CC = "View %s %s Info"; // idb
char *off_4F63D0 = "View Spell Points Info"; // idb
char *off_4F63D4 = "Set army combat formation to 'Spread'"; // idb
char *off_4F63D8 = "Set army combat formation to 'Grouped'"; // idb
char *cCastleInfo = "Build Mage Guild"; // idb
char *off_4F63F0 = "%s is already built"; // idb
char *off_4F63F4 = "Cannot build %s"; // idb
char *off_4F63F8 = "Cannot afford %s"; // idb
char *off_4F63FC = "Build %s"; // idb
char *off_4F6400 = "Cannot afford a Hero."; // idb
char *off_4F6404 = "Cannot recruit - you already have %d Heroes."; // idb
char *off_4F6408 = "Cannot recruit - you already have a Hero in this town."; // idb
char *off_4F640C = "Recruit %s the %s"; // idb
char *off_4F6410 = "Exit Castle"; // idb
char *off_4F6414 = "Castle Options"; // idb
char *off_4F6418 = "Set garrison combat formation to 'Grouped'"; // idb
char *off_4F641C = "Set garrison combat formation to 'Spread'"; // idb
char *cLuckInfo = "{Good Luck}\n\nGood luck sometimes lets your armies get lucky attacks (double strength) in combat."; // idb
char *off_4F6424 = "{Neutral Luck}\n\nNeutral luck means your armies will never get lucky or unlucky attacks on the enemy."; // idb
char *off_4F6428 = "{Bad Luck}\n\nBad luck sometimes falls on your armies in combat, causing their attacks to only do half damage."; // idb
char *off_4F642C = "%s\n\n\nCurrent Luck Modifiers:"; // idb
char *off_4F6430 = "\nLucky Rabbit's Foot +1"; // idb
char *off_4F6434 = "\nGolden Horseshoe +1"; // idb
char *off_4F6438 = "\nGambler's Lucky Coin +1"; // idb
char *off_4F643C = "\nFour-Leaf Clover +1"; // idb
char *off_4F6440 = "\nFaerie ring visited +1"; // idb
char *off_4F6444 = "\nFountain visited +1"; // idb
char *off_4F6448 = "\nnone"; // idb
char *off_4F6450 = "\nSorceress Rainbow +2"; // idb
char *off_4F6454 = "\nIdol visited +1"; // idb
char *off_4F6458 = "\nPyramid raided -2"; // idb
char *off_4F645C = "\nBasic Luck +1"; // idb
char *off_4F6460 = "\nAdvanced Luck +2"; // idb
char *off_4F6464 = "\nExpert Luck +3"; // idb
char *off_4F6468 = "\nMasthead bonus at sea +1"; // idb
char *off_4F646C = "\nMermaid visited +1"; // idb
char *off_4F6470 = "\nBattle Garb of Anduran gives you maximum luck."; // idb
char *cSpellHelp = "View previous page"; // idb
char *off_4F6494 = "View next page"; // idb
char *off_4F6498 = "View adventure Spells"; // idb
char *off_4F649C = "View Combat Spells"; // idb
char *off_4F64A0 = "Close Spellbook"; // idb
char *off_4F64A4 = "View Spells"; // idb
char *off_4F64A8 = "Select Spell"; // idb
char *off_4F64AC = "View Combat Spells";
char *off_4F64B0 = "Your hero has %d spell points remaining"; // idb
char *speedText[] =
{
  &unk_5036FC,
  "Crawling",
  "Very slow",
  "Slow",
  "Average",
  "Fast",
  "Very Fast",
  "Ultra Fast",
  "Blazing",
  "Instant"
};
char *cArmyDetail[9] =
{
  "Attack Skill: ",
  "Defense Skill: ",
  "Shots left: ",
  "Damage: ",
  "Hit Points: ",
  "Speed: ",
  "Morale: ",
  "Luck: ",
  "Shots: "
}; // weak
char *off_4F64E4[8] =
{
  "Defense Skill: ",
  "Shots left: ",
  "Damage: ",
  "Hit Points: ",
  "Speed: ",
  "Morale: ",
  "Luck: ",
  "Shots: "
}; // weak
char *off_4F64E8[7] =
{
  "Shots left: ",
  "Damage: ",
  "Hit Points: ",
  "Speed: ",
  "Morale: ",
  "Luck: ",
  "Shots: "
}; // weak
char *off_4F64EC[6] = { "Damage: ", "Hit Points: ", "Speed: ", "Morale: ", "Luck: ", "Shots: " }; // weak
char *off_4F64F0[5] = { "Hit Points: ", "Speed: ", "Morale: ", "Luck: ", "Shots: " }; // weak
char *off_4F64F4[4] = { "Speed: ", "Morale: ", "Luck: ", "Shots: " }; // weak
char *off_4F64F8[3] = { "Morale: ", "Luck: ", "Shots: " }; // weak
char *off_4F64FC[2] = { "Luck: ", "Shots: " }; // weak
char *off_4F6500 = "Shots: "; // weak
char *cWellDetail[9] =
{
  "Attack: ",
  "Defense: ",
  "Shots: ",
  "Damg: ",
  "HP: ",
  "Speed: ",
  "Available: ",
  "\n\nSpeed:\n%s",
  "\n\nGrowth\n + %d / week"
}; // weak
char *off_4F650C[8] =
{
  "Defense: ",
  "Shots: ",
  "Damg: ",
  "HP: ",
  "Speed: ",
  "Available: ",
  "\n\nSpeed:\n%s",
  "\n\nGrowth\n + %d / week"
}; // weak
char *off_4F6514[6] =
{
  "Damg: ",
  "HP: ",
  "Speed: ",
  "Available: ",
  "\n\nSpeed:\n%s",
  "\n\nGrowth\n + %d / week"
}; // weak
char *off_4F6518[5] =
{
  "HP: ",
  "Speed: ",
  "Available: ",
  "\n\nSpeed:\n%s",
  "\n\nGrowth\n + %d / week"
}; // weak
char *off_4F6524 = "\n\nSpeed:\n%s"; // idb
char *off_4F6528 = "\n\nGrowth\n + %d / week"; // idb
char *cNewTurn = "%s, you only have %d days left to capture a town, or you will be banished from this land."; // idb
char *off_4F6544 = "%s, this is your last day to capture a town, or you will be banished from this land."; // idb
char *off_4F6548 = "Astrologers proclaim month of the %s.\n\nAll dwellings increase population."; // idb
char *off_4F654C = "Astrologers proclaim month of the %s.\n\n%s population doubles!\n\nAll dwellings increase population."; // idb
char *off_4F6550 = "Astrologers proclaim month of the PLAGUE!\n\nAll populations are halved."; // idb
char *off_4F6554 = "Astrologers proclaim week of the %s.\n\nAll dwellings increase population."; // idb
char *off_4F6558 = "Astrologers proclaim week of the %s.\n\n%s growth +5.\n\nAll dwellings increase population."; // idb
char *off_4F6560[7] =
{
  "Attack: ",
  "Defense: ",
  "Spell Power: ",
  "Knowledge: ",
  "Morale: ",
  "Luck: ",
  "Spell Points: "
}; // weak
char *off_4F6564[6] =
{
  "Defense: ",
  "Spell Power: ",
  "Knowledge: ",
  "Morale: ",
  "Luck: ",
  "Spell Points: "
}; // weak
char *off_4F6568[5] = { "Spell Power: ", "Knowledge: ", "Morale: ", "Luck: ", "Spell Points: " }; // weak
char *off_4F656C[4] = { "Knowledge: ", "Morale: ", "Luck: ", "Spell Points: " }; // weak
char *off_4F6570[3] = { "Morale: ", "Luck: ", "Spell Points: " }; // weak
char *off_4F6574[2] = { "Luck: ", "Spell Points: " }; // weak
char *off_4F6578 = "Spell Points: "; // weak
char *cViewGeneralHelp = "Stop Catapult"; // idb
char *cViewGeneralLongHelp = "{Cast Spell}\n\nCast a magical spell.  You may only cast one spell per combat round.  The round is reset when every creature has had a turn."; // idb
char *off_4F65B0 = &unk_503D8C; // idb
char *off_4F65B4 = "Move %s here."; // idb
char *off_4F65B8 = "Fly %s here."; // idb
char *off_4F65BC = "Attack %s"; // idb
char *off_4F65C0 = "Shoot %s(%d shot(s) left)"; // idb
char *off_4F65C4 = "Hero's Options"; // idb
char *off_4F65C8 = "View Opposing Hero"; // idb
char *off_4F65CC = "View %s info."; // idb
char *off_4F65D0 = "No shots left!"; // idb
char *off_4F65D4 = "Captain's Options"; // idb
char *off_4F65D8 = "View Opposing Captain"; // idb
char *off_4F65DC = "View Ballista Info"; // idb
char *cHeroLevel = "%s has gained"; // idb
char *off_4F65E4 = " a level.\n"; // idb
char *off_4F65F4 = "Skip this unit"; // idb
char *off_4F65F8 = "Auto combat"; // idb
char *off_4F65FC = "Customize system options."; // idb
char *off_4F6600 = &unk_503EDC; // idb
char *cLongCombatHelp[] =
{
  "{Wait}\n\nHave the current creature wait to take its turn until all the other creatures have gone.  The creature does not lose its turn."
};
char *cTownCommand = "Redistribute %s army"; // idb
char *off_4F6624 = "Cannot combine hero's last army"; // idb
char *off_4F6628 = "Combine %s armies"; // idb
char *off_4F662C = "Redistribute %s army"; // idb
char *off_4F6630 = "View %s"; // idb
char *off_4F6634 = "Cannot move last army to garrison."; // idb
char *off_4F6638 = "Move %s"; // idb
char *off_4F663C = "Exchange %s with %s"; // idb
char *off_4F6640 = "Exit town"; // idb
char *off_4F6644 = &unk_504164; // idb
char *off_4F664C = "Empty"; // idb
char *off_4F6650 = "Select %s"; // idb
char *off_4F6654 = "View Hero"; // idb
char *off_4F6658 = "Mage Guild"; // idb
char *off_4F665C = "Thieves' Guild"; // idb
char *off_4F6660 = "Tavern"; // idb
char *off_4F6664 = "Dock"; // idb
char *off_4F6668 = "Well"; // idb
char *off_4F666C = "Tent"; // idb
char *off_4F6670 = "Castle"; // idb
char *off_4F6674 = "Recruit %s"; // idb
char *off_4F6678 = "Statue"; // idb
char *off_4F667C = "Left Turret"; // idb
char *off_4F6680 = "Right Turret"; // idb
char *off_4F6684 = "Moat"; // idb
char *off_4F6688 = "Marketplace"; // idb
char *off_4F668C = "Captain's Quarters"; // idb
char *gHeroDefaultNames = "Lord Kilburn"; // idb
char *gNewGameHelp = "{Game Difficulty}\n\nThis lets you change the starting difficulty at which you will play.  Higher difficulty levels start you off with fewer resources, and at the higher settings, give extra resources to the computer."; // idb
char *gSetupBaudHelp = "{2400 Baud}\n\nUse a 2400 baud connection speed. \n\nNote: For a 14400 baud modem, use the 19200 baud speed.  For a 28800 baud modem, use the 38400 baud speed."; // idb
char *gSetupComPortHelp = "{COM 1}\n\nUse COM Port 1 for the modem connection."; // idb
char *gSetupDCBaudHelp = "{2400 Baud}\n\nUse a 2400 baud connection speed. \n\nNote: In general, computers with the older UART 8250 chip should use 19200 baud, and computers with the newer UART 16550 chip should use 38400 baud.  When in doubt, try slower speeds first, and if they work, then try faster speeds.  Most computers made in 1994 or later have a UART 16550 chip."; // idb
char *gSetupDCComPortHelp = "{COM 1}\n\nUse COM Port 1 for the direct connection."; // idb
char *gSetupHotSeatGameHelp = "{2 Players}\n\nPlay with 2 human players, and optionally, up to 4 additional computer players."; // idb
char *gSetupModemGameHelp = "{Host}\n\nThe host sets up the game options, chooses the number to dial, and places the call."; // idb
char *gSetupDCGameHelp = "{Host}\n\nThe host sets up the game options."; // idb
char *gSetupMultiPlayerGameHelp = "{Hot Seat}\n\nPlay a Hot Seat game, where 2 to 4 players play around the same computer, switching into the 'Hot Seat' when it is their turn."; // idb
char *xSetupCampaignGameHelp = "{Host}\n\nThe host sets up the game options.  There can only be one host per network game."; // idb
char *gSetupNetworkGame2Help = "{IPX}\n\nIPX networking is the most commonly used form of network in Windows 95.  Up to 6 players can play using IPX.  Only the Windows 95 version of Heroes II supports IPX networking."; // idb
char *xSetupStandardGameHelp = "{Standard Game}\n\nA single player game playing out a single map."; // idb
char *cBattleResults = "The enemy has surrendered!"; // idb
char *off_4F686C = "The enemy has fled!"; // idb
char *off_4F6870 = "A glorious victory!"; // idb
char *off_4F6874 = "\n\nFor valor in combat, %s receives %d experience"; // idb
char *off_4F6878 = "%s surrenders to the enemy, and departs in shame."; // idb
char *off_4F687C = "The cowardly %s flees from battle."; // idb
char *off_4F6880 = "Your forces suffer a bitter defeat, and %s abandons your cause."; // idb
char *off_4F6884 = "Your forces surrender to the enemy, and depart in shame."; // idb
char *off_4F6888 = "Your cowardly forces flee from battle."; // idb
char *off_4F688C = "Your forces suffer a bitter defeat."; // idb
char *off_4F6890 = "\n\nFor valor in combat, %s receives %d experience, and gains %d level(s)."; // idb
char *cMoraleInfo = "{Good Morale}\n\nGood morale may give your armies extra attacks in combat."; // idb
char *off_4F689C = "{Neutral Morale}\n\nNeutral morale means your armies will never be blessed with extra attacks or freeze in combat."; // idb
char *off_4F68A0 = "{Bad Morale}\n\nBad morale may cause your armies to freeze in combat."; // idb
char *off_4F68A4 = "%s\n\n\nCurrent Morale Modifiers:"; // idb
char *off_4F68AC = "\nAll %s troops +1"; // idb
char *off_4F68B0 = "\nTroops of 3 alignments -1"; // idb
char *off_4F68B4 = "\nTroops of 4 alignments -2"; // idb
char *off_4F68B8 = "\nMedal of Valor +1"; // idb
char *off_4F68BC = "\nMedal of Courage +1"; // idb
char *off_4F68C0 = "\nMedal of Honor +1"; // idb
char *off_4F68C4 = "\nMedal of Distinction +1"; // idb
char *off_4F68C8 = "\nFizbin of Misfortune -2"; // idb
char *off_4F68CC = "\nBuoy visited +1"; // idb
char *off_4F68D0 = "\nOasis visited +1"; // idb
char *off_4F68D4 = "\nTemple visited +2"; // idb
char *off_4F68D8 = "\nGraveyard robber -1"; // idb
char *off_4F68DC = "\nShipwreck robber -1"; // idb
char *off_4F68E4 = "\nnone"; // idb
char *off_4F68E8 = "\nTroops of 5 alignments -3"; // idb
char *off_4F68EC = "\nEntire unit is undead, so morale does not apply."; // idb
char *off_4F68F0 = "\nSome undead in group -1"; // idb
char *off_4F68F4 = "\nWatering hole visited +1"; // idb
char *off_4F68F8 = "\nDerelict ship robber -1"; // idb
char *off_4F68FC = "\nBarbarian Coliseum +2"; // idb
char *off_4F6900 = "\nTavern +1"; // idb
char *off_4F6904 = "\nBasic Leadership +1"; // idb
char *off_4F6908 = "\nAdvanced Leadership +2"; // idb
char *off_4F690C = "\nExpert Leadership +3"; // idb
char *off_4F6910 = "\nMasthead bonus at sea +1"; // idb
char *off_4F6914 = "\nBattle Garb of Anduran gives you maximum morale."; // idb
char *cMapSize[9] =
{
  "Small",
  "Medium",
  "Large",
  "Huge",
  "Easy",
  "Normal",
  "Hard",
  "Expert",
  "Impossible"
}; // weak
char *cDifficulty[5] = { "Easy", "Normal", "Hard", "Expert", "Impossible" }; // weak
char *musicQualityText[3] = { "MIDI", "CD Stereo w/o Opera", "CD Stereo with Opera" }; // weak
char *gSpellDesc[] =
{
  "{Fireball}\n\nCauses a giant fireball to strike the selected area, damaging all nearby creatures.",
  "{Fireblast}\n\nAn improved version of fireball, fireblast affects two hexes around the center point of the spell, rather than one.",
  "{Lightning Bolt}\n\nCauses a bolt of electrical energy to strike the selected creature.",
  "{Chain Lightning}\n\nCauses a bolt of electrical energy to strike a selected creature, then strike the nearest creature with half damage, then strike the NEXT nearest creature with half again damage, and so on, until it becomes too weak to be harmful.  Warning:  This spell can hit your own creatures!",
  "{Teleport}\n\nTeleports the creature you select to any open position on the battlefield.",
  "{Cure}\n\nRemoves all negative spells cast upon one of your units, and restores up to 5 HP per level of spell power.",
  "{Mass Cure}\n\nRemoves all negative spells cast upon your forces, and restores up to 5 HP per level of spell power, per creature.",
  "{Resurrect}\n\nResurrects creatures from a damaged or dead unit until end of combat.",
  "{Resurrect True}\n\nResurrects creatures from a damaged or dead unit permanently.",
  "{Haste}\n\nIncreases the speed of any creature by two.",
  "{Mass Haste}\n\nIncreases the speed of all of your creatures by two.",
  "{Slow}\n\nSlows target to half movement rate.",
  "{Mass Slow}\n\nSlows all enemies to half movement rate.",
  "{Blind }\n\nClouds the affected creatures' eyes, preventing them from moving.",
  "{Bless}\n\nCauses the selected creatures to inflict maximum damage.",
  "{Mass Bless}\n\nCauses all of your units to inflict maximum damage.",
  "{Stoneskin}\n\nMagically increases the defense skill of the selected creatures.",
  "{Steelskin}\n\nIncreases the defense skill of the targeted creatures.  This is an improved version of Stoneskin.",
  "{Curse}\n\nCauses the selected creatures to inflict minimum damage.",
  "{Mass Curse}\n\nCauses all enemy troops to inflict minimum damage.",
  "{Holy Word}\n\nDamages all undead in the battle.",
  "{Holy Shout}\n\nDamages all undead in the battle.  This is an improved version of Holy Word.",
  "{Anti-Magic}\n\nPrevents harmful magic against the selected creatures.",
  "{Dispel Magic}\n\nRemoves all magic spells from a single target.",
  "{Mass Dispel}\n\nRemoves all magic spells from all creatures.",
  "{Magic Arrow}\n\nCauses a magic arrow to strike the selected target.",
  "{Berzerker}\n\nCauses a creature to attack its nearest neighbor.",
  "{Armageddon}\n\nHoly terror strikes the battlefield, causing severe damage to all creatures.",
  "{Elemental Storm}\n\nMagical elements pour down on the battlefield, damaging all creatures.",
  "{Meteor Shower}\n\nA rain of rocks strikes an area of the battlefield, damaging all nearby creatures.",
  "{Paralyze}\n\nThe targeted creatures are paralyzed, unable to move or retaliate.",
  "{Hypnotize}\n\nBrings a single enemy unit under your control for one combat round if its hits are less than 25 times the caster's spell power.",
  "{Cold Ray}\n\nDrains body heat from a single enemy unit.",
  "{Cold Ring}\n\nDrains body heat from all units surrounding the center point, but not including the center point.",
  "{Disrupting Ray}\n\nReduces the defense rating of an enemy unit by three.",
  "{Death Ripple}\n\nDamages all living (non-undead) units in the battle.",
  "{Death Wave}\n\nDamages all living (non-undead) units in the battle.  This spell is an improved version of Death Ripple.",
  "{Dragon Slayer}\n\nGreatly increases a unit's attack skill vs. Dragons.",
  "{Blood Lust}\n\nIncreases a unit's attack skill.",
  "{Animate Dead}\n\n'Resurrects' creatures from a damaged or dead undead unit permanently.",
  "{Mirror Image}\n\nCreates an illusionary unit that duplicates one of your existing units.  This illusionary unit does the same damages as the original, but will vanish if it takes any damage.",
  "{Shield}\n\nHalves damage received from ranged attacks for a single unit.",
  "{Mass Shield}\n\nHalves damage received from ranged attacks for all of your units.",
  "{Summon Earth Elemental}\n\nSummons Earth Elementals to fight for your army.",
  "{Summon Air Elemental}\n\nSummons Air Elementals to fight for your army.",
  "{Summon Fire Elemental}\n\nSummons Fire Elementals to fight for your army.",
  "{Summon Water Elemental}\n\nSummons Water Elementals to fight for your army.",
  "{Earthquake}\n\nDamages castle walls.",
  "{View Mines}\n\nCauses all mines across the land to become visible.",
  "{View Resources}\n\nCauses all resources across the land to become visible.",
  "{View Artifacts}\n\nCauses all artifacts across the land to become visible.",
  "{View Towns}\n\nCauses all towns and castles across the land to become visible.",
  "{View Heroes}\n\nCauses all Heroes across the land to become visible.",
  "{View All}\n\nCauses the entire land to become visible.",
  "{Identify Hero}\n\nAllows the caster to view detailed information on enemy Heroes.",
  "{Summon Boat}\n\nSummons the nearest unoccupied, friendly boat to an adjacent shore location.  A friendly boat is one which you just built or were the most recent player to occupy.",
  "{Dimension Door}\n\nAllows the caster to magically transport to a nearby location.",
  "{Town Gate}\n\nReturns the caster to any town or castle currently owned.",
  "{Town Portal}\n\nReturns the hero to the town or castle of choice, provided it is controlled by you.",
  "{Visions}\n\n Visions predicts the likely outcome of an encounter with a neutral army camp.",
  "{Haunt}\n\nHaunts a mine you control with Ghosts.  This mine stops producing resources.  (If I can't keep it, nobody will!)",
  "{Set Earth Guardian}\n\nSets Earth Elementals to guard a mine against enemy armies.",
  "{Set Air Guardian}\n\nSets Air Elementals to guard a mine against enemy armies.",
  "{Set Fire Guardian}\n\nSets Fire Elementals to guard a mine against enemy armies.",
  "{Set Water Guardian}\n\nSets Water Elementals to guard a mine against enemy armies."
};
int dword_4F6ABC[] = { 0 }; // weak
char *gSpellNames[65] =
{
  "Fireball",
  "Fireblast",
  "Lightning Bolt",
  "Chain Lightning",
  "Teleport",
  "Cure",
  "Mass Cure",
  "Resurrect",
  "Resurrect True",
  "Haste",
  "Mass Haste",
  "Slow",
  "Mass Slow",
  "Blind ",
  "Bless",
  "Mass Bless",
  "Stoneskin",
  "Steelskin",
  "Curse",
  "Mass Curse",
  "Holy Word",
  "Holy Shout",
  "Anti-Magic",
  "Dispel Magic",
  "Mass Dispel",
  "Magic Arrow",
  "Berzerker",
  "Armageddon",
  "Elemental Storm",
  "Meteor Shower",
  "Paralyze",
  "Hypnotize",
  "Cold Ray",
  "Cold Ring",
  "Disrupting Ray",
  "Death Ripple",
  "Death Wave",
  "Dragon Slayer",
  "Blood Lust",
  "Animate Dead",
  "Mirror Image",
  "Shield",
  "Mass Shield",
  "Summon Earth Elemental",
  "Summon Air Elemental",
  "Summon Fire Elemental",
  "Summon Water Elemental",
  "Earthquake",
  "View Mines",
  "View Resources",
  "View Artifacts",
  "View Towns",
  "View Heroes",
  "View All",
  "Identify Hero",
  "Summon Boat",
  "Dimension Door",
  "Town Gate",
  "Town Portal",
  "Visions",
  "Haunt",
  "Set Earth Guardian",
  "Set Air Guardian",
  "Set Fire Guardian",
  "Set Water Guardian"
};
int secondarySkillLevels[] = { 0, 5275392, 5275400, 5275412 }; // idb
char *gSecondarySkills[25] =
{
  "Pathfinding",
  "Archery",
  "Logistics",
  "Scouting",
  "Diplomacy",
  "Navigation",
  "Leadership",
  "Wisdom",
  "Mysticism",
  "Luck",
  "Ballistics",
  "Eagle Eye",
  "Necromancy",
  "Estates",
  "Mage Guild",
  "Thieves' Guild",
  "Tavern",
  "Shipyard",
  "Well",
  "Tent",
  "Castle",
  "Statue",
  "Left Turret",
  "Right Turret",
  "Marketplace"
}; // weak
char *gNeutralBuildingNames[11] =
{
  "Mage Guild",
  "Thieves' Guild",
  "Tavern",
  "Shipyard",
  "Well",
  "Tent",
  "Castle",
  "Statue",
  "Left Turret",
  "Right Turret",
  "Marketplace"
}; // weak
char *(*off_4F6C54)[12] = &unk_508064;
char *gWellExtraNames[] =
{
  "Farm",
  "Garbage Heap",
  "Crystal Garden",
  "Waterfall",
  "Orchard",
  "Skull Pile",
  "1st Lvl Growth"
};
char *gSpecialBuildingNames[] =
{
  "Fortifications",
  "Coliseum",
  "Rainbow",
  "Dungeon",
  "Library",
  "Storm",
  "Special"
};
char *gDwellingNames[72] =
{
  "Thatched Hut",
  "Archery Range",
  "Blacksmith",
  "Armory",
  "Jousting Arena",
  "Cathedral",
  "Upg. Archery Range",
  "Upg. Blacksmith",
  "Upg. Armory",
  "Upg. Jousting Arena",
  "Upg. Cathedral",
  &unk_5081AC,
  "Hut",
  "Stick Hut",
  "Den",
  "Adobe",
  "Bridge",
  "Pyramid",
  "Upg. Stick Hut",
  &unk_5081EC,
  "Upg. Adobe",
  "Upg. Bridge",
  &unk_508208,
  &unk_50820C,
  "Treehouse",
  "Cottage",
  "Archery Range",
  "Stonehenge",
  "Fenced Meadow",
  "Red Tower",
  "Upg. Cottage",
  "Upg. Archery Range",
  "Upg. Stonehenge",
  &unk_508290,
  &unk_508294,
  &unk_508298,
  "Cave",
  "Crypt",
  "Nest",
  "Maze",
  "Swamp",
  "Green Tower",
  &unk_5082D0,
  &unk_5082D4,
  "Upg. Maze",
  &unk_5082E4,
  "Red Tower",
  "Black Tower",
  "Habitat",
  "Pen",
  "Foundry",
  "Cliff Nest",
  "Ivory Tower",
  "Cloud Castle",
  &unk_50833C,
  "Upg. Foundry",
  &unk_508350,
  "Upg. Ivory Tower",
  "Upg. Cloud Castle",
  &unk_50837C,
  "Excavation",
  "Graveyard",
  "Pyramid",
  "Mansion",
  "Mausoleum",
  "Laboratory",
  "Upg. Graveyard",
  "Upg. Pyramid",
  "Upg. Mansion",
  "Upg. Mausoleum",
  &unk_508400,
  &unk_508404
}; // weak
char *cSecSkillDesc[42] =
{
  "{Basic Pathfinding}\n\nBasic Pathfinding reduces the movement penalty for rough terrain by 25 percent.",
  "{Advanced Pathfinding}\n\nAdvanced Pathfinding reduces the movement penalty for rough terrain by 50 percent.",
  "{Expert Pathfinding}\n\nExpert Pathfinding eliminates the movement penalty for rough terrain.",
  "{Basic Archery}\n\nBasic Archery increases the damage done by range attacking creatures by 10 percent.",
  "{Advanced Archery}\n\nAdvanced Archery increases the damage done by range attacking creatures by 25 percent.",
  "{Expert Archery}\n\nExpert Archery increases the damage done by range attacking creatures by 50 percent.",
  "{Basic Logistics}\n\nBasic Logistics increases your hero's movement points by 10 percent.",
  "{Advanced Logistics}\n\nAdvanced Logistics increases your hero's movement points by 20 percent.",
  "{Expert Logistics}\n\nExpert Logistics increases your hero's movement points by 30 percent.",
  "{Basic Scouting}\n\nBasic Scouting increases your hero's viewable area by 1 square.",
  "{Advanced Scouting}\n\nAdvanced Scouting increases your hero's viewable area by 2 squares.",
  "{Expert Scouting}\n\nExpert Scouting increases your hero's viewable area by 3 squares.",
  "{Basic Diplomacy}\n\nBasic Diplomacy allows you to negotiate with monsters who are weaker than your group.  Approximately 1/4 of the creatures may offer to join you.",
  "{Advanced Diplomacy}\n\nAdvanced Diplomacy allows you to negotiate with monsters who are weaker than your group.  Approximately 1/2 of the creatures may offer to join you.",
  "{Expert Diplomacy}\n\nExpert Diplomacy allows you to negotiate with monsters who are weaker than your group.  All of the creatures may offer to join you.",
  "{Basic Navigation}\n\nBasic Navigation increases your hero's movement points over water by 1/3.",
  "{Advanced Navigation}\n\nAdvanced Navigation increases your hero's movement points over water by 2/3.",
  "{Expert Navigation}\n\nExpert Navigation doubles your hero's movement points over water.",
  "{Basic Leadership}\n\nBasic Leadership increases your hero's troops' morale by 1.",
  "{Advanced Leadership}\n\nAdvanced Leadership increases your hero's troops' morale by 2.",
  "{Expert Leadership}\n\nExpert Leadership increases your hero's troops' morale by 3.",
  "{Basic Wisdom}\n\nBasic Wisdom allows your hero to learn third level spells.",
  "{Advanced Wisdom}\n\nAdvanced Wisdom allows your hero to learn fourth level spells.",
  "{Expert Wisdom}\n\nExpert Wisdom allows your hero to learn fifth level spells.",
  "{Basic Mysticism}\n\nBasic Mysticism regenerates two of your hero's spell points per day.",
  "{Advanced Mysticism}\n\nAdvanced Mysticism regenerates three of your hero's spell points per day.",
  "{Expert Mysticism}\n\nExpert Mysticism regenerates four of your hero's spell points per day.",
  "{Basic Luck}\n\nBasic Luck increases your hero's luck by 1.",
  "{Advanced Luck}\n\nAdvanced Luck increases your hero's luck by 2.",
  "{Expert Luck}\n\nExpert Luck increases your hero's luck by 3.",
  "{Basic Ballistics}\n\nBasic Ballistics gives your hero's catapult shots a greater chance to hit and do damage to castle walls.",
  "{Advanced Ballistics}\n\nAdvanced Ballistics gives your hero's catapult an extra shot, and each shot has a greater chance to hit and do damage to castle walls.",
  "{Expert Ballistics}\n\nExpert Ballistics gives your hero's catapult an extra shot, and each shot automatically destroys any wall, except a fortified wall in a Knight town.",
  "{Basic Eagle Eye}\n\nBasic Eagle Eye gives your hero a 20 percent chance to learn any given 1st or 2nd level enemy spell used against him in a combat.",
  "{Advanced Eagle Eye}\n\nAdvanced Eagle Eye gives your hero a 30 percent chance to learn any given 3rd level spell (or below) used against him in combat.",
  "{Expert Eagle Eye}\n\nExpert Eagle Eye gives your hero a 40 percent chance to learn any given 4th level spell (or below) used against him in combat.",
  "{Basic Necromancy}\n\nBasic Necromancy allows 10 percent of the creatures killed in combat to be brought back from the dead as Skeletons.",
  "{Advanced Necromancy}\n\nAdvanced Necromancy allows 20 percent of the creatures killed in combat to be brought back from the dead as Skeletons.",
  "{Expert Necromancy}\n\nExpert Necromancy allows 30 percent of the creatures killed in combat to be brought back from the dead as Skeletons.",
  "{Small Estates}\n\nYour hero produces 100 gold pieces per turn as tax revenue from estates.",
  "{Moderate Estates}\n\nYour hero produces 250 gold pieces per turn as tax revenue from estates.",
  "{Grand Estates}\n\nYour hero produces 500 gold pieces per turn as tax revenue from estates."
}; // weak
char *cBuildingInfoNeutral = "The Mage Guild allows heroes to learn spells and replenish their spell points."; // idb
char *gBuildingInfoSpecial[] =
{
  "The Fortifications increase the toughness of the walls, increasing the number of turns it takes to knock them down.",
  "The Coliseum provides inspiring spectacles to defending troops, raising their morale by two during combat.",
  "The Rainbow increases the luck of the defending units by two.",
  "The Dungeon increases the income of the town by 500 / day.",
  "The Library increases the number of spells in the Guild by one for each level of the guild.",
  "The Storm adds +2 to the power of spells of a defending spell caster."
};
char *cDirections[9] =
{
  "northern",
  "northeastern",
  "eastern",
  "southeastern",
  "southern",
  "southwestern",
  "western",
  "northwestern",
  "central"
}; // weak
char *cRumourTerrainDescriptions[9] =
{
  "in the murky depths of the ocean.",
  "on a grassy plain.",
  "in the driven snow.",
  "in a murky swamp.",
  "buried in barren lava.",
  "under a desert drift.",
  "in the dirt.",
  "in a parched wasteland.",
  "buried on a beach."
}; // weak
char *gInterfaceTypeText[3] = { "Dynamic", "Good", "Evil" }; // weak
char *cBWMouseText[5] = { "Black & White", "Color", "Normal", "Fast", "Very Fast" }; // weak
char *combatSpeedText[3] = { "Normal", "Fast", "Very Fast" }; // weak
char *combatMiniInfoText[3] = { "None", "Spells Only", "Full" }; // weak
char *gcCommandLineHelp = "\n\n\n***Command Line Help***\n"; // idb
char *cOverviewText = "Hero/Stats"; // idb
char *cWinComError = "Communications error on function '%s'\n\nWin95 Error Code: %d\nWin95 Error Meaning: %s\n\n"; // idb
char *off_4F6FAC = "Suggested solutions:"; // idb
char *off_4F6FB0 = "\n  1) Make sure all cables are firmly connected."; // idb
char *off_4F6FB4 = "\n  2) Reboot computer."; // idb
char *off_4F6FB8 = "\n  3) Check to make sure you have the correct COM port setting in 'CONFIG'. (The 3rd button down on the screen where you choose Host or Guest.)"; // idb
char *off_4F6FBC = "\n  4) Consider lowering the BAUD rate in 'CONFIG' to 19200 or 9600."; // idb
char *cMiniViewText = "%d Units"; // idb
char *off_4F6FC4 = "%d Unit"; // idb
char *off_4F6FC8 = "Attack"; // idb
char *off_4F6FCC = "Defense"; // idb
char *off_4F6FD0 = "HP "; // idb
char *off_4F6FD4 = "Dmg"; // idb
char *off_4F6FD8 = "Mrl"; // idb
char *off_4F6FDC = "Luk"; // idb
char *off_4F6FE0 = "Shots"; // idb
char *gFileRequestHelp = "{Small Maps}\n\nView only maps of size small (36 x 36)."; // idb
char *personality_types[] = { "Warrior", "Builder", "Explorer", "Human" };
char *gArmySizeNames[27] =
{
  "Few",
  "A few",
  "a few",
  "Several",
  "Several",
  "several",
  "Pack",
  "A pack of",
  "a pack of",
  "Lots",
  "Lots of",
  "lots of",
  "Horde",
  "A Horde of",
  "a horde of",
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *severalStrings[24] =
{
  "Several",
  "Several",
  "several",
  "Pack",
  "A pack of",
  "a pack of",
  "Lots",
  "Lots of",
  "lots of",
  "Horde",
  "A Horde of",
  "a horde of",
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *packStrings[21] =
{
  "Pack",
  "A pack of",
  "a pack of",
  "Lots",
  "Lots of",
  "lots of",
  "Horde",
  "A Horde of",
  "a horde of",
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *lotsStrings[18] =
{
  "Lots",
  "Lots of",
  "lots of",
  "Horde",
  "A Horde of",
  "a horde of",
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *hordeStrings[15] =
{
  "Horde",
  "A Horde of",
  "a horde of",
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *throngStrings[12] =
{
  "Throng",
  "A Throng of",
  "a throng of",
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *swarmStrings[9] =
{
  "Swarm",
  "A Swarm of",
  "a swarm of",
  "Zounds",
  "Zounds...",
  "zounds of",
  "Legion",
  "A Legion of",
  "a legion of"
}; // weak
char *zoundsStrings[6] = { "Zounds", "Zounds...", "zounds of", "Legion", "A Legion of", "a legion of" }; // weak
char *legionStrings[3] = { "Legion", "A Legion of", "a legion of" }; // weak
char *cRandomTavernText[] = { "The truth is out there." };
char *defaultSignMessages[4] = { "See Rock City", "This space for rent", "Next sign 50 miles", "Burma shave" };
char *cCampaignAwards = "Dwarven alliance"; // idb
char *cCampaignName[10] =
{
  "Force of Arms",
  "Annexation",
  "Save the Dwarves",
  "Carator Mines",
  "Turning Point",
  "Defender",
  "The Gauntlet",
  "The Crown",
  "Corlagon's Defense",
  "Final Justice"
}; // weak
char *off_4F7134[23] =
{
  "Betrayal",
  "First Blood",
  "Barbarian Wars",
  "Necromancers",
  "Slay the Dwarves",
  "Turning Point",
  "Rebellion",
  "Dragon Master",
  "Country Lords",
  "The Crown",
  "Greater Glory",
  "Apocalypse",
  "Betrayal",
  "Roland needs you to defeat the lords near his castle to begin his war of rebellion against his brother.  They are not allied with each other, so they will spend most of their time fighting with one another.  Victory is yours when you have defeated all of their castles and heroes.",
  "The local lords refuse to swear allegiance to Roland, and must be subdued.  They are wealthy and powerful, so be prepared for a tough fight.  Capture all enemy castles to win.",
  "Your task is to defend the Dwarves against Archibald's forces.  Capture all of the enemy towns and castles to win, and be sure not to lose all of the dwarf towns at once, or the enemy will have won.",
  "You will face four allied enemies in a straightforward fight for resources and treasure.  Capture all of the enemy castles for victory.",
  "Your enemies are allied against you and start close by, so be ready to come out fighting.  You will need to own all four castles in this small valley to win.",
  "The Sorceress' guild of Noraston has requested Roland's aid against an attack from Archibald's allies.  Capture all of the enemy castles to win, and don't lose Noraston, or you'll lose the scenario.  (Hint:  There is an enemy castle on an island in the ocean.)",
  "Gather as large an army as possible and capture the enemy castle within 8 weeks.  You are opposed by only one enemy, but must travel a long way to get to the enemy castle.  Any troops you have in your army at the end of this scenario will be with you in the final battle.",
  "Find the Crown before Archibald's heroes find it.  Roland will need the Crown for the final battle.",
  "Three allied enemies stand before you and victory, including Lord Corlagon.  Roland is in a castle to the northwest, and you will lose if he falls to the enemy.  Remember that capturing Lord Corlagon will ensure that he will not fight against you in the final scenario.",
  "This is the final battle.  Both you and your enemy are armed to the teeth, and all are allied against you.  Capture Archibald to end the war!"
}; // weak
char *cCampaignDescription[10] =
{
  "Roland needs you to defeat the lords near his castle to begin his war of rebellion against his brother.  They are not allied with each other, so they will spend most of their time fighting with one another.  Victory is yours when you have defeated all of their castles and heroes.",
  "The local lords refuse to swear allegiance to Roland, and must be subdued.  They are wealthy and powerful, so be prepared for a tough fight.  Capture all enemy castles to win.",
  "Your task is to defend the Dwarves against Archibald's forces.  Capture all of the enemy towns and castles to win, and be sure not to lose all of the dwarf towns at once, or the enemy will have won.",
  "You will face four allied enemies in a straightforward fight for resources and treasure.  Capture all of the enemy castles for victory.",
  "Your enemies are allied against you and start close by, so be ready to come out fighting.  You will need to own all four castles in this small valley to win.",
  "The Sorceress' guild of Noraston has requested Roland's aid against an attack from Archibald's allies.  Capture all of the enemy castles to win, and don't lose Noraston, or you'll lose the scenario.  (Hint:  There is an enemy castle on an island in the ocean.)",
  "Gather as large an army as possible and capture the enemy castle within 8 weeks.  You are opposed by only one enemy, but must travel a long way to get to the enemy castle.  Any troops you have in your army at the end of this scenario will be with you in the final battle.",
  "Find the Crown before Archibald's heroes find it.  Roland will need the Crown for the final battle.",
  "Three allied enemies stand before you and victory, including Lord Corlagon.  Roland is in a castle to the northwest, and you will lose if he falls to the enemy.  Remember that capturing Lord Corlagon will ensure that he will not fight against you in the final scenario.",
  "This is the final battle.  Both you and your enemy are armed to the teeth, and all are allied against you.  Capture Archibald to end the war!"
}; // weak
char *off_4F7194[14] =
{
  "Switching sides leaves you with three castles against the enemy's one.  This battle will be the easiest one you will face for the rest of the war...traitor.",
  "King Archibald requires you to defeat the three enemies in this region.  They are not allied with one another, so they will spend most of their energy fighting amongst themselves.  You will win when you own all of the enemy castles and there are no more heroes left to fight.",
  "You must unify the barbarian tribes of the north by conquering them.  As in the previous mission, the enemy is not allied against you, but they have more resources at their disposal.  You will win when you own all of the enemy castles and there are no more heroes left to fight.",
  "Do-gooder wizards have taken the Necromancers' castle.  You must retake it to achieve victory.  Remember that while you start with a powerful army, you have no castle and must take one within 7 days, or lose this battle.  (Hint: The nearest castle is to the southeast.)",
  "The Dwarves need conquering before they can interfere in King Archibald's plans.  Roland's forces have more than one hero and many towns to start with, so be ready for attack from multiple directions.  You must capture all of the enemy towns and castles to claim victory.",
  "Your enemies are allied against you and start close by, so be ready to come out fighting.  You will need to own all four castles in this small valley to win.",
  "You must put down a peasant revolt led by Roland's forces.  All are allied against you, but you have Lord Corlagon, an experienced hero, to help you.  Capture all enemy castles to win.",
  "There are two enemies allied against you in this mission.  Both are well armed and seek to evict you from their island.  Avoid them and capture Dragon City to win.",
  "Your orders are to conquer the country lords that have sworn to serve Roland.  All of the enemy castles are unified against you.  Since you start without a castle, you must hurry to capture one before the end of the week.  Capture all enemy castles for victory.",
  "Find the Crown before Roland's heroes find it.  Archibald will need the Crown for the final battle with Roland.",
  "Gather as large an army as possible and capture the enemy castle within 8 weeks.  You are opposed by only one enemy, but must travel a long way to get to the enemy castle.  Any troops you have in your army at the end of this scenario will be with you in the next.",
  "This is the final battle.  Both you and your enemy are armed to the teeth, and all are allied against you.  Capture Roland to win the war, and be sure not to lose Archibald in the fight!",
  "Switching sides leaves you with three castles against the enemy's one.  This battle will be the easiest one you will face for the rest of the war...traitor.",
  "\n\n\n\n\n\n\n\n\n\n\n\n\n\n%s\nHeroes II requires a minimum of\n%dK of Extended Memory (XMS) and\n480K of Conventional Memory\n\n"
}; // weak
char *cOutOfMemory = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n%s\nHeroes II requires a minimum of\n%dK of Extended Memory (XMS) and\n480K of Conventional Memory\n\n"; // idb
char *off_4F71D4[26] =
{
  "Interlaced",
  "{OK}\n\nExit this menu.",
  "{Music}\n\nToggle ambient music level.\n\n(Note: When using CD Stereo music in DOS, the music may only be turned on or off - the level has no effect.)",
  "{Effects}\n\nToggle foreground sounds level.",
  "{Speed}\n\nChange the speed at which your heroes move on the main screen.",
  "{Music Type}\n\nChange the type of music.  MIDI music does not usually sound as good, but hurts performance less than CD Stereo.  If you use CD Stereo, you can select whether or not to have the operatic town themes play or not.\n\n(Note: Some older computers do not handle CD Stereo music well.  If you have a computer that leaves the music playing when you quit or crashes when you switch music tracks, try MIDI music.)",
  "{Show Path}\n\nToggle 'Show Path' on/off.  If 'Show Path' is on, your first click on a map location will show the path to get there, your second will start you moving. If this option is off, one click starts you moving immediately.",
  "{Enemy Speed}\n\nSets the speed that A.I. heroes move at.  You can also elect not to view A.I. movement at all.",
  "{Interface}\n\nSets what type of interface you want to use.  The default selection is a dynamic interface, which uses Evil graphics for the 3 evil heroes (Barbarian, Warlock, and Necromancer).",
  "{Video}\n\nDetermines if the video sequences play normally or in interlaced mode.  Interlaced mode runs better on slower machines, or machines with double-speed CD drives.",
  "{Mouse Cursor}\n\nToggle color cursors on/off.  Color cursors look nicer, but sometimes don't move as smoothly as black and white ones.",
  "aqua",
  "blue",
  "brown",
  "gold",
  "green",
  "orange",
  "purple",
  "red",
  "Alchemist's Tower",
  "Arena",
  "Hut of the Magi",
  "Eye of the Magi",
  "Stables",
  "Mermaid",
  "Sirens"
}; // weak
char *gSPanelHelp = "{OK}\n\nExit this menu."; // idb
char *xBarrierColor[15] =
{
  "aqua",
  "blue",
  "brown",
  "gold",
  "green",
  "orange",
  "purple",
  "red",
  "Alchemist's Tower",
  "Arena",
  "Hut of the Magi",
  "Eye of the Magi",
  "Stables",
  "Mermaid",
  "Sirens"
}; // weak
char *off_4F7220 = "Alchemist's Tower"; // idb
char *off_4F7240 = "Barrow Mounds"; // idb
SWinSetup gWinSetup[] =
{
  { 0, 100, "Build improvement:" },
  { 1, 100, "Speed" },
  { 1, 101, "Monster Info" },
  { 1, 102, "Auto Combat\nSpell Casting" },
  { 1, 103, "Grid" },
  { 1, 104, "Shadow\nCursor" },
  { 1, 105, "Shadow\nMovement" },
  { 2, 100, "Music" },
  { 2, 101, "Effects" },
  { 2, 102, "Music Type" },
  { 2, 103, "Speed" },
  { 2, 104, "Show Path" },
  { 2, 105, "Enemy Speed" },
  { 2, 106, "Interface" },
  { 2, 107, "Video" },
  { 2, 108, "Mouse Cursor" },
  { 6, 300, "Attack Skill" },
  { 6, 301, "Defense Skill" },
  { 6, 302, "Spell Power" },
  { 6, 303, "Knowledge" },
  { 7, 600, "Game Difficulty:" },
  { 7, 57, "Easy" },
  { 7, 58, "Normal" },
  { 7, 59, "Hard" },
  { 7, 60, "Expert" },
  { 7, 61, "Impossible" },
  { 7, 62, "Opponents:" },
  { 7, 84, "Class:" },
  { 9, 41, "Gold Per Day:" },
  { 12, 0, "Build a new ship:" },
  { 12, 1, "Resource cost:" },
  { 14, 800, "1st" },
  { 14, 801, "2nd" },
  { 14, 802, "3rd" },
  { 14, 803, "4th" },
  { 14, 804, "5th" }
};
int gbHeroWindShowing = 0; // weak
int gbFullCombatScreenDrawn = 1; // weak
int gbLimitedCombatUpdatePalette = 0; // weak
int gbFirstTimeThrough = 0; // weak
int gbSkipIntro = 0; // weak
int dword_4F746C = 1; // weak
int gbAllBlack = 0; // weak
int dword_4F7474 = 0; // weak
int gbDirectConnect = 0; // weak
int giForceSwitchMusic = 4294967295; // weak
int gbComputeExtent = 0; // weak
int gbSaveBiggestExtent = 0; // weak
int gbLimitToExtent = 0; // weak
int gbCurrArmyDrawn = 1; // weak
int gAdvDisposeLevel = 0; // weak
int gbRemoteOn = 0; // weak
int gbGameInitialized = 0; // weak
int giHighScoreRank = 4294967295; // weak
int giHighScoreType = 1; // weak
int gbShowHighScore = 0; // weak
int gbLowMemory = 0; // weak
int giHighMemBuffer = 5; // weak
char byte_4F74B8 = '\0'; // weak
int gbInPollSound = 0; // weak
int iCDRomErr = 0; // weak
int bEarlySetupDone = 0; // weak
int bKBDone = 0; // weak
int bForceCheckTimeEvent = 0; // weak
char byte_50CE04[] = { '\0', '\0', '\0', '\0' }; // idb
char aArchibald[10] = "Archibald"; // weak
char byte_50CFB4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50CFB8[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 IMHotSpots[] = { 481 }; // weak
__int16 word_50CFEA[] = { 185 }; // weak
__int16 word_50CFEC[] = { 83 }; // weak
__int16 word_50CFEE[] = { 96 }; // weak
int lastIMHoverID = 4294967295; // weak
char byte_50D014[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D018[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D030[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_50D2C0 = 0; // weak
char byte_50D7B0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D7B4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D7B8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D7BC[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_50D804 = 3262; // weak
char byte_50D8C4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50D8F0[] = { '\0', '\0', '\0', '\0' }; // idb
int bInShutDown = 0; // weak
__int16 word_50D8F8 = 3828; // weak
__int16 word_50D970 = 3937; // weak
__int16 word_50D9D4 = 3991; // weak
int gbInMemError = 0; // weak
int iShingleAnimFrame = 0; // weak
__int16 word_50DFC8 = 5285; // weak
char byte_50DFF8[] = { '\0', '\0', '\0', '\0' }; // idb
char unk_50E028[] = { '\0' };
char unk_50E03C[] = { '\0' };
_UNKNOWN unk_50E054; // weak
_UNKNOWN unk_50E07C; // weak
char byte_50E094[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50E0A8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50E1C0[4] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_50E34C = 1664; // weak
__int16 word_50E3D8 = 1736; // weak
__int16 word_50E530 = 1794; // weak
__int16 word_50E5E0 = 1867; // weak
char aAttacker[9] = "Attacker"; // weak
char byte_50E6F8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50E800[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50E8D0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_50E9A0[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_50EA80 = 0; // weak
int dword_50EA84 = 0; // weak
int giLimitUpdMinX = 4294967295; // idb
int iLastScrollTime = 0; // weak
int iSandAnim = 0; // weak
int giLastHourGlassUpdateTime = 0; // weak
int TrigX = 0; // idb
int iCurBottomView = 0; // weak
int giBottomViewPlayer = 4294967295; // weak
__int64 iCurHourGlassPhase = 4294967296i64; // weak
int gbForceUpdate = 0; // weak
__int16 word_50EC80 = 296; // weak
int dword_50ECB0 = 0; // weak
char monAnimDrawFrame[] = { '\0' }; // weak
char aAlreadyVisit_0[18] = "(already visited)"; // weak
char aAlreadyVisit_1[18] = "(already visited)"; // weak
char aAlreadyVisit_2[18] = "(already visited)"; // weak
char aAlreadyVisit_3[18] = "(already visited)"; // weak
char aAlreadyVisit_4[18] = "(already visited)"; // weak
char aAlreadyVisit_5[18] = "(already visited)"; // weak
char aAlreadyVisit_6[18] = "(already visited)"; // weak
char aAlreadyVisit_7[18] = "(already visited)"; // weak
char aNoDigging[13] = "(no digging)"; // weak
char aAlreadyVisit_8[18] = "(already visited)"; // weak
char aAlreadyVisited[18] = "(already visited)"; // weak
int iLastSandAnimTime = 0; // weak
int iLastNewSandAnimTime = 0; // weak
__int16 word_50F424 = 4586; // weak
__int16 word_50F4C4 = 4681; // weak
__int16 word_50F544 = 4784; // weak
__int16 word_50F5A0 = 4861; // weak
__int16 word_50F600 = 5008; // weak
__int16 word_50F6E8 = 5372; // weak
__int16 word_50F7C0 = 5698; // weak
int giFrameCount = 0; // weak
__int16 word_50FAE8 = 8270; // weak
int dword_50FED8 = 0; // weak
int bSmackSound = 0; // weak
icon *brotherIcon = NULL; // idb
wchar_t a1cc[5] = { 215u, 49u, 230u, 150u, 217u }; // weak
icon *backImage = NULL; // idb
char SmackOptions[8] = "H2INTRO"; // weak
char byte_50FF34[] = { '\x01' }; // weak
char byte_50FF35[] = { '\x01' }; // weak
char byte_50FF36[] = { '\0' }; // weak
char byte_50FF37[] = { '\0' }; // weak
char byte_50FF38[] = { '\0' }; // weak
__int16 word_50FF39 = 0; // weak
__int16 word_50FF3B = 0; // weak
int bTesting = 0; // weak
int smk1 = 0; // weak
int smk2 = 0; // weak
int gbNewGameDialogOver = 1; // weak
int NGKPcursorFlashOn = 1; // weak
char byte_5110D4[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_51117C = 319; // weak
char byte_5111B0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5111F4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5111F8[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_511304 = 635; // weak
char byte_5113C4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51140C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_511410[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_511444[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_511448 = 1615; // weak
char byte_511520[] = { '\0', '\0', '\0', '\0' }; // idb
char aCastle[7] = "castle"; // weak
char aCastle_0[7] = "castle"; // weak
int bHostFound = 0; // weak
SOCKET sd_dg = 4294967295u; // idb
int iWSLastMsgNumHumanPlayers = 1; // weak
int iWSAttempts = 0; // weak
int iWSNextTickCount = 0; // weak
int iWSWaitForHostStatus = 0; // weak
__int16 word_511798 = 61; // weak
char byte_511B78[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_511BEC = 248; // weak
__int16 word_511C30 = 279; // weak
__int16 word_511CBC = 359; // weak
__int16 word_511CE0 = 413; // weak
heroWindow *overWin = NULL; // idb
void *textWidgetDynamic = NULL; // idb
void *iconWidgetDynamic = NULL; // idb
int giOverviewType = 0; // weak
int giOverviewTop[] = { 0 }; // weak
widget *OVScrollKnob = NULL; // idb
__int16 word_511E74 = 116; // weak
char aMinicapt_icn[13] = "minicapt.icn"; // weak
__int16 word_5120D0 = 698; // weak
__int16 word_512108 = 778; // weak
int iBaudBits = 8; // weak
int inescape = 0; // weak
int newpacket = 0; // weak
int packetlen = 0; // weak
__int16 word_5124C8 = 20; // weak
__int16 word_5124EC = 26; // weak
float durationBenefit[] =
{
   0.0,
   0.33000001,
   0.55000001,
   0.72000003,
   0.85000002,
   0.94999999,
   1.03,
   1.08,
   1.12,
   1.15,
   1.1799999
};
float heuristicModifierForDuration[] =
{
   0.0,
   0.5,
   0.64999998,
   0.77999997,
   0.85000002,
   0.94999999,
   1.03,
   1.08,
   1.12,
   1.15,
   1.1799999
}; // idb
int bEnteringTown = 0; // weak
int iInOrderCtr = 0; // weak
int iCurLastID = 0; // weak
int dword_512578 = 4294967295; // weak
char GameMode = '\0'; // weak
int lLastHeartbeatSend = 0; // weak
int gbInRemoteMain = 0; // weak
int gbInRemoteCleanup = 0; // weak
int iIDCtr = 0; // weak
int iTimesDropped = 0; // weak
char gbInNetSetup = '\0'; // weak
int bUseDirectPlay = 0; // weak
int bUseWinsock = 0; // weak
char bInTimeoutFail = '\0'; // weak
__int16 word_512728 = 716; // weak
__int16 word_512748 = 757; // weak
char byte_5128E8[4] = { '\0', '\0', '\0', '\0' }; // idb
int dword_512930[] = { 113 }; // weak
int dword_512934[] = { 310 }; // weak
int dword_512A30[] = { 8 }; // weak
_UNKNOWN xCampaignChoices; // weak
char byte_512C20[] = { '\0' }; // weak
char byte_512CE8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_512EAC = '\0'; // weak
char byte_512EB0 = '\0'; // weak
char byte_512EB4 = '\0'; // weak
char byte_512EB8 = '\0'; // weak
char byte_512EBC = '\xFF'; // weak
char byte_512EC0 = '\0'; // weak
char byte_512EC4[] = { '\0' }; // weak
char *off_512ED0 = "Empire Too "; // idb
wchar_t *off_512ED4 = &asc_512EE4; // weak
__int16 word_512EE8 = 105; // weak
__int16 word_512F24 = 169; // weak
__int16 word_512F7C = 226; // weak
__int16 word_512F9C = 245; // weak
__int16 word_512FBC = 412; // weak
__int16 word_512FF8 = 534; // weak
__int16 word_513030 = 710; // weak
__int16 word_513050 = 780; // weak
int bInHighMoraleBonus = 0; // weak
int giSeed = 1; // weak
char byte_513078[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51307C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5130C4[] = { '\0', '\0', '\0', '\0' }; // idb
char aSmalclod_icn[13] = "smalclod.icn"; // weak
char aPerish[7] = "perish"; // weak
char aGarrisonDoes[14] = "Garrison does"; // weak
char aGarrisonDoes_0[14] = "Garrison does"; // weak
int bSecondAttack = 0; // weak
char aPerish_0[7] = "perish"; // weak
char aDo[3] = "do"; // weak
char aDo_0[3] = "do"; // weak
char aPerish_1[7] = "perish"; // weak
char aCreatures[10] = "creatures"; // weak
char aDo_1[3] = "do"; // weak
char aDo_2[3] = "do"; // weak
char aDestroy[8] = "destroy"; // weak
char aPerish_2[7] = "perish"; // weak
char aDo_3[3] = "do"; // weak
char aDo_4[3] = "do"; // weak
HWND hwndApp = NULL; // idb
HMENU hmnuApp = NULL; // idb
HANDLE gEventHandle = NULL; // idb
int lLastGTimerTickCount = 0; // weak
int lLastGetMessage = 0; // weak
int lLastAilServe = 0; // weak
int gbNoDialogMenusOn = 0; // weak
char byte_514A64[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514A68[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514A6C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514A70[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514B94[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514B98[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514B9C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514BA0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514CDC[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_514CE0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_515240[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51525C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_515894[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_515898[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51589C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5158A0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5158A4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5158A8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5158AC[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516134[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516138[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51613C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516140[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516144[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516148[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_516540[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_517684[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_517688[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_5184CC[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_518548[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51854C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_518550[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_518974[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_518AFC[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_518B64 = 5724; // weak
__int16 word_518BF4 = 5825; // weak
char aTown_1[5] = "Town"; // weak
__int16 word_518CBC = 6099; // weak
__int16 word_518CF8 = 6212; // weak
int gbNoShowCombat = 0; // weak
hero *gpHVHero = NULL;
heroWindow *gheroWin = NULL; // idb
char byte_518DDC[] =
{
  'A',
  'r',
  'e',
  ' ',
  'y',
  'o',
  'u',
  ' ',
  's',
  'u',
  'r',
  'e',
  ' ',
  'y',
  'o',
  'u',
  ' ',
  'w',
  'a',
  'n',
  't',
  ' ',
  't',
  'o',
  ' ',
  'd',
  'i',
  's',
  'm',
  'i',
  's',
  's',
  ' ',
  't',
  'h',
  'i',
  's',
  ' ',
  'H',
  'e',
  'r',
  'o'
}; // idb
__int16 experienceForLevelTable[] = { 63, 0, 1000, 2000, 3200, 4500, 6000, 7700, 9000, 11000, 13200, 15500, 18500 };
char byte_519218[] = { '\x03' }; // weak
char byte_519219[] = { '\x03' }; // weak
char byte_51921A[] = { '\x05' }; // weak
char byte_51921B[] = { '\x05' }; // weak
char byte_51921C[] = { '\x06' }; // weak
char byte_51921D[] = { '\x06' }; // weak
char byte_51921E[] = { '\b' }; // weak
char byte_51921F[] = { '\x05' }; // weak
char byte_519220[] = { '\x02' }; // weak
char byte_519221[] = { '\x03' }; // weak
char byte_519222[] = { '\x02' }; // weak
char byte_519223[] = { '\x02' }; // weak
signed int giViewWorldScale = 6; // idb
int giViewWorldScaleLookup = 1; // weak
int gbInViewWorld = 0; // weak
int gbWinGAttached = 1; // weak
int gbDDrawAttached = 0; // weak
int giGraphicsType = 1; // weak
int Orientation = 1; // weak
LOGPALETTE LogicalPalette = { 768u, 256u, { { 0u, 0u, 0u, 0u } } };
char byte_5196D4[] = { '\0' }; // weak
char byte_5196D5[] = { '\0' }; // weak
char byte_5196D6[] = { '\0' }; // weak
char byte_5196D7[] = { '\0' }; // weak
bitmap *lpInitWin = NULL;
int dword_519704 = 0; // weak
int gbWinGraphBusy = 0; // weak
int (__cdecl *lpDirectDrawCreate)(_DWORD, _DWORD, _DWORD) = NULL; // weak
LPDIRECTDRAW *lpDD = NULL;
int lpDDSPrimary = 0; // weak
int lpDDSOne = 0; // weak
int lpClipper = 0; // weak
int lpDDPal = 0; // idb
__int16 word_519724 = 45; // weak
__int16 word_519748 = 67; // weak
__int16 word_51976C = 87; // weak
__int16 word_5197D0 = 110; // weak
int iBusyRetry = 0; // weak
__int16 word_519858 = 157; // weak
__int16 word_519950 = 296; // weak
__int16 word_519974 = 368; // weak
__int16 word_519998 = 393; // weak
int bInDDSD = 0; // weak
const __int16 fiveHundred = 500;
__int16 word_519D70 = 526; // weak
__int16 word_519DB4 = 572; // weak
HDC hdcImage = NULL; // idb
HGDIOBJ gbmOldMonoBitmap = NULL; // idb
HPALETTE hpalApp = NULL; // idb
HMODULE hDDrawLibrary = NULL; // idb
__int16 word_519F88 = 1247; // weak
int castX = 0; // idb
int castY = 0; // idb
int bInTeleportGetDest = 0; // weak
int indexToCastOn = 4294967295; // weak
char uRedBeam[] = { 'w' }; // weak
char uRainbow[] = { '' }; // weak
void *gyModify = NULL; // idb
__int16 word_51A404 = 2524; // weak
__int16 twoFiveEightSeven = 2587; // weak
char aResists[8] = "resists"; // weak
char *off_51A720 = "{Original Campaign}\n\nEither Roland's or Archibald's campaign from the original Heroes of Might and Magic II."; // idb
char *off_51A730 = "{Original Map}\n\nSelects a game from the original Heroes of Might and Magic II."; // idb
char *xCampaignAwards = "Elven alliance"; // idb
char *xScenarioName[20] =
{
  "Uprising",
  "Island of Chaos",
  "Arrow's Flight",
  "The Abyss",
  "The Giant's Pass",
  "Aurora Borealis",
  "Betrayal's End",
  "Corruption's Heart",
  "Conquer and Unify",
  "Border Towns",
  "The Wayward Son",
  "Crazy Uncle Ivan",
  "The Southern War",
  "Ivory Gates",
  "The Elven Lands",
  "The Epic Battle",
  "The Shrouded Isles",
  "The Eternal Scrolls",
  "Power's End",
  "Fount of Wizardry"
}; // weak
char *xScenarioDescription[20] =
{
  "Subdue the unruly local lords in order to provide the Empire with facilities to operate in this region.",
  "Eliminate all oposition in this area. Then the first piece of the artifact will be yours.",
  "The sorceresses to the northeast are rebelling! For the good of the empire you must quash their feeble uprising on your way to the mountains.",
  "Having prepared for your arrival, Kraeger has arranged for a force of necromancers to thwart your quest. You must capture the castle of Scabsdale before the first day of the third week, or the Necromancers will be too strong for you.",
  "The barbarian despot in this area is, as yet, ignorant of your presence. Quickly, build up your forces before you are discovered and attacked! Secure the region by subduing all enemy forces.",
  "The Empire is weak in this region. You will be unable to completely subdue all forces in this area, so take what you can before reprisal strikes. Remember, your true goal is to claim the Helmet of Anduran.",
  "For the good of the Empire, eliminate Kraeger.",
  "At last, you have the opportunity and the facilities to rid the Empire of the necromancer's evil. Eradicate them completely, and you will be sung as a hero for all time.",
  "Conquer and unite all the enemy tribes. Don't lose the hero Jarkonas, the forefather of all descendants.",
  "Your rival, the kingdom of Harondale, is attacking weak towns on your border! Recover from their first strike and crush them completely!",
  "Find your wayward son Joseph who is rumored to be living in the desolate lands. Do it before the first day of the third month or it will be of no help to your family.",
  "Rescue your crazy uncle Ivan. Find him before the first day of the fourth month or it will be no help to your kingdom.",
  "Destroy the barbarians who are attacking the southern border of your kingdom! Recover your fallen towns, and then invade the jungle kingdom. Leave no enemy standing.",
  "Retake the castle of Ivory Gates, which has fallen due to treachery.",
  "Gain the favor of the elves. They will not allow trees to be chopped down, so we will send you wood every 2 weeks. You must complete your mission before the first day of the seventh month, or the kingdom will surely fall.",
  "This is the final battle against your rival kingdom of Harondale. Eliminate everyone, and don't lose the hero Jarkonas VI.",
  "Your mission is to vanquish the warring mages in the magical Shrouded Isles. The completion of this task will give you a fighting chance against your rivals.",
  "The location of the great library has been discovered! You must make your way to it, and reclaim the city of Chronos in which it lies.",
  "Find the Orb of negation, which is said to be buried in this land. There are clues inscribed on stone obelisks which will help lead you to your prize. Find the Orb before the first day of the sixth month, or your rivals will surely have gotten to the fount before you.",
  "You must take control of the castle of Magic, where the fount of wizardry lies. Do this and your victory will be supreme."
}; // weak
char *xShortCampaignNames[2] = { "POL", &off_51BE6C }; // weak
char *xHSCampaignNames = "Price of Loyalty"; // idb
char *xRecruitEmpty = "This burial site is deathly still."; // idb
char *xRecruitBuy = "Restless spirits of long dead warriors seeking their final resting place offer to join you in hopes of finding peace.  Do you wish to recruit ghosts?"; // idb
char *xNecromancerShrine = "Shrine"; // idb
char *xNecromancerShrineDesc = "The Shrine increases the necromancy skill of all your necromancers by 10 percent."; // idb
char *xStableText = "The head groom approaches you and speaks, \"You already have a fine horse, and have no inexperienced cavalry which might make use of our trained war horses.\""; // idb
char *off_51A8D8[15] =
{
  "Joseph",
  "Joseph II",
  "Joseph III",
  "Joseph IV",
  "Joseph V",
  "Joseph VI",
  "Uncle Ivan",
  "Ivan II",
  "Ivan III",
  "Ivan IV",
  "Ivan V",
  "Ivan VI",
  "Bas.",
  "Adv.",
  "Exp."
}; // weak
char *off_51A8E0[13] =
{
  "Joseph III",
  "Joseph IV",
  "Joseph V",
  "Joseph VI",
  "Uncle Ivan",
  "Ivan II",
  "Ivan III",
  "Ivan IV",
  "Ivan V",
  "Ivan VI",
  "Bas.",
  "Adv.",
  "Exp."
}; // weak
char *off_51A8F0[9] =
{
  "Uncle Ivan",
  "Ivan II",
  "Ivan III",
  "Ivan IV",
  "Ivan V",
  "Ivan VI",
  "Bas.",
  "Adv.",
  "Exp."
}; // weak
char *off_51A904[4] = { "Ivan VI", "Bas.", "Adv.", "Exp." }; // weak
char *xPasswordStrings[211] =
{
  "Advance",
  "Advent",
  "Adventure",
  "Animate",
  "Archer",
  "Arena",
  "Armor",
  "Army",
  "Arrow",
  "Artifact",
  "Attraction",
  "Backstab",
  "Barbarian",
  "Baron",
  "Battle",
  "Berserk",
  "Blacksmith",
  "Blade",
  "Bless",
  "Blind",
  "Boots",
  "Breastplate",
  "Buckler",
  "Captain",
  "Castle",
  "Catapult",
  "Cathedral",
  "Cauldron",
  "Cavalry",
  "Centaur",
  "Champion",
  "Charm",
  "Cloak",
  "Coffin",
  "Command",
  "Control",
  "Cower",
  "Create",
  "Crest",
  "Crossbow",
  "Crush",
  "Crypt",
  "Crystal",
  "Curse",
  "Cyclops",
  "Dagger",
  "Damage",
  "Darkness",
  "Death",
  "Decimate",
  "Decisive",
  "Defeat",
  "Demon",
  "Desert",
  "Destroy",
  "Devastation",
  "Deviate",
  "Dimension",
  "Diplomacy",
  "Discover",
  "Disruption",
  "Distance",
  "Dragon",
  "Druid",
  "Dungeon",
  "Dwarven",
  "Dwelling",
  "Earthquake",
  "Elemental",
  "Elixir",
  "Elven",
  "Emblem",
  "Engage",
  "Enrage",
  "Entertain",
  "Evil",
  "Fear",
  "Fire",
  "Fireball",
  "Flail",
  "Flask",
  "Flood",
  "Follower",
  "Fortunate",
  "Fortune",
  "Gargoyle",
  "Gauntlets",
  "Gems",
  "Genie",
  "Ghost",
  "Giants",
  "Gloves",
  "Goblin",
  "Gold",
  "Golem",
  "Graveyard",
  "Gravity",
  "Guard",
  "Guild",
  "Halberd",
  "Hammer",
  "Harp",
  "Haunt",
  "Helm",
  "Heroic",
  "Honor",
  "Hope",
  "Horde",
  "Horse",
  "Horseshoe",
  "Hydra",
  "Identify",
  "Ignite",
  "Illusion",
  "Invisible",
  "Kingdom",
  "Knife",
  "Knighthood",
  "Lance",
  "Lantern",
  "Leadership",
  "Leather",
  "Library",
  "Liege",
  "Life",
  "Lightning",
  "Lord",
  "Mace",
  "Mage",
  "Magic",
  "Majesty",
  "Malevolent",
  "Medusa",
  "Meteor",
  "Might",
  "Minotaur",
  "Minutemen",
  "Missile",
  "Monster",
  "Mummy",
  "Navigation",
  "Necromancy",
  "Noho",
  "Ogre",
  "Ointment",
  "Paladin",
  "Paralyze",
  "Parry",
  "Partake",
  "Phoenix",
  "Portal",
  "Potion",
  "Pouch",
  "Powder",
  "Power",
  "Pyramid",
  "Quest",
  "Rainbow",
  "Ranger",
  "Recruit",
  "Rescue",
  "Resurrect",
  "Retreat",
  "Righteous",
  "Robe",
  "Rogue",
  "Rope",
  "Scabbard",
  "Scarab",
  "Scimitar",
  "Scroll",
  "Shield",
  "Shout",
  "Shrine",
  "Siege",
  "Skeleton",
  "Skill",
  "Slayer",
  "Sling",
  "Sorceress",
  "Speed",
  "Staff",
  "Statue",
  "Storm",
  "Sulfur",
  "Summon",
  "Swamp",
  "Sword",
  "Telepathy",
  "Terror",
  "Thunder",
  "Torch",
  "Tower",
  "Travesty",
  "Treaty",
  "Trident",
  "Troll",
  "Unicorn",
  "Vampire",
  "Venom",
  "Victory",
  "Volcano",
  "Vulnerable",
  "Wand",
  "Warfare",
  "Warlock",
  "Weapon",
  "Wings",
  "Wizardry",
  "Wolf",
  "Zombie"
}; // weak
char xNetHasOldPlayers = '\0'; // weak
void xShrineBuildingCost; // idb
__int16 trackXY[] = { 39 }; // weak
__int16 word_51D0F2[] = { 336 }; // weak
heroWindow *campWin = NULL; // idb
char byte_51D1EC[] = { '\0', '\0', '\0', '\0' }; // idb
char Str1[] = "origdata.bin"; // idb
HREDBOOK dword_51D4A8 = NULL; // idb
int dword_51D58C = 0; // weak
int giShowComputerRoute = 0; // weak
void *gaiLiveChanceOfPos = NULL; // idb
void *gaiHeroStrategicRVOfPos = NULL; // idb
void *gaiHeroEventStratRVOfPos = NULL; // idb
void *gaiTurnValueOfMine = NULL; // idb
void *gaiEnemyHeroReachable = NULL; // idb
hero *gpCurAIHero = NULL; // idb
int gfAttackHumanBonus = 1073741824; // weak
int gfAttackComputerBonus = 1061997773; // weak
int iLastFrameRateTimer = 0; // weak
int dword_51D768 = 0; // weak
int dword_51D7EC = 1; // weak
__int16 word_51D840 = 7046; // weak
__int16 word_51D8D0 = 7062; // weak
int gbDoModemConfig = 0; // weak
char byte_51DA2C[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51DA5C[] = { '\0', '\0', '\0', '\0' }; // idb
__int16 word_51DF7C = 199; // weak
__int16 word_51DFF8 = 247; // weak
__int16 word_51E050 = 310; // weak
int bMoveSoundMade = 1; // weak
int dword_51E188[] = { 2 }; // weak
int giStepDelay[] = { 20 }; // weak
int hOldWalkSample = 0; // weak
int hNewWalkSample = 0; // weak
int EveryOther = 0; // weak
int dword_51E1C4[] = { 0 }; // weak
__int16 word_51E33C = 1505; // weak
char byte_51E390[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E394[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E398[] = { '\0', '\0', '\0', '\0' }; // idb
char possiblyAlwaysBlankCombatMessage1[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E3A0[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E3A4[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E3A8[] = { '\0', '\0', '\0', '\0' }; // idb
char byte_51E3B4[] = { '\0', '\0', '\0', '\0' }; // idb
int bGridWasShowing = 0; // weak
int gbInDrawSmallView = 0; // weak
int iCombatCycleFrame = 0; // weak
int gbEveryOtherCycle = 1; // weak
int iCycle1Count = 0; // weak
int iCycle2Count = 0; // weak
int iCycle3Count = 0; // weak
int iDialogNestCount = 0; // weak
int iMemEntries = 0; // idb
void *gpMemEntry = NULL; // idb
_UNKNOWN giTotalMemAllocated; // weak
int iLastSeed = 135621123; // weak
char byte_51E6E4[] = { 'A' }; // weak
_UNKNOWN unk_51E728; // weak
_UNKNOWN unk_51EAC8; // weak
_UNKNOWN unk_51EAD4; // weak
_UNKNOWN unk_51EB30; // weak
__int16 word_51EFC8 = 10; // weak
__int16 word_51EFD8 = 10; // weak
_UNKNOWN unk_51F104; // weak
_UNKNOWN unk_51F118; // weak
char byte_51F138[4] = { '\0', '\0', '\0', '\0' }; // idb
HMDIDRIVER hMDI = NULL; // idb
int CurrentMidiFile = 4294967295; // weak
char bGotMidi[] = { '\0' }; // weak
int iSaveCtr = 0; // weak
char unk_51F1F8[] = { '\0' };
int iMouseOffset[] = { 0 }; // weak
CursorDimension iMouseSize[] =
{
  { '\x0F', '\x15' },
  { '\x16', '\x15' },
  { '\x18', '\x14' },
  { '\x18', '\x18' },
  { '\x1E', '\x19' },
  { '\x18', '\x18' },
  { '\x18', '\x18' },
  { '\x13', '\x17' },
  { '\x0F', '\x14' },
  { '\x1E', '\x1E' },
  { ' ', '\x1A' },
  { '\x1F', '\x19' },
  { '\x1E', '\x19' },
  { '\x18', '\x18' },
  { '\x16', '\x15' },
  { '\x1F', '\x1F' },
  { ' ', '\x1A' },
  { '\x1F', '\x19' },
  { '\x1E', '\x19' },
  { '\x18', '\x18' },
  { '\x16', '\x15' },
  { '\x1F', '\x1F' },
  { ' ', '\x1A' },
  { ' ', '\x19' },
  { ' ', '\x19' },
  { '\x1B', '\x18' },
  { '\x19', '\x16' },
  { '\x1F', '\x1F' },
  { '\x18', '\x18' },
  { '\x1E', '\x19' },
  { '\x1E', '\x19' },
  { ' ', '\x19' },
  { '\b', ' ' },
  { '\x18', '\x18' },
  { ' ', '\b' },
  { '\x18', '\x18' },
  { '\b', ' ' },
  { '\x18', '\x18' },
  { ' ', '\b' },
  { '\x18', '\x18' },
  { '\x0F', '\x15' },
  { '\x14', '\x14' },
  { '\x12', '\x17' },
  { '\x15', '\x18' },
  { '\x18', '\x18' },
  { '\x12', '\x16' },
  { '\v', '\x12' },
  { '\r', '\r' },
  { '\x16', '\x16' },
  { '\x1F', '\x0E' },
  { '\x16', '\x16' },
  { '\x16', '\x16' },
  { '\x1F', '\x0E' },
  { '\x16', '\x16' },
  { '\x0E', '\x1F' },
  { '\x0E', '\x1F' },
  { '\x1C', '\x10' },
  { '\x14', '\x14' },
  { '\x1C', '!' },
  { '\x19', '(' },
  { '%', ')' },
  { '\x19', '\x1D' },
  { '4', '\x1D' },
  { '\x18', '\'' },
  { '\x1D', '#' },
  { '-', '\x1C' },
  { '4', '(' },
  { '!', '*' },
  { '\"', '\x1F' },
  { ' ', '#' },
  { ' ', '#' },
  { '+', '!' },
  { '\"', '&' },
  { '%', '#' },
  { '\x1B', '\x1E' },
  { '\x1D', '\x1B' },
  { ' ', '\x17' },
  { '\x17', '$' },
  { '\x1E', '$' },
  { '\x15', '!' },
  { '\x1B', '&' },
  { '\x1C', '\"' },
  { '$', '\"' },
  { 'B', ')' },
  { '&', '#' },
  { ';', ')' },
  { '6', '\'' },
  { '#', '*' },
  { '\x1E', '\"' },
  { '-', ')' },
  { '\'', '\"' },
  { '\x1D', '+' },
  { '\x19', '#' },
  { '\'', '#' },
  { '/', '%' },
  { '3', '\r' }
};
CursorHotspot iHotSpot[] =
{
  { '\x02', '\x03' },
  { '\x02', '\x03' },
  { '\f', '\v' },
  { '\f', '\r' },
  { '\x0F', '\v' },
  { '\n', '\n' },
  { '\f', '\r' },
  { '\t', '\f' },
  { '\a', '\t' },
  { '\x0F', '\x0F' },
  { '\x0F', '\v' },
  { '\n', '\n' },
  { '\f', '\r' },
  { '\t', '\f' },
  { '\a', '\t' },
  { '\x0F', '\x0F' },
  { '\x0F', '\v' },
  { '\n', '\n' },
  { '\f', '\r' },
  { '\t', '\f' },
  { '\a', '\t' },
  { '\x0F', '\x0F' },
  { '\x0F', '\v' },
  { '\n', '\n' },
  { '\f', '\r' },
  { '\t', '\f' },
  { '\a', '\t' },
  { '\x0F', '\x0F' },
  { '\f', '\f' },
  { '\f', '\f' },
  { '\f', '\f' },
  { '\f', '\f' },
  { '\x03', '\0' },
  { '\x17', '\0' },
  { '\x1F', '\x04' },
  { '\x17', '\x17' },
  { '\x03', '\x1F' },
  { '\0', '\x18' },
  { '\0', '\x05' },
  { '\0', '\0' },
  { '\x02', '\x03' },
  { '\n', '\t' },
  { '\t', '\v' },
  { '\n', '\v' },
  { '\f', '\f' },
  { '\n', '\f' },
  { '\x05', '\b' },
  { '\x01', '\x01' },
  { '\x15', '\x01' },
  { '\x1E', '\a' },
  { '\x15', '\x15' },
  { '\x01', '\x15' },
  { '\x01', '\a' },
  { '\x01', '\x01' },
  { '\a', '\x01' },
  { '\a', '\x1E' },
  { '\x0E', '\b' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' },
  { '\xFF', '\xFF' }
};
int gbInSetPointer = 0; // weak
int bInNewMouseUpdate = 0; // weak
char byte_51F6B4[4] = { '\0', '\0', '\0', '\0' }; // idb
int bLastMouseOffscreen = 0; // weak
int bLastOnscreenMouseColor = 0; // weak
int bInCheckChangeCursor = 0; // weak
int crc32Table[] = { 0 }; // weak
void *words = NULL; // idb
void *zptr = NULL; // idb
void *ftab = NULL; // idb
void *block = NULL; // idb
void *ll = NULL; // idb
int dword_520628 = 7826990; // weak
int dword_520650 = 4403784; // weak
int dword_520654 = 7826990; // weak
int dword_520664 = 4403784; // weak
int dword_520668 = 7826990; // weak
int dword_5206C4 = 0; // weak
int dword_5206C8 = 0; // weak
int iLeftRightSave = 0; // weak
int __fastflag = 0; // weak
int _adjust_fdiv = 0; // weak
LCID Locale = 0u; // idb
UINT __lc_codepage = 0u; // idb
unsigned __int16 *_pctype = (unsigned __int16 *)0x520FEA;
void *off_520FE4 = (void *)0x520FEA; // weak
unsigned __int16 _ctype[] = { 0u, 32u }; // idb
int __mb_cur_max = 1; // idb
FILE _iob[] = ;
_UNKNOWN unk_521848; // weak
_UNKNOWN unk_5218A8; // weak
_UNKNOWN unk_521AF0; // weak
_UNKNOWN unk_521B08; // weak
void *dword_521B34 = NULL; // idb
void *dword_521B38 = NULL; // idb
LCID word_521B4C = 0u; // idb
struct waveformat_tag Format = { 0u, 0u, 0u, 0u, 0u }; // idb
__int16 word_522B2E = 0; // weak
__int16 iLastVolume[32] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int numRedbookTrackSlots = 0; // weak
void giNetPosToDCOPos; // idb
int dword_522B7C[] = { 0 }; // weak
SOCKET g_lpGuid = 0u; // idb
int iMaxSession = 0; // weak
int iSessionToTry = 0; // weak
int lSessions[] = { 0 }; // weak
int giHostAcceptStatus = 0; // weak
HMENU hmnuRecruitSave = NULL; // idb
heroWindow *casWin = NULL; // idb
char castleSlotsUse[] = { '\0' }; // weak
int fGutterTravelLength = 0; // weak
int fGutterMinY = 0; // weak
int iMaxListSize = 0; // weak
int fTradingPostEfficiency = 0; // weak
int bLeftDenominated = 0; // weak
int leftResource; // weak
int iMaxUnitsToTrade; // weak
int tpX; // idb
int tpY; // idb
int bTradeMade; // weak
int qtyToTrade; // weak
int iTradeRatio; // weak
int rightResource; // weak
int bIsMarketPlace; // weak
heroWindow *tpWindow; // idb
widget *tradeKnob; // idb
int iViewArmyNumTroops; // weak
int gbUpgradeArmy; // weak
SMonFrameInfo sViewArmyMonFrameInfo;
char byte_522CA5[]; // idb
int dword_522CE2; // weak
char byte_522D39; // weak
char byte_522DB5[451]; // idb
int viewArmyFacingWIPXMod; // weak
int iViewArmyUpgradeToType; // weak
int gbAllowUpgrade; // weak
__int16 giUARadius; // weak
__int16 viewArmyBaseY; // idb
__int16 viewArmyBaseX; // idb
__int16 word_522FA0[]; // weak
hero *viewSpellsHero; // idb
__int16 giUABaseX; // weak
__int16 giUABaseY; // weak
int iViewArmyFrame; // weak
int gbDismissArmy; // weak
int iViewArmyType; // weak
char gcCurMapName[]; // idb
int giEndSequence; // weak
heroWindow *pNormalDialogWindow; // idb
char giSetupGameType; // weak
int gbFunctionComplete; // weak
void bSaveMusicPosition; // idb
char byte_52302B; // weak
char byte_52302C; // weak
char byte_52302D; // weak
char byte_52302E; // weak
char byte_52302F; // weak
char byte_523030; // weak
char byte_523031; // weak
char byte_523032; // weak
char byte_52303C; // weak
char byte_52304A; // weak
struct SAMPLE2 NULL_SAMPLE2; // weak
mouseManager *gpMouseManager;
char gText[];
int gGameCommand; // weak
int giTCPHostStatus; // weak
int giTCPNumPlayers; // weak
icon *gBuyBuildIcons; // idb
void puzzlePiecesRemoved; // idb
int giHeroScreenSrcIndex; // weak
int iCombatControlNetPos; // idb
int dword_523434; // weak
advManager *gpAdvManager;
int giMonthTypeExtra;
int gCurLoadedSpellEffect;
int gbInCampaign;
int giWeekType;
char *EXPANSION_AGGREGATE_NAME; // idb
char gbCombatSurrender; // weak
char cExpAggPathName[]; // idb
char gcTCPAddress[]; // idb
char *DEFAULT_AGGREGATE_NAME; // idb
int iLastMsgNumHumanPlayers; // weak
int bFreshSave; // weak
char cPlayerNames[6][21];
void sMapChangeQueue; // idb
int dword_523667; // weak
int gbHitEvent; // weak
int gbTextEntryEscaped; // weak
int gbThisNetGotAdventureControl; // weak
int iMPExtendedType; // weak
int giCurWatchPlayer; // weak
int giTCPType; // weak
heroWindowManager *gpWindowManager;
searchArray *gpSearchArray;
icon *gCurLoadedSpellIcon; // idb
char gFullMapName[]; // idb
__int16 giBottomViewResource; // idb
int gbWaitForRemoteReceive; // weak
int bSpecialHideCursor; // weak
int giWeekTypeExtra;
int giThisNetPos; // idb
resourceManager *gpResourceManager;
int gbInNewGameSetup; // weak
int gpPhilAI; // idb
int gbNoSound; // weak
char gbSetupGamePosToRealGamePos[]; // weak
char gcWinText[]; // idb
int giBottomViewOverride; // weak
char bMusicIsLooping[5];
char byte_524065; // weak
char byte_524066; // weak
char byte_524067; // weak
char byte_524068; // weak
char byte_524069; // weak
char byte_52406A; // weak
char byte_52406B; // weak
char byte_52406C; // weak
char byte_52406D; // weak
char byte_52406E; // weak
char byte_52406F; // weak
char byte_524070; // weak
char byte_524071; // weak
char byte_524072; // weak
char byte_524076; // weak
char byte_524078; // weak
char byte_52407C; // weak
char byte_52408A; // weak
char byte_52408B; // weak
int giShowIntro; // weak
heroWindow *heroWin; // idb
int iMaxMapExtra;
int gpSoundManager; // weak
baseManager *gpHighScoreManager; // idb
char gLastFilename[]; // idb
char gbRetreatWin; // weak
int gMapX; // weak
int gMapY; // weak
combatManager *gpCombatManager; // idb
char gcColorToSetupPos[]; // weak
int giResType1; // weak
palette *gpBufferPalette;
int giResType2; // weak
palette *gPalette;
int giOverviewReturnAction; // weak
char cNetBoxLine[]; // idb
char cAggPathName[]; // idb
BYTE gcRegAppPath; // idb
int giThisGamePos; // weak
int giMaxExtentX; // weak
int giMaxExtentY; // weak
int gbBlackoutPlayer; // weak
char gMapName[]; // idb
int giWaitType; // weak
inputManager *gpInputManager;
signed __int8 gbThisNetHumanPlayer[];
int giCurTempMobility; // weak
int iMPBaseType; // weak
game *gpGame;
int giTotalHighMem; // weak
void **ppMapExtra;
int giResExtra1; // weak
void gbIAmGreatest; // idb
int giResExtra2; // weak
int giLimitPlayer; // weak
int giBottomViewOverrideEndTime; // weak
signed __int8 gbGamePosToNetPos[];
int gbMoveShown; // weak
icon *gSystemIcons; // idb
int giScore; // weak
int giOverviewReturnActionExtra; // idb
char gbCampaignSideChoice[]; // idb
armyGroup *gpMonGroup;
int giSeedingValid; // weak
townManager *gpTownManager;
char gcCommandLine[];
int giFullySeeded; // weak
int gbHumanPlayer[6];
char gcTCPName[]; // idb
BYTE gConfig;
BYTE walkSpeed;
BYTE Data;
BYTE soundVolume;
BYTE shouldAutosave;
BYTE showRoute;
BYTE blackoutComputer;
BOOL bMenu;
BYTE firstMapOffset;
BYTE currentMapOffset;
BYTE showObjectBoxes;
BYTE editorScreenAnimation;
BYTE editorPaletteCycling;
BYTE showCombatGrid;
BYTE showCombatMouseHex;
LONG combatShadeLevel;
BYTE combatArmyInfoLevel;
BYTE evilInterfaceUsage;
_UNKNOWN unk_5248BC; // weak
_UNKNOWN unk_5248C9; // weak
char byte_5248D6; // weak
char byte_5248D7; // weak
BYTE useCDMusic;
BYTE modemInitString;
BYTE modemComPort;
BYTE directConnectComPort;
BYTE modemBaudRate;
BYTE directConnectBaudRate;
BYTE uniqueSystemID;
BYTE useOpera;
BYTE quickCombatLevel;
int giCombatSpeed;
BYTE autoCombatUseSpells;
BYTE slowVideo;
char byte_52497A[]; // idb
char byte_524987[]; // idb
char byte_524994[]; // idb
char byte_5249A1[]; // idb
char byte_5249AE[]; // idb
char byte_5249BB[]; // idb
BYTE networkDefaultName;
int giBottomViewResourceQty; // weak
__int16 *pwSizeOfMapExtra;
int giMinExtentX; // idb
int giMinExtentY; // idb
char gcBottomViewText[]; // idb
executive *gpExec;
int bDoColorCycle; // weak
int gCurSpellEffectFrame; // idb
int gbRemoteGameOpen; // weak
DWORD giCurWindowsStyleFlags; // idb
int giMonthType;
void giMapChangeCtr; // idb
BYTE gcRegCDRomPath; // idb
int gbTCPFirstTime; // weak
int giCurGeneral; // weak
int glTimers;
int animTimer; // idb
int dword_524BF0; // weak
int dword_524BF8; // weak
int globalSoundUpdateTimer; // weak
int timer2; // weak
int timer1; // weak
int nextCombatAnimationTime; // weak
int bShowIt; // weak
char gArmyEffected[2][20];
char cNetBoxColor; // weak
char byte_524C41; // weak
char byte_524C42; // weak
char byte_524C43; // weak
Spell giNextActionExtra; // idb
char iTransferArtifactsInfo[]; // weak
int gbThisNetHasControl; // weak
__int16 giSkeletonsCreated; // idb
int giNextActionGridIndex2; // idb
int bSkeletonsShown; // weak
int gbWhichAnimationPlaying; // weak
char iTransferArtifacts[]; // weak
int giWinCmbtFrame; // weak
int iCurTransferArtifact; // weak
int dword_524C90; // weak
int giNextActionGridIndex; // idb
int giNextAction; // idb
int iMaxTransferArtifacts; // weak
int giSurrenderCost; // weak
int word_524CAC; // idb
int iLastAnimFrame; // weak
int giFrameStep; // weak
int dword_524CD4; // weak
int dword_524CDC; // weak
int dword_524CE0; // weak
int dword_524CE4; // weak
int spriteIdx; // idb
int idx; // idb
int dword_524CF0; // weak
int y; // idb
int dword_524CF8; // weak
int dword_524CFC; // weak
mapCell *currentlyDrawnMapTile;
int dword_524D04; // weak
int dword_524D08; // weak
int dword_524D0C; // weak
int dword_524D10; // idb
int dword_524D14; // weak
int giLimitUpdMaxX; // weak
int giLimitUpdMaxY; // weak
int bPrefsChanged; // weak
int dword_524D24; // weak
int giTownPortalChoice; // weak
int dword_524D2C; // weak
void bComboDraw; // idb
char byte_524D31[]; // weak
char byte_524D3E[]; // weak
char byte_524DA1; // weak
char byte_524DB3; // weak
char byte_524DC5; // weak
int dword_524E74; // weak
int giLimitUpdMinY; // idb
int dword_524E7C; // weak
heroWindow *cPanel; // idb
int dword_524EA0; // weak
heroWindow *townPortalWin; // idb
int dword_524EA8; // weak
mapCellExtra *currentlyDrawingMapCellExtra;
char cArmySizeName[]; // idb
int dword_524EBC; // weak
char bSmackNum; // weak
int gbPlayedThrough; // weak
char smksum[8]; // idb
int dword_524ED0; // weak
int dword_524EE4; // weak
int dword_524EE8; // weak
char byte_524F14; // weak
char bMainDone; // weak
int gbLastFramePlayed; // weak
int NGKPcursorIndex; // idb
int gbNewGameShadowHidden; // weak
char *cTextReceivedBuffer; // idb
char *dword_524F2C; // idb
char *dword_524F30; // idb
char *cNGKPCore; // idb
icon *NGKPBkg; // idb
char *cNGKPDisplay; // idb
int iRc; // weak
struct in_addr gIn_addrIP; // idb
struct WSAData wsadata; // idb
sockaddr saddr_loc;
__int16 word_5250E2; // weak
int dword_5250E4; // weak
WORD wVer; // idb
char cWSTextBuffer[]; // idb
int giOverviewItems[]; // weak
int dword_52520C; // weak
int iLastDynamicTop; // weak
int iLastDynamicType; // weak
int textWidgetTitle[]; // weak
int iOverviewItems; // weak
heroWindow *arenaWinPtr; // idb
int skillWidget[]; // weak
int choice; // weak
_UNKNOWN numbuf; // weak
char cModemCommand[]; // idb
int localstage; // weak
int oldsec; // weak
int iLastDialPos; // weak
int stime; // weak
char remoteidstr[]; // idb
int inque; // weak
int dword_5252AC; // weak
char GUIMRresp[]; // idb
int GUIMRrespptr; // weak
int remotestage; // weak
int iModemCommandPos; // weak
int iLastActionTime; // weak
int GUIMRc; // weak
int WFDCStage; // weak
void GUIMRresponse; // idb
char byte_526329; // weak
int outque; // weak
int dword_52636C; // weak
char idstr[]; // idb
int dword_526B78; // weak
int a3; // idb
int dword_526B80; // weak
int dword_526B84; // weak
int dword_526B88; // idb
int dword_526B8C; // weak
int dword_526B90; // weak
int dword_526B94; // weak
int dword_526B98; // weak
int dword_526B9C; // weak
char bIsMoatSlowed[]; // idb
int dword_526C18; // weak
void *Src; // idb
int giCurrSpellGroup; // weak
int dword_526C28; // weak
int dword_526C2C; // idb
char byte_526C30[]; // weak
int dword_526C38; // idb
int dword_526C3C; // idb
int dword_526C44; // idb
int dword_526C48; // weak
int dword_526C4C; // idb
int dword_526C50; // idb
char byte_526C58; // weak
char byte_526C59; // weak
__int16 word_526C5A; // weak
char byte_526C5C; // weak
char byte_526C5D; // weak
char byte_526C5E; // weak
char byte_526C5F; // weak
char byte_526C60; // weak
int dword_526C64; // idb
int dword_526C68; // weak
int dword_526C6C; // idb
int dword_526C70; // weak
char byte_526C78[]; // weak
int dword_526C80; // weak
int dword_526C84; // weak
int dword_526C88; // idb
int dword_526C8C; // idb
int dword_526C90; // weak
char dword_526C94[]; // idb
int dword_526C98; // weak
int dword_526C9C; // idb
int dword_526CA0; // weak
int dword_526CA4; // weak
int dword_526CA8; // weak
char dword_526CAC[]; // idb
signed int dword_526CB0; // idb
int dword_526CB4; // weak
void gsThisNetPlayerInfo; // idb
_UNKNOWN unk_526CBC; // weak
char byte_526CD1; // weak
char byte_526CD2; // weak
char byte_526CD3; // weak
char byte_526CD4; // weak
void gsNetPlayerInfo; // idb
char byte_526CFA[]; // weak
char byte_526CFB[]; // weak
char byte_526CFC[]; // weak
char gbUseDiffCompression; // weak
int lLastHeartbeatReceive[]; // weak
int dword_526DB4[]; // weak
char packet[]; // idb
char byte_526DC9; // weak
char byte_526DCB; // weak
__int16 word_526DCC; // weak
char byte_526DD1; // weak
int bGotGameType; // weak
char gbUseRegularCompression; // weak
int iInOrder[]; // weak
char sndBuf; // weak
int dword_527109; // weak
char byte_52710D; // weak
char byte_52710E; // weak
__int16 word_52710F; // weak
void PacketSend; // idb
char byte_527219; // weak
char byte_52721A; // weak
char byte_52721B; // weak
__int16 word_52721C; // weak
char rcvBufIn[]; // idb
int dword_527329; // weak
char byte_52732D; // weak
char byte_52732E; // weak
int rcvBuf[];
void iLastIds; // idb
void rcvBufOut; // idb
_UNKNOWN unk_527808; // weak
HANDLE hObject; // idb
HANDLE hHandle; // idb
_UNKNOWN unk_527838; // weak
void byte_527840; // idb
_UNKNOWN unk_527848; // weak
void unk_527850; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
char Dest[4096]; // idb
void byte_52F868; // idb
char byte_52F869[]; // weak
char byte_52F86A[]; // weak
char byte_52F86B[]; // weak
int dword_52F86C[]; // weak
__int16 word_52F870[]; // weak
int dword_52F894[]; // weak
char byte_52F898[]; // weak
char byte_52F899[]; // weak
int dword_52F8A4[]; // weak
_NCB pncb;
char byte_52FA2A; // weak
char byte_52FA2B; // weak
int dword_52FA2C; // weak
__int16 word_52FA30; // weak
char byte_52FA58; // weak
char byte_52FA59; // weak
_BYTE dword_52FA68[112]; // idb
struct _RTL_CRITICAL_SECTION stru_52FAD8; // idb
int bCPrefsChanged; // weak
heroWindow *CSPanel; // idb
int bMouseWasVis; // weak
int gbGenieHalf; // weak
struct tagRECT rcTemp; // idb
int lTemp; // weak
int iMainWinScreenHeight; // idb
int iTempX; // idb
int iTempY; // idb
HINSTANCE hInstApp; // idb
byte bProcessMessage[1024];
HMENU *hmnuCurrent;
int iMainWinScreenWidth; // idb
int iOrigHeroViewID; // weak
int gbNoDismiss; // weak
icon *pVWLetters; // idb
int iVWWhatToDraw; // weak
int iVWDrawAllObjs; // weak
int iVWDrawAllTerrains; // weak
icon *pVWGround; // idb
int iVWXPixelOffset; // weak
int iVWYPixelOffset; // weak
icon *pVWFlags; // idb
icon *pVWMisc; // idb
int iVWMapOriginX; // weak
int iVWMapOriginY; // weak
int iVWCenterOffset; // weak
int iVWViewableCells; // weak
struct tagRECT Rect; // idb
void dword_52FF80; // idb
int dword_52FFA4; // weak
int screenImage; // weak
int dword_52FFF4; // weak
int dword_52FFF8; // weak
__int16 word_52FFFC; // weak
__int16 word_52FFFE; // weak
int dword_530000; // weak
int dword_530004; // weak
int dword_530010; // weak
int dword_530014; // weak
PALETTEENTRY redBlueSwappedGlobalPaletteEntries[];
char byte_5303F0[]; // idb
char byte_5303F1[]; // idb
char byte_5303F2[]; // idb
char byte_5303F3[]; // idb
int dword_530418; // weak
int dword_530420; // weak
int dword_530424; // weak
int dword_530428; // weak
int dword_53042C; // weak
struct tagRECT rc; // idb
int dword_530434; // weak
int dword_530438; // weak
int dword_53043C; // weak
int lPaintStart; // weak
signed int errorCode; // idb
bool xIsExpansionMap;
void xCampaign; // idb
int dword_530454; // weak
char byte_53045C[]; // idb
char byte_530464[]; // idb
char byte_530487[]; // idb
int dword_530493; // weak
heroWindow *dword_530497; // idb
int dword_53049B; // weak
char xIsPlayingExpansionCampaign; // weak
int xPasswordStringsIndex[]; // idb
int xLastChoice; // weak
int xTheSpell; // weak
int iCampaignTrackType; // weak
int bCampaignViewOnly; // weak
int iCurViewSide; // weak
int iCurViewMap; // weak
int dword_5304E0; // weak
int dword_5304E8[]; // idb
int fReduceFactor; // weak
int dword_5305C4; // weak
_UNKNOWN unk_5305C8; // weak
int dword_5305CC; // weak
int giCurPlayer;
int dword_5305D8[]; // idb
int dword_5305DC[]; // idb
char giBuildBoat[]; // idb
playerData *gpCurPlayer;
int giCurAIHeroLuck; // weak
int fBerserkFactor; // weak
int giCurAIHeroMorale; // weak
int dword_5306E0; // weak
char giBuildBoatStuffTurn[]; // idb
char giCurWatchPlayerBit; // weak
int costTemp; // idb
float flt_530714[]; // idb
float gafAITurnCostResource[]; // idb
float flt_53071C; // weak
float flt_530720; // weak
float flt_530724; // weak
float flt_530728; // weak
float flt_53072C; // weak
float flt_530730; // weak
int iAlphaMale; // weak
searchArray SVSearchArray; // idb
int gbTroopReload; // weak
int giCurTurn; // weak
int bHeroBuiltThisTurn; // weak
char giCurPlayerBit; // weak
__int16 gaiHeroLiveChance[]; // weak
int gbBerserk; // weak
int gbReduceByBerserk; // weak
int gbReduceByReload; // weak
char giBuildShipyard[]; // weak
int dword_532CE0; // weak
int giMaxHeroesForThisPlayer; // weak
int dword_532CE8; // weak
int dword_532CEC; // weak
int dword_532CF0[]; // weak
int dword_532CF8[]; // weak
int dword_532D40[]; // weak
int dword_532D48[]; // weak
int S1cursorFrameCount; // weak
int S1cursorBaseFrame; // weak
_BYTE sMapChangeLastFew[44]; // idb
int S1cursorDirection; // weak
int S1cursorCycle; // weak
int S1cursorTurning; // weak
void gCyclePal; // idb
int dword_532E54; // weak
int bDataEntryTime; // weak
int inBoxY; // weak
int inBoxX; // weak
void *DataEntryWin; // idb
char *cDEDest; // idb
int dword_532E70; // weak
int iDEMaxLen; // weak
int dword_532E78; // weak
MIDIWrap *pMIDIWrap[];
HSEQUENCE hSequence;
__int32 lastPositionZ[];
int lastAggZ[]; // idb
int dword_5330B0; // weak
BITMAP bmpAndMask;
int dword_5330BC[]; // weak
int dword_5330C0[]; // weak
int dword_5330C4[]; // weak
__int16 word_5330C8[]; // weak
__int16 word_5330CA[]; // weak
int dword_5330CC[]; // weak
HCURSOR hMouseCursor;
int dword_533B38; // weak
int dword_533B3C; // weak
HBITMAP hbmpAndMask[];
void *cColorBits[96];
ICONINFO IconInfo[];
struct tagPOINT retrieveVirtualCursorCoordinates_lppoint; // idb
LPVOID cAndBits[];
int dword_534748; // weak
struct tagPOINT Point; // idb
int iLastBWOnScreenCheck; // weak
int dword_53475C; // weak
int dword_534760; // weak
int dword_534764; // weak
int dword_534768; // weak
int dword_53476C; // weak
int dword_534770; // weak
int dword_534774; // weak
char byte_534778; // weak
int dword_53477C; // weak
int dword_534780; // weak
int dword_534784; // weak
int dword_534788; // weak
int dword_53478C; // weak
int dword_534790; // weak
int dword_534794; // weak
int dword_534798; // weak
int lastPP; // weak
int last; // weak
int bytesIn; // weak
int bitsOutstanding; // weak
_UNKNOWN bogusModel; // weak
int bytesOut; // weak
int outputHandleJustInCase; // weak
int bigD; // weak
int bigL; // weak
int bigR; // weak
char outName[]; // idb
char inName[]; // idb
char *progName; // idb
int dword_5357FC; // weak
_UNKNOWN models; // weak
_UNKNOWN unk_535C24; // weak
_UNKNOWN unk_536048; // weak
_UNKNOWN unk_53646C; // weak
_UNKNOWN unk_536890; // weak
_UNKNOWN unk_536CB4; // weak
_UNKNOWN unk_5370D8; // weak
_UNKNOWN unk_5374FC; // weak
int veryVerbose; // weak
int bsInUse; // weak
int globalCrc; // weak
int origPtr; // weak
int blockSize100k; // weak
_UNKNOWN unk_537938; // weak
int dword_537948; // weak
int dword_53794C; // weak
int bitmapColorSubstRectI; // weak
unsigned __int8 *bitmapColorSubstRectPixel;
int bitmapColorSubstRectJ; // weak
int blitI; // weak
unsigned __int8 *bitmapColorSubstRectNextRow;
int blitFromRow; // weak
int blitToRow; // weak
int dword_53796C; // weak
IconEntry *rasterizeRightAlignedHeader;
int rasterizeRightAlignedLastColX; // weak
int dword_537978; // weak
int rasterizeRightAlignedSecondColX; // weak
int rasterizeRightTopY; // weak
int dword_537984; // weak
int dword_537988; // weak
int rasterizeRightLastColX; // weak
int dword_537990; // weak
int dword_537994; // weak
int rasterizeRightFirstByte; // weak
int dword_53799C; // weak
int dword_5379A0; // weak
int dword_5379A4; // weak
char byte_5379A8; // weak
int rasterizeRightCurPixel; // weak
int dword_5379B0; // weak
int dword_5379B4; // weak
int dword_5379B8; // weak
int dword_5379BC; // weak
char byte_5379C0; // weak
int dword_5379C4; // weak
int dword_5379C8; // weak
int dword_5379CC; // weak
int dword_5379D0; // weak
int dword_5379D4; // weak
int dword_5379D8; // weak
int dword_5379DC; // weak
int dword_5379E0; // weak
int dword_5379E4; // weak
int dword_5379E8; // weak
int dword_5379EC; // weak
unsigned __int8 *dword_5379F0;
int dword_5379F4; // weak
int dword_5379F8; // weak
int dword_5379FC; // weak
int dword_537A00; // weak
int dword_537A04; // weak
int dword_537A08; // weak
int dword_537A0C; // weak
int dword_537A10; // weak
int dword_537A14; // weak
int dword_537A18; // weak
int dword_537A1C; // weak
int dword_537A20; // weak
int dword_537A24; // weak
int dword_537A28; // weak
int dword_537A2C; // weak
int dword_537A30; // weak
int dword_537A34; // weak
int dword_537A38; // weak
int dword_537A3C; // weak
int dword_537A40; // weak
int dword_537A44; // weak
int dword_537A48; // weak
int dword_537A90; // weak
int dword_537A94; // weak
IconEntry *dword_537A98;
int dword_537A9C; // weak
int dword_537AA0; // weak
int dword_537AA4; // weak
int dword_537AA8; // weak
int dword_537AAC; // weak
int dword_537AB0; // weak
int dword_537AB4; // weak
int dword_537AB8; // weak
int dword_537ABC; // weak
int dword_537AC0; // weak
int dword_537AC4; // weak
int dword_537AC8; // weak
int dword_537ACC; // weak
int dword_537AD0; // weak
char byte_537AD4; // weak
int dword_537AD8; // weak
int dword_537ADC; // weak
int dword_537AE0; // weak
int dword_537AE4; // weak
int dword_537AE8; // weak
int dword_537AEC; // weak
int dword_537AF0; // weak
int dword_537AF4; // weak
int dword_537AF8; // weak
int dword_537AFC; // weak
int dword_537B00; // weak
int dword_537B04; // weak
int dword_537B08; // weak
int dword_537B0C; // weak
int dword_537B10; // weak
int dword_537B14; // weak
char byte_537B18; // weak
int dword_537B1C; // weak
int dword_537B20; // weak
int dword_537B24; // weak
int dword_537B28; // weak
int dword_537B2C; // weak
int dword_537B30; // weak
int dword_537B34; // weak
char byte_537B38; // weak
int dword_537B3C; // weak
int dword_537B40; // weak
int dword_537B44; // weak
int dword_537B48; // weak
int dword_537B4C; // weak
int dword_537B50; // weak
int dword_537B54; // weak
int dword_537B58; // weak
int dword_537B5C; // weak
int dword_537B60; // weak
int dword_537B64; // weak
int dword_537B68; // weak
int dword_537B6C; // weak
int dword_537B70; // weak
int dword_537B74; // weak
int dword_537B78; // weak
int dword_537B7C; // weak
int dword_537B80; // weak
int dword_537B84; // weak
int __piob; // weak
size_t _nstream; // idb
int __pioinfo[]; // weak


//----- (00401000) --------------------------------------------------------
bool __thiscall army::CanFit(army *this, int hex, int mayShiftTwoHexers, int *rearHex)
{
  bool result; // eax@6
  int secondHex; // [sp+10h] [bp-8h]@11
  int othSecondHex; // [sp+10h] [bp-8h]@23
  hexcell *tile; // [sp+14h] [bp-4h]@1

  tile = 0;
  if ( rearHex )
    *rearHex = hex;
  if ( ValidHex(hex) && hex % 13 && hex % 13 != 12 )
  {
    if ( gpCombatManager->combatGrid[hex].unitOwner != -1 || gpCombatManager->combatGrid[hex].isBlocked )
    {
      result = 0;
    }
    else if ( this->creature.creature_flags & TWO_HEXER )
    {
      secondHex = army::GetAdjacentCellIndex(this, hex, (unsigned int)(this->facingRight - 1) < 1 ? 1 : 4);
      if ( ValidHex(secondHex) && secondHex % 13 && secondHex % 13 != 12 )
        tile = &gpCombatManager->combatGrid[secondHex];
      if ( !ValidHex(secondHex)
        || tile->unitOwner != -1
        && (tile->unitOwner != gpCombatManager->activeStackOwner || tile->stackIdx != gpCombatManager->activeStack)
        || tile->isBlocked )
      {
        if ( mayShiftTwoHexers )
        {
          othSecondHex = army::GetAdjacentCellIndex(this, hex, (unsigned int)(this->facingRight - 1) < 1 ? 4 : 1);
          if ( ValidHex(othSecondHex) )
          {
            if ( gpCombatManager->combatGrid[othSecondHex].unitOwner != -1
              && (gpCombatManager->combatGrid[othSecondHex].unitOwner != gpCombatManager->activeStackOwner
               || gpCombatManager->combatGrid[othSecondHex].stackIdx != gpCombatManager->activeStack)
              || gpCombatManager->combatGrid[othSecondHex].isBlocked )
            {
              result = 0;
            }
            else
            {
              if ( rearHex )
                *rearHex = othSecondHex;
              result = 1;
            }
          }
          else
          {
            result = 0;
          }
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004012C0) --------------------------------------------------------
signed int __thiscall army::ValidFlight(army *this, int hex, int flag)
{
  signed int result; // eax@2
  int i; // [sp+10h] [bp-34h]@33
  int rearHex; // [sp+14h] [bp-30h]@30
  int neighbor; // [sp+18h] [bp-2Ch]@17
  int neighborIdx; // [sp+1Ch] [bp-28h]@17
  int mask; // [sp+20h] [bp-24h]@15
  army *target; // [sp+2Ch] [bp-18h]@10
  signed int nextNeighborIdx; // [sp+30h] [bp-14h]@29
  int a1; // [sp+34h] [bp-10h]@29
  int targHex; // [sp+3Ch] [bp-8h]@11
  int targMask; // [sp+40h] [bp-4h]@20

  if ( ValidHex(hex) )
  {
    if ( this->targetOwner >= 0 && this->targetOwner <= 1 && this->targetStackIdx >= 0 && this->targetStackIdx <= 19 )
    {
      target = &gpCombatManager->creatures[this->targetOwner][this->targetStackIdx];
      if ( flag )
        targHex = hex;
      else
        targHex = target->occupiedHex;
      if ( ValidHex(targHex) )
      {
        for ( mask = army::GetAttackMask(this, this->occupiedHex, 0, -1); mask != 255; mask |= 1 << neighbor )
        {
          neighbor = army::GetBestDirection(this->occupiedHex, targHex, mask);
          if ( army::ValidAttack(this, this->occupiedHex, neighbor, 0, -1, &neighborIdx) )
          {
            this->targetNeighborIdx = neighbor;
            this->targetHex = this->occupiedHex;
            return 1;
          }
        }
        targMask = 0;
        if ( target->creature.creature_flags & TWO_HEXER && !flag )
        {
          if ( target->facingRight == 1 )
            ++targHex;
          else
            --targHex;
          if ( target->facingRight == 1 )
            targMask = 16;
          else
            targMask = 2;
        }
        while ( targMask != 63 )
        {
          nextNeighborIdx = army::GetBestDirection(targHex, this->occupiedHex, targMask);
          a1 = army::GetAdjacentCellIndex(this, targHex, nextNeighborIdx);
          if ( ValidHex(a1) && army::CanFit(this, a1, 1 - flag, &rearHex) )
          {
            this->targetHex = rearHex;
            if ( this->creature.creature_flags & TWO_HEXER )
            {
              mask = ~army::GetAttackMask(this, this->targetHex, 0, -1);
              for ( i = 0; i < 8; ++i )
              {
                if ( (1 << i) & mask )
                  this->targetNeighborIdx = i;
              }
            }
            else
            {
              this->targetNeighborIdx = OppositeDirection(nextNeighborIdx);
            }
            return 1;
          }
          targMask |= 1 << nextNeighborIdx;
        }
        if ( target->creature.creature_flags & 1 && !flag )
        {
          if ( target->facingRight == 1 )
            --targHex;
          else
            ++targHex;
          if ( target->facingRight == 1 )
            targMask = 2;
          else
            targMask = 16;
          while ( targMask != 63 )
          {
            nextNeighborIdx = army::GetBestDirection(targHex, this->occupiedHex, targMask);
            a1 = army::GetAdjacentCellIndex(this, targHex, nextNeighborIdx);
            if ( ValidHex(a1) && army::CanFit(this, a1, 0, 0) )
            {
              this->targetHex = a1;
              this->targetNeighborIdx = army::GetBestDirection(this->targetHex, targHex, 0);
              return 1;
            }
            targMask |= 1 << nextNeighborIdx;
          }
        }
        result = 0;
      }
      else
      {
        result = 0;
      }
    }
    else if ( army::CanFit(this, hex, 0, 0) )
    {
      this->targetHex = hex;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004016D0) --------------------------------------------------------
signed int __thiscall army::FlyTo(int this)
{
  return army::FlyTo((void *)this, *(_DWORD *)(this + 98));
}

//----- (00401700) --------------------------------------------------------
signed int __thiscall army::FlyTo(army *this, signed int hexIdx)
{
  signed int result; // eax@2
  int v3; // ST98_4@19
  signed int v5; // [sp+64h] [bp-70h]@76
  signed int v6; // [sp+68h] [bp-6Ch]@47
  int v7; // [sp+6Ch] [bp-68h]@21
  int v8; // [sp+70h] [bp-64h]@24
  int offsetY; // [sp+74h] [bp-60h]@47
  signed int v10; // [sp+78h] [bp-5Ch]@47
  int offsetX; // [sp+7Ch] [bp-58h]@47
  signed int v12; // [sp+80h] [bp-54h]@24
  int dist; // [sp+8Ch] [bp-48h]@14
  signed int v14; // [sp+90h] [bp-44h]@14
  int deltaY; // [sp+94h] [bp-40h]@14
  float v16; // [sp+98h] [bp-3Ch]@18
  int i; // [sp+A0h] [bp-34h]@21
  int colDiff; // [sp+A4h] [bp-30h]@3
  signed int v19; // [sp+A8h] [bp-2Ch]@14
  int deltaX; // [sp+ACh] [bp-28h]@14
  int numFrames; // [sp+BCh] [bp-18h]@14
  float v22; // [sp+C4h] [bp-10h]@14
  float v23; // [sp+CCh] [bp-8h]@14
  float v24; // [sp+D0h] [bp-4h]@18

  if ( ValidHex(hexIdx) )
  {
    colDiff = hexIdx % 13 - this->occupiedHex % 13;
    this->field_8E = 0;
    if ( colDiff <= 0 || this->facingRight )
    {
      if ( colDiff < 0 )
      {
        if ( this->facingRight == 1 )
        {
          this->field_8E = 1;
          this->facingRight = 1 - this->facingRight;
          if ( this->creature.creature_flags & TWO_HEXER )
          {
            ++this->occupiedHex;
            ++hexIdx;
          }
        }
      }
    }
    else
    {
      this->field_8E = 1;
      this->facingRight = 1 - this->facingRight;
      if ( this->creature.creature_flags & TWO_HEXER )
      {
        --this->occupiedHex;
        --hexIdx;
      }
    }
    if ( this->field_8E )
      combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    v19 = gpCombatManager->combatGrid[this->occupiedHex].centerX;
    v14 = gpCombatManager->combatGrid[this->occupiedHex].occupyingCreatureBottomY;
    v23 = (double)v19;
    v22 = (double)v14;
    deltaX = gpCombatManager->combatGrid[hexIdx].centerX - v19;
    deltaY = gpCombatManager->combatGrid[hexIdx].occupyingCreatureBottomY - v14;
    dist = (signed __int64)sqrt((double)(deltaY * deltaY + deltaX * deltaX));
    numFrames = 0;
    if ( this->frameInfo.flightSpeed > 0 )
      numFrames = (dist + (this->frameInfo.flightSpeed >> 1)) / this->frameInfo.flightSpeed;
    if ( numFrames <= 0 )
      numFrames = 1;
    v16 = (double)deltaX / (double)numFrames;
    v24 = (double)deltaY / (double)numFrames;
    gpCombatManager->combatGrid[this->occupiedHex].stackIdx = -1;
    gpCombatManager->combatGrid[this->occupiedHex].unitOwner = -1;
    gpCombatManager->combatGrid[this->occupiedHex].occupiersOtherHexIsToLeft = -1;
    if ( this->creature.creature_flags & TWO_HEXER )
    {
      v3 = this->occupiedHex + (this->facingRight < 1u ? -1 : 1);
      gpCombatManager->combatGrid[v3].stackIdx = -1;
      gpCombatManager->combatGrid[v3].unitOwner = -1;
      gpCombatManager->combatGrid[v3].occupiersOtherHexIsToLeft = -1;
    }
    if ( !gbNoShowCombat )
    {
      v7 = 0;
      combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 1, 1);
      bitmap::CopyTo(
        gpWindowManager->screenBuffer,
        gpCombatManager->probablyBitmapForCombatScreen,
        0,
        0,
        0,
        0,
        0x280u,
        442);
      gpCombatManager->zeroedAfterAnimatingDeathAndHolySpells = 0;
      this->animationType = 6;
      for ( i = 0; numFrames > i; ++i )
      {
        BuildTempWalkSeq(&this->frameInfo, i + 1 == numFrames, i > 0);
        if ( numFrames )
        {
          if ( i <= 0 )
            v8 = this->frameInfo.animationLengths[0];
          else
            v8 = 0;
          v12 = this->frameInfo.animationLengths[2];
          v7 = this->frameInfo.animationLengths[2];
          if ( i + 1 < numFrames )
            v12 += this->frameInfo.animationLengths[3];
        }
        else
        {
          v12 = this->frameInfo.animationLengths[6];
          v8 = 0;
        }
        for ( this->animationFrame = 0; this->frameInfo.animationLengths[6] > this->animationFrame; ++this->animationFrame )
        {
          if ( this->animationFrame >= v8 && v8 + v12 > this->animationFrame )
          {
            v23 = v16 / (double)v12 + v23;
            v22 = v24 / (double)v12 + v22;
          }
          if ( this->animationFrame % this->frameInfo.animationLengths[6] == 1 )
          {
            if ( this->creatureIdx != 52 && this->creatureIdx != 53 || i )
            {
              if ( this->creatureIdx != 52 && this->creatureIdx != 53 || numFrames - 1 != i )
                soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[0]);
              else
                soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[6]);
            }
            else
            {
              soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[5]);
              DelayMilli(100);
            }
          }
          if ( i || this->animationFrame )
          {
            bitmap::CopyTo(
              gpCombatManager->probablyBitmapForCombatScreen,
              gpWindowManager->screenBuffer,
              giMinExtentX,
              giMinExtentY,
              giMinExtentX,
              giMinExtentY,
              giMaxExtentX - giMinExtentX + 1,
              giMaxExtentY - giMinExtentY + 1);
            offsetX = giMinExtentX;
            offsetY = giMinExtentY;
            v10 = giMaxExtentX;
            v6 = giMaxExtentY;
          }
          else
          {
            offsetX = 0;
            offsetY = 0;
            v10 = 639;
            v6 = 442;
          }
          giMinExtentY = 640;
          giMinExtentX = 640;
          giMaxExtentY = 0;
          giMaxExtentX = 0;
          gbComputeExtent = 1;
          gbSaveBiggestExtent = 1;
          army::DrawToBuffer(this, (signed __int64)v23, (signed __int64)v22, 0);
          gbComputeExtent = 0;
          gbSaveBiggestExtent = 0;
          if ( giMinExtentX < 0 )
            giMinExtentX = 0;
          if ( giMinExtentY < 0 )
            giMinExtentY = 0;
          if ( giMaxExtentX > 639 )
            giMaxExtentX = 639;
          if ( giMaxExtentY > 442 )
            giMaxExtentY = 442;
          if ( offsetX > giMinExtentX )
            offsetX = giMinExtentX;
          if ( offsetY > giMinExtentY )
            offsetY = giMinExtentY;
          if ( v10 < giMaxExtentX )
            v10 = giMaxExtentX;
          if ( giMaxExtentY > v6 )
            v6 = giMaxExtentY;
          DelayTil(&glTimers);
          if ( this->animationFrame >= v8
            && (this->animationFrame + 1 < v7 || this->creatureIdx != 52 && this->creatureIdx != 53) )
            glTimers = (signed __int64)((double)KBTickCount()
                                      + (double)this->frameInfo.stepTime * gfCombatSpeedMod[giCombatSpeed] / (double)v12);
          else
            glTimers = (signed __int64)((double)KBTickCount()
                                      + (double)this->frameInfo.stepTime
                                      * gfCombatSpeedMod[giCombatSpeed]
                                      * 1.3
                                      / (double)v12);
          heroWindowManager::UpdateScreenRegion(gpWindowManager, offsetX, offsetY, v10 - offsetX + 1, v6 - offsetY + 1);
          if ( this->frameInfo.animationLengths[6] - 1 == this->animationFrame )
          {
            v23 = (double)(i + 1) * v16 + (double)v19;
            v22 = (double)(i + 1) * v24 + (double)v14;
          }
        }
      }
    }
    army::CancelSpellType(this, 0);
    gpCombatManager->combatGrid[hexIdx].unitOwner = LOBYTE(gpCombatManager->activeStackOwner);
    gpCombatManager->combatGrid[hexIdx].stackIdx = LOBYTE(gpCombatManager->activeStack);
    gpCombatManager->combatGrid[hexIdx].occupiersOtherHexIsToLeft = -1;
    if ( this->creature.creature_flags & TWO_HEXER )
    {
      v5 = hexIdx + (this->facingRight < 1u ? -1 : 1);
      gpCombatManager->combatGrid[v5].unitOwner = LOBYTE(gpCombatManager->activeStackOwner);
      gpCombatManager->combatGrid[v5].stackIdx = LOBYTE(gpCombatManager->activeStack);
      gpCombatManager->combatGrid[v5].occupiersOtherHexIsToLeft = v5 >= hexIdx;
      gpCombatManager->combatGrid[hexIdx].occupiersOtherHexIsToLeft = v5 <= hexIdx;
    }
    this->occupiedHex = hexIdx;
    this->animationType = 7;
    this->animationFrame = 0;
    if ( this->field_8E )
    {
      this->facingRight = 1 - this->facingRight;
      if ( this->creature.creature_flags & TWO_HEXER )
      {
        if ( this->facingRight )
          --this->occupiedHex;
        else
          ++this->occupiedHex;
      }
      this->field_8E = 0;
    }
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    combatManager::TestRaiseDoor(gpCombatManager);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 518CFC: using guessed type int gbNoShowCombat;
// 5240A8: using guessed type int gpSoundManager;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004022B0) --------------------------------------------------------
void __thiscall soundManager::CDStop(soundManager *this)
{
  soundManager *thisa; // [sp+Ch] [bp-8h]@1
  unsigned __int32 v2; // [sp+10h] [bp-4h]@6

  thisa = this;
  if ( !gbNoSound && this->field_69E )
  {
    if ( CDPlaying )
    {
      if ( this->currentTrack >= 0 )
      {
        if ( soundManager::CDIsPlaying(this) )
        {
          v2 = AIL_redbook_position(aStatusCdPositi);
          if ( *((_DWORD *)ptr + thisa->currentTrack) <= v2 )
          {
            if ( *((_DWORD *)dword_4ED0B4 + thisa->currentTrack) >= v2 )
              *((_DWORD *)dword_4ED0B8 + thisa->currentTrack) = v2;
          }
        }
      }
    }
    thisa->redbookStatus = AIL_redbook_stop(aStatusCdPositi);
    if ( thisa->redbookStatus != 3 )
    {
      DelayMilli(100);
      thisa->redbookStatus = AIL_redbook_status(aStatusCdPositi);
      if ( thisa->redbookStatus != 3 )
        thisa->redbookStatus = AIL_redbook_stop(aStatusCdPositi);
    }
    CDPlaying = 0;
  }
}
// 4ED0AC: using guessed type int CDPlaying;
// 523F24: using guessed type int gbNoSound;

//----- (004023E0) --------------------------------------------------------
bool __thiscall soundManager::CDIsPlaying(soundManager *this)
{
  bool result; // eax@2

  if ( gbNoSound )
  {
    result = 0;
  }
  else if ( this->field_69E )
  {
    result = AIL_redbook_status(aStatusCdPositi) == REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 523F24: using guessed type int gbNoSound;

//----- (00402450) --------------------------------------------------------
void __thiscall soundManager::CDStartup(soundManager *this)
{
  soundManager *thisa; // [sp+Ch] [bp-40h]@1
  struct tagAUXCAPSA pac; // [sp+10h] [bp-3Ch]@11
  unsigned __int32 tracknum; // [sp+40h] [bp-Ch]@6
  int numDevs; // [sp+44h] [bp-8h]@9
  UINT uDeviceID; // [sp+48h] [bp-4h]@9

  thisa = this;
  if ( !gbNoSound )
  {
    this->field_6A6 = 1;
    this->field_69E = 0;
    if ( !gbNoCDRom )
    {
      if ( !byte_5248D6 )
      {
        if ( !gbDontTryRedbook )
        {
          aStatusCdPositi = AIL_redbook_open(0);
          if ( aStatusCdPositi )
          {
            thisa->field_69E = 1;
            thisa->someTick = KBTickCount() + 5000;
            numRedbookTrackSlots = AIL_redbook_tracks(aStatusCdPositi) + 2;
            ptr = BaseAlloc(4 * numRedbookTrackSlots + 1, "F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED168 + 26);
            dword_4ED0B4 = BaseAlloc(4 * numRedbookTrackSlots + 1, "F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED168 + 27);
            dword_4ED0B8 = BaseAlloc(4 * numRedbookTrackSlots + 1, "F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED168 + 28);
            for ( tracknum = 0; (signed int)tracknum < numRedbookTrackSlots; ++tracknum )
            {
              AIL_redbook_track_info(
                aStatusCdPositi,
                tracknum,
                (unsigned __int32 *)ptr + tracknum,
                (unsigned __int32 *)dword_4ED0B4 + tracknum);
              *((_DWORD *)dword_4ED0B8 + tracknum) = 0;
            }
            numDevs = auxGetNumDevs();
            thisa->outputDeviceID = -1;
            for ( uDeviceID = 0; numDevs > (signed int)uDeviceID; ++uDeviceID )
            {
              memset(&pac, 0, 0x30u);
              auxGetDevCapsA(uDeviceID, &pac, 0x30u);
              if ( pac.wTechnology == AUXCAPS_CDAUDIO )
              {
                thisa->outputDeviceID = uDeviceID;
                break;
              }
            }
            if ( thisa->outputDeviceID != -1 )
              auxGetVolume(thisa->outputDeviceID, &pdwVolume);
          }
        }
      }
    }
  }
}
// 4ED168: using guessed type __int16 word_4ED168;
// 4F1C90: using guessed type int gbDontTryRedbook;
// 4F1CBC: using guessed type int gbNoCDRom;
// 522B70: using guessed type int numRedbookTrackSlots;
// 523F24: using guessed type int gbNoSound;
// 5248D6: using guessed type char byte_5248D6;

//----- (00402690) --------------------------------------------------------
void __thiscall soundManager::CDShutdown(soundManager *this)
{
  soundManager *v1; // [sp+Ch] [bp-4h]@1

  v1 = this;
  if ( !gbNoSound && this->field_69E )
  {
    this->redbookStatus = AIL_redbook_stop(aStatusCdPositi);
    if ( v1->redbookStatus != 3 )
    {
      DelayMilli(100);
      v1->redbookStatus = AIL_redbook_status(aStatusCdPositi);
      if ( v1->redbookStatus != 3 )
        v1->redbookStatus = AIL_redbook_stop(aStatusCdPositi);
    }
    AIL_redbook_close(aStatusCdPositi);
    if ( v1->outputDeviceID != -1 )
      auxSetVolume(v1->outputDeviceID, pdwVolume);
    aStatusCdPositi = 0;
    if ( ptr )
      BaseFree(ptr, (int)"F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED1C0 + 26);
    ptr = 0;
    if ( dword_4ED0B4 )
      BaseFree(dword_4ED0B4, (int)"F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED1C0 + 30);
    dword_4ED0B4 = 0;
    if ( dword_4ED0B8 )
      BaseFree(dword_4ED0B8, (int)"F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED1C0 + 34);
    dword_4ED0B8 = 0;
  }
}
// 4ED1C0: using guessed type __int16 word_4ED1C0;
// 523F24: using guessed type int gbNoSound;

//----- (00402800) --------------------------------------------------------
void __thiscall soundManager::CDSetVolume(soundManager *this, int weight, int a3)
{
  soundManager *thisa; // [sp+Ch] [bp-14h]@1
  int dwVolume; // [sp+18h] [bp-8h]@9
  signed int weighta; // [sp+28h] [bp+8h]@3
  signed int weightb; // [sp+28h] [bp+8h]@7

  thisa = this;
  if ( !gbNoSound && this->field_69E )
  {
    weighta = 127;
    if ( this->volRelated > 0 )
    {
      if ( this->volRelated > 10 )
        weighta = 127 * (this->volRelated - 10) / 6;
      else
        weighta = 127 * (11 - this->volRelated) / 11;
    }
    weightb = soundManager::ConvertVolume(weighta, 101);
    if ( thisa->outputDeviceID != -1 )
    {
      if ( weightb )
        dwVolume = ((12 - (11 - weightb / 12)) << 12) | ((12 - (11 - weightb / 12)) << 28);
      else
        dwVolume = 0;
      auxSetVolume(thisa->outputDeviceID, dwVolume);
    }
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (00402950) --------------------------------------------------------
void __thiscall soundManager::CDPlay(soundManager *this, int a2, signed int a3, int a4, int a5)
{
  int v5; // eax@20
  soundManager *thisa; // [sp+Ch] [bp-1Ch]@1
  unsigned __int32 startmsec; // [sp+10h] [bp-18h]@14

  thisa = this;
  if ( !gbNoSound && this->field_69E && *(_DWORD *)&Data )
  {
    if ( a2 == -1 )
    {
      soundManager::CDStop(this);
    }
    else if ( this->currentTrack != a2 || !CDPlaying || a5 )
    {
      Process1WindowsMessage();
      soundManager::ServiceSound();
      thisa->field_694 = a2;
      thisa->field_698 = a4;
      if ( *((_BYTE *)&bSaveMusicPosition + a2) )
        a3 = 1;
      soundManager::StopAllSamples(thisa, 1);
      soundManager::CDStop(thisa);
      if ( !a5 && a3 && *((_DWORD *)dword_4ED0B8 + a2) )
        startmsec = *((_DWORD *)dword_4ED0B8 + a2);
      else
        startmsec = *((_DWORD *)ptr + a2);
      thisa->redbookStatus = AIL_redbook_play(aStatusCdPositi, startmsec, *((_DWORD *)dword_4ED0B4 + a2));
      if ( thisa->redbookStatus != REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION )
      {
        DelayMilli(100);
        thisa->redbookStatus = AIL_redbook_status(aStatusCdPositi);
        if ( thisa->redbookStatus != REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION )
          thisa->redbookStatus = AIL_redbook_play(aStatusCdPositi, startmsec, *((_DWORD *)dword_4ED0B4 + a2));
      }
      CDPlaying = 1;
      Process1WindowsMessage();
      soundManager::ServiceSound();
      if ( thisa->volRelated <= 0 )
      {
        if ( a4 != -1 )
          soundManager::CDSetVolume(thisa, -1, 0);
      }
      else
      {
        thisa->volRelated = 10;
        dword_524BF8 = KBTickCount() + 600;
        v5 = soundManager::ConvertVolume(1, 101);
        soundManager::CDSetVolume(thisa, v5, 1);
      }
      thisa->currentTrack = a2;
    }
  }
}
// 4ED0AC: using guessed type int CDPlaying;
// 523F24: using guessed type int gbNoSound;
// 524BF8: using guessed type int dword_524BF8;

//----- (00402B80) --------------------------------------------------------
void __thiscall soundManager::CDPoll(int ecx0)
{
  int this; // [sp+Ch] [bp-4h]@1

  this = ecx0;
  if ( !gbNoSound
    && *(_DWORD *)(ecx0 + 1694)
    && *(_DWORD *)&Data
    && CDPlaying
    && (signed int)*(_BYTE *)(ecx0 + 1404) >= 0
    && bMusicIsLooping[*(_BYTE *)(ecx0 + 1404)]
    && KBTickCount() >= *(_DWORD *)(ecx0 + 1710) + 3000 )
  {
    *(_DWORD *)(this + 1710) = KBTickCount();
    if ( !soundManager::CDIsPlaying((soundManager *)this) )
      soundManager::CDPlay((soundManager *)this, *(_DWORD *)(this + 1684), 0, -1, 1);
  }
}
// 4ED0AC: using guessed type int CDPlaying;
// 523F24: using guessed type int gbNoSound;

//----- (00402C70) --------------------------------------------------------
int __stdcall soundManager::ConvertVolume(int weight, int ifForMusicThen101)
{
  int res; // [sp+10h] [bp-4h]@1

  res = 0;
  if ( ifForMusicThen101 == 101 )
  {
    if ( *(_DWORD *)&Data >= 1 )
    {
      if ( *(_DWORD *)&Data <= 10 )
      {
        res = weight * (11 - *(_DWORD *)&Data) / 10;
        if ( res < 1 )
          res = 1;
      }
    }
  }
  else if ( *(_DWORD *)&soundVolume >= 1 )
  {
    if ( *(_DWORD *)&soundVolume <= 10 )
    {
      res = weight * (11 - *(_DWORD *)&soundVolume) / 10;
      if ( res < 1 )
        res = 1;
    }
  }
  if ( res < 0 )
    res = 0;
  if ( res > 127 )
    res = 127;
  return res;
}

//----- (00402D50) --------------------------------------------------------
int __stdcall SetReady2Poll(unsigned __int32 a1)
{
  int result; // eax@2

  if ( gpSoundManager )
  {
    *(_BYTE *)(gpSoundManager + 1407) ^= 1u;
    result = *(_BYTE *)(gpSoundManager + 1407);
    if ( *(_BYTE *)(gpSoundManager + 1407) )
    {
      result = gpSoundManager;
      *(_BYTE *)(gpSoundManager + 1406) = 1;
    }
  }
  return result;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00402DB0) --------------------------------------------------------
int __stdcall UpdateTimers(unsigned __int32 a1)
{
  ++iCalibrateLoop;
  glMilliCounter += 16;
  return SetReady2Poll(0);
}
// 4ED218: using guessed type int iCalibrateLoop;
// 4F0A20: using guessed type int glMilliCounter;

//----- (00402DE0) --------------------------------------------------------
// public SoundManager {
//  super();
//  this.field578 = 1;
//  this.field32 = 0;
//  this.field68C = 0;
//  this.field570 = 0;
// 
//  for(int i = 0; i < 32; i++) {
//   word_522B30[i] = 0;
//  }
// 
//  memset(174,0, &this.field42);
//  this.field688 = 0;
//  this.field3A = 0;
//  this.field3EH = 0;
//  this.field694 = 0;
//  this.field698 = 0;
// }
soundManager *__thiscall soundManager::soundManager(soundManager *ecx0)
{
  soundManager *this; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  this = ecx0;
  baseManager::baseManager((baseManager *)ecx0);
  this->field_578 = 1;
  this->vtable = (managerVtable *)&soundManager::_vftable_;
  this->ready = 0;
  this->volRelated = 0;
  this->field_570 = 0;
  for ( i = 0; i < 32; ++i )
    iLastVolume[i] = 0;
  memset(this->_0, 0, 174u);
  this->aiMusicOff = 0;
  this->hdidriver = 0;
  this->field_3E = 0;
  this->field_694 = 0;
  this->field_698 = 0;
  return this;
}
// 4EA008: using guessed type int (__stdcall *soundManager___vftable_)(int);
// 522B30: using guessed type __int16 iLastVolume[32];

//----- (00402EC0) --------------------------------------------------------
HDIGDRIVER __fastcall WAVE_init_driver(DWORD samplesPerSec, unsigned __int16 bitsPerSample, WORD nChannels, __int16 a4)
{
  HDIGDRIVER result; // eax@2
  char *v5; // eax@12
  unsigned __int16 bitsPerSamplea; // [sp+Ch] [bp-E0h]@1
  DWORD samplesPerSecb; // [sp+10h] [bp-DCh]@1
  struct tagWAVEOUTCAPSA pwoc; // [sp+20h] [bp-CCh]@3
  HDIGDRIVER drvr; // [sp+54h] [bp-98h]@2
  struct _OSVERSIONINFOA samplesPerSeca; // [sp+58h] [bp-94h]@5

  bitsPerSamplea = bitsPerSample;
  samplesPerSecb = samplesPerSec;
  if ( waveOutGetNumDevs() )
  {
    if ( waveOutGetDevCapsA(0, &pwoc, 0x34u) )
    {
      MessageBoxA(hwndApp, "Sound initialization error!  No wave devices found.", "Startup Error", 0);
      drvr = 0;
      result = 0;
    }
    else
    {
      memset(&samplesPerSeca, 0, 0x94u);
      samplesPerSeca.dwOSVersionInfoSize = 148;
      if ( GetVersionExA(&samplesPerSeca) && samplesPerSeca.dwPlatformId == VER_PLATFORM_WIN32_NT )
        gbUseWaveout = 1;
      if ( gbUseWaveout )
        AIL_set_preference(0xFu, 1);
      Format.wFormatTag = 1;
      Format.nChannels = nChannels;
      Format.nSamplesPerSec = samplesPerSecb;
      Format.nAvgBytesPerSec = samplesPerSecb * nChannels * ((unsigned int)bitsPerSamplea >> 3);
      Format.nBlockAlign = nChannels * (bitsPerSamplea >> 3);
      word_522B2E = bitsPerSamplea;
      if ( AIL_waveOutOpen(&drvr, 0, 0, &Format) )
      {
        if ( a4 )
        {
          v5 = AIL_last_error();
          MessageBoxA(hwndApp, v5, "Sound initialization error!", 0);
        }
        drvr = 0;
        result = 0;
      }
      else
      {
        result = drvr;
      }
    }
  }
  else
  {
    drvr = 0;
    result = 0;
  }
  return result;
}
// 4F1CCC: using guessed type int gbUseWaveout;
// 522B2E: using guessed type __int16 word_522B2E;

//----- (004030A0) --------------------------------------------------------
int __thiscall soundManager::Open(soundManager *this, int a2)
{
  soundManager *thisa; // [sp+Ch] [bp-Ch]@1
  signed int i; // [sp+14h] [bp-4h]@1

  thisa = this;
  this->field_6A6 = 0;
  LODWORD(this->field_6AA) = 0;
  this->field_69E = 0;
  this->usingRedbookRelated = 0;
  memset(&bSaveMusicPosition, 0, 0x3Cu);
  memset(bMusicIsLooping, 0, 0x3Cu);
  byte_523030 = 1;
  byte_523032 = 1;
  byte_52302E = 1;
  byte_52302F = 1;
  byte_52302B = 1;
  byte_52302D = 1;
  byte_523031 = 1;
  byte_52302C = 1;
  byte_52303C = 1;
  byte_52304A = 1;
  byte_524070 = 1;
  byte_524072 = 1;
  byte_52406E = 1;
  byte_52406F = 1;
  byte_52406B = 1;
  byte_52406D = 1;
  byte_524071 = 1;
  byte_52406C = 1;
  byte_524068 = 1;
  byte_524069 = 1;
  byte_524065 = 1;
  byte_524066 = 1;
  byte_52406A = 1;
  byte_524067 = 1;
  byte_52408A = 1;
  byte_52407C = 1;
  byte_52408B = 1;
  byte_524076 = 1;
  byte_524078 = 1;
  for ( i = 2; i <= 4; ++i )
    bMusicIsLooping[i] = 1;
  if ( (unsigned __int16)GetAsyncKeyState(VK_F6) >> 8 )
  {
    *(_DWORD *)&useCDMusic = 0;
    WritePrefs();
  }
  if ( (unsigned __int16)GetAsyncKeyState(VK_F7) >> 8 )
  {
    *(_DWORD *)&useCDMusic = 1;
    WritePrefs();
  }
  thisa->currentTrack = -1;
  if ( !gbNoSound )
  {
    thisa->_4[0] = 0;
    thisa->_4[1] = thisa->_4[0];
    thisa->_4[2] = thisa->_4[1];
    AIL_startup();
    if ( *(_DWORD *)&useCDMusic )
    {
      soundManager::CDStartup(thisa);
      if ( !thisa->field_69E )
      {
        soundManager::MIDIStartup(thisa);
        if ( thisa->usingRedbookRelated )
        {
          *(_DWORD *)&useCDMusic = 0;
          WritePrefs();
        }
        else
        {
          *(_DWORD *)&Data = 0;
          WritePrefs();
        }
      }
    }
    else
    {
      soundManager::MIDIStartup(thisa);
      if ( !thisa->usingRedbookRelated )
      {
        soundManager::CDStartup(thisa);
        if ( thisa->field_69E )
        {
          *(_DWORD *)&useCDMusic = 1;
          WritePrefs();
        }
        else
        {
          *(_DWORD *)&Data = 0;
          WritePrefs();
        }
      }
    }
    thisa->aiMusicOff = 1;
    memset(thisa->_0, 0, 0xAEu);
    if ( !gbDontTryDigital && !thisa->hdidriver )
      thisa->hdidriver = WAVE_init_driver(0x5622u, 8u, 1u, 0);
    if ( !thisa->hdidriver )
    {
      *(_DWORD *)&soundVolume = 0;
      WritePrefs();
    }
    soundManager::AllocateSampleHandles(thisa);
    *(_DWORD *)&thisa->_0[0] = 1;
    *(_DWORD *)&thisa->_0[18] = 0;
    memset(&thisa->_4[23], 0, 0xF0u);
    *(_DWORD *)&thisa->_4[263] = 1;
  }
  thisa->type = 16;
  thisa->idx = -1;
  thisa->ready = 1;
  strcpy(thisa->name, "soundManager");
  return 0;
}
// 4F1C98: using guessed type int gbDontTryDigital;
// 52302B: using guessed type char byte_52302B;
// 52302C: using guessed type char byte_52302C;
// 52302D: using guessed type char byte_52302D;
// 52302E: using guessed type char byte_52302E;
// 52302F: using guessed type char byte_52302F;
// 523030: using guessed type char byte_523030;
// 523031: using guessed type char byte_523031;
// 523032: using guessed type char byte_523032;
// 52303C: using guessed type char byte_52303C;
// 52304A: using guessed type char byte_52304A;
// 523F24: using guessed type int gbNoSound;
// 524065: using guessed type char byte_524065;
// 524066: using guessed type char byte_524066;
// 524067: using guessed type char byte_524067;
// 524068: using guessed type char byte_524068;
// 524069: using guessed type char byte_524069;
// 52406A: using guessed type char byte_52406A;
// 52406B: using guessed type char byte_52406B;
// 52406C: using guessed type char byte_52406C;
// 52406D: using guessed type char byte_52406D;
// 52406E: using guessed type char byte_52406E;
// 52406F: using guessed type char byte_52406F;
// 524070: using guessed type char byte_524070;
// 524071: using guessed type char byte_524071;
// 524072: using guessed type char byte_524072;
// 524076: using guessed type char byte_524076;
// 524078: using guessed type char byte_524078;
// 52407C: using guessed type char byte_52407C;
// 52408A: using guessed type char byte_52408A;
// 52408B: using guessed type char byte_52408B;

//----- (00403450) --------------------------------------------------------
void __thiscall soundManager::AllocateSampleHandles(soundManager *this)
{
  soundManager *thisa; // [sp+Ch] [bp-8h]@1
  int i; // [sp+10h] [bp-4h]@3

  thisa = this;
  if ( !gbNoSound && this->hdidriver )
  {
    for ( i = 0; ; ++i )
    {
      if ( i < 14 )
      {
        thisa->hsamples[i] = AIL_allocate_sample_handle(thisa->hdidriver);
        if ( thisa->hsamples[i] )
          continue;
      }
      break;
    }
    thisa->numSamplesAllocated = i;
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (004034F0) --------------------------------------------------------
void __thiscall soundManager::Close(soundManager *this)
{
  soundManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( this->ready == 1 )
  {
    if ( !gbNoSound )
    {
      soundManager::CDShutdown(this);
      soundManager::MIDIShutdown(thisa);
      AIL_shutdown();
    }
    thisa->ready = 0;
    gbNoSound = 1;
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (00403560) --------------------------------------------------------
// return NULL;
int __stdcall soundManager::Main(int a1)
{
  return 0;
}

//----- (00403580) --------------------------------------------------------
int __stdcall sub_403580(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return 0;
}

//----- (004035A0) --------------------------------------------------------
void __thiscall soundManager::StopAllSamples(soundManager *this, int a2)
{
  soundManager *thisa; // [sp+Ch] [bp-E0h]@1
  signed int j; // [sp+10h] [bp-DCh]@14
  signed int k; // [sp+14h] [bp-D8h]@18
  __int16 i; // [sp+18h] [bp-D4h]@4

  thisa = this;
  if ( !gbNoSound && this->hdidriver && this->aiMusicOff )
  {
    for ( i = 0; thisa->numSamplesAllocated > i; ++i )
    {
      if ( AIL_sample_status(thisa->hsamples[i]) == 4 )
        AIL_end_sample(thisa->hsamples[i]);
    }
    thisa->volRelated = 0;
    if ( a2 )
    {
      if ( *(_DWORD *)&useCDMusic )
        soundManager::CDStop(thisa);
      else
        soundManager::MIDIStop((int)thisa);
    }
    if ( !dword_50FED8 )
    {
      AIL_digital_handle_release(thisa->hdidriver);
      for ( j = 0; ; ++j )
      {
        if ( j < 20 )
        {
          DelayMilli(5);
          if ( !AIL_digital_handle_reacquire(thisa->hdidriver) )
            continue;
        }
        break;
      }
    }
    for ( k = 0; k < 10; ++k )
      DelayMilli(2);
  }
}
// 50FED8: using guessed type int dword_50FED8;
// 523F24: using guessed type int gbNoSound;

//----- (00403760) --------------------------------------------------------
void __thiscall soundManager::StopSample(soundManager *this, HSAMPLE S)
{
  signed int i; // [sp+10h] [bp-8h]@3

  if ( !gbNoSound && this->hdidriver )
  {
    AIL_end_sample(S);
    for ( i = 0; i < 10; ++i )
      DelayMilli(5);
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (004037F0) --------------------------------------------------------
void __thiscall soundManager::ModifySample(soundManager *this, HSAMPLE S, __int16 a3, int weight)
{
  signed __int32 v4; // eax@11
  signed __int32 v5; // eax@14
  signed int v6; // [sp+14h] [bp-Ch]@5
  int i; // [sp+18h] [bp-8h]@5

  if ( !gbNoSound && this->hdidriver && this->aiMusicOff && *(_DWORD *)&this->_0[0] )
  {
    v6 = -1;
    for ( i = 0; this->numSamplesAllocated > i; ++i )
    {
      if ( this->hsamples[i] == S )
        v6 = i;
    }
    switch ( a3 )
    {
      case 1:
      case 100:
        v4 = soundManager::ConvertVolume(weight, 100);
        AIL_set_sample_volume(S, v4);
        if ( v6 >= 0 )
          iLastVolume[v6] = weight;
        break;
      case 101:
        ProcessAssert(*(_DWORD *)&useCDMusic < 1u, "F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED28C + 27);
        v5 = soundManager::ConvertVolume(weight, 101);
        AIL_set_sample_volume(S, v5);
        if ( v6 >= 0 )
          iLastVolume[v6] = weight;
        break;
      case 5:
        AIL_start_sample(S);
        break;
      default:
        break;
    }
    Process1WindowsMessage();
  }
}
// 4ED28C: using guessed type __int16 word_4ED28C;
// 522B30: using guessed type __int16 iLastVolume[32];
// 523F24: using guessed type int gbNoSound;

//----- (004039F0) --------------------------------------------------------
signed __int32 __thiscall soundManager::DigitalReport(soundManager *this, HSAMPLE samp, __int16 always4)
{
  signed __int32 result; // eax@2

  if ( gbNoSound )
  {
    result = 0;
  }
  else if ( this->hdidriver )
  {
    if ( always4 == 1 )
    {
      result = AIL_sample_volume(samp);
    }
    else if ( always4 == 4 )
    {
      result = AIL_sample_status(samp) == 4;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 523F24: using guessed type int gbNoSound;

//----- (00403AA0) --------------------------------------------------------
void __thiscall soundManager::AdjustSoundVolumes(soundManager *ecx0)
{
  soundManager *this; // [sp+Ch] [bp-Ch]@1
  HSAMPLE a2; // [sp+10h] [bp-8h]@6
  int i; // [sp+14h] [bp-4h]@4

  this = ecx0;
  if ( !gbNoSound && ecx0->hdidriver && ecx0->aiMusicOff )
  {
    for ( i = 1; this->numSamplesAllocated > i; ++i )
    {
      a2 = this->hsamples[i];
      if ( *(_DWORD *)&soundVolume )
      {
        if ( soundManager::DigitalReport(this, a2, 4) )
          soundManager::ModifySample(this, a2, 100, iLastVolume[i]);
      }
      else
      {
        soundManager::ModifySample(this, a2, 1, 0);
      }
    }
  }
}
// 522B30: using guessed type __int16 iLastVolume[32];
// 523F24: using guessed type int gbNoSound;

//----- (00403B80) --------------------------------------------------------
void __thiscall soundManager::AdjustMusicVolumes(int this)
{
  if ( !gbNoSound && *(_DWORD *)(this + 1672) && (signed int)*(_BYTE *)(this + 1404) >= 0 )
  {
    if ( *(_DWORD *)&Data )
    {
      if ( *(_DWORD *)&useCDMusic )
        soundManager::CDSetVolume((soundManager *)this, -1, 0);
      else
        soundManager::MIDISetVolume((soundManager *)this);
    }
    else if ( *(_DWORD *)&useCDMusic )
    {
      soundManager::CDSetVolume((soundManager *)this, -1, 0);
    }
    else
    {
      soundManager::MIDISetVolume((soundManager *)this);
    }
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (00403C60) --------------------------------------------------------
void __thiscall soundManager::ForcePollSound(int this)
{
  if ( !gbNoSound )
  {
    *(_BYTE *)(this + 1405) = 1;
    soundManager::PollSound((soundManager *)this);
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (00403CA0) --------------------------------------------------------
char __thiscall soundManager::SetMusicQuality(int this, int a2)
{
  char result; // al@2
  int thisb; // [sp+Ch] [bp-8h]@1
  int track; // [sp+10h] [bp-4h]@6

  thisb = this;
  if ( !gbNoSound )
  {
    result = this;
    if ( *(_DWORD *)(this + 66) )
    {
      if ( *(_DWORD *)&Data )
      {
        result = this;
        if ( *(_DWORD *)(this + 1694) )
        {
          if ( *(_DWORD *)&useCDMusic )
          {
            track = *(_BYTE *)(this + 1404);
            soundManager::CDStop((soundManager *)this);
            *(_BYTE *)(thisb + 1404) = -1;
          }
          else
          {
            track = *(_BYTE *)(this + 1404);
            soundManager::MIDIStop(this);
          }
          memset((void *)(thisb + 1428), 0, 0xF0u);
          result = a2;
          *(_DWORD *)&useCDMusic = a2;
          if ( track >= 0 )
            result = soundManager::PlayAmbientMusic(thisb, track, 0, -1);
        }
      }
    }
  }
  return result;
}
// 523F24: using guessed type int gbNoSound;

//----- (00403D90) --------------------------------------------------------
char __thiscall soundManager::PlayAmbientMusic(int this, int track, signed int a3, int a4)
{
  int v4; // eax@2

  if ( !gbNoSound )
  {
    LOBYTE(v4) = this;
    if ( *(_DWORD *)(this + offsetof(soundManager, aiMusicOff)) )
    {
      LOBYTE(v4) = this;
      if ( *(_DWORD *)(this + offsetof(soundManager, _0)) )
      {
        v4 = *(_BYTE *)(this + offsetof(soundManager, currentTrack));
        if ( v4 != track )
        {
          if ( *(_DWORD *)&Data )
          {
            if ( *(_DWORD *)&useCDMusic )
              soundManager::CDPlay((soundManager *)this, track, a3, -1, 0);
            else
              soundManager::MIDIPlay((soundManager *)this, track);
            LOBYTE(v4) = track;
            *(_BYTE *)(this + offsetof(soundManager, currentTrack)) = track;
          }
          else
          {
            LOBYTE(v4) = track;
            *(_BYTE *)(this + offsetof(soundManager, currentTrack)) = track;
          }
        }
      }
    }
  }
  return v4;
}
// 523F24: using guessed type int gbNoSound;

//----- (00403E60) --------------------------------------------------------
void __thiscall soundManager::PollSound(soundManager *this)
{
  soundManager *thisa; // [sp+Ch] [bp-18h]@1
  int a2; // [sp+1Ch] [bp-8h]@28
  signed int a2a; // [sp+1Ch] [bp-8h]@35

  thisa = this;
  if ( !gbNoSound )
  {
    if ( *(_DWORD *)&useCDMusic )
      soundManager::CDPoll((int)this);
    if ( (thisa->_4[0] || thisa->volRelated) && *(_DWORD *)&Data )
    {
      if ( thisa->volRelated > 0 )
      {
        Process1WindowsMessage();
        if ( thisa->currentTrack < 8 || thisa->currentTrack > 15 )
          dword_524BF8 = KBTickCount();
        thisa->volRelated = (dword_524BF8 - KBTickCount()) / 60;
        if ( thisa->volRelated < 1 )
          thisa->volRelated = 0;
        if ( thisa->volRelated <= 10 && thisa->currentTrack != thisa->_5 )
        {
          if ( *(_DWORD *)&thisa->_0[18] && *((_BYTE *)&bSaveMusicPosition + thisa->currentTrack) )
          {
            if ( !*(_DWORD *)&useCDMusic )
            {
              ProcessAssert(*(_DWORD *)&thisa->_0[18], "F:\\h2xsrc\\Base\\Soundmgr.cpp", word_4ED2AC + 39);
              *(_DWORD *)&thisa->_4[4 * thisa->currentTrack + 23] = ftell(*(_DWORD *)&thisa->_0[18]);
            }
          }
          else
          {
            dword_524BF8 = KBTickCount();
          }
          *(_DWORD *)&thisa->_4[263] = 1;
          if ( *((_BYTE *)&bSaveMusicPosition + thisa->_5) )
            soundManager::PlayAmbientMusic((int)thisa, thisa->_5, *(_DWORD *)&thisa->_4[4 * thisa->_5 + 23], -1);
          else
            soundManager::PlayAmbientMusic((int)thisa, thisa->_5, 0, -1);
          thisa->volRelated = (dword_524BF8 - KBTickCount()) / 60;
          if ( thisa->volRelated < 1 )
            thisa->volRelated = 0;
          thisa->currentTrack = LOBYTE(thisa->_5);
        }
        if ( thisa->volRelated > 10 )
          a2 = ((thisa->volRelated - 10) << 6) / 6;
        else
          a2 = ((11 - thisa->volRelated) << 6) / 11;
        if ( a2 > 64 )
          a2 = 64;
        if ( a2 < 0 )
          a2 = 0;
        if ( *(_DWORD *)&useCDMusic )
        {
          a2a = 127 * a2 * (11 - *(_DWORD *)&Data) / 640;
          if ( a2a > 127 )
            a2a = 127;
          if ( a2a < 0 )
            a2a = 0;
          soundManager::CDSetVolume(thisa, a2a, 1);
        }
        else
        {
          soundManager::MIDISetVolume(thisa);
        }
      }
      thisa->_4[0] = 0;
    }
  }
}
// 4ED2AC: using guessed type __int16 word_4ED2AC;
// 523F24: using guessed type int gbNoSound;
// 524BF8: using guessed type int dword_524BF8;

//----- (004041C0) --------------------------------------------------------
void __thiscall soundManager::SwitchAmbientMusic(soundManager *this, int track)
{
  if ( !gbNoSound && this->aiMusicOff )
  {
    if ( *(_DWORD *)&Data )
    {
      if ( soundManager::MusicPlaying(this) )
      {
        if ( this->currentTrack != track )
        {
          if ( (Process1WindowsMessage(), this->volRelated) && this->_5 != track
            || !this->volRelated && this->currentTrack != track )
          {
            if ( this->volRelated <= 10 )
            {
              this->volRelated = 11;
              dword_524BF8 = KBTickCount() + 900;
            }
            this->_5 = track;
            soundManager::PollSound(this);
          }
        }
      }
      else
      {
        soundManager::PlayAmbientMusic((int)this, track, 0, -1);
      }
    }
    else
    {
      this->currentTrack = track;
    }
  }
}
// 523F24: using guessed type int gbNoSound;
// 524BF8: using guessed type int dword_524BF8;

//----- (004042F0) --------------------------------------------------------
HSAMPLE __thiscall soundManager::MemorySample(soundManager *this, sample *a2)
{
  signed __int32 v3; // ST08_4@23
  soundManager *thisa; // [sp+Ch] [bp-14h]@1
  char *v5; // [sp+10h] [bp-10h]@12
  struct _SAMPLE *S; // [sp+14h] [bp-Ch]@22
  __int16 i; // [sp+18h] [bp-8h]@12

  thisa = this;
  if ( gbNoSound )
    return 0;
  if ( !this->hdidriver )
    return 0;
  if ( !this->aiMusicOff )
    return 0;
  if ( !*(_DWORD *)&soundVolume )
    return 0;
  if ( !*(_DWORD *)&this->_0[0] || !a2->field_28 )
    return 0;
  v5 = (char *)&SCS + 12 * a2->codeThing;
  for ( i = *(_DWORD *)v5; *((_DWORD *)v5 + 1) > (signed int)i && AIL_sample_status(thisa->hsamples[i]) != 2; ++i )
    ;
  if ( *((_DWORD *)v5 + 1) == i )
  {
    if ( a2->codeThing == 4 )
      return 0;
    i = (*((_DWORD *)v5 + 2))++;
    if ( *((_DWORD *)v5 + 1) <= *((_DWORD *)v5 + 2) )
    {
      *((_DWORD *)v5 + 2) = *(_DWORD *)v5;
      i = *((_DWORD *)v5 + 2);
    }
    soundManager::StopSample(thisa, thisa->hsamples[i]);
  }
  S = thisa->hsamples[i];
  thisa->_1[i + 64] = LOBYTE(a2->field_28);
  iLastVolume[i] = a2->field_28;
  AIL_init_sample(S);
  AIL_set_sample_type(S, a2->sampleType, 0);
  AIL_set_sample_playback_rate(S, a2->playbackRate);
  AIL_set_sample_loop_count(S, a2->loopCount);
  AIL_set_sample_address(S, a2->contents, a2->nbytes);
  if ( *(_DWORD *)&soundVolume )
  {
    v3 = soundManager::ConvertVolume(a2->field_28, 100);
    AIL_set_sample_volume(S, v3);
  }
  else
  {
    AIL_set_sample_volume(S, 0);
  }
  AIL_start_sample(S);
  a2->field_10 = (int)S;
  *(_DWORD *)&thisa->_2[4 * i] = S;
  *(_DWORD *)&thisa->_2[4 * i + 64] = a2->contents;
  *(_DWORD *)&thisa->_2[4 * i + 128] = a2->nbytes;
  return S;
}
// 522B30: using guessed type __int16 iLastVolume[32];
// 523F24: using guessed type int gbNoSound;

//----- (00404590) --------------------------------------------------------
void __cdecl soundManager::ServiceSound()
{
  if ( !gbNoSound )
    AIL_serve();
}
// 523F24: using guessed type int gbNoSound;

//----- (004045C0) --------------------------------------------------------
bool __thiscall soundManager::MusicPlaying(soundManager *this)
{
  bool result; // eax@2

  if ( gbNoSound )
  {
    result = 0;
  }
  else if ( *(_DWORD *)&useCDMusic )
  {
    if ( this->field_69E )
      result = soundManager::CDIsPlaying(this);
    else
      result = 0;
  }
  else if ( this->usingRedbookRelated )
  {
    result = soundManager::MIDIIsPlaying(this);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 523F24: using guessed type int gbNoSound;

//----- (00404640) --------------------------------------------------------
signed int __stdcall dpEnumServiceProvider(int a1, const CHAR *prefix, int a3, int a4, int a5)
{
  LogStr("ServiceProvider:");
  _strupr(prefix);
  LogInt((int)prefix, a1, -999, -999, -999, -999, -999, -999);
  if ( FindStringInString(prefix, "IPX") )
  {
    IPXGuid = a1;
  }
  else if ( FindStringInString(prefix, (const char *)&off_4ED330) )
  {
    TCPGuid = a1;
  }
  return 1;
}
// 4ED2D4: using guessed type int IPXGuid;
// 4ED2D8: using guessed type int TCPGuid;
// 4ED330: using guessed type void *off_4ED330;

//----- (004046E0) --------------------------------------------------------
signed int __stdcall dpEnumSession(int a1, int a2, int a3, char a4)
{
  signed int result; // eax@2

  if ( a4 & 1 )
  {
    result = 0;
  }
  else
  {
    LogStr("Sessions:");
    LogInt(a1 + 36, *(_DWORD *)(a1 + 20), -999, -999, -999, -999, -999, -999);
    lSessions[iMaxSession++] = *(_DWORD *)(a1 + 20);
    result = 1;
  }
  return result;
}
// 522B94: using guessed type int iMaxSession;
// 522BA0: using guessed type int lSessions[];

//----- (00404760) --------------------------------------------------------
__int16 __cdecl dpnet_init()
{
  __int16 result; // ax@2
  char v1; // [sp+10h] [bp-2Ch]@19
  char v2; // [sp+11h] [bp-2Bh]@21
  char v3; // [sp+12h] [bp-2Ah]@19
  FARPROC v4; // [sp+2Ch] [bp-10h]@5
  int i; // [sp+30h] [bp-Ch]@19
  int v6; // [sp+34h] [bp-8h]@14
  FARPROC v7; // [sp+38h] [bp-4h]@5

  if ( lpIDC )
  {
    result = 0;
  }
  else
  {
    ppDPRcvBuffer = BaseAlloc(0x320u, "F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED340 + 7);
    piDPRcvBufferSize = BaseAlloc(0x320u, "F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED340 + 8);
    memset(ppDPRcvBuffer, 0, 0x320u);
    memset(piDPRcvBufferSize, 0, 0x320u);
    hinstDplayx = LoadLibraryA("DPLAYX.DLL");
    if ( !hinstDplayx )
      ShutDown("Can't load 'DPLAYX.DLL'");
    v7 = 0;
    v4 = GetProcAddress(hinstDplayx, "DirectPlayCreate");
    if ( !v4 )
      ShutDown("Can't load 'DPLAYX.DLL'");
    v7 = GetProcAddress(hinstDplayx, "DirectPlayEnumerateA");
    if ( !v7 )
      ShutDown("Can't load 'DPLAYX.DLL'");
    ((void (__cdecl *)(signed int (__stdcall *)(int, const CHAR *, int, int, int), _DWORD))v7)(dpEnumServiceProvider, 0);
    if ( iMPNetProtocol == 1 )
    {
      g_lpGuid = IPXGuid;
    }
    else if ( iMPNetProtocol == 2 )
    {
      g_lpGuid = TCPGuid;
    }
    v6 = ((int (__cdecl *)(SOCKET, int *, _DWORD))v4)(g_lpGuid, &lpIDC, 0);
    if ( v6 )
      DPSD(v6, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED340 + 41);
    if ( (unsigned __int8)GameMode == 1 )
    {
      gbRemoteGameOpen = 1;
      giWaitType = 8;
      sprintf(gText, "Waiting On Guest.\n\n  Press 'CANCEL' to abort.");
      NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( !gbFunctionComplete )
        ShutDown(0);
      giNumHumanPlayers = iLastMsgNumHumanPlayers;
      giWaitType = 9;
      sprintf(
        gText,
        "You have %d guest(s) now logged in.  Click 'OK' to move on, or wait for additional guests.",
        iLastMsgNumHumanPlayers - 1);
      NormalDialog(gText, 5, -1, -1, -1, 0, -1, 0, -1, 0);
      gbRemoteGameOpen = 0;
      v1 = iLastMsgNumHumanPlayers;
      memcpy(&v3, &giNetPosToDCOPos, 0x18u);
      for ( i = 1; i < iLastMsgNumHumanPlayers; ++i )
      {
        v2 = i;
        dpSendMessage(*((_DWORD *)&giNetPosToDCOPos + i), 3, 0x1Au, &v1);
      }
    }
    else
    {
      giWaitType = 10;
      sprintf(gText, "Waiting for other remote player to set up game.");
      NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( !gbFunctionComplete )
        ShutDown(0);
    }
    result = 0;
  }
  return result;
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D4: using guessed type int IPXGuid;
// 4ED2D8: using guessed type int TCPGuid;
// 4ED314: using guessed type int giNumHumanPlayers;
// 4ED340: using guessed type __int16 word_4ED340;
// 4F31B4: using guessed type int iMPNetProtocol;
// 51257C: using guessed type char GameMode;
// 523018: using guessed type int gbFunctionComplete;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524750: using guessed type int giWaitType;
// 524A6C: using guessed type int gbRemoteGameOpen;

//----- (00404B40) --------------------------------------------------------
void __cdecl dpnet_term()
{
  char v0; // [sp+Ch] [bp-68h]@4

  gbRemoteOn = 0;
  if ( dcoID )
    (*(void (__cdecl **)(int, int))(*(_DWORD *)lpIDC + 32))(lpIDC, dcoID);
  (*(void (__cdecl **)(int))(*(_DWORD *)lpIDC + 16))(lpIDC);
  (*(void (__cdecl **)(int))(*(_DWORD *)lpIDC + 8))(lpIDC);
  lpIDC = 0;
  while ( dpnet_rcv(&v0) )
    ;
  if ( ppDPRcvBuffer )
    BaseFree(ppDPRcvBuffer, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED4E0 + 14);
  ppDPRcvBuffer = 0;
  if ( piDPRcvBufferSize )
    BaseFree(piDPRcvBufferSize, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED4E0 + 18);
  piDPRcvBufferSize = 0;
  if ( hinstDplayx )
    FreeLibrary(hinstDplayx);
  hinstDplayx = 0;
  _cfltcvt_init();
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D0: using guessed type int dcoID;
// 4ED4E0: using guessed type __int16 word_4ED4E0;
// 4F7494: using guessed type int gbRemoteOn;

//----- (00404C60) --------------------------------------------------------
void __fastcall dpSendMessage(int a1, char a2, unsigned __int16 a3, const void *a4)
{
  char v4; // ST28_1@1
  int v5; // [sp+10h] [bp-Ch]@1
  signed int v6; // [sp+14h] [bp-8h]@3
  LPVOID a1a; // [sp+18h] [bp-4h]@1

  v4 = a2;
  v5 = a1;
  a1a = BaseAlloc(a3 + 1, "F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED524 + 2);
  *(_BYTE *)a1a = v4;
  if ( a3 )
    memcpy((char *)a1a + 1, a4, a3);
  v6 = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)lpIDC + 92))(
         lpIDC,
         dcoID,
         v5,
         0,
         a1a,
         a3 + 1);
  if ( v6 && v6 != -2005466986 && v6 != -2147024809 )
    DPSD(v6, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED524 + 14);
  BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED524 + 16);
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D0: using guessed type int dcoID;
// 4ED524: using guessed type __int16 word_4ED524;

//----- (00404D50) --------------------------------------------------------
int __fastcall dpnet_snd(int a1, unsigned __int16 a2, const void *a3)
{
  unsigned __int16 v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+10h] [bp-8h]@1
  int v6; // [sp+14h] [bp-4h]@2

  v4 = a2;
  v5 = a1;
  dpProcessMessages();
  if ( v5 == 127 )
    v6 = 0;
  else
    v6 = *((_DWORD *)&giNetPosToDCOPos + v5);
  dpSendMessage(v6, 1, v4, a3);
  return 0;
}

//----- (00404DB0) --------------------------------------------------------
__int16 __stdcall dpnet_rcv(void *a1)
{
  __int16 result; // ax@2
  int v2; // ST20_4@3

  dpProcessMessages();
  if ( iDPRcvBufferTail == iDPRcvBufferHead )
  {
    result = 0;
  }
  else
  {
    v2 = *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferTail);
    memcpy(a1, *((const void **)ppDPRcvBuffer + iDPRcvBufferTail), *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferTail));
    BaseFree(*((void **)ppDPRcvBuffer + iDPRcvBufferTail), (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED588 + 9);
    iDPRcvBufferTail = (iDPRcvBufferTail + 1) % 200;
    result = v2;
  }
  return result;
}
// 4ED2E0: using guessed type int iDPRcvBufferHead;
// 4ED2E4: using guessed type int iDPRcvBufferTail;
// 4ED588: using guessed type __int16 word_4ED588;

//----- (00404E60) --------------------------------------------------------
int __cdecl _ismbbkpunct(unsigned int a1)
{
  int result; // eax@1

  LOBYTE(result) = 0;
  return result;
}

//----- (00404E80) --------------------------------------------------------
__int16 __cdecl sub_404E80()
{
  return 0;
}

//----- (00404EA0) --------------------------------------------------------
void __cdecl dpProcessMessages()
{
  signed int v0; // [sp+Ch] [bp-18h]@2
  int v1; // [sp+10h] [bp-14h]@2
  int v2; // [sp+1Ch] [bp-8h]@2
  int v3; // [sp+20h] [bp-4h]@2

  if ( lpIDC )
  {
    while ( 1 )
    {
      v3 = 256;
      v0 = (*(int (__cdecl **)(int, int *, int *, signed int, _DWORD, int *))(*(_DWORD *)lpIDC + 84))(
             lpIDC,
             &v1,
             &v2,
             1,
             rcvBufIn,
             &v3);
      if ( v0 == -2005466946 )
        break;
      if ( v0 )
        DPSD(v0, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED5AC + 23);
      if ( v1 && (!v2 || v2 == dcoID) )
        dpEvaluateMessage(v3, v1);
    }
  }
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D0: using guessed type int dcoID;
// 4ED5AC: using guessed type __int16 word_4ED5AC;

//----- (00404F60) --------------------------------------------------------
void __fastcall dpEvaluateMessage(int a1, int a2)
{
  int v2; // [sp+14h] [bp-Ch]@1
  signed int i; // [sp+18h] [bp-8h]@4
  const void *v4; // [sp+1Ch] [bp-4h]@1

  v2 = a1;
  v4 = &rcvBufIn[1];
  switch ( rcvBufIn[0] )
  {
    case 1:
      *((_DWORD *)ppDPRcvBuffer + iDPRcvBufferHead) = BaseAlloc(
                                                        a1 - 1,
                                                        "F:\\h2xsrc\\Source\\dpnetwin.cpp",
                                                        word_4ED5D0 + 8);
      memcpy(*((void **)ppDPRcvBuffer + iDPRcvBufferHead), &rcvBufIn[1], v2 - 1);
      *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferHead) = v2;
      iDPRcvBufferHead = (iDPRcvBufferHead + 1) % 200;
      break;
    case 2:
      if ( (unsigned __int8)GameMode == 1 )
      {
        for ( i = 1; i < iLastMsgNumHumanPlayers; ++i )
        {
          if ( *((_DWORD *)&giNetPosToDCOPos + i) == a2 )
          {
            dpSendMessage(a2, 4, 0, 0);
            return;
          }
        }
        if ( gbRemoteGameOpen )
        {
          *((_DWORD *)&giNetPosToDCOPos + iLastMsgNumHumanPlayers) = a2;
          memcpy((char *)&gsNetPlayerInfo + 34 * iLastMsgNumHumanPlayers, v4, 0x22u);
          if ( !byte_526CFC[34 * iLastMsgNumHumanPlayers] )
            xNetHasOldPlayers = 1;
          dpSendMessage(a2, 4, 0, 0);
          ++iLastMsgNumHumanPlayers;
        }
        else
        {
          dpSendMessage(a2, 5, 0, 0);
        }
      }
      break;
    case 4:
      giHostAcceptStatus = 1;
      break;
    case 5:
      giHostAcceptStatus = 2;
      break;
    case 3:
      iLastMsgNumHumanPlayers = *(_BYTE *)v4;
      giThisNetPos = rcvBufIn[2];
      LogInt((int)"DPMSGSTARTUP", giThisNetPos, a2, -999, -999, -999, -999, -999);
      memcpy(&giNetPosToDCOPos, &rcvBufIn[3], 0x18u);
      bStartUpInfoReceived = 1;
      break;
    default:
      sprintf(gText, "Unknown message: %d\n", rcvBufIn[0]);
      LogStr(gText);
      break;
  }
}
// 4ED2E0: using guessed type int iDPRcvBufferHead;
// 4ED2F0: using guessed type int bStartUpInfoReceived;
// 4ED5D0: using guessed type __int16 word_4ED5D0;
// 51257C: using guessed type char GameMode;
// 51AC64: using guessed type char xNetHasOldPlayers;
// 522BC8: using guessed type int giHostAcceptStatus;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524A6C: using guessed type int gbRemoteGameOpen;

//----- (004051E0) --------------------------------------------------------
signed int __cdecl dpWaitForFirstGuest()
{
  signed int result; // eax@10
  signed int v1; // [sp+10h] [bp-80h]@2
  signed int v2; // [sp+10h] [bp-80h]@6
  int v3; // [sp+14h] [bp-7Ch]@2
  int v4; // [sp+18h] [bp-78h]@2
  int v5; // [sp+1Ch] [bp-74h]@2
  int v6; // [sp+20h] [bp-70h]@2
  int v7; // [sp+24h] [bp-6Ch]@2
  int v8; // [sp+2Ch] [bp-64h]@2
  int v9; // [sp+34h] [bp-5Ch]@2
  char a1; // [sp+38h] [bp-58h]@2

  switch ( iDPWaitForFirstGuestStatus )
  {
    case 0:
      memset(&v3, 0, 0x7Cu);
      v3 = 124;
      v8 = 6;
      v4 = *(_DWORD *)g_lpGuid;
      v5 = *(_DWORD *)(g_lpGuid + 4);
      v6 = *(_DWORD *)(g_lpGuid + 8);
      v7 = *(_DWORD *)(g_lpGuid + 12);
      v9 = 2;
      strcpy(&a1, "Heroes 2");
      v1 = (*(int (__cdecl **)(int, int *))(*(_DWORD *)lpIDC + 80))(lpIDC, &v3);
      if ( v1 )
        DPSD(v1, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED61C + 16);
      ++iDPWaitForFirstGuestStatus;
      goto LABEL_13;
    case 1:
      byte_526CD2 = 0;
      byte_526CD3 = 0;
      ++iDPWaitForFirstGuestStatus;
      goto LABEL_13;
    case 2:
      v2 = (*(int (__cdecl **)(int, int *, _DWORD, _DWORD, int *))(*(_DWORD *)lpIDC + 20))(
             lpIDC,
             &dcoID,
             "Dude",
             "Heroes Player",
             &dword_4ED2DC);
      if ( v2 )
        DPSD(v2, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED61C + 46);
      *(_DWORD *)&giNetPosToDCOPos = dcoID;
      ++iDPWaitForFirstGuestStatus;
      goto LABEL_13;
    case 3:
      dpProcessMessages();
      if ( iLastMsgNumHumanPlayers <= 1 )
        goto LABEL_13;
      result = 1;
      break;
    default:
LABEL_13:
      result = 0;
      break;
  }
  return result;
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D0: using guessed type int dcoID;
// 4ED2DC: using guessed type int dword_4ED2DC;
// 4ED2F8: using guessed type int iDPWaitForFirstGuestStatus;
// 4ED61C: using guessed type __int16 word_4ED61C;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 526CD2: using guessed type char byte_526CD2;
// 526CD3: using guessed type char byte_526CD3;

//----- (00405370) --------------------------------------------------------
int __cdecl dpWaitForExtraGuests()
{
  int evt; // [sp+Ch] [bp-1Ch]@2
  int v2; // [sp+10h] [bp-18h]@2
  int v3; // [sp+14h] [bp-14h]@2
  char *v4; // [sp+24h] [bp-4h]@2

  dpProcessMessages();
  if ( giNumHumanPlayers != iLastMsgNumHumanPlayers )
  {
    giNumHumanPlayers = iLastMsgNumHumanPlayers;
    sprintf(
      gText,
      "You have %d guest(s) now logged in.  Click 'OK' to move on, or wait for additional guests.",
      iLastMsgNumHumanPlayers - 1);
    evt = 512;
    v2 = 3;
    v3 = 1;
    v4 = gText;
    heroWindow::BroadcastMessage(pNormalDialogWindow, (tag_message *)&evt);
    heroWindow::DrawWindow(pNormalDialogWindow);
  }
  return 0;
}
// 4ED314: using guessed type int giNumHumanPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (00405400) --------------------------------------------------------
signed int __cdecl dpWaitForHost()
{
  signed int result; // eax@3
  signed int v1; // [sp+10h] [bp-A4h]@5
  char v2; // [sp+14h] [bp-A0h]@1
  int v3; // [sp+34h] [bp-80h]@7
  int v4; // [sp+38h] [bp-7Ch]@4
  int v5; // [sp+3Ch] [bp-78h]@4
  int v6; // [sp+40h] [bp-74h]@4
  int v7; // [sp+44h] [bp-70h]@4
  int v8; // [sp+48h] [bp-6Ch]@4
  int v9; // [sp+4Ch] [bp-68h]@14
  int v10; // [sp+50h] [bp-64h]@14
  int v11; // [sp+58h] [bp-5Ch]@14
  char a1; // [sp+5Ch] [bp-58h]@14

  sprintf(&v2, "WFHS %d", iDPWaitForHostStatus);
  AiPrint(&v2);
  switch ( iDPWaitForHostStatus )
  {
    case 0:
      if ( iWaitForHostWaitCount )
      {
        --iWaitForHostWaitCount;
        DelayMilli(100);
        result = 0;
      }
      else
      {
        iSessionToTry = 0;
        memset(&v4, 0, 0x7Cu);
        v4 = 124;
        v5 = *(_DWORD *)g_lpGuid;
        v6 = *(_DWORD *)(g_lpGuid + 4);
        v7 = *(_DWORD *)(g_lpGuid + 8);
        v8 = *(_DWORD *)(g_lpGuid + 12);
        iMaxSession = 0;
        if ( ((unsigned int)((unsigned __int64)iEnumCount >> 32) ^ abs(iEnumCount) & 7)
           - ((unsigned __int64)iEnumCount >> 32) == 4 )
          v1 = 5000;
        else
          v1 = 2000;
        v3 = (*(int (__cdecl **)(int, int *, signed int, signed int (__stdcall *)(int, int, int, char), _DWORD, _DWORD))(*(_DWORD *)lpIDC + 56))(
               lpIDC,
               &v4,
               v1,
               dpEnumSession,
               0,
               0);
        ++iEnumCount;
        if ( v3 != -2005466916 )
        {
          if ( v3 )
            DPSD(v3, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED6E0 + 38);
          if ( iMaxSession > 0 )
          {
            iWaitForHostWaitCount = 30;
            ++iDPWaitForHostStatus;
          }
          goto LABEL_37;
        }
        iWaitForHostWaitCount = 30;
        result = 0;
      }
      return result;
    case 1:
      memset(&v4, 0, 0x7Cu);
      v4 = 124;
      v10 = 6;
      v5 = *(_DWORD *)g_lpGuid;
      v6 = *(_DWORD *)(g_lpGuid + 4);
      v7 = *(_DWORD *)(g_lpGuid + 8);
      v8 = *(_DWORD *)(g_lpGuid + 12);
      v11 = 1;
      v9 = lSessions[iSessionToTry];
      strcpy(&a1, "Heroes 2");
      v3 = (*(int (__cdecl **)(int, int *))(*(_DWORD *)lpIDC + 80))(lpIDC, &v4);
      if ( v3 )
        DPSD(v3, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED6E0 + 57);
      ++iDPWaitForHostStatus;
      goto LABEL_37;
    case 2:
      v3 = (*(int (__cdecl **)(int, int *, _DWORD, _DWORD, int *))(*(_DWORD *)lpIDC + 20))(
             lpIDC,
             &dcoID,
             "Dude",
             "Heroes Player",
             &dword_4ED2DC);
      if ( v3 )
        DPSD(v3, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED6E0 + 67);
      ++iDPWaitForHostStatus;
      goto LABEL_37;
    case 3:
      iLastHereIAmTickCount = KBTickCount();
      giHostAcceptStatus = 0;
      dpSendMessage(0, 2, 0x22u, &gsThisNetPlayerInfo);
      ++iDPWaitForHostStatus;
      goto LABEL_37;
    case 4:
      dpProcessMessages();
      if ( giHostAcceptStatus == 1 )
      {
        ++iDPWaitForHostStatus;
      }
      else if ( giHostAcceptStatus == 2 )
      {
        if ( iSessionToTry + 1 < iMaxSession )
        {
          iDPWaitForHostStatus = 1;
          ++iSessionToTry;
        }
        else
        {
          iDPWaitForHostStatus = 0;
        }
        v3 = (*(int (__cdecl **)(int))(*(_DWORD *)lpIDC + 16))(lpIDC);
        if ( v3 )
          DPSD(v3, (int)"F:\\h2xsrc\\Source\\dpnetwin.cpp", word_4ED6E0 + 93);
      }
      else if ( KBTickCount() > iLastHereIAmTickCount + 5000 )
      {
        --iDPWaitForHostStatus;
      }
      goto LABEL_37;
    case 5:
      dpProcessMessages();
      if ( !bStartUpInfoReceived )
        goto LABEL_37;
      result = 1;
      break;
    default:
LABEL_37:
      result = 0;
      break;
  }
  return result;
}
// 4ED2CC: using guessed type int lpIDC;
// 4ED2D0: using guessed type int dcoID;
// 4ED2DC: using guessed type int dword_4ED2DC;
// 4ED2F0: using guessed type int bStartUpInfoReceived;
// 4ED2FC: using guessed type int iDPWaitForHostStatus;
// 4ED300: using guessed type int iWaitForHostWaitCount;
// 4ED304: using guessed type int iEnumCount;
// 4ED308: using guessed type int iLastHereIAmTickCount;
// 4ED6E0: using guessed type __int16 word_4ED6E0;
// 522B94: using guessed type int iMaxSession;
// 522B98: using guessed type int iSessionToTry;
// 522BA0: using guessed type int lSessions[];
// 522BC8: using guessed type int giHostAcceptStatus;

//----- (004057C0) --------------------------------------------------------
void __fastcall DPSD(signed int a1, int a2, int a3)
{
  int v3; // [sp+10h] [bp-D4h]@1
  char a1a; // [sp+18h] [bp-CCh]@3
  int v5; // [sp+E0h] [bp-4h]@2

  v3 = a2;
  if ( !bInDPSD )
  {
    bInDPSD = 1;
    v5 = 0;
    if ( a1 > -2147467259 )
    {
      if ( a1 > -2147024809 )
      {
        if ( a1 > -2005467126 )
        {
          if ( a1 > -2005467106 )
          {
            if ( a1 > -2005467086 )
            {
              if ( a1 > -2005467066 )
              {
                if ( a1 > -2005467046 )
                {
                  if ( a1 > -2005467006 )
                  {
                    if ( a1 > -2005466976 )
                    {
                      if ( a1 > -2005466946 )
                      {
                        if ( a1 > -2005466926 )
                        {
                          if ( a1 > -2005466906 )
                          {
                            if ( a1 > -2005466886 )
                            {
                              if ( a1 == -2005466866 )
                              {
                                strcpy(&a1a, "DPERR_BUSY               ");
                              }
                              else
                              {
                                if ( a1 != -2005466856 )
                                {
                                  if ( !a1 )
                                    return;
                                  goto LABEL_31;
                                }
                                strcpy(&a1a, "DPERR_USERCANCEL         ");
                              }
                            }
                            else if ( a1 == -2005466886 )
                            {
                              strcpy(&a1a, "DPERR_UNAVAILABLE        ");
                            }
                            else
                            {
                              if ( a1 != -2005466896 )
                                goto LABEL_31;
                              strcpy(&a1a, "DPERR_TIMEOUT            ");
                            }
                          }
                          else if ( a1 == -2005466906 )
                          {
                            strcpy(&a1a, "DPERR_SENDTOOBIG         ");
                          }
                          else
                          {
                            if ( a1 != -2005466916 )
                              goto LABEL_31;
                            strcpy(&a1a, "DPERR_NOSESSIONS         ");
                          }
                        }
                        else if ( a1 == -2005466926 )
                        {
                          strcpy(&a1a, "DPERR_NOPLAYERS          ");
                        }
                        else
                        {
                          if ( a1 != -2005466936 )
                            goto LABEL_31;
                          strcpy(&a1a, "DPERR_NONAMESERVERFOUND  ");
                        }
                      }
                      else if ( a1 == -2005466946 )
                      {
                        strcpy(&a1a, "DPERR_NOMESSAGES         ");
                      }
                      else
                      {
                        if ( a1 != -2005466966 )
                          goto LABEL_31;
                        strcpy(&a1a, "DPERR_NOCONNECTION       ");
                      }
                    }
                    else if ( a1 == -2005466976 )
                    {
                      strcpy(&a1a, "DPERR_NOCAPS             ");
                    }
                    else
                    {
                      if ( a1 != -2005466986 )
                        goto LABEL_31;
                      strcpy(&a1a, "DPERR_INVALIDPLAYER      ");
                    }
                  }
                  else if ( a1 == -2005467006 )
                  {
                    strcpy(&a1a, "DPERR_INVALIDOBJECT      ");
                  }
                  else
                  {
                    if ( a1 != -2005467016 )
                      goto LABEL_31;
                    strcpy(&a1a, "DPERR_INVALIDFLAGS       ");
                  }
                }
                else if ( a1 == -2005467046 )
                {
                  strcpy(&a1a, "DPERR_EXCEPTION          ");
                }
                else
                {
                  if ( a1 != -2005467056 )
                    goto LABEL_31;
                  strcpy(&a1a, "DPERR_CAPSNOTAVAILABLEYET");
                }
              }
              else if ( a1 == -2005467066 )
              {
                strcpy(&a1a, "DPERR_CANTCREATESESSION  ");
              }
              else
              {
                if ( a1 != -2005467076 )
                  goto LABEL_31;
                strcpy(&a1a, "DPERR_CANTCREATEPLAYER   ");
              }
            }
            else if ( a1 == -2005467086 )
            {
              strcpy(&a1a, "DPERR_CANTCREATEGROUP    ");
            }
            else
            {
              if ( a1 != -2005467096 )
                goto LABEL_31;
              strcpy(&a1a, "DPERR_CANTADDPLAYER      ");
            }
          }
          else if ( a1 == -2005467106 )
          {
            strcpy(&a1a, "DPERR_BUFFERTOOSMALL     ");
          }
          else
          {
            if ( a1 != -2005467116 )
              goto LABEL_31;
            strcpy(&a1a, "DPERR_ACTIVEPLAYERS      ");
          }
        }
        else if ( a1 == -2005467126 )
        {
          strcpy(&a1a, "DPERR_ACCESSDENIED       ");
        }
        else
        {
          if ( a1 != -2005467131 )
            goto LABEL_31;
          strcpy(&a1a, "DPERR_ALREADYINITIALIZED ");
        }
      }
      else if ( a1 == -2147024809 )
      {
        strcpy(&a1a, "DPERR_INVALIDPARAMS      ");
      }
      else
      {
        if ( a1 != -2147024882 )
          goto LABEL_31;
        strcpy(&a1a, "DPERR_OUTOFMEMORY        ");
      }
    }
    else if ( a1 == -2147467259 )
    {
      strcpy(&a1a, "DPERR_GENERIC            ");
    }
    else
    {
      if ( a1 != -2147467263 )
      {
LABEL_31:
        strcpy(&a1a, "Error type unknown");
        goto LABEL_88;
      }
      strcpy(&a1a, "DPERR_UNSUPPORTED        ");
    }
LABEL_88:
    MessageBeep(0);
    MessageBeep(0);
    MessageBeep(0);
    sprintf(gText, "DirectPlay Error:\n\n'%s'\n\n  File:'%s'\n Line# %d", &a1a, v3, a3);
    LogStr(gText);
    ShutDown(gText);
  }
}
// 4ED30C: using guessed type int bInDPSD;

//----- (00405DB0) --------------------------------------------------------
int __thiscall army::FindPath(army *this, int knownHex, int targHex, int speed, int flying, int flag)
{
  int result; // eax@3
  int v7; // [sp+Ch] [bp-10h]@9
  int v9; // [sp+14h] [bp-8h]@6
  char savedSpeed; // [sp+18h] [bp-4h]@4

  if ( ValidHex(knownHex) && ValidHex(targHex) )
  {
    savedSpeed = this->creature.speed;
    if ( flying )
      this->creature.speed = 99;
    v9 = searchArray::FindCombatPath(gpSearchArray, knownHex, targHex, this, flag, 0);
    if ( !v9 && this->creature.creature_flags & TWO_HEXER && !flag )
    {
      v7 = this->facingRight;
      if ( v7 )
      {
        if ( v7 == 1 )
          targHex = army::GetAdjacentCellIndex(this, targHex, 4);
      }
      else
      {
        targHex = army::GetAdjacentCellIndex(this, targHex, 1);
      }
      if ( ValidHex(targHex) )
        v9 = searchArray::FindCombatPath(gpSearchArray, knownHex, targHex, this, 0, 1);
      else
        v9 = 0;
    }
    this->creature.speed = savedSpeed;
    result = v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00405F00) --------------------------------------------------------
signed int __thiscall army::ValidPath(army *this, int hex, int flag)
{
  signed int result; // eax@2
  army *thisa; // [sp+Ch] [bp-Ch]@1

  thisa = this;
  if ( ValidHex(hex) )
  {
    if ( thisa->creature.creature_flags & FLYER )
    {
      result = army::ValidFlight(thisa, hex, flag);
    }
    else if ( army::FindPath(thisa, thisa->occupiedHex, hex, thisa->creature.speed, 0, flag) )
    {
      thisa->targetHex = hex;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00405FA0) --------------------------------------------------------
int __thiscall army::GetMoveMask(army *this, int targHex)
{
  army *thisa; // [sp+Ch] [bp-10h]@1
  signed int v4; // [sp+10h] [bp-Ch]@1
  signed int neighborIdx; // [sp+14h] [bp-8h]@1
  int v6; // [sp+18h] [bp-4h]@1

  thisa = this;
  v6 = 0;
  v4 = 1;
  for ( neighborIdx = 0; neighborIdx <= 5; ++neighborIdx )
  {
    if ( !army::ValidMove(thisa, targHex, neighborIdx) )
      v6 |= v4;
    v4 *= 2;
  }
  return v6 | 0xC0;
}

//----- (00406010) --------------------------------------------------------
int __thiscall army::GetAttackMask(army *this, int hex, int focusLevel, int a5)
{
  army *thisa; // [sp+Ch] [bp-18h]@1
  int neighbor; // [sp+10h] [bp-14h]@9
  int nNeighbors; // [sp+14h] [bp-10h]@5
  int v8; // [sp+18h] [bp-Ch]@4
  signed int neighborIdx; // [sp+1Ch] [bp-8h]@7
  int v10; // [sp+20h] [bp-4h]@2

  thisa = this;
  if ( this->creature.creature_flags & TWO_HEXER )
    v10 = 0;
  else
    v10 = 192;
  v8 = 1;
  if ( this->creature.creature_flags & TWO_HEXER )
    nNeighbors = 8;
  else
    nNeighbors = 6;
  for ( neighborIdx = 0; nNeighbors > neighborIdx; ++neighborIdx )
  {
    if ( !army::ValidAttack(thisa, hex, neighborIdx, focusLevel, a5, &neighbor) )
      v10 |= v8;
    v8 *= 2;
  }
  return v10;
}

//----- (004060D0) --------------------------------------------------------
int __cdecl _atoldbl(_LDOUBLE *Result, char *Str)
{
  int v2; // ecx@0

  return army::ValidMove((army *)v2, *(_DWORD *)(v2 + 122), (signed int)Result);
}
// 4060D0: inconsistent function type and number of purged bytes

//----- (00406100) --------------------------------------------------------
bool __thiscall army::ValidMove(army *this, int hexIdx, signed int neighborIdx)
{
  bool result; // eax@2
  int facingRight; // [sp+Ch] [bp-18h]@16
  army *thisa; // [sp+10h] [bp-14h]@1
  signed int othNeighbAvail; // [sp+14h] [bp-10h]@25
  int othNeighb; // [sp+18h] [bp-Ch]@16
  signed int neighbAvail; // [sp+1Ch] [bp-8h]@5
  int neighb; // [sp+20h] [bp-4h]@3

  thisa = this;
  if ( !ValidHex(hexIdx) )
    return 0;
  neighb = army::GetAdjacentCellIndex(thisa, hexIdx, neighborIdx);
  if ( !ValidHex(neighb) )
    return 0;
  neighbAvail = 0;
  if ( gpCombatManager->combatGrid[neighb].unitOwner == -1
    && (!gpCombatManager->combatGrid[neighb].isBlocked
     || gpCombatManager->isCastleBattle
     && (neighb == 58 || neighb == 59)
     && (gpCombatManager->drawBridgePosition != 4
      || gpCombatManager->currentActionSide == 1
      && gpCombatManager->combatGrid[58].unitOwner == -1
      && !gpCombatManager->combatGrid[58].numCorpses)) )
    neighbAvail = 1;
  if ( thisa->creature.creature_flags & 1 )
  {
    othNeighb = -1;
    facingRight = thisa->facingRight;
    if ( facingRight )
    {
      if ( facingRight == 1 )
      {
        if ( neighborIdx == 4 )
          return neighbAvail;
        othNeighb = army::GetAdjacentCellIndex(thisa, neighb, 1);
      }
    }
    else
    {
      if ( neighborIdx == 1 )
        return neighbAvail;
      othNeighb = army::GetAdjacentCellIndex(thisa, neighb, 4);
    }
    othNeighbAvail = 0;
    if ( ValidHex(othNeighb)
      && gpCombatManager->combatGrid[othNeighb].unitOwner == -1
      && (!gpCombatManager->combatGrid[othNeighb].isBlocked
       || gpCombatManager->isCastleBattle
       && (othNeighb == 58 || othNeighb == 59)
       && (gpCombatManager->drawBridgePosition != 4
        || gpCombatManager->currentActionSide == 1
        && gpCombatManager->combatGrid[58].unitOwner == -1
        && !gpCombatManager->combatGrid[58].numCorpses)) )
      othNeighbAvail = 1;
    if ( neighborIdx != 1 && neighborIdx != 4 )
      result = neighbAvail == 1 && othNeighbAvail == 1;
    else
      result = othNeighbAvail;
  }
  else
  {
    result = neighbAvail;
  }
  return result;
}

//----- (00406400) --------------------------------------------------------
// focus 0: Only check if hex contains target
// focus 1: Only check if hex contains hostile creature
// focus 2: Check if hex contains any creature
signed int __thiscall army::ValidAttack(army *this, int knownHex, signed int neighborIdx, int focusLevel, int a5, int *neighbor)
{
  int v7; // [sp+10h] [bp-10h]@8
  army *thisa; // [sp+14h] [bp-Ch]@1
  int neighborOwner; // [sp+18h] [bp-8h]@27
  int v10; // [sp+1Ch] [bp-4h]@3

  thisa = this;
  if ( !ValidHex(knownHex) )
    return 0;
  v10 = knownHex;
  if ( thisa->creature.creature_flags & TWO_HEXER )
  {
    if ( neighborIdx == 6 )
    {
      *neighbor = army::GetAdjacentCellIndex(thisa, knownHex, thisa->facingRight < 1u ? 5 : 0);
    }
    else if ( neighborIdx == 7 )
    {
      *neighbor = army::GetAdjacentCellIndex(thisa, knownHex, (thisa->facingRight < 1u) + 2);
    }
    else
    {
      v7 = thisa->facingRight;
      if ( v7 )
      {
        if ( v7 == 1 && neighborIdx <= 2 )
          v10 = army::GetAdjacentCellIndex(thisa, knownHex, 1);
      }
      else if ( neighborIdx >= 3 )
      {
        v10 = army::GetAdjacentCellIndex(thisa, knownHex, 4);
      }
      if ( v10 == -1 )
        return 0;
      *neighbor = army::GetAdjacentCellIndex(thisa, v10, neighborIdx);
    }
  }
  else
  {
    *neighbor = army::GetAdjacentCellIndex(thisa, knownHex, neighborIdx);
  }
  if ( !ValidHex(*neighbor) )
    return 0;
  if ( a5 != -1 && *neighbor != a5 )
    return 0;
  neighborOwner = gpCombatManager->combatGrid[*neighbor].unitOwner;
  if ( focusLevel )
  {
    if ( focusLevel == 1 )
    {
      if ( 1 - gpCombatManager->currentActionSide == neighborOwner )
        return 1;
    }
    else if ( focusLevel == 2 && neighborOwner != -1 )
    {
      return 1;
    }
  }
  else if ( thisa->targetOwner == neighborOwner && gpCombatManager->combatGrid[*neighbor].stackIdx == thisa->targetStackIdx )
  {
    return 1;
  }
  return 0;
}

//----- (00406680) --------------------------------------------------------
// Also used for getting the other hex in a two-hex attack
signed int __thiscall army::GetAdjacentCellIndex(army *this, int knownHex, signed int hexIdx)
{
  signed int result; // eax@2

  if ( knownHex == -1 )
  {
    result = -1;
  }
  else
  {
    if ( hexIdx == 6 )
    {
      if ( this->facingRight == 1 )
        hexIdx = 5;
      else
        hexIdx = 0;
    }
    else if ( hexIdx == 7 )
    {
      if ( this->facingRight == 1 )
        hexIdx = 3;
      else
        hexIdx = 2;
    }
    result = gpCombatManager->hexNeighbors[knownHex][hexIdx];
  }
  return result;
}

//----- (00406730) --------------------------------------------------------
signed int __fastcall GetAdjacentCellIndexNoArmy(int hexIdx, signed int neighborIdx)
{
  signed int result; // eax@2
  signed int idx; // [sp+Ch] [bp-8h]@1

  idx = neighborIdx;
  if ( hexIdx == -1 )
  {
    result = -1;
  }
  else
  {
    if ( neighborIdx == 6 )
    {
      idx = 5;
    }
    else if ( neighborIdx == 7 )
    {
      idx = 3;
    }
    result = gpCombatManager->hexNeighbors[hexIdx][idx];
  }
  return result;
}

//----- (004067A0) --------------------------------------------------------
bool __thiscall army::ValidRange(void *ecx0, int destHex)
{
  bool result; // eax@2
  int v3; // [sp+Ch] [bp-10h]@9
  void *this; // [sp+10h] [bp-Ch]@1
  int knownHex; // [sp+14h] [bp-8h]@4
  int knownHexa; // [sp+14h] [bp-8h]@11
  int knownHexb; // [sp+14h] [bp-8h]@16
  int knownHexc; // [sp+14h] [bp-8h]@26
  int knownHexd; // [sp+14h] [bp-8h]@32
  int knownHexe; // [sp+14h] [bp-8h]@36
  int knownHexf; // [sp+14h] [bp-8h]@45
  signed int hexIdx; // [sp+18h] [bp-4h]@10
  signed int hexIdxa; // [sp+18h] [bp-4h]@15
  signed int hexIdxb; // [sp+18h] [bp-4h]@31
  signed int hexIdxc; // [sp+18h] [bp-4h]@35

  this = ecx0;
  if ( !ValidHex(destHex) )
    return 0;
  *(_DWORD *)((char *)this + 98) = *(_DWORD *)((char *)this + 122);
  if ( !(*((_BYTE *)this + 208) & 1) )
  {
    *(_DWORD *)((char *)this + 90) = army::GetBestDirection(*(_DWORD *)((char *)this + 122), destHex, -64);
    knownHex = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122), *(_DWORD *)((char *)this + 90));
    if ( knownHex == destHex )
      return 1;
    if ( army::GetAdjacentCellIndex((army *)this, knownHex, *(_DWORD *)((char *)this + 90)) == destHex )
      return 1;
    return 0;
  }
  v3 = *(_DWORD *)((char *)this + 134);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      hexIdx = army::GetBestDirection(*(_DWORD *)((char *)this + 122), destHex, -64);
      if ( hexIdx > 2 )
      {
        *(_DWORD *)((char *)this + 90) = hexIdx;
        knownHexa = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122), hexIdx);
        if ( knownHexa == destHex )
          return 1;
        if ( army::GetAdjacentCellIndex((army *)this, knownHexa, hexIdx) == destHex )
          return 1;
      }
      hexIdxa = army::GetBestDirection(*(_DWORD *)((char *)this + 122) + 1, destHex, -64);
      if ( hexIdxa < 3 )
      {
        *(_DWORD *)((char *)this + 90) = hexIdxa;
        knownHexb = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122) + 1, hexIdxa);
        if ( knownHexb == destHex )
          return 1;
        if ( army::GetAdjacentCellIndex((army *)this, knownHexb, hexIdxa) == destHex )
          return 1;
      }
      if ( hexIdxa == 4 )
        return 0;
      if ( hexIdxa == 5 )
      {
        *(_DWORD *)((char *)this + 90) = 6;
      }
      else if ( hexIdxa == 3 )
      {
        *(_DWORD *)((char *)this + 90) = 7;
      }
      knownHexc = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122) + 1, hexIdxa);
      if ( knownHexc == destHex )
        return 1;
      if ( army::GetAdjacentCellIndex((army *)this, knownHexc, hexIdxa) == destHex )
        return 1;
    }
    return 0;
  }
  hexIdxb = army::GetBestDirection(*(_DWORD *)((char *)this + 122), destHex, -64);
  if ( hexIdxb >= 3 )
  {
    hexIdxc = army::GetBestDirection(*(_DWORD *)((char *)this + 122) - 1, destHex, -64);
    if ( hexIdxc <= 2 )
    {
      if ( hexIdxc == 1 )
        return 0;
      if ( hexIdxc )
      {
        if ( hexIdxc == 2 )
          *(_DWORD *)((char *)this + 90) = 7;
      }
      else
      {
        *(_DWORD *)((char *)this + 90) = 6;
      }
      knownHexf = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122) - 1, hexIdxc);
      if ( knownHexf == destHex )
        return 1;
      if ( army::GetAdjacentCellIndex((army *)this, knownHexf, hexIdxc) == destHex )
        return 1;
      return 0;
    }
    *(_DWORD *)((char *)this + 90) = hexIdxc;
    knownHexe = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122) - 1, hexIdxc);
    if ( knownHexe == destHex )
      result = 1;
    else
      result = army::GetAdjacentCellIndex((army *)this, knownHexe, hexIdxc) == destHex;
  }
  else
  {
    *(_DWORD *)((char *)this + 90) = hexIdxb;
    knownHexd = army::GetAdjacentCellIndex((army *)this, *(_DWORD *)((char *)this + 122), hexIdxb);
    if ( knownHexd == destHex )
      result = 1;
    else
      result = army::GetAdjacentCellIndex((army *)this, knownHexd, hexIdxb) == destHex;
  }
  return result;
}

//----- (00406BF0) --------------------------------------------------------
int __fastcall OppositeDirection(signed int a1)
{
  int result; // eax@2

  if ( a1 >= 6 )
  {
    if ( a1 == 6 )
      result = 7;
    else
      result = 6;
  }
  else
  {
    result = (a1 + 3) % 6;
  }
  return result;
}

//----- (00406C50) --------------------------------------------------------
signed int __stdcall army::GetBestDirection(int curHex, int destHex, char mask)
{
  signed int goRight; // [sp+10h] [bp-20h]@4
  int curRow; // [sp+14h] [bp-1Ch]@4
  int destRow; // [sp+18h] [bp-18h]@4
  signed int goUp; // [sp+1Ch] [bp-14h]@4
  signed int goLeft; // [sp+20h] [bp-10h]@4
  signed int goDown; // [sp+2Ch] [bp-4h]@4

  if ( !ValidHex(curHex) || !ValidHex(destHex) )
    return -1;
  curRow = curHex / 13;
  destRow = destHex / 13;
  goUp = 0;
  goDown = 0;
  goLeft = 0;
  goRight = 0;
  if ( curHex % 13 >= destHex % 13 )
  {
    if ( curHex % 13 != destHex % 13 )
      goLeft = 1;
  }
  else
  {
    goRight = 1;
  }
  if ( curRow >= destRow )
  {
    if ( curRow != destRow )
      goUp = 1;
  }
  else
  {
    goDown = 1;
  }
  if ( goLeft == goRight )
  {
    if ( goUp == 1 )
    {
      if ( curRow & 1 )
      {
        if ( !(mask & 0x20) )
          return 5;
        if ( !(mask & 1) )
          return 0;
        if ( !(mask & 0x10) )
          return 4;
        if ( !(mask & 2) )
          return 1;
        if ( !(mask & 8) )
          return 3;
        if ( !(mask & 4) )
          return 2;
        if ( !(mask & 0x40) )
          return 6;
        if ( !(mask & 0x80) )
          return 7;
      }
      else
      {
        if ( !(mask & 1) )
          return 0;
        if ( !(mask & 0x20) )
          return 5;
        if ( !(mask & 2) )
          return 1;
        if ( !(mask & 0x10) )
          return 4;
        if ( !(mask & 4) )
          return 2;
        if ( !(mask & 8) )
          return 3;
        if ( !(mask & 0x40) )
          return 6;
        if ( !(mask & 0x80) )
          return 7;
      }
    }
    else if ( curRow & 1 )
    {
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
    else
    {
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
  }
  if ( goLeft == 1 )
  {
    if ( goUp == 1 )
    {
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 0x40) )
        return 6;
      if ( !(mask & 0x80) )
        return 7;
    }
    else if ( goDown == 1 )
    {
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
    else
    {
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
  }
  else if ( goRight == 1 )
  {
    if ( goUp == 1 )
    {
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 0x40) )
        return 6;
      if ( !(mask & 0x80) )
        return 7;
    }
    else if ( goDown == 1 )
    {
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
    else
    {
      if ( !(mask & 2) )
        return 1;
      if ( !(mask & 1) )
        return 0;
      if ( !(mask & 4) )
        return 2;
      if ( !(mask & 0x20) )
        return 5;
      if ( !(mask & 8) )
        return 3;
      if ( !(mask & 0x10) )
        return 4;
      if ( !(mask & 0x80) )
        return 7;
      if ( !(mask & 0x40) )
        return 6;
    }
  }
  return -1;
}

//----- (00407550) --------------------------------------------------------
baseManager *__thiscall highScoreManager::highScoreManager(baseManager *ecx0)
{
  baseManager *this; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  this = ecx0;
  baseManager::baseManager(ecx0);
  this->vtable = &highScoreManager::_vftable_;
  for ( i = 0; i < 10; ++i )
    *((_WORD *)&this[1].vtable + i) = Random(0, 17);
  this[1].name[20] = 0;
  return this;
}

//----- (004075C0) --------------------------------------------------------
int __thiscall highScoreManager::Open(int this, int a2)
{
  int v3; // [sp+Ch] [bp-8h]@1
  heroWindow *thisa; // [sp+10h] [bp-4h]@5

  v3 = this;
  *(_BYTE *)(this + 94) = !giHighScoreType || giHighScoreType == 2;
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  sprintf(gText, "hsbkg.icn");
  resourceManager::GetBackdrop(gpResourceManager, gText, gpWindowManager->screenBuffer, 1);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    *(_DWORD *)(v3 + 95) = heroWindow::heroWindow(thisa, 0, 0, "hiscore.bin");
  else
    *(_DWORD *)(v3 + 95) = 0;
  if ( !*(_DWORD *)(v3 + 95) )
    MemError();
  highScoreManager::Update(v3);
  heroWindowManager::AddWindow(gpWindowManager, *(heroWindow **)(v3 + 95), -1, 1);
  *(_DWORD *)(v3 + 12) = 16384;
  *(_DWORD *)(v3 + 16) = a2;
  *(_DWORD *)(v3 + 50) = 1;
  strcpy((char *)(v3 + 20), "highScoreManager");
  KBChangeMenu(hmnuDflt);
  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
  glTimers = KBTickCount() + 120;
  return 0;
}
// 4F74A0: using guessed type int giHighScoreType;

//----- (00407710) --------------------------------------------------------
void *__thiscall highScoreManager::Close(void *this)
{
  void *v1; // ST18_4@1
  void *result; // eax@1

  v1 = this;
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)((char *)v1 + 95));
  operator delete(*(void **)((char *)v1 + 95));
  result = v1;
  *(_DWORD *)((char *)v1 + 50) = 0;
  return result;
}

//----- (00407770) --------------------------------------------------------
signed int __thiscall highScoreManager::Main(void *this, int a2)
{
  signed int result; // eax@9
  int v3; // [sp+Ch] [bp-34h]@12
  int v4; // [sp+18h] [bp-28h]@1
  int evt; // [sp+1Ch] [bp-24h]@6
  int v6; // [sp+20h] [bp-20h]@6
  int v7; // [sp+24h] [bp-1Ch]@6
  int v8; // [sp+34h] [bp-Ch]@6
  int i; // [sp+38h] [bp-8h]@4
  int v10; // [sp+3Ch] [bp-4h]@1

  v4 = (int)this;
  v10 = 0;
  if ( gbShowHighScore )
    gbShowHighScore = 0;
  if ( KBTickCount() > glTimers )
  {
    glTimers = KBTickCount() + 120;
    for ( i = 0; i < 10; ++i )
    {
      *(_WORD *)(v4 + 2 * i + 54) = (*(_WORD *)(v4 + 2 * i + 54) + 1) % 18;
      evt = 512;
      v7 = i + 201;
      v6 = 4;
      v8 = 9 * *(_WORD *)(v4 + 2 * i + 74) + (unsigned __int8)monAnimDrawFrame[*(_WORD *)(v4 + 2 * i + 54)] + 1;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 95), (tag_message *)&evt);
    }
    heroWindow::DrawWindow(*(heroWindow **)(v4 + 95), 0, 200, 230);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 512, 51, 0x4Cu, 406);
  }
  if ( *(_BYTE *)(a2 + 13) & 2 )
  {
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)a2 == 512 && *(_DWORD *)(a2 + 4) == 13 )
    {
      v3 = *(_DWORD *)(a2 + 8);
      if ( v3 == 100 || v3 == 147 )
      {
        *(_BYTE *)(v4 + 94) = 1 - *(_BYTE *)(v4 + 94);
        highScoreManager::Update(v4);
        heroWindow::DrawWindow(*(heroWindow **)(v4 + 95), 1);
      }
      else if ( v3 == 30720 )
      {
        *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 8);
        v10 = 1;
      }
    }
    if ( v10 == 1 )
    {
      *(_DWORD *)a2 = 16384;
      *(_DWORD *)(a2 + 4) = 4;
      result = 2;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 4F74A4: using guessed type int gbShowHighScore;

//----- (004079A0) --------------------------------------------------------
int __thiscall highScoreManager::Update(int this)
{
  int result; // eax@15
  int v2; // [sp+Ch] [bp-1F0h]@1
  int evt; // [sp+10h] [bp-1ECh]@6
  int v4; // [sp+14h] [bp-1E8h]@6
  int v5; // [sp+18h] [bp-1E4h]@6
  int v6; // [sp+28h] [bp-1D4h]@7
  char v7; // [sp+2Ch] [bp-1D0h]@2
  int v8; // [sp+18Ch] [bp-70h]@1
  int fd; // [sp+190h] [bp-6Ch]@4
  int i; // [sp+194h] [bp-68h]@15
  char buf; // [sp+198h] [bp-64h]@19
  char v12; // [sp+1A9h] [bp-53h]@33
  int v13; // [sp+1D2h] [bp-2Ah]@18
  int v14; // [sp+1D6h] [bp-26h]@36
  char v15; // [sp+1DEh] [bp-1Eh]@30

  v2 = this;
  v8 = 0;
  if ( *(_BYTE *)(this + 94) )
    sprintf(&v7, "%sCAMPAIGN.HS", ".\\DATA\\");
  else
    sprintf(&v7, "%sSTANDARD.HS", ".\\DATA\\");
  fd = open(&v7, 32768);
  if ( fd == -1 )
    v8 = 1;
  sprintf(gText, "hsbkg.icn");
  resourceManager::GetBackdrop(gpResourceManager, gText, gpWindowManager->screenBuffer, 1);
  evt = 512;
  v5 = 102;
  v4 = 4;
  if ( *(_BYTE *)(v2 + 94) )
    v6 = 7;
  else
    v6 = 6;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
  if ( *(_BYTE *)(v2 + 94) )
    v5 = 147;
  else
    v5 = 100;
  v4 = 6;
  v6 = 6;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
  if ( *(_BYTE *)(v2 + 94) )
    v5 = 100;
  else
    v5 = 147;
  v4 = 5;
  v6 = 6;
  result = heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
  for ( i = 0; i < 10; ++i )
  {
    if ( v8 )
      v13 = -1;
    else
      _read(fd, &buf, 0x64u);
    if ( v13 == -1 )
    {
      *(_WORD *)(v2 + 2 * i + 74) = 0;
      sprintf(gText, byte_4EDB4C);
    }
    else
    {
      *(_WORD *)(v2 + 2 * i + 74) = GetMonType(v13, (unsigned int)*(_BYTE *)(v2 + 94) < 1);
    }
    if ( v13 == -1 )
      v4 = 6;
    else
      v4 = 5;
    v5 = i + 201;
    v6 = 6;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    v5 = i + 221;
    v6 = 6;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    if ( v13 != -1 )
    {
      *(_WORD *)(v2 + 2 * i + 54) = (*(_WORD *)(v2 + 2 * i + 54) + 1) % 18;
      v5 = i + 201;
      v4 = 4;
      v6 = 9 * *(_WORD *)(v2 + 2 * i + 74) + (unsigned __int8)monAnimDrawFrame[*(_WORD *)(v2 + 2 * i + 54)] + 1;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
      v5 = i + 221;
      v4 = 4;
      v6 = 9 * *(_WORD *)(v2 + 2 * i + 74);
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    }
    v4 = 3;
    v6 = (int)gText;
    sprintf(gText, byte_4EDB50);
    v5 = 4 * i + 106;
    if ( v13 != -1 )
      sprintf(gText, &buf);
    if ( v15 )
      strcat(gText, "\n(Cheater)");
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    sprintf(gText, byte_4EDB60);
    v5 = 4 * i + 107;
    if ( v13 != -1 )
      sprintf(gText, &v12);
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    sprintf(gText, byte_4EDB64);
    v5 = 4 * i + 108;
    if ( v13 != -1 )
    {
      if ( *(_BYTE *)(v2 + 94) )
        sprintf(gText, "%d", v13);
      else
        sprintf(gText, "%d", v14);
    }
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    sprintf(gText, byte_4EDB70);
    v5 = 4 * i + 109;
    sprintf(gText, byte_4EDB74);
    if ( !*(_BYTE *)(v2 + 94) && v13 != -1 )
      sprintf(gText, "%d", v13);
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    v4 = 52;
    v5 = 4 * i + 107;
    if ( *(_BYTE *)(v2 + 94) )
      v6 = 295;
    else
      v6 = 241;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    v5 = 4 * i + 108;
    if ( *(_BYTE *)(v2 + 94) )
      v6 = 467;
    else
      v6 = 400;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    result = giHighScoreRank;
    if ( i == giHighScoreRank )
    {
      if ( (!*(_BYTE *)(v2 + 94) || giHighScoreType == 1) && (*(_BYTE *)(v2 + 94) || giHighScoreType != 1) )
      {
        v4 = 8;
        v6 = 1;
      }
      else
      {
        v4 = 8;
        v6 = 2;
      }
      v5 = 4 * i + 106;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
      v5 = 4 * i + 107;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
      v5 = 4 * i + 108;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
      v5 = 4 * i + 109;
      result = heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 95), (tag_message *)&evt);
    }
  }
  if ( !v8 )
    result = _close(fd);
  return result;
}
// 4F749C: using guessed type int giHighScoreRank;
// 4F74A0: using guessed type int giHighScoreType;

//----- (004080F0) --------------------------------------------------------
int __fastcall SetupRecruitWin(heroWindow *window, int a2, int goldCost, int specialResource, int resourceAmt, int numAvail)
{
  char *singularName; // eax@1
  int result; // eax@3
  int creature; // [sp+Ch] [bp-60h]@1
  heroWindow *this; // [sp+10h] [bp-5Ch]@1
  char buf[40]; // [sp+14h] [bp-58h]@1
  GUIMessage evt; // [sp+3Ch] [bp-30h]@1
  char a1[1]; // [sp+58h] [bp-14h]@1
  int goldCosta; // [sp+74h] [bp+8h]@1
  int specialResourcea; // [sp+78h] [bp+Ch]@1

  creature = a2;
  this = window;
  singularName = GetMonsterName(a2);
  strcpy(a1, singularName);
  a1[0] -= 32;
  sprintf(buf, "%s %s", "Recruit", a1);
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.messageType = GUI_MESSAGE_SET_TEXT;
  evt.fieldID = 64;
  evt.payload = buf;
  heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  sprintf(buf, "%d", goldCosta);
  evt.fieldID = 73;
  heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  if ( specialResourcea != -1 )
  {
    sprintf(buf, "%d", resourceAmt);
    evt.fieldID = 75;
    heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  }
  sprintf(gText, "%s%d", "Available: ", numAvail);
  evt.fieldID = 67;
  evt.payload = gText;
  heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  sprintf(gText, "monh%04d.icn", creature);
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.messageType = GUI_MESSAGE_SET_ICON;
  evt.fieldID = 66;
  evt.payload = gText;
  result = heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  if ( specialResource != -1 )
  {
    evt.messageType = GUI_MESSAGE_SET_IMG_IDX;
    evt.fieldID = 74;
    evt.payload = (void *)specialResource;
    heroWindow::BroadcastMessage(this, (tag_message *)&evt);
    evt.messageType = GUI_MESSAGE_SET_IMG_IDX;
    evt.fieldID = 78;
    result = heroWindow::BroadcastMessage(this, (tag_message *)&evt);
  }
  return result;
}

//----- (00408280) --------------------------------------------------------
int __thiscall recruitUnit::Open(void *this, int a2)
{
  int v2; // eax@7
  int v4; // [sp+Ch] [bp-10h]@1
  heroWindow *thisa; // [sp+10h] [bp-Ch]@1
  int v6; // [sp+14h] [bp-8h]@6

  v4 = (int)this;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    *(_DWORD *)(v4 + 82) = heroWindow::heroWindow(
                             thisa,
                             143,
                             16,
                             &aRecruit0_bin[("recruit1.bin" - "recruit0.bin") & ((*(_DWORD *)(v4 + 70) == -1) - 1)]);
  else
    *(_DWORD *)(v4 + 82) = 0;
  if ( !*(_DWORD *)(v4 + 82) )
    MemError();
  *(_DWORD *)(v4 + 122) = 0;
  *(_DWORD *)(v4 + 114) = 0;
  *(_DWORD *)(v4 + 118) = 0;
  SetupRecruitWin(
    *(heroWindow **)(v4 + 82),
    *(_DWORD *)(v4 + 58),
    *(_DWORD *)(v4 + 66),
    *(_DWORD *)(v4 + 70),
    *(_DWORD *)(v4 + 74),
    **(_WORD **)(v4 + 106));
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  recruitUnit::Update(v4);
  heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 30720, 16392);
  heroWindowManager::AddWindow(gpWindowManager, *(heroWindow **)(v4 + 82), -1, 1);
  v6 = gpCurPlayer->resources[6] / *(_DWORD *)(v4 + 66);
  if ( *(_DWORD *)(v4 + 70) == -1 )
  {
    *(_DWORD *)(v4 + 110) = v6;
  }
  else
  {
    v2 = gpCurPlayer->resources[6] / *(_DWORD *)(v4 + 66);
    if ( v6 >= gpCurPlayer->resources[*(_DWORD *)(v4 + 70)] / *(_DWORD *)(v4 + 74) )
      v2 = gpCurPlayer->resources[*(_DWORD *)(v4 + 70)] / *(_DWORD *)(v4 + 74);
    *(_DWORD *)(v4 + 110) = v2;
  }
  if ( (signed int)**(_WORD **)(v4 + 106) < *(_DWORD *)(v4 + 110) )
    *(_DWORD *)(v4 + 110) = **(_WORD **)(v4 + 106);
  *(_DWORD *)(v4 + 98) = 0;
  *(_DWORD *)(v4 + 102) = 0;
  if ( !**(_WORD **)(v4 + 106) )
  {
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30722, 2);
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 30722, 16392);
  }
  hmnuRecruitSave = hmnuCurrent;
  KBChangeMenu(hmnuDflt);
  *(_DWORD *)(v4 + 12) = 16384;
  *(_DWORD *)(v4 + 16) = a2;
  *(_DWORD *)(v4 + 50) = 1;
  strcpy((char *)(v4 + 20), "recruitManager");
  return 0;
}

//----- (004084D0) --------------------------------------------------------
void __thiscall recruitUnit::Close(int this)
{
  int v1; // [sp+Ch] [bp-Ch]@1

  v1 = this;
  heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)(this + 82));
  operator delete(*(void **)(v1 + 82));
  if ( *(_DWORD *)(v1 + 102) )
    NormalDialog("There is no room in the garrison for this army.", 1, 177, 100, -1, 0, -1, 0, -1, 0);
  heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30720, 16392);
  if ( *(_DWORD *)(v1 + 54) == 35 && *(_DWORD *)(v1 + 98) && *(_DWORD *)(v1 + 78) )
  {
    townManager::ResetStrips((int)gpTownManager);
    bankBox::Update(gpTownManager->bankbox, 1);
  }
  *(_DWORD *)(v1 + 50) = 0;
  KBChangeMenu(hmnuRecruitSave);
}

//----- (004085C0) --------------------------------------------------------
int __thiscall recruitUnit::Update(int this)
{
  int result; // eax@1
  int v2; // [sp+Ch] [bp-34h]@1
  int evt; // [sp+10h] [bp-30h]@1
  int v4; // [sp+14h] [bp-2Ch]@1
  int v5; // [sp+18h] [bp-28h]@1
  char *v6; // [sp+28h] [bp-18h]@1

  v2 = this;
  evt = 512;
  v4 = 3;
  sprintf(gText, "%s%d", "Available: ", **(_WORD **)(this + 106));
  v5 = 67;
  v6 = gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 82), (tag_message *)&evt);
  sprintf(gText, "%d", *(_DWORD *)(v2 + 122));
  v5 = 68;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 82), (tag_message *)&evt);
  *(_DWORD *)(v2 + 114) = *(_DWORD *)(v2 + 66) * *(_DWORD *)(v2 + 122);
  sprintf(gText, "%d", *(_DWORD *)(v2 + 114));
  v5 = 77;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 82), (tag_message *)&evt);
  result = v2;
  if ( *(_DWORD *)(v2 + 70) != -1 )
  {
    *(_DWORD *)(v2 + 118) = *(_DWORD *)(v2 + 74) * *(_DWORD *)(v2 + 122);
    sprintf(gText, "%d", *(_DWORD *)(v2 + 118));
    v5 = 79;
    result = heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 82), (tag_message *)&evt);
  }
  return result;
}

//----- (004086F0) --------------------------------------------------------
signed int __thiscall recruitUnit::Main(int this, int a2)
{
  CREATURE_FLAGS v3; // [sp+Ch] [bp-1Ch]@14
  int v4; // [sp+10h] [bp-18h]@3
  int v5; // [sp+14h] [bp-14h]@2
  int v6; // [sp+18h] [bp-10h]@1
  signed int v7; // [sp+20h] [bp-8h]@1

  v6 = this;
  v7 = 0;
  if ( *(_DWORD *)a2 != 512 )
    return 1;
  v5 = *(_DWORD *)(a2 + 4);
  if ( v5 == 12 )
  {
LABEL_3:
    v4 = *(_DWORD *)(a2 + 8);
    if ( v4 == 66 )
    {
      game::ViewArmy(
        gpGame,
        119,
        32,
        *(CREATURES *)(this + 58),
        0,
        0,
        1,
        1u,
        (*(_BYTE *)(a2 + 13) & 2) != 0,
        0,
        0,
        0,
        0);
    }
    else if ( v4 == 68 && !(*(_BYTE *)(a2 + 13) & 2) )
    {
      *(_DWORD *)(a2 + 4) = 7;
      heroWindow::BroadcastMessage(*(heroWindow **)(this + 82), (tag_message *)a2);
      *(_DWORD *)(v6 + 122) = atoi(*(int **)(a2 + 24));
      if ( *(_DWORD *)(v6 + 122) < 0 )
        *(_DWORD *)(v6 + 122) = 0;
      if ( *(_DWORD *)(v6 + 122) > *(_DWORD *)(v6 + 110) )
        *(_DWORD *)(v6 + 122) = *(_DWORD *)(v6 + 110);
    }
    recruitUnit::Update(v6);
    heroWindow::DrawWindow(*(heroWindow **)(v6 + 82), 1, 0, 32767);
    goto LABEL_47;
  }
  if ( v5 != 13 )
  {
    if ( v5 != 14 )
      goto LABEL_47;
    goto LABEL_3;
  }
  v3 = *(_DWORD *)(a2 + 8);
  if ( v3 > (CREATURE_PETRIFIED|CREATURE_BROWN|TWO_HEXER|0x1800) )
  {
    if ( v3 == 30722 && !(*(_BYTE *)(a2 + 13) & 2) )
    {
      if ( *(_DWORD *)(this + 122) )
      {
        if ( armyGroup::CanJoin(*(armyGroup **)(this + 90), *(_DWORD *)(this + 58)) )
        {
          armyGroup::Add(*(armyGroup **)(v6 + 90), *(_DWORD *)(v6 + 58), *(_DWORD *)(v6 + 122), -1);
          gpCurPlayer->resources[6] -= *(_DWORD *)(v6 + 66) * *(_DWORD *)(v6 + 122);
          if ( *(_DWORD *)(v6 + 70) != -1 )
            gpCurPlayer->resources[*(_DWORD *)(v6 + 70)] -= *(_DWORD *)(v6 + 74) * *(_DWORD *)(v6 + 122);
          **(_WORD **)(v6 + 106) -= *(_WORD *)(v6 + 122);
          *(_DWORD *)(v6 + 98) = 1;
          v7 = 1;
        }
        else
        {
          v7 = 1;
          *(_DWORD *)(v6 + 102) = 1;
        }
      }
      else
      {
        v7 = 1;
      }
    }
  }
  else
  {
    switch ( v3 )
    {
      case CREATURE_PETRIFIED|CREATURE_BROWN|TWO_HEXER|0x1800:
        if ( !(*(_BYTE *)(a2 + 13) & 2) )
        {
          *(_DWORD *)(this + 122) = 0;
          v7 = 1;
        }
        break;
      case RETALIATED|SHOOTER|TWO_HEXER:
        if ( !(*(_BYTE *)(a2 + 13) & 2) )
        {
          ++*(_DWORD *)(this + 122);
          if ( *(_DWORD *)(this + 122) > *(_DWORD *)(this + 110) )
            *(_DWORD *)(this + 122) = *(_DWORD *)(this + 110);
          recruitUnit::Update(this);
          heroWindow::DrawWindow(*(heroWindow **)(v6 + 82), 1, 0, 32767);
        }
        break;
      case RETALIATED|SHOOTER|FLYER:
        if ( !(*(_BYTE *)(a2 + 13) & 2) )
        {
          --*(_DWORD *)(this + 122);
          if ( *(_DWORD *)(this + 122) < 0 )
            *(_DWORD *)(this + 122) = 0;
          recruitUnit::Update(this);
          heroWindow::DrawWindow(*(heroWindow **)(v6 + 82), 1, 0, 32767);
        }
        break;
      default:
        if ( v3 == 71 && !(*(_BYTE *)(a2 + 13) & 2) )
        {
          *(_DWORD *)(this + 122) = *(_DWORD *)(this + 110);
          recruitUnit::Update(this);
          heroWindow::DrawWindow(*(heroWindow **)(v6 + 82), 1, 0, 32767);
        }
        break;
    }
  }
LABEL_47:
  if ( v7 == 1 )
  {
    *(_DWORD *)a2 = 16384;
    *(_DWORD *)(a2 + 4) = 4;
    return 2;
  }
  return 1;
}

//----- (00408B10) --------------------------------------------------------
recruitUnit *__thiscall recruitUnit::recruitUnit(recruitUnit *this, armyGroup *armyGrp, int creature, int available)
{
  int i; // [sp+10h] [bp-20h]@1
  int arr[6]; // [sp+14h] [bp-1Ch]@1
  int v8; // [sp+2Ch] [bp-4h]@1

  baseManager::baseManager((baseManager *)this);
  this->vtable = &recruitUnit::_vftable_;
  this->field_36 = -1;
  this->field_4E = 0;
  this->army = armyGrp;
  this->creatureType = creature;
  this->available = available;
  GetMonsterCost(this->creatureType, arr);
  this->field_42 = v8;
  for ( i = 0; i < 6 && !arr[i]; ++i )
    ;
  if ( i >= 6 )
  {
    this->field_46 = -1;
    this->field_4A = 0;
  }
  else
  {
    this->field_46 = i;
    this->field_4A = arr[this->field_46];
  }
  return this;
}
// 408B10: using guessed type int arr[6];

//----- (00408BF0) --------------------------------------------------------
recruitUnit *__thiscall recruitUnit::recruitUnit(recruitUnit *this, int a2, int a3, int a4)
{
  recruitUnit *thisa; // [sp+Ch] [bp-24h]@1
  int i; // [sp+10h] [bp-20h]@1
  int arr[6]; // [sp+14h] [bp-1Ch]@1
  int v8; // [sp+2Ch] [bp-4h]@1

  thisa = this;
  baseManager::baseManager((baseManager *)this);
  thisa->vtable = &recruitUnit::_vftable_;
  thisa->field_4E = a4;
  thisa->field_36 = 35;
  thisa->army = (armyGroup *)(a2 + 8);
  thisa->creatureType = gDwellingType[*(_BYTE *)(a2 + 3)][a3];
  thisa->available = a2 + 2 * a3 + 30;
  GetMonsterCost(thisa->creatureType, arr);
  thisa->field_42 = v8;
  for ( i = 0; i < 6 && !arr[i]; ++i )
    ;
  if ( i >= 6 )
  {
    thisa->field_46 = -1;
    thisa->field_4A = 0;
  }
  else
  {
    thisa->field_46 = i;
    thisa->field_4A = arr[thisa->field_46];
  }
  return thisa;
}
// 408BF0: using guessed type int arr[6];

//----- (00408CF0) --------------------------------------------------------
void __fastcall QuickViewRecruit(town *castle, int dwellingIdx)
{
  heroWindow *v8; // [sp+14h] [bp-3Ch]@8
  int avail; // [sp+18h] [bp-38h]@1
  int goldCost; // [sp+1Ch] [bp-34h]@1
  signed int i; // [sp+20h] [bp-30h]@1
  int specialResourceAmt; // [sp+24h] [bp-2Ch]@6
  heroWindow *window; // [sp+28h] [bp-28h]@9
  int costs[7]; // [sp+2Ch] [bp-24h]@1
  int specialResource; // [sp+48h] [bp-8h]@6
  int creatureType; // [sp+4Ch] [bp-4h]@1

  creatureType = gDwellingType[castle->factionID][dwellingIdx];
  avail = castle->numCreaturesInDwelling[dwellingIdx];
  GetMonsterCost(creatureType, costs);
  goldCost = costs[6];
  for ( i = 0; i < 6 && !costs[i]; ++i )
    ;
  if ( i >= 6 )
  {
    specialResource = -1;
    specialResourceAmt = 0;
  }
  else
  {
    specialResource = i;
    specialResourceAmt = costs[i];
  }
  v8 = (heroWindow *)operator new(68);
  if ( v8 )
    window = heroWindow::heroWindow(
               v8,
               160,
               16,
               &aRecruiq0_bin[("recruiq1.bin" - "recruiq0.bin") & ((specialResource == -1) - 1)]);
  else
    window = 0;
  if ( !window )
    MemError();
  SetupRecruitWin(window, creatureType, goldCost, specialResource, specialResourceAmt, avail);
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  QuickViewWait();
  heroWindowManager::RemoveWindow(gpWindowManager, window);
}

//----- (00408E40) --------------------------------------------------------
strip *__thiscall strip::strip(strip *ecx0, int x, int y, int a4, int portraitFileID, int portraitIconIdx, armyGroup *armyGrp, __int16 fieldIDStart, int redraw, int a10)
{
  border *v12; // [sp+10h] [bp-14h]@17
  border *this; // [sp+14h] [bp-10h]@10
  heroWindow *wind; // [sp+18h] [bp-Ch]@4
  signed int j; // [sp+1Ch] [bp-8h]@15
  signed int i; // [sp+20h] [bp-4h]@1

  ecx0->drawBorder = -1;
  ecx0->x = x;
  ecx0->y = y;
  ecx0->field_24 = a4;
  ecx0->portraitIcon = resourceManager::GetIcon(gpResourceManager, portraitFileID);
  ecx0->portraitIconIdx = portraitIconIdx;
  ecx0->army = armyGrp;
  ecx0->stripIcon = resourceManager::GetIcon(gpResourceManager, "strip.icn");
  for ( i = 0; i < 5; ++i )
  {
    ecx0->creaturePortraits[i] = 0;
    ecx0->creatureTypes[i] = -1;
  }
  ecx0->portraitFlagIcon = resourceManager::GetIcon(gpResourceManager, "portcflg.icn");
  ecx0->field_7C = a10;
  wind = (heroWindow *)operator new(68);
  if ( wind )
    ecx0->window = heroWindow::heroWindow(wind, ecx0->x, ecx0->y, 552, 105, 8);
  else
    ecx0->window = 0;
  if ( !ecx0->window )
    MemError();
  if ( ecx0->army )
  {
    this = (border *)operator new(42);
    if ( this )
      ecx0->field_2C[0] = border::border(this, 5, 6, 101, 93, fieldIDStart, 1, 0, 0);
    else
      ecx0->field_2C[0] = 0;
    if ( !ecx0->field_2C[0] )
      MemError();
    heroWindow::AddWidget(ecx0->window, (widget *)ecx0->field_2C[0], -1);
    for ( j = 0; j < 5; ++j )
    {
      v12 = (border *)operator new(42);
      if ( v12 )
        ecx0->field_2C[j + 1] = border::border(v12, 88 * j + 112, 6, 82, 93, fieldIDStart + j + 1, 1, 0, 0);
      else
        ecx0->field_2C[j + 1] = 0;
      if ( !ecx0->field_2C[j + 1] )
        MemError();
      heroWindow::AddWidget(ecx0->window, (widget *)ecx0->field_2C[j + 1], -1);
    }
  }
  strip::DrawIcons(ecx0, redraw);
  heroWindowManager::AddWindow(gpWindowManager, ecx0->window, -1, redraw);
  return ecx0;
}

//----- (004090C0) --------------------------------------------------------
void __thiscall strip::_strip(strip *this)
{
  strip *thisa; // [sp+Ch] [bp-20h]@1
  widget *v2; // [sp+1Ch] [bp-10h]@7
  widget *v3; // [sp+24h] [bp-8h]@4
  signed int i; // [sp+28h] [bp-4h]@2
  signed int j; // [sp+28h] [bp-4h]@9

  thisa = this;
  heroWindowManager::RemoveWindow(gpWindowManager, this->window);
  if ( thisa->army )
  {
    for ( i = 0; i < 5; ++i )
    {
      v3 = (widget *)thisa->field_2C[i];
      if ( v3 )
        v3->vtable->cleanUp(v3, 1);
    }
    v2 = (widget *)thisa->field_2C[5];
    if ( v2 )
      v2->vtable->cleanUp(v2, 1);
  }
  operator delete(thisa->window);
  resourceManager::Dispose(gpResourceManager, (resource *)thisa->stripIcon);
  for ( j = 0; j < 5; ++j )
  {
    if ( thisa->creaturePortraits[j] )
      resourceManager::Dispose(gpResourceManager, (resource *)thisa->creaturePortraits[j]);
  }
  resourceManager::Dispose(gpResourceManager, (resource *)thisa->portraitIcon);
  resourceManager::Dispose(gpResourceManager, (resource *)thisa->portraitFlagIcon);
}

//----- (00409210) --------------------------------------------------------
void __thiscall strip::Draw(int this)
{
  int v1; // ST1C_4@1

  v1 = this;
  strip::DrawIcons((strip *)this, 1);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, *(_DWORD *)(v1 + 28), *(_DWORD *)(v1 + 32), 0x228u, 105);
}

//----- (00409250) --------------------------------------------------------
void __thiscall strip::DrawIcons(strip *this, int updateScreen)
{
  strip *thisa; // [sp+Ch] [bp-38h]@1
  int creatureType; // [sp+10h] [bp-34h]@25
  icon *oldCreaturePortraits[5]; // [sp+14h] [bp-30h]@14
  int oldCreatureTypes[5]; // [sp+28h] [bp-1Ch]@14
  int i; // [sp+3Ch] [bp-8h]@5
  int upToDate; // [sp+40h] [bp-4h]@5

  thisa = this;
  icon::DrawToBuffer(this->portraitIcon, this->x + 5, this->y + 6, this->portraitIconIdx, 0);
  if ( thisa->field_7C != -1 )
    icon::DrawToBuffer(thisa->portraitFlagIcon, thisa->x + 5, thisa->y + 6, thisa->field_7C, 0);
  if ( thisa->army )
  {
    upToDate = 1;
    for ( i = 0; i < 5; ++i )
    {
      if ( thisa->army->creatureTypes[i] != -1 )
      {
        if ( thisa->army->creatureTypes[i] != thisa->creatureTypes[i] )
          upToDate = 0;
      }
    }
    if ( !upToDate )
    {
      for ( i = 0; i < 5; ++i )
      {
        oldCreaturePortraits[i] = thisa->creaturePortraits[i];
        oldCreatureTypes[i] = thisa->creatureTypes[i];
        if ( thisa->army->creatureTypes[i] == -1 )
        {
          thisa->creaturePortraits[i] = NULL;
          thisa->creatureTypes[i] = -1;
        }
        else
        {
          sprintf(gText, "monh%04d.icn", thisa->army->creatureTypes[i]);
          thisa->creaturePortraits[i] = resourceManager::GetIcon(gpResourceManager, gText);
          thisa->creatureTypes[i] = thisa->army->creatureTypes[i];
        }
      }
      for ( i = 0; i < 5; ++i )
      {
        if ( oldCreatureTypes[i] )
          resourceManager::Dispose(gpResourceManager, (resource *)oldCreaturePortraits[i]);
      }
    }
    for ( i = 0; i < 5; ++i )
    {
      creatureType = thisa->army->creatureTypes[i];
      if ( creatureType == -1 )
      {
        icon::DrawToBuffer(thisa->stripIcon, thisa->x + 88 * i + 112, thisa->y + 6, 2, 0);
      }
      else
      {
        icon::DrawToBuffer(
          thisa->stripIcon,
          thisa->x + 88 * i + 112,
          thisa->y + 6,
          gMonsterDatabase[creatureType].faction + 4,
          0);
        icon::DrawToBuffer(thisa->creaturePortraits[i], thisa->x + 88 * i + 112, thisa->y + 6, 0, 0);
        sprintf(gText, "%d", thisa->army->quantities[i]);
        font::DrawBoundedString(smallFont, gText, thisa->x + 88 * i + 112, thisa->y + 86, 77, 13, 1, 2);
      }
    }
    heroWindow::DrawWindow(thisa->window, updateScreen);
    if ( thisa->drawBorder != -1 )
      icon::DrawToBuffer(thisa->stripIcon, thisa->x + 88 * thisa->drawBorder + 112, thisa->y + 6, 1, 0);
  }
  else
  {
    icon::DrawToBuffer(thisa->stripIcon, thisa->x + 112, thisa->y + 6, 11, 0);
    heroWindow::DrawWindow(thisa->window, updateScreen);
  }
}
// 409250: using guessed type int oldCreatureTypes[5];

//----- (00409630) --------------------------------------------------------
int __thiscall strip::DrawFrame(strip *this)
{
  return icon::DrawToBuffer(this->stripIcon, this->x, this->y, 0, 0);
}

//----- (00409670) --------------------------------------------------------
bankBox *__thiscall bankBox::bankBox(bankBox *this, __int16 x, __int16 y, playerData *player)
{
  bankBox *thisa; // [sp+Ch] [bp-8h]@1
  heroWindow *window; // [sp+10h] [bp-4h]@1

  thisa = this;
  this->player = player;
  this->x = x;
  this->y = y;
  window = (heroWindow *)operator new(68);
  if ( window )
    thisa->window = heroWindow::heroWindow(window, thisa->x, thisa->y, "bankbox.bin");
  else
    thisa->window = 0;
  if ( !thisa->window )
    MemError();
  heroWindowManager::AddWindow(gpWindowManager, thisa->window, -1, 1);
  bankBox::Update(thisa, 1);
  return thisa;
}

//----- (00409730) --------------------------------------------------------
BOOL __thiscall bankBox::_bankBox(bankBox *this)
{
  bankBox *thisa; // ST10_4@1

  thisa = this;
  heroWindowManager::RemoveWindow(gpWindowManager, this->window);
  return operator delete(thisa->window);
}

//----- (00409780) --------------------------------------------------------
void __thiscall bankBox::Update(bankBox *this, int updateScreen)
{
  bankBox *thisa; // [sp+Ch] [bp-30h]@1
  tag_message evt; // [sp+10h] [bp-2Ch]@1
  int i; // [sp+2Ch] [bp-10h]@1
  char v5; // [sp+30h] [bp-Ch]@3

  thisa = this;
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
  for ( i = 0; i < 6; ++i )
  {
    sprintf(&v5, "%d", thisa->player->resources[i]);
    evt.yCoordOrFieldID = i + 2030;
    evt.payload = &v5;
    heroWindow::BroadcastMessage(thisa->window, &evt);
  }
  sprintf(&v5, "%d", thisa->player->resources[6]);
  evt.yCoordOrFieldID = 2036;
  evt.payload = &v5;
  heroWindow::BroadcastMessage(thisa->window, &evt);
  heroWindow::DrawWindow(thisa->window, updateScreen);
}

//----- (00409850) --------------------------------------------------------
void __thiscall townManager::SetupCastle(townManager *ecx0, heroWindow *window, int a3)
{
  int v3; // eax@34
  townManager *thisa; // [sp+Ch] [bp-13Ch]@1
  iconWidget *v5; // [sp+10h] [bp-138h]@136
  iconWidget *this; // [sp+14h] [bp-134h]@127
  iconWidget *v7; // [sp+18h] [bp-130h]@113
  int evt; // [sp+20h] [bp-128h]@25
  int v9; // [sp+24h] [bp-124h]@25
  int v10; // [sp+28h] [bp-120h]@27
  char *v11; // [sp+38h] [bp-110h]@27
  char a2; // [sp+3Ch] [bp-10Ch]@70
  int v13; // [sp+104h] [bp-44h]@41
  int v14; // [sp+108h] [bp-40h]@109
  __int16 v15; // [sp+10Ch] [bp-3Ch]@1
  __int16 v16; // [sp+110h] [bp-38h]@1
  int i; // [sp+114h] [bp-34h]@1
  char v18; // [sp+118h] [bp-30h]@28
  int v19; // [sp+128h] [bp-20h]@108
  int j; // [sp+12Ch] [bp-1Ch]@109
  widget *guiObj; // [sp+130h] [bp-18h]@114
  int v22; // [sp+134h] [bp-14h]@108
  int k; // [sp+138h] [bp-10h]@111
  int v24; // [sp+13Ch] [bp-Ch]@108
  int v25; // [sp+140h] [bp-8h]@108
  unsigned int v26; // [sp+144h] [bp-4h]@59

  thisa = ecx0;
  casWin = window;
  v16 = 11;
  v15 = 12;
  for ( i = 0; i < 18; ++i )
  {
    castleSlotsUse[i] = castleSlotsBase[i];
    if ( (signed int)(unsigned __int8)castleSlotsBase[i] >= 20
      && (signed int)(unsigned __int8)castleSlotsBase[i] <= 24
      && ((1 << castleSlotsBase[i]) & ecx0->castle->buildingsBuiltFlags
       || (1 << (castleSlotsBase[i] + 5)) & ecx0->castle->buildingsBuiltFlags
       || (unsigned __int8)castleSlotsBase[i] == 24
       && ecx0->castle->factionID == 3
       && BYTE3(ecx0->castle->buildingsBuiltFlags) & 0x40)
      && (1 << (castleSlotsBase[i] + 5)) & gTownEligibleBuildMask[ecx0->castle->factionID] )
    {
      if ( (unsigned __int8)castleSlotsBase[i] == 24
        && ecx0->castle->factionID == 3
        && (BYTE3(ecx0->castle->buildingsBuiltFlags) & 0x20 || BYTE3(ecx0->castle->buildingsBuiltFlags) & 0x40) )
        castleSlotsUse[i] = 30;
      else
        castleSlotsUse[i] = castleSlotsBase[i] + 5;
    }
  }
  ecx0->field_156 = 0;
  ecx0->field_152 = ecx0->field_156;
  for ( i = 0; i < 18; ++i )
  {
    if ( CanBuy((int)&thisa->castle->idx, (unsigned __int8)castleSlotsUse[i]) )
      thisa->field_152 |= 1 << castleSlotsUse[i];
    if ( CanBuild((unsigned int *)thisa->castle, (unsigned __int8)castleSlotsUse[i]) )
      thisa->field_156 |= 1 << castleSlotsUse[i];
  }
  evt = 512;
  v9 = 4;
  for ( i = 0; i < 18; ++i )
  {
    v10 = i + 700;
    v11 = (char *)(unsigned __int8)castleSlotsUse[i];
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  v9 = 9;
  sprintf(&v18, "cstl%s.icn", cHeroTypeShortName[thisa->castle->factionID]);
  v11 = &v18;
  for ( i = 0; i < 18; ++i )
  {
    v10 = i + 700;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  v9 = 3;
  for ( i = 0; i < 18; ++i )
  {
    v10 = i + 600;
    if ( castleSlotsUse[i] )
    {
      v11 = GetBuildingName(thisa->castle->factionID, (unsigned __int8)castleSlotsUse[i]);
    }
    else
    {
      v3 = thisa->castle->mageGuildLevel + 1;
      if ( v3 >= 5 )
        v3 = 5;
      sprintf(gText, "Mage Guild, Level %d", v3);
      v11 = gText;
    }
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  for ( i = 0; i < 18; ++i )
  {
    v13 = -1;
    if ( (1 << castleSlotsUse[i]) & thisa->castle->buildingsBuiltFlags
      && (castleSlotsUse[i] || thisa->castle->mageGuildLevel == 5) )
    {
      v13 = 11;
    }
    else if ( (1 << castleSlotsUse[i]) & thisa->field_156 )
    {
      if ( !((1 << castleSlotsUse[i]) & thisa->field_152) )
        v13 = 13;
    }
    else
    {
      v13 = 12;
    }
    if ( v13 == -1 )
    {
      v9 = 6;
      v11 = (char *)4;
      v10 = i + 800;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
    else
    {
      v9 = 5;
      v10 = i + 800;
      v11 = (char *)4;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
      v9 = 4;
      v11 = (char *)v13;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
    if ( v13 == 11 )
    {
      v9 = 6;
      v11 = (char *)4;
      v10 = i + 400;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
    else
    {
      v9 = 5;
      v11 = (char *)4;
      v10 = i + 400;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
      v9 = 4;
      if ( v13 == -1 )
        v11 = (char *)1;
      else
        v11 = (char *)2;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
  }
  v26 = thisa->castle->buildingsBuiltFlags & 0x8000;
  if ( v26 )
    v9 = 6;
  else
    v9 = 5;
  v10 = 1101;
  v11 = (char *)6;
  heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  v9 = 4;
  v10 = 1100;
  v11 = (char *)(v26 != 0);
  heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  sprintf(gText, "CSTLCAP%c.ICN", cHeroTypeInitial[thisa->castle->factionID]);
  v9 = 9;
  v10 = 1100;
  v11 = gText;
  heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  if ( v26 )
    v9 = 5;
  else
    v9 = 6;
  v10 = 1106;
  v11 = (char *)4;
  heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  if ( v26 )
  {
    v9 = 4;
    v10 = 1106;
    v11 = (char *)gpCurPlayer->color;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  v13 = -1;
  if ( v26 )
  {
    v9 = 3;
    v11 = gText;
    sprintf(gText, byte_4EDCF0);
    for ( i = 0; i < 4; ++i )
    {
      sprintf(&a2, "%s\n", gStatNames[i]);
      strcat(gText, &a2);
    }
    v10 = 1104;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    sprintf(gText, byte_4EDCF8);
    for ( i = 0; i < 4; ++i )
    {
      sprintf(&a2, "%d\n", *(&captainStats[4 * thisa->castle->factionID] + i));
      strcat(gText, &a2);
    }
    v10 = 1105;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    if ( thisa->castle->field_38 )
      v9 = 6;
    else
      v9 = 5;
    v10 = 213;
    v11 = (char *)4;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    if ( thisa->castle->field_38 )
      v9 = 5;
    else
      v9 = 6;
    v10 = 215;
    v11 = (char *)4;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  else
  {
    if ( CanBuild((unsigned int *)thisa->castle, 15) )
    {
      if ( !CanBuy((int)&thisa->castle->idx, 15) )
        v13 = 13;
    }
    else
    {
      v13 = 12;
    }
    if ( CanBuild((unsigned int *)thisa->castle, 15) )
      thisa->field_156 |= 0x8000u;
    if ( CanBuy((int)&thisa->castle->idx, 15) )
      thisa->field_152 |= 0x8000u;
  }
  if ( v13 == -1 )
    v9 = 6;
  else
    v9 = 5;
  v10 = 1102;
  v11 = (char *)4;
  heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  if ( v13 != -1 )
  {
    v9 = 4;
    v11 = (char *)v13;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  if ( gpCurPlayer->resources[6] >= gHeroGoldCost )
  {
    if ( gpCurPlayer->numHeroes != 8 && thisa->castle->visitingHeroIdx == -1 )
    {
      if ( thisa->field_14E )
        v13 = 11;
      else
        v13 = -1;
    }
    else
    {
      v13 = 12;
    }
  }
  else
  {
    v13 = 13;
  }
  for ( i = 0; i < 2; ++i )
  {
    v11 = (char *)4;
    v10 = i + 902;
    if ( v13 == -1 )
    {
      v9 = 6;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
    else
    {
      v9 = 5;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
      v9 = 4;
      v11 = (char *)v13;
      heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
    }
    v9 = 9;
    sprintf(&v18, "port%04d.icn", gpGame->heroes[gpCurPlayer->heroesForPurchase[i]].heroID);
    v11 = &v18;
    v10 = i + 900;
    heroWindow::BroadcastMessage(casWin, (tag_message *)&evt);
  }
  v25 = 458;
  v24 = 0;
  v22 = 2
      * (5
       * (unsigned __int8)giGroundToTerrain[*(&gpGame->map.tiles[thisa->castle->x].groundIndex
                                            + 6 * gpGame->map.width * thisa->castle->y)]
       - 5);
  v19 = 32 * thisa->castle->factionID;
  if ( !a3 )
  {
    v14 = 0;
    for ( j = 5; j <= 6; ++j )
    {
      for ( k = 4; k <= 8; ++k )
      {
        v7 = (iconWidget *)operator new(45);
        if ( v7 )
          guiObj = (widget *)iconWidget::iconWidget(
                               v7,
                               32 * (k - 4) + 458,
                               32 * (j - 2),
                               32,
                               32,
                               "objntwba.icn",
                               v14 + v22,
                               0,
                               -1,
                               16,
                               1);
        else
          guiObj = 0;
        if ( !guiObj )
          MemError();
        heroWindow::AddWidget(casWin, guiObj, -1);
        ++v14;
      }
    }
    v14 = 0;
    for ( j = 2; j <= 5; ++j )
    {
      for ( k = 4; k <= 8; ++k )
      {
        if ( j != 2 || k == 6 )
        {
          this = (iconWidget *)operator new(45);
          if ( this )
            guiObj = (widget *)iconWidget::iconWidget(
                                 this,
                                 32 * (k - 4) + 458,
                                 32 * (j - 2),
                                 32,
                                 32,
                                 "objntown.icn",
                                 v14 + v19,
                                 0,
                                 -1,
                                 16,
                                 1);
          else
            guiObj = 0;
          if ( !guiObj )
            MemError();
          heroWindow::AddWidget(casWin, guiObj, -1);
          ++v14;
        }
      }
    }
    if ( !xIsExpansionMap && thisa->castle->factionID == 5 )
    {
      v5 = (iconWidget *)operator new(45);
      if ( v5 )
        guiObj = (widget *)iconWidget::iconWidget(v5, 149, 157, 137, 72, "caslxtra.icn", 0, 0, -1, 16, 1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(casWin, guiObj, -1);
    }
  }
}
// 4F1DA8: using guessed type int gHeroGoldCost;
// 4F4BA0: using guessed type char *cHeroTypeShortName[6];

//----- (0040A780) --------------------------------------------------------
signed int __thiscall CastleHandler(void *this)
{
  signed int result; // eax@24
  char *v2; // eax@29
  char *v3; // eax@31
  char *v4; // eax@44
  char *v5; // eax@46
  char *v6; // eax@48
  char *v7; // eax@49
  int v8; // [sp+14h] [bp-30h]@71
  signed int v9; // [sp+18h] [bp-2Ch]@51
  void *evt; // [sp+20h] [bp-24h]@1
  int a3; // [sp+24h] [bp-20h]@105
  signed int building; // [sp+28h] [bp-1Ch]@1
  signed int v13; // [sp+30h] [bp-14h]@33
  int i; // [sp+30h] [bp-14h]@91
  signed int v15; // [sp+34h] [bp-10h]@1
  int a2; // [sp+38h] [bp-Ch]@52
  int a2a; // [sp+38h] [bp-Ch]@97
  bool v18; // [sp+3Ch] [bp-8h]@1

  evt = this;
  building = -1;
  v18 = 0;
  v15 = 0;
  if ( *(_DWORD *)this == 4 || *(_DWORD *)this == 512 )
  {
    if ( *(_DWORD *)this == 4 )
    {
      heroWindowManager::ConvertToHover(gpWindowManager, (tag_message *)this);
      v15 = 1;
    }
    switch ( *((_DWORD *)evt + 2) )
    {
      case 0x44C:
        building = 15;
        break;
      case 0xD8:
        building = 216;
        break;
      case 0xD6:
        building = 214;
        break;
      default:
        if ( *((_DWORD *)evt + 2) < 600 || *((_DWORD *)evt + 2) >= 618 )
        {
          if ( *((_DWORD *)evt + 2) < 700 || *((_DWORD *)evt + 2) >= 718 )
          {
            if ( *((_DWORD *)evt + 2) >= 800 && *((_DWORD *)evt + 2) < 818 )
              building = *((_DWORD *)evt + 2) - 800;
          }
          else
          {
            building = *((_DWORD *)evt + 2) - 700;
          }
        }
        else
        {
          building = *((_DWORD *)evt + 2) - 600;
        }
        if ( building != -1 )
          building = (unsigned __int8)castleSlotsUse[building];
        break;
    }
  }
  if ( !v15 )
  {
    if ( *(_DWORD *)evt == 512 )
    {
      v8 = *((_DWORD *)evt + 1);
      if ( v8 == 12 )
        goto LABEL_120;
      if ( v8 == 13 )
      {
        if ( *((_DWORD *)evt + 2) == 30720 )
          v18 = 1;
        goto LABEL_115;
      }
      if ( v8 == 14 )
      {
LABEL_120:
        switch ( building + 1 )
        {
          case 215:
            if ( *((_BYTE *)evt + 13) & 2 )
            {
              NormalDialog(
                "{Spread Formation}\n\n'Spread' combat formation spreads your armies from the top to the bottom of the battlefield, with at least one empty space between each army.",
                4,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              gpTownManager->castle->field_38 = 0;
              townManager::SetupCastle(gpTownManager, gpTownManager->curScreen, 1);
              heroWindow::DrawWindow(gpTownManager->curScreen);
            }
            break;
          case 217:
            if ( *((_BYTE *)evt + 13) & 2 )
            {
              NormalDialog(
                "{Grouped Formation}\n\n'Grouped' combat formation bunches your army together in the center of your side of the battlefield.",
                4,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              gpTownManager->castle->field_38 = 1;
              townManager::SetupCastle(gpTownManager, gpTownManager->curScreen, 1);
              heroWindow::DrawWindow(gpTownManager->curScreen);
            }
            break;
          case 1:
            if ( *((_BYTE *)evt + 13) & 2
              || gpTownManager->castle->mageGuildLevel != 5 && (1 << building) & gpTownManager->field_156 )
              goto LABEL_91;
            break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 16:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
            if ( *((_BYTE *)evt + 13) & 2
              || !((1 << building) & gpTownManager->castle->buildingsBuiltFlags)
              && (1 << building) & gpTownManager->field_156 )
            {
LABEL_91:
              for ( i = 0;
                    gpTownManager->curBuilding > i && gpTownManager->buildingDisplays[i]->buildingCode != building;
                    ++i )
                ;
              v18 = townManager::BuyBuild(
                      gpTownManager,
                      building,
                      ((1 << building) & gpTownManager->field_152) == 0,
                      (*((_BYTE *)evt + 13) & 2) != 0);
            }
            break;
          case 0:
            switch ( *((_DWORD *)evt + 2) )
            {
              case 0x384:
              case 0x385:
                a2a = *((_DWORD *)evt + 2) - 900;
                goto LABEL_99;
              case 0x386:
              case 0x387:
                a2a = *((_DWORD *)evt + 2) - 902;
LABEL_99:
                if ( *((_BYTE *)evt + 13) & 2 )
                {
                  HeroView(gpCurPlayer->heroesForPurchase[a2a], 1, 0);
                  heroWindow::DrawWindow(casWin);
                  bankBox::Update(gpTownManager->bankbox, 1);
                  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
                }
                else
                {
                  a3 = gpTownManager->field_14E
                    || gpCurPlayer->resources[6] < gHeroGoldCost
                    || gpCurPlayer->numHeroes >= 8
                    || gpTownManager->castle->visitingHeroIdx != -1;
                  v18 = townManager::RecruitHero(gpTownManager, a2a, a3);
                }
                break;
              default:
                goto LABEL_115;
            }
            break;
          default:
            break;
        }
      }
    }
LABEL_115:
    if ( v18 )
    {
      *((_DWORD *)evt + 2) = 10;
      *((_DWORD *)evt + 1) = *((_DWORD *)evt + 2);
      result = 2;
    }
    else
    {
      result = 1;
    }
    return result;
  }
  if ( *((_DWORD *)evt + 2) == gpTownManager->field_142 )
  {
    result = 1;
  }
  else
  {
    gpTownManager->field_142 = *((_DWORD *)evt + 2);
    switch ( building + 1 )
    {
      case 217:
        sprintf(gText, off_4F6418);
        break;
      case 215:
        sprintf(gText, off_4F641C);
        break;
      case 1:
        if ( (1 << building) & gpTownManager->field_156 )
        {
          if ( (1 << building) & gpTownManager->field_152 )
          {
            if ( gpTownManager->castle->buildingsBuiltFlags & 1 )
            {
              if ( gpTownManager->castle->mageGuildLevel == 5 )
              {
                v13 = 1;
              }
              else if ( CanBuy((int)&gpTownManager->castle->idx, 0) )
              {
                v13 = 3;
              }
              else
              {
                v13 = 2;
              }
            }
            else
            {
              v13 = 0;
            }
            strcpy(gText, (&cCastleInfo)[4 * v13]);
          }
          else
          {
            v3 = GetBuildingName(gpTownManager->castle->factionID, building);
            sprintf(gText, off_4F63F8, v3);
          }
        }
        else
        {
          v2 = GetBuildingName(gpTownManager->castle->factionID, building);
          sprintf(gText, off_4F63F4, v2);
        }
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 16:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
        if ( BitTest(gpGame->field_27BB, gpTownManager->castle->idx) )
        {
          sprintf(gText, "Cannot build.  Already built here this turn.");
        }
        else if ( (1 << building) & gpTownManager->castle->buildingsBuiltFlags )
        {
          v4 = GetBuildingName(gpTownManager->castle->factionID, building);
          sprintf(gText, off_4F63F0, v4);
        }
        else if ( (1 << building) & gpTownManager->field_156 )
        {
          if ( (1 << building) & gpTownManager->field_152 )
          {
            v7 = GetBuildingName(gpTownManager->castle->factionID, building);
            sprintf(gText, off_4F63FC, v7);
          }
          else
          {
            v6 = GetBuildingName(gpTownManager->castle->factionID, building);
            sprintf(gText, off_4F63F8, v6);
          }
        }
        else
        {
          v5 = GetBuildingName(gpTownManager->castle->factionID, building);
          sprintf(gText, off_4F63F4, v5);
        }
        break;
      case 0:
        v9 = *((_DWORD *)evt + 2);
        if ( v9 > 30720 )
        {
LABEL_63:
          strcpy(gText, off_4F6414);
        }
        else if ( v9 == 30720 )
        {
          strcpy(gText, off_4F6410);
        }
        else
        {
          switch ( v9 )
          {
            case 900:
            case 901:
              a2 = *((_DWORD *)evt + 2) - 900;
              break;
            case 902:
            case 903:
              a2 = *((_DWORD *)evt + 2) - 902;
              break;
            default:
              goto LABEL_63;
          }
          if ( gpCurPlayer->resources[6] >= gHeroGoldCost )
          {
            if ( gpCurPlayer->numHeroes == 8 )
            {
              sprintf(gText, off_4F6404, 8);
            }
            else if ( gpTownManager->castle->visitingHeroIdx == -1 )
            {
              sprintf(
                gText,
                off_4F640C,
                gpGame->heroes[gpCurPlayer->heroesForPurchase[a2]].name,
                gAlignmentNames[gpGame->heroes[gpCurPlayer->heroesForPurchase[a2]].factionID]);
            }
            else
            {
              strcpy(gText, off_4F6408);
            }
          }
          else
          {
            strcpy(gText, off_4F6400);
          }
        }
        break;
      default:
        break;
    }
    *(_DWORD *)evt = 512;
    *((_DWORD *)evt + 1) = 3;
    *((_DWORD *)evt + 2) = 502;
    *((_DWORD *)evt + 6) = gText;
    heroWindow::BroadcastMessage(gpTownManager->curScreen, (tag_message *)evt);
    heroWindow::DrawWindow(gpTownManager->curScreen, 0, 500, 502);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 18, 463, 0x25Cu, 16);
    result = 1;
  }
  return result;
}
// 4F1DA8: using guessed type int gHeroGoldCost;

//----- (0040B430) --------------------------------------------------------
signed int __fastcall GetMapHeader(char *name, SMapHeader *hdr)
{
  signed int result; // eax@2
  UINT fd; // [sp+14h] [bp-4h]@1

  sprintf(gText, "%s%s", ".\\MAPS\\", name);
  fd = open(gText, O_BINARY);
  if ( fd == -1 )
  {
    result = 0;
  }
  else
  {
    _read(fd, hdr, 420u);
    _close(fd);
    result = 1;
  }
  return result;
}

//----- (0040B4D0) --------------------------------------------------------
signed int __cdecl ShowThisMapGame()
{
  return 1;
}

//----- (0040B5B0) --------------------------------------------------------
int __thiscall fileRequester::InitializeFiles(void *this, int a2, int a3, int a4)
{
  int result; // eax@18
  int v5; // eax@48
  char name; // [sp+10h] [bp-658h]@61
  int k; // [sp+204h] [bp-464h]@49
  int i; // [sp+208h] [bp-460h]@27
  char v10; // [sp+20Ch] [bp-45Ch]@45
  struct _WIN32_FIND_DATAA FindFileData; // [sp+214h] [bp-454h]@1
  int v12; // [sp+354h] [bp-314h]@30
  char *v13; // [sp+358h] [bp-310h]@44
  char a1; // [sp+35Ch] [bp-30Ch]@44
  SMapHeader hdr; // [sp+4BCh] [bp-1ACh]@4
  int j; // [sp+660h] [bp-8h]@1
  HANDLE hFindFile; // [sp+664h] [bp-4h]@1

  sprintf(gText, "%s%s", a2, a3);
  *(_DWORD *)((char *)this + 1042) = 0;
  j = 1;
  hFindFile = FindFirstFileA(gText, &FindFileData);
  if ( hFindFile != (HANDLE)-1 )
  {
    while ( j )
    {
      if ( *(_DWORD *)((char *)this + 66) != 1
        || (GetMapHeader(FindFileData.cFileName, &hdr), (unsigned __int8)hdr.minHumans <= iLastMsgNumHumanPlayers)
        && (unsigned __int8)hdr.maxHumans >= iLastMsgNumHumanPlayers
        && (giMapSizeFilter == 4 || (unsigned __int8)giMapSizes[giMapSizeFilter] == (unsigned __int8)hdr.width)
        && ShowThisMapGame() )
      {
        if ( *(_DWORD *)((char *)this + 66) != 4
          || ((GetMapHeader(FindFileData.cFileName, &hdr), giMapSizeFilter == 4)
           || (unsigned __int8)giMapSizes[giMapSizeFilter] == (unsigned __int8)hdr.width)
          && ShowThisMap() )
          ++*(_DWORD *)((char *)this + 1042);
      }
      j = FindNextFileA(hFindFile, &FindFileData);
    }
    FindClose(hFindFile);
  }
  if ( a4 )
  {
    result = *(_DWORD *)((char *)this + 1042);
  }
  else
  {
    *(_DWORD *)((char *)this + 670) = operator new(351 * (*(_DWORD *)((char *)this + 1042) + 1));
    if ( !*(_DWORD *)((char *)this + 670) )
      MemError();
    *(_DWORD *)((char *)this + 674) = operator new(5 * *(_DWORD *)((char *)this + 1042) + 5);
    if ( !*(_DWORD *)((char *)this + 674) )
      MemError();
    if ( *(_DWORD *)((char *)this + 66) == 4 || *(_DWORD *)((char *)this + 66) == 1 )
    {
      *(_DWORD *)((char *)this + 678) = operator new(420 * *(_DWORD *)((char *)this + 1042));
      if ( !*(_DWORD *)((char *)this + 678) )
        MemError();
    }
    for ( i = 0; *(_DWORD *)((char *)this + 1042) > i; ++i )
    {
      strcpy((char *)(351 * i + *(_DWORD *)((char *)this + 670)), byte_4EDEAC);
      strcpy((char *)(5 * i + *(_DWORD *)((char *)this + 674)), byte_4EDEB0);
    }
    v12 = 0;
    sprintf(gText, "%s%s", a2, a3);
    hFindFile = FindFirstFileA(gText, &FindFileData);
    if ( hFindFile != (HANDLE)-1 )
    {
      for ( j = 1; j; j = FindNextFileA(hFindFile, &FindFileData) )
      {
        if ( *(_DWORD *)((char *)this + 66) == 1 )
        {
          GetMapHeader(FindFileData.cFileName, &hdr);
          if ( (unsigned __int8)hdr.minHumans > iLastMsgNumHumanPlayers
            || (unsigned __int8)hdr.maxHumans < iLastMsgNumHumanPlayers
            || giMapSizeFilter != 4 && (unsigned __int8)giMapSizes[giMapSizeFilter] != (unsigned __int8)hdr.width )
            continue;
          if ( !ShowThisMapGame() )
            continue;
        }
        if ( *(_DWORD *)((char *)this + 66) == 4 )
        {
          GetMapHeader(FindFileData.cFileName, &hdr);
          if ( giMapSizeFilter != 4 )
          {
            if ( (unsigned __int8)giMapSizes[giMapSizeFilter] != (unsigned __int8)hdr.width )
              continue;
          }
          if ( !ShowThisMap() )
            continue;
        }
        strcpy(&a1, FindFileData.cFileName);
        v13 = (char *)FindLastToken(&a1, 46);
        if ( v13 )
        {
          strcpy(&v10, v13);
          *v13 = 0;
        }
        for ( i = 0; i < v12; ++i )
        {
          LOBYTE(v5) = stricmp(&a1, (char *)(351 * i + *(_DWORD *)((char *)this + 670)));
          if ( v5 < 0 )
          {
            for ( k = v12; k > i; --k )
            {
              strcpy(
                (char *)(351 * k + *(_DWORD *)((char *)this + 670)),
                (char *)(*(_DWORD *)((char *)this + 670) + 351 * (k - 1)));
              strcpy(
                (char *)(5 * k + *(_DWORD *)((char *)this + 674)),
                (char *)(*(_DWORD *)((char *)this + 674) + 5 * k - 5));
            }
            break;
          }
        }
        strcpy((char *)(351 * i + *(_DWORD *)((char *)this + 670)), &a1);
        strcpy((char *)(5 * i + *(_DWORD *)((char *)this + 674)), &v10);
        ++v12;
      }
      FindClose(hFindFile);
    }
    if ( *(_DWORD *)((char *)this + 66) == 1 || *(_DWORD *)((char *)this + 66) == 4 )
    {
      for ( i = 0; i < v12; ++i )
      {
        sprintf(&name, "%s%s", 351 * i + *(_DWORD *)((char *)this + 670), 5 * i + *(_DWORD *)((char *)this + 674));
        GetMapHeader(&name, (SMapHeader *)(420 * i + *(_DWORD *)((char *)this + 678)));
      }
    }
    result = *(_DWORD *)((char *)this + 1042);
  }
  return result;
}
// 4EDE90: using guessed type int giMapSizeFilter;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0040BD50) --------------------------------------------------------
fileRequester *__thiscall fileRequester::fileRequester(fileRequester *this, int a2, int a3, int a4, char *a5, char *a6, char *a7)
{
  baseManager::baseManager((baseManager *)this);
  this->vtable = (managerVtable *)&fileRequester::_vftable_;
  strcpy(this->field_46, a5);
  strcpy(this->field_172, a6);
  this->field_41A = -1;
  this->field_412 = 0;
  this->field_416 = 0;
  this->field_29E = 0;
  this->field_2A2 = 0;
  this->field_2A6 = 0;
  this->field_3A = a2;
  this->field_3E = a3;
  this->field_42 = a4;
  strcpy(this->field_2AE, a7);
  if ( a4 != 1 && a4 != 4 )
  {
    fGutterMinY = 1126367232;
    fGutterTravelLength = 1116864512;
    iMaxListSize = 11;
  }
  else
  {
    fGutterMinY = 1123418112;
    fGutterTravelLength = 1116864512;
    iMaxListSize = 9;
  }
  if ( !fileRequester::MapExistsForFilter(this, giMapSizeFilter) )
    giMapSizeFilter = 4;
  fileRequester::InitializeFiles(this, (int)this->field_172, (int)this->field_46, 0);
  this->field_41E = -2;
  return this;
}
// 4EA040: using guessed type int (__stdcall *fileRequester___vftable_)(int);
// 4EDE90: using guessed type int giMapSizeFilter;
// 522BEC: using guessed type int fGutterTravelLength;
// 522BF0: using guessed type int fGutterMinY;
// 522BF4: using guessed type int iMaxListSize;

//----- (0040BEC0) --------------------------------------------------------
bool __thiscall fileRequester::MapExistsForFilter(void *this, int a2)
{
  int v2; // ST1C_4@1
  int v3; // ST20_4@1

  v2 = giMapSizeFilter;
  giMapSizeFilter = a2;
  v3 = fileRequester::InitializeFiles(this, (int)((char *)this + 370), (int)((char *)this + 70), 1);
  giMapSizeFilter = v2;
  return v3 > 0;
}
// 4EDE90: using guessed type int giMapSizeFilter;

//----- (0040BF30) --------------------------------------------------------
int __thiscall fileRequester::SetupFiles(int this)
{
  int v1; // ST18_4@1

  v1 = this;
  fileRequester::CleanUpData(this);
  *(_DWORD *)(v1 + 1042) = 0;
  *(_DWORD *)(v1 + 1046) = 0;
  *(_DWORD *)(v1 + 1054) = -2;
  *(_DWORD *)(v1 + 1050) = -1;
  return fileRequester::InitializeFiles((void *)v1, v1 + 370, v1 + 70, 0);
}

//----- (0040BFA0) --------------------------------------------------------
int __thiscall fileRequester::CleanUpData(int this)
{
  int result; // eax@7
  int v2; // [sp+Ch] [bp-1Ch]@1

  v2 = this;
  if ( *(_DWORD *)(this + 670) )
    operator delete(*(void **)(this + 670));
  *(_DWORD *)(v2 + 670) = 0;
  if ( *(_DWORD *)(v2 + 674) )
    operator delete(*(void **)(v2 + 674));
  *(_DWORD *)(v2 + 674) = 0;
  if ( *(_DWORD *)(v2 + 678) )
    operator delete(*(void **)(v2 + 678));
  result = v2;
  *(_DWORD *)(v2 + 678) = 0;
  return result;
}

//----- (0040C070) --------------------------------------------------------
int __thiscall fileRequester::Close(int this)
{
  int result; // eax@1
  int v2; // eax@2
  int v3; // [sp+Ch] [bp-Ch]@1

  v3 = this;
  result = this;
  if ( *(_DWORD *)(this + 50) )
  {
    KBChangeMenu(*(HMENU *)(this + 682));
    v2 = fileRequester::GetFilename(v3);
    strcpy(gLastFilename, (char *)v2);
    fileRequester::CleanUpData(v3);
    heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)(v3 + 54));
    operator delete(*(void **)(v3 + 54));
    result = v3;
    *(_DWORD *)(v3 + 50) = 0;
  }
  return result;
}

//----- (0040C100) --------------------------------------------------------
int __thiscall fileRequester::Open(void *this, int a2)
{
  int v2; // eax@20
  int v3; // eax@32
  int v4; // eax@41
  int v6; // [sp+Ch] [bp-44h]@1
  char *filnam; // [sp+10h] [bp-40h]@4
  iconWidget *v8; // [sp+14h] [bp-3Ch]@10
  heroWindow *thisa; // [sp+18h] [bp-38h]@1
  char a2a[12]; // [sp+1Ch] [bp-34h]@25
  int evt; // [sp+28h] [bp-28h]@15
  int v12; // [sp+2Ch] [bp-24h]@15
  int v13; // [sp+30h] [bp-20h]@18
  int v14; // [sp+40h] [bp-10h]@18
  int i; // [sp+44h] [bp-Ch]@18
  int v16; // [sp+48h] [bp-8h]@16
  unsigned __int8 v17; // [sp+4Ch] [bp-4h]@16

  v6 = (int)this;
  strcpy(gLastFilename, byte_4EDEC4);
  *(_DWORD *)(v6 + 682) = hmnuCurrent;
  KBChangeMenu(hmnuDflt);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
  {
    if ( *(_DWORD *)(v6 + 66) != 1 && *(_DWORD *)(v6 + 66) != 4 )
      filnam = "request.bin";
    else
      filnam = "requests.bin";
    *(_DWORD *)(v6 + 54) = heroWindow::heroWindow(thisa, *(_DWORD *)(v6 + 58), *(_DWORD *)(v6 + 62), filnam);
  }
  else
  {
    *(_DWORD *)(v6 + 54) = 0;
  }
  if ( !*(_DWORD *)(v6 + 54) )
    MemError();
  v8 = (iconWidget *)operator new(45);
  if ( v8 )
    *(_DWORD *)(v6 + 1067) = iconWidget::iconWidget(
                               v8,
                               346,
                               (signed __int64)*(float *)&fGutterTravelLength,
                               8,
                               17,
                               "scrollcn.icn",
                               4,
                               0,
                               14,
                               16,
                               1);
  else
    *(_DWORD *)(v6 + 1067) = 0;
  if ( !*(_DWORD *)(v6 + 1067) )
    MemError();
  heroWindow::AddWidget(*(heroWindow **)(v6 + 54), *(widget **)(v6 + 1067), -1);
  evt = 512;
  v12 = 3;
  if ( *(_DWORD *)(v6 + 66) == 3 )
  {
    v17 = 1;
    strcpy((char *)(v6 + 691), gpGame->lastSaveFile);
    v16 = FindLastToken((const char *)(v6 + 691), 46);
    if ( v16 )
      *(_BYTE *)v16 = 0;
    v13 = 15;
    v14 = v6 + 691;
    heroWindow::BroadcastMessage(*(heroWindow **)(v6 + 54), (tag_message *)&evt);
    v13 = 16;
    sprintf(gText, "File to Save:");
    v14 = (int)gText;
    heroWindow::BroadcastMessage(*(heroWindow **)(v6 + 54), (tag_message *)&evt);
    for ( i = 0; *(_DWORD *)(v6 + 1042) > i; ++i )
    {
      LOBYTE(v2) = stricmp((char *)(351 * i + *(_DWORD *)(v6 + 670)), (char *)(v6 + 691));
      if ( !v2 )
        *(_DWORD *)(v6 + 1050) = i;
    }
  }
  else
  {
    v17 = 0;
    if ( *(_DWORD *)(v6 + 66) == 1 )
    {
      i = 0;
      memset(a2a, 0, 9u);
      while ( i < 8 && gMapName[i] && gMapName[i] != 46 )
      {
        a2a[i] = gMapName[i];
        ++i;
      }
      for ( i = 0; *(_DWORD *)(v6 + 1042) > i; ++i )
      {
        LOBYTE(v3) = stricmp((char *)(351 * i + *(_DWORD *)(v6 + 670)), a2a);
        if ( !v3 )
        {
          *(_DWORD *)(v6 + 1050) = i;
          v17 = 1;
        }
      }
    }
    v13 = 16;
    sprintf(gText, "File to Load:");
    v14 = (int)gText;
    heroWindow::BroadcastMessage(*(heroWindow **)(v6 + 54), (tag_message *)&evt);
  }
  evt = 512;
  v12 = 51;
  v13 = 15;
  v14 = 201;
  heroWindow::BroadcastMessage(*(heroWindow **)(v6 + 54), (tag_message *)&evt);
  fileRequester::Update(v6, 0);
  if ( *(_DWORD *)(v6 + 1050) != -1 )
    v17 = 1;
  heroWindowManager::AddWindow(gpWindowManager, *(heroWindow **)(v6 + 54), -1, 1);
  if ( !*(_DWORD *)(v6 + 1042) )
    v17 = 0;
  if ( *(_DWORD *)(v6 + 66) == 3 )
  {
    LOBYTE(v4) = stricmp((char *)(v6 + 691), "NEWGAME");
    if ( !v4 )
    {
      if ( *(_DWORD *)(v6 + 1050) == -1 )
        v17 = 1;
    }
  }
  fileRequester::SetOK(v6, v17);
  *(_DWORD *)(v6 + 12) = 16384;
  *(_DWORD *)(v6 + 16) = a2;
  *(_DWORD *)(v6 + 50) = 1;
  strcpy((char *)(v6 + 20), "fileRequester");
  return 0;
}
// 522BEC: using guessed type int fGutterTravelLength;
// 40C100: using guessed type char a2[12];

//----- (0040C570) --------------------------------------------------------
int __thiscall fileRequester::SetOK(int this, int a2)
{
  int v3; // [sp+Ch] [bp-20h]@1
  int evt; // [sp+10h] [bp-1Ch]@1
  int v5; // [sp+14h] [bp-18h]@2
  int v6; // [sp+18h] [bp-14h]@4
  int v7; // [sp+28h] [bp-4h]@5

  v3 = this;
  evt = 512;
  if ( a2 )
    v5 = 6;
  else
    v5 = 5;
  v6 = 30722;
  if ( *(_DWORD *)(this + 50) == 1 )
    v7 = 8;
  else
    v7 = 4096;
  heroWindow::BroadcastMessage(*(heroWindow **)(this + 54), (tag_message *)&evt);
  if ( a2 )
    v5 = 5;
  else
    v5 = 6;
  v7 = 2;
  return heroWindow::BroadcastMessage(*(heroWindow **)(v3 + 54), (tag_message *)&evt);
}

//----- (0040C620) --------------------------------------------------------
signed int __thiscall fileRequester::Main(int this, int a2)
{
  int v2; // eax@9
  int v3; // eax@104
  int v4; // eax@171
  int v5; // eax@172
  signed int result; // eax@180
  signed int v7; // [sp+1Ch] [bp-410h]@50
  signed int v8; // [sp+20h] [bp-40Ch]@28
  int v9; // [sp+24h] [bp-408h]@27
  int v10; // [sp+28h] [bp-404h]@2
  int v11; // [sp+2Ch] [bp-400h]@1
  int v12; // [sp+30h] [bp-3FCh]@1
  char v13; // [sp+3Ch] [bp-3F0h]@99
  int v14; // [sp+168h] [bp-2C4h]@131
  int evt; // [sp+16Ch] [bp-2C0h]@108
  int v16; // [sp+170h] [bp-2BCh]@108
  int v17; // [sp+174h] [bp-2B8h]@108
  char *a2a; // [sp+184h] [bp-2A8h]@108
  int v19; // [sp+188h] [bp-2A4h]@50
  char a1; // [sp+18Ch] [bp-2A0h]@4
  unsigned int v21; // [sp+2B8h] [bp-174h]@108
  int i; // [sp+2BCh] [bp-170h]@7
  int v23; // [sp+2C0h] [bp-16Ch]@133
  int v24; // [sp+2C4h] [bp-168h]@133
  int v25; // [sp+2C8h] [bp-164h]@1
  char chr[4]; // [sp+2CCh] [bp-160h]@108

  v12 = this;
  v25 = 0;
  v11 = *(_DWORD *)a2;
  if ( v11 == 1 )
  {
    v10 = *(_DWORD *)(a2 + 4);
    if ( v10 == 64 )
    {
      if ( *(_DWORD *)(this + 1050) == -1 )
        strcpy(&a1, byte_4EDF2C);
      else
        strcpy(&a1, (char *)(*(_DWORD *)(this + 670) + 351 * *(_DWORD *)(this + 1050)));
      giMapSizeFilter = (giMapSizeFilter + 1) % 5;
      fileRequester::SetupFiles(v12);
      if ( strlen(&a1) )
      {
        for ( i = 0; *(_DWORD *)(v12 + 1042) > i; ++i )
        {
          LOBYTE(v2) = stricmp((char *)(351 * i + *(_DWORD *)(v12 + 670)), &a1);
          if ( !v2 )
            *(_DWORD *)(v12 + 1050) = i;
        }
      }
      fileRequester::Update(v12, 1);
    }
    else if ( v10 == 72 )
    {
      if ( *(_DWORD *)(this + 1050) > 0 )
      {
        --*(_DWORD *)(this + 1050);
        if ( *(_DWORD *)(this + 1046) > *(_DWORD *)(this + 1050) )
          --*(_DWORD *)(this + 1046);
        fileRequester::Update(this, 1);
      }
    }
    else if ( v10 == 80 && *(_DWORD *)(this + 1042) - 1 > *(_DWORD *)(this + 1050) )
    {
      ++*(_DWORD *)(this + 1050);
      if ( iMaxListSize + *(_DWORD *)(this + 1046) <= *(_DWORD *)(this + 1050) )
        ++*(_DWORD *)(this + 1046);
      fileRequester::Update(this, 1);
    }
  }
  else
  {
    if ( v11 != 512 )
      goto LABEL_167;
    v9 = *(_DWORD *)(a2 + 4);
    if ( v9 != 12 )
    {
      if ( v9 == 13 )
      {
        v8 = *(_DWORD *)(a2 + 8);
        if ( v8 > 30721 )
        {
          if ( v8 == 30722 )
          {
            if ( *(_DWORD *)(this + 1050) != -1 || *(_BYTE *)(this + 691) )
            {
              *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 8);
              v25 = 1;
            }
            else
            {
              NormalDialog("Please make a selection from the list, or press cancel.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
          }
        }
        else if ( v8 == 30721 )
        {
          *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 8);
          v25 = 1;
        }
        else if ( v8 == 1 )
        {
          if ( *(_DWORD *)(this + 1046) > 0 )
          {
            --*(_DWORD *)(this + 1046);
            fileRequester::Update(this, 1);
          }
        }
        else if ( v8 == 2 && iMaxListSize + *(_DWORD *)(this + 1046) < *(_DWORD *)(this + 1042) )
        {
          ++*(_DWORD *)(this + 1046);
          if ( iMaxListSize + *(_DWORD *)(this + 1046) - 1 >= *(_DWORD *)(this + 1042) )
            *(_DWORD *)(this + 1046) = *(_DWORD *)(this + 1042) - iMaxListSize;
          fileRequester::Update(this, 1);
        }
        goto LABEL_167;
      }
      if ( v9 != 14 )
        goto LABEL_167;
    }
    if ( *(_BYTE *)(a2 + 13) & 2 )
    {
      v19 = -1;
      v7 = *(_DWORD *)(a2 + 8);
      if ( v7 > 80 )
      {
        if ( v7 <= 30721 )
        {
          if ( v7 == 30721 )
          {
            v19 = 7;
          }
          else
          {
            switch ( v7 )
            {
              case 100:
                v19 = 0;
                break;
              case 101:
                v19 = 1;
                break;
              case 102:
                v19 = 2;
                break;
              case 103:
                v19 = 3;
                break;
              case 104:
                v19 = 4;
                break;
              case 82:
                v19 = 8;
                break;
              case 81:
                v19 = 9;
                break;
              case 86:
                v19 = 10;
                break;
              case 87:
                v19 = 11;
                break;
              case 85:
                v19 = 13;
                break;
              case 83:
                v19 = 14;
                break;
              case 84:
                v19 = 14;
                break;
              default:
                goto LABEL_67;
            }
          }
          goto LABEL_89;
        }
        if ( v7 != 30722 )
          goto LABEL_67;
        v19 = 6;
      }
      else if ( v7 == 80 )
      {
        v19 = 12;
      }
      else
      {
        if ( v7 != 15 )
        {
LABEL_67:
          if ( *(_DWORD *)(a2 + 8) < 200 || *(_DWORD *)(a2 + 8) >= 220 )
          {
            if ( *(_DWORD *)(a2 + 8) < 220 || *(_DWORD *)(a2 + 8) >= 240 )
            {
              if ( *(_DWORD *)(a2 + 8) < 240 || *(_DWORD *)(a2 + 8) >= 260 )
              {
                if ( *(_DWORD *)(a2 + 8) >= 260 && *(_DWORD *)(a2 + 8) < 280 )
                  v19 = 11;
              }
              else
              {
                v19 = 10;
              }
            }
            else
            {
              v19 = 9;
            }
          }
          else
          {
            v19 = 8;
          }
          goto LABEL_89;
        }
        v19 = 5;
      }
LABEL_89:
      if ( v19 >= 0 )
        NormalDialog((&gFileRequestHelp)[4 * v19], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      goto LABEL_167;
    }
    switch ( *(_DWORD *)(a2 + 8) )
    {
      case 0x64:
      case 0x65:
      case 0x66:
      case 0x67:
      case 0x68:
        i = *(_DWORD *)(a2 + 8) - 100;
        if ( fileRequester::MapExistsForFilter((void *)this, i) )
        {
          giMapSizeFilter = i;
          if ( *(_DWORD *)(v12 + 1050) == -1 )
            strcpy(&v13, byte_4EDFCC);
          else
            strcpy(&v13, (char *)(*(_DWORD *)(v12 + 670) + 351 * *(_DWORD *)(v12 + 1050)));
          fileRequester::SetupFiles(v12);
          if ( strlen(&v13) )
          {
            for ( i = 0; *(_DWORD *)(v12 + 1042) > i; ++i )
            {
              LOBYTE(v3) = stricmp((char *)(351 * i + *(_DWORD *)(v12 + 670)), &v13);
              if ( !v3 )
                *(_DWORD *)(v12 + 1050) = i;
            }
          }
          fileRequester::Update(v12, 1);
        }
        else
        {
          if ( iLastMsgNumHumanPlayers == 1 )
            sprintf(gText, "No maps exist for %d human player at that size.", iLastMsgNumHumanPlayers);
          else
            sprintf(gText, "No maps exist for %d human players at that size.", iLastMsgNumHumanPlayers);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
        break;
      case 0xF:
        evt = 512;
        v16 = 7;
        v17 = 15;
        heroWindow::BroadcastMessage(*(heroWindow **)(this + 54), (tag_message *)&evt);
        memset(chr, 0, 9u);
        strcpy(chr, a2a);
        v21 = strlen(chr);
        for ( i = 0; i < (signed int)v21; ++i )
        {
          if ( (chr[i] < 65 || chr[i] > 90)
            && (chr[i] < 97 || chr[i] > 122)
            && (chr[i] < 48 || chr[i] > 57)
            && chr[i] != 95
            && chr[i] != 32
            && !FindToken("$%'-_@~`!(){}^#&+,;=[].", *(_DWORD *)&chr[i]) )
            chr[i] = 0;
        }
        for ( i = strlen(chr) - 1; i >= 0; --i )
        {
          if ( chr[i] == 32 )
            chr[i] = 0;
          else
            i = -1;
        }
        if ( strlen(chr) && chr[0] > 32 )
        {
          *(_DWORD *)(v12 + 1050) = -1;
          strcpy((char *)(v12 + 691), chr);
          fileRequester::SetOK(v12, 1);
        }
        v16 = 3;
        v17 = 15;
        a2a = (char *)(v12 + 691);
        heroWindow::BroadcastMessage(*(heroWindow **)(v12 + 54), (tag_message *)&evt);
        fileRequester::Update(v12, 1);
        break;
      case 3:
        v14 = *(_DWORD *)(this + 1042) - (iMaxListSize - 1);
        if ( v14 < 1 )
          v14 = 1;
        v24 = *(_DWORD *)(a2 + 16);
        v23 = (unsigned __int64)(signed __int64)((double)*(signed int *)(a2 + 20)
                                               - ((double)*(signed int *)(this + 62)
                                                + *(float *)&fGutterTravelLength))
            - 9;
        *(_DWORD *)(this + 1046) = 100
                                 * v23
                                 / (signed int)(signed __int64)(*(float *)&fGutterMinY * 100.0 / (double)v14);
        if ( iMaxListSize + *(_DWORD *)(this + 1046) - 1 >= *(_DWORD *)(this + 1042) )
          *(_DWORD *)(this + 1046) = *(_DWORD *)(this + 1042) - iMaxListSize;
        if ( *(_DWORD *)(this + 1046) < 0 )
          *(_DWORD *)(this + 1046) = 0;
        fileRequester::Update(this, 1);
        break;
      case 0xE:
        fileRequester::DoKnob(this);
        break;
      default:
        if ( *(_DWORD *)(a2 + 8) < 200 || *(_DWORD *)(a2 + 8) > 219 )
        {
          if ( *(_DWORD *)(a2 + 8) < 220 || *(_DWORD *)(a2 + 8) > 239 )
          {
            if ( *(_DWORD *)(a2 + 8) < 240 || *(_DWORD *)(a2 + 8) > 259 )
            {
              if ( *(_DWORD *)(a2 + 8) < 260 || *(_DWORD *)(a2 + 8) > 279 )
              {
                if ( *(_DWORD *)(a2 + 8) < 20 || *(_DWORD *)(a2 + 8) > 39 )
                  goto LABEL_167;
                i = *(_DWORD *)(a2 + 8) - 20;
              }
              else
              {
                i = *(_DWORD *)(a2 + 8) - 260;
              }
            }
            else
            {
              i = *(_DWORD *)(a2 + 8) - 240;
            }
          }
          else
          {
            i = *(_DWORD *)(a2 + 8) - 220;
          }
        }
        else
        {
          i = *(_DWORD *)(a2 + 8) - 200;
        }
        if ( i + *(_DWORD *)(this + 1046) == *(_DWORD *)(this + 1050) )
        {
          *(_DWORD *)(a2 + 24) = 30722;
          *(_DWORD *)(a2 + 8) = 30722;
          v25 = 1;
        }
        else if ( i + *(_DWORD *)(this + 1046) < *(_DWORD *)(this + 1042) )
        {
          *(_DWORD *)(this + 1050) = i + *(_DWORD *)(this + 1046);
          fileRequester::SetOK(this, 1);
          fileRequester::Update(v12, 1);
        }
        break;
    }
  }
  if ( v25 != 1 )
    goto LABEL_184;
LABEL_167:
  if ( *(_DWORD *)(v12 + 66) == 2 )
  {
    if ( *(_DWORD *)(v12 + 1050) >= 0 )
    {
      if ( *(_DWORD *)(a2 + 24) != 30721 )
      {
        LOBYTE(v4) = stricmp((char *)(*(_DWORD *)(v12 + 674) + 5 * *(_DWORD *)(v12 + 1050)), ".GMC");
        if ( v4 )
        {
          LOBYTE(v5) = stricmp((char *)(*(_DWORD *)(v12 + 674) + 5 * *(_DWORD *)(v12 + 1050)), ".GXC");
          if ( v5 )
          {
            i = *(_BYTE *)(5 * *(_DWORD *)(v12 + 1050) + *(_DWORD *)(v12 + 674) + 3) - 48;
            if ( i < iLastMsgNumHumanPlayers && giDebugLevel < 2 )
            {
              sprintf(
                gText,
                "The game you have chosen only has slots for %d human(s).  You need one with room for at least %d humans.",
                i,
                iLastMsgNumHumanPlayers);
              NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
              v25 = 0;
            }
            if ( i > iLastMsgNumHumanPlayers )
            {
              sprintf(
                gText,
                "The game you have chosen was being played with %d humans. Is it OK if the computer takes the place of the last %d human(s)?",
                i,
                i - iLastMsgNumHumanPlayers);
              NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
              if ( gpWindowManager->buttonPressedCode != 30725 )
                v25 = 0;
            }
          }
        }
      }
    }
  }
  if ( v25 )
  {
    *(_DWORD *)a2 = 16384;
    *(_DWORD *)(a2 + 4) = 4;
    result = 2;
  }
  else
  {
LABEL_184:
    result = 1;
  }
  return result;
}
// 4EDE90: using guessed type int giMapSizeFilter;
// 4F21F0: using guessed type int giDebugLevel;
// 522BEC: using guessed type int fGutterTravelLength;
// 522BF0: using guessed type int fGutterMinY;
// 522BF4: using guessed type int iMaxListSize;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0040D7C0) --------------------------------------------------------
void __thiscall fileRequester::DoKnob(int this)
{
  int v1; // [sp+2Ch] [bp-74h]@1
  char v2; // [sp+30h] [bp-70h]@19
  tag_message a2; // [sp+4Ch] [bp-54h]@1
  int v4; // [sp+68h] [bp-38h]@10
  int y; // [sp+6Ch] [bp-34h]@1
  int v6; // [sp+70h] [bp-30h]@1
  int v7; // [sp+78h] [bp-28h]@5
  int x; // [sp+8Ch] [bp-14h]@1
  int v9; // [sp+90h] [bp-10h]@1
  int v10; // [sp+94h] [bp-Ch]@1
  double v11; // [sp+98h] [bp-8h]@1

  v1 = this;
  v10 = *(_DWORD *)(this + 1046);
  v11 = *(float *)&fGutterMinY / (double)(*(_DWORD *)(this + 1042) - (iMaxListSize - 1));
  mouseManager::MouseCoords(&x, &y);
  v9 = y - *(_WORD *)(*(_DWORD *)(v1 + 1067) + 26);
  inputManager::Flush(gpInputManager);
  memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
  while ( v6 != 16 && v6 != 64 )
  {
    if ( v6 == 4 )
    {
      if ( (double)v7 < (double)v9 + *(float *)&fGutterTravelLength )
        v7 = (signed __int64)((double)v9 + *(float *)&fGutterTravelLength);
      if ( (double)v7 > (double)v9 + *(float *)&fGutterTravelLength + *(float *)&fGutterMinY )
        v7 = (signed __int64)((double)v9 + *(float *)&fGutterTravelLength + *(float *)&fGutterMinY);
      (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
      *(_WORD *)(*(_DWORD *)(v1 + 1067) + 26) = v7 - v9;
      if ( *(_DWORD *)(v1 + 1042) <= iMaxListSize )
      {
        heroWindow::DrawWindow(*(heroWindow **)(v1 + 54), 1, 0, 32767);
      }
      else
      {
        v4 = (signed __int64)(((double)*(_WORD *)(*(_DWORD *)(v1 + 1067) + 26) - *(float *)&fGutterTravelLength) / v11);
        if ( v4 == v10 )
        {
          heroWindow::DrawWindow(*(heroWindow **)(v1 + 54), 1, 0, 32767);
        }
        else
        {
          if ( *(_DWORD *)(v1 + 1042) - iMaxListSize < v4 )
            v4 = *(_DWORD *)(v1 + 1042) - iMaxListSize;
          if ( v4 < 0 )
            v4 = 0;
          *(_DWORD *)(v1 + 1046) = v4;
          fileRequester::Update(v1, 0);
          *(_WORD *)(*(_DWORD *)(v1 + 1067) + 26) = v7 - v9;
          heroWindow::DrawWindow(*(heroWindow **)(v1 + 54), 1, 0, 32767);
          v10 = v4;
        }
      }
    }
    Process1WindowsMessage();
    memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v2), 0x1Cu);
  }
  *(_WORD *)(*(_DWORD *)(v1 + 1067) + 22) &= 0xFFFEu;
  fileRequester::Update(v1, 1);
}
// 522BEC: using guessed type int fGutterTravelLength;
// 522BF0: using guessed type int fGutterMinY;
// 522BF4: using guessed type int iMaxListSize;

//----- (0040DA80) --------------------------------------------------------
void __thiscall fileRequester::Update(int this, int a2)
{
  int v2; // [sp+14h] [bp-1B4h]@1
  int evt; // [sp+24h] [bp-1A4h]@1
  int v4; // [sp+28h] [bp-1A0h]@5
  int v5; // [sp+2Ch] [bp-19Ch]@5
  int v6; // [sp+3Ch] [bp-18Ch]@5
  int i; // [sp+1B4h] [bp-14h]@3
  int v8; // [sp+1C4h] [bp-4h]@1

  v2 = this;
  evt = 512;
  v8 = 0;
  if ( *(_DWORD *)(this + 66) == 1 || *(_DWORD *)(this + 66) == 4 )
  {
    for ( i = 0; i < 5; ++i )
    {
      v4 = 4;
      v5 = i + 100;
      v6 = (i == giMapSizeFilter) + 2 * i + 9;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    }
    if ( *(_DWORD *)(v2 + 1050) == -1 && *(_DWORD *)(v2 + 1042) > 0 )
      *(_DWORD *)(v2 + 1050) = 0;
    fileRequester::SetOK(v2, 1);
    v4 = 4;
    v5 = 82;
    switch ( *(_BYTE *)(420 * *(_DWORD *)(v2 + 1050) + *(_DWORD *)(v2 + 678) + 6) )
    {
      case 0x24:
        v6 = 26;
        break;
      case 0x48:
        v6 = 27;
        break;
      case 0x6C:
        v6 = 28;
        break;
      default:
        v6 = 29;
        break;
    }
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    v5 = 81;
    v6 = *(_BYTE *)(420 * *(_DWORD *)(v2 + 1050) + *(_DWORD *)(v2 + 678) + 26) + 19;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    v5 = 86;
    v6 = *(_BYTE *)(420 * *(_DWORD *)(v2 + 1050) + *(_DWORD *)(v2 + 678) + 29) + 30;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    v5 = 87;
    v6 = *(_BYTE *)(420 * *(_DWORD *)(v2 + 1050) + *(_DWORD *)(v2 + 678) + 34) + 36;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    v4 = 3;
    v6 = (int)gText;
    sprintf(gText, "%s", *(_DWORD *)(v2 + 678) + 420 * *(_DWORD *)(v2 + 1050) + 58);
    v5 = 80;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    sprintf(gText, "%s", cDifficulty[*(_BYTE *)(420 * *(_DWORD *)(v2 + 1050) + *(_DWORD *)(v2 + 678) + 4)]);
    v5 = 84;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    sprintf(gText, "%s", *(_DWORD *)(v2 + 678) + 420 * *(_DWORD *)(v2 + 1050) + 118);
    v5 = 85;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
  }
  for ( i = 0; i < iMaxListSize; ++i )
  {
    if ( i + *(_DWORD *)(v2 + 1046) < *(_DWORD *)(v2 + 1042) )
    {
      v5 = i + 20;
      v4 = 5;
      v6 = 4;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
      if ( *(_DWORD *)(v2 + 66) == 4 || *(_DWORD *)(v2 + 66) == 1 )
      {
        v5 = i + 200;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 220;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 240;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 260;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v4 = 4;
        v5 = i + 200;
        switch ( *(_BYTE *)(420 * (i + *(_DWORD *)(v2 + 1046)) + *(_DWORD *)(v2 + 678) + 6) )
        {
          case 0x24:
            v6 = 26;
            break;
          case 0x48:
            v6 = 27;
            break;
          case 0x6C:
            v6 = 28;
            break;
          default:
            v6 = 29;
            break;
        }
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 220;
        v6 = *(_BYTE *)(420 * (i + *(_DWORD *)(v2 + 1046)) + *(_DWORD *)(v2 + 678) + 26) + 19;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 240;
        v6 = *(_BYTE *)(420 * (i + *(_DWORD *)(v2 + 1046)) + *(_DWORD *)(v2 + 678) + 29) + 30;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 260;
        v6 = *(_BYTE *)(420 * (i + *(_DWORD *)(v2 + 1046)) + *(_DWORD *)(v2 + 678) + 34) + 36;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
      }
      v4 = 3;
      if ( *(_DWORD *)(v2 + 66) != 4 && *(_DWORD *)(v2 + 66) != 1 )
        sprintf(gText, "%s", *(_DWORD *)(v2 + 670) + 351 * (i + *(_DWORD *)(v2 + 1046)));
      else
        sprintf(gText, "%s", *(_DWORD *)(v2 + 678) + 420 * (i + *(_DWORD *)(v2 + 1046)) + 58);
      v6 = (int)gText;
      v5 = i + 20;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
    }
    else
    {
      v4 = 6;
      v6 = 4;
      v5 = i + 20;
      heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
      if ( *(_DWORD *)(v2 + 66) == 4 || *(_DWORD *)(v2 + 66) == 1 )
      {
        v5 = i + 200;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 220;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 240;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
        v5 = i + 260;
        heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
      }
    }
    v5 = i + 20;
    v4 = 8;
    if ( i + *(_DWORD *)(v2 + 1046) == *(_DWORD *)(v2 + 1050) )
      v6 = 2;
    else
      v6 = 1;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
  }
  v5 = 15;
  v4 = 5;
  v6 = 2;
  heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
  if ( *(_DWORD *)(v2 + 1050) != -1 )
  {
    v4 = 3;
    if ( *(_DWORD *)(v2 + 66) != 1 && *(_DWORD *)(v2 + 66) != 4 )
      sprintf(gText, "%s", *(_DWORD *)(v2 + 670) + 351 * *(_DWORD *)(v2 + 1050));
    else
      sprintf(gText, "%s", *(_DWORD *)(v2 + 678) + 420 * *(_DWORD *)(v2 + 1050) + 58);
    v6 = (int)gText;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
  }
  if ( *(_DWORD *)(v2 + 66) == 1 || *(_DWORD *)(v2 + 66) == 2 || *(_DWORD *)(v2 + 66) == 4 )
  {
    v4 = 6;
    v6 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)(v2 + 54), (tag_message *)&evt);
  }
  if ( *(_DWORD *)(v2 + 1042) > iMaxListSize )
    *(_WORD *)(*(_DWORD *)(v2 + 1067) + 26) = (signed __int64)((double)*(signed int *)(v2 + 1046)
                                                             * (*(float *)&fGutterMinY
                                                              / (double)(*(_DWORD *)(v2 + 1042) - iMaxListSize))
                                                             + *(float *)&fGutterTravelLength);
  else
    *(_WORD *)(*(_DWORD *)(v2 + 1067) + 26) = (signed __int64)(*(float *)&fGutterMinY / 2.0
                                                             + *(float *)&fGutterTravelLength);
  if ( a2 )
    heroWindow::DrawWindow(*(heroWindow **)(v2 + 54), 1, 0, 32767);
}
// 4EDE90: using guessed type int giMapSizeFilter;
// 4F6928: using guessed type char *cDifficulty[5];
// 522BEC: using guessed type int fGutterTravelLength;
// 522BF0: using guessed type int fGutterMinY;
// 522BF4: using guessed type int iMaxListSize;

//----- (0040E630) --------------------------------------------------------
int __thiscall fileRequester::GetFilename(int this)
{
  int result; // eax@4
  int v2; // [sp+Ch] [bp-4h]@1

  v2 = this;
  if ( *(_DWORD *)(this + 66) == 3
    || *(_DWORD *)(this + 1050) >= 0 && *(_DWORD *)(this + 1042) > *(_DWORD *)(this + 1050) )
  {
    if ( *(_DWORD *)(this + 1050) == -1 )
    {
      sprintf(gText, "%s%s", this + 691, this + 686);
    }
    else if ( *(_DWORD *)(this + 66) != 2 && *(_DWORD *)(this + 66) != 4 && *(_DWORD *)(this + 66) != 1 )
    {
      sprintf(gText, "%s%s", *(_DWORD *)(this + 670) + 351 * *(_DWORD *)(this + 1050), this + 686);
    }
    else
    {
      sprintf(
        gText,
        "%s%s",
        *(_DWORD *)(this + 670) + 351 * *(_DWORD *)(this + 1050),
        *(_DWORD *)(this + 674) + 5 * *(_DWORD *)(this + 1050));
    }
    strcpy((char *)(v2 + 691), gText);
    result = v2 + 691;
  }
  else
  {
    result = (int)off_4EE0E0;
  }
  return result;
}
// 4EE0E0: using guessed type void *off_4EE0E0;

//----- (0040E790) --------------------------------------------------------
char __cdecl InitNetHost()
{
  char result; // al@8
  int v1; // eax@9
  char v2; // al@13
  char v3; // [sp+14h] [bp-2Ch]@9
  int v4; // [sp+3Ch] [bp-4h]@13

  switch ( iInitNetHostStatus )
  {
    case 0:
      if ( nb_init(5, 0) == 1 )
      {
        ShutDown("NETBIOS is not loaded.");
      }
      else
      {
        ++iInitNetHostStatus;
        gbRemoteOn = 1;
      }
      goto LABEL_17;
    case 1:
      if ( nb_stat(0) & 2 )
      {
        result = 1;
      }
      else
      {
        ++iInitNetHostStatus;
LABEL_17:
        result = 0;
      }
      return result;
    case 2:
      v1 = Random(0, 99999);
      sprintf(&v3, "H2H%d", v1);
      if ( nb_sess(0, (int)&v3) )
        ShutDown("Network initialization failed");
      else
        ++iInitNetHostStatus;
      goto LABEL_17;
    case 3:
      v2 = nb_stat(0);
      v4 = (unsigned __int8)v2;
      if ( !(v2 & 2) )
        goto LABEL_17;
      return 1;
    default:
      goto LABEL_17;
  }
}
// 4EE11C: using guessed type char iInitNetHostStatus;
// 4F7494: using guessed type int gbRemoteOn;

//----- (0040E8F0) --------------------------------------------------------
char __cdecl InitNetGuest()
{
  int v0; // eax@10
  char result; // al@22
  char v2; // [sp+10h] [bp-30h]@14
  char v3; // [sp+14h] [bp-2Ch]@10

  switch ( iInitNetGuestStatus )
  {
    case 0:
      if ( nb_init(5, 6) == 1 )
      {
        ShutDown("NETBIOS is not loaded.");
      }
      else
      {
        gbRemoteOn = 1;
        ++iInitNetGuestStatus;
      }
      goto LABEL_24;
    case 1:
      if ( nb_stat(6) & 2 )
        iInitNetGuestStatus += 3;
      else
        ++iInitNetGuestStatus;
      goto LABEL_24;
    case 2:
      v0 = Random(0, 99999);
      sprintf(&v3, "H2G%d", v0);
      if ( nb_sess(0, (int)&v3) )
        ++iNameRetryCount;
      else
        ++iInitNetGuestStatus;
      goto LABEL_24;
    case 3:
      v2 = nb_stat(6);
      if ( v2 & 2 )
      {
        ++iInitNetGuestStatus;
      }
      else if ( v2 & 0x80 )
      {
        ++iNameRetryCount;
        --iInitNetGuestStatus;
      }
      goto LABEL_24;
    case 4:
      if ( nb_sess(1, 0) )
      {
        sprintf(gText, "Network initialization failed");
        ShutDown(gText);
      }
      result = 1;
      break;
    default:
LABEL_24:
      result = 0;
      break;
  }
  return result;
}
// 4EE120: using guessed type char iInitNetGuestStatus;
// 4EE124: using guessed type int iNameRetryCount;
// 4F7494: using guessed type int gbRemoteOn;

//----- (0040EAA0) --------------------------------------------------------
char __cdecl WaitForHost()
{
  return !iWaitForHostStatus && nb_stat(0) & 1;
}
// 4EE168: using guessed type char iWaitForHostStatus;

//----- (0040EB00) --------------------------------------------------------
char __cdecl WaitForGuest()
{
  char result; // al@4

  if ( iWaitForGuestStatus )
  {
    if ( iWaitForGuestStatus == 1 )
    {
      if ( nb_stat(6) & 1 )
      {
        nb_sess(5, 6);
        return 1;
      }
      if ( KBTickCount() > iLastBroadcastTime + 500 )
      {
        iLastBroadcastTime = KBTickCount();
        nb_snd(0, 0, 0);
      }
    }
    result = 0;
  }
  else
  {
    if ( !nb_sess(3, 6) )
      ++iWaitForGuestStatus;
    result = 0;
  }
  return result;
}
// 4EE1AC: using guessed type char iWaitForGuestStatus;
// 4EE1B0: using guessed type int iLastBroadcastTime;

//----- (0040EBF0) --------------------------------------------------------
int __cdecl nbnet_init()
{
  LogStr("GUON1");
  if ( (unsigned __int8)GameMode == 1 )
  {
    giWaitType = 4;
    sprintf(gText, "Initializing network.\n\n  Press 'CANCEL' to abort.");
    NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( !gbFunctionComplete )
      ShutDown(0);
    giWaitType = 1;
    sprintf(gText, "Waiting On Guest.\n\n  Press 'CANCEL' to abort.");
    LogStr("GUON2");
    NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    LogStr("GUON3");
    if ( !gbFunctionComplete )
      ShutDown(0);
    LogStr("GUON4");
  }
  else if ( (unsigned __int8)GameMode == 2 )
  {
    giWaitType = 3;
    sprintf(gText, "Initializing network.\n\n  Press 'CANCEL' to abort.");
    NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( !gbFunctionComplete )
      ShutDown(0);
    giWaitType = 2;
    sprintf(gText, "Waiting On Host.\n\n  Press 'CANCEL' to abort.");
    NormalDialog(gText, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( !gbFunctionComplete )
      ShutDown(0);
  }
  LogStr("GUON5");
  return 0;
}
// 51257C: using guessed type char GameMode;
// 523018: using guessed type int gbFunctionComplete;
// 524750: using guessed type int giWaitType;

//----- (0040EDB0) --------------------------------------------------------
BOOL __thiscall DoTradingPost(void *this, int a2)
{
  iconWidget *v3; // [sp+18h] [bp-24h]@6
  heroWindow *thisa; // [sp+1Ch] [bp-20h]@1

  bIsMarketPlace = (int)this;
  fTradingPostEfficiency = a2;
  bTradeMade = 0;
  tpX = 159;
  tpY = 23;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    tpWindow = heroWindow::heroWindow(thisa, tpX, tpY, "tradpost.bin");
  else
    tpWindow = 0;
  if ( !tpWindow )
    MemError();
  leftResource = -1;
  rightResource = -1;
  qtyToTrade = 0;
  v3 = (iconWidget *)operator new(45);
  if ( v3 )
    tradeKnob = (widget *)iconWidget::iconWidget(v3, 67, 204, 17, 8, "tradpost.icn", 2, 0, 31, 16, 1);
  else
    tradeKnob = 0;
  if ( !tradeKnob )
    MemError();
  heroWindow::AddWidget(tpWindow, tradeKnob, -1);
  UpdateTradingPost(0);
  heroWindowManager::DoDialog(gpWindowManager, tpWindow, (int (__fastcall *)(tag_message *))TradingPostHandler, 0);
  return operator delete(tpWindow);
}
// 522BF8: using guessed type int fTradingPostEfficiency;
// 522C00: using guessed type int leftResource;
// 522C10: using guessed type int bTradeMade;
// 522C14: using guessed type int qtyToTrade;
// 522C1C: using guessed type int rightResource;
// 522C24: using guessed type int bIsMarketPlace;

//----- (0040EF20) --------------------------------------------------------
void __thiscall UpdateTradingPost(void *this)
{
  void *v1; // [sp+Ch] [bp-3Ch]@1
  int v2; // [sp+10h] [bp-38h]@46
  int v3; // [sp+14h] [bp-34h]@46
  char v4; // [sp+18h] [bp-30h]@46
  int v5; // [sp+1Ch] [bp-2Ch]@5
  int v6; // [sp+20h] [bp-28h]@5
  int j; // [sp+24h] [bp-24h]@19
  int evt; // [sp+28h] [bp-20h]@1
  int v9; // [sp+2Ch] [bp-1Ch]@11
  int v10; // [sp+30h] [bp-18h]@11
  int v11; // [sp+40h] [bp-8h]@11
  int i; // [sp+44h] [bp-4h]@11

  v1 = this;
  evt = 512;
  if ( leftResource == -1 || rightResource == -1 || rightResource == leftResource )
  {
    if ( bTradeMade )
      sprintf(
        gText,
        "{%s}\n\nYou have received quite a bargain.  I expect to make no profit on the deal.  Can I interest you in any of my other wares?",
        &aMarketplace_0[("Trading Post" - "Marketplace") & ((bIsMarketPlace != 0) - 1)]);
    else
      sprintf(
        gText,
        "{%s}\n\nPlease inspect our fine wares.  If you feel like offering a trade, click on the items you wish to trade with and for.",
        &aMarketplace_1[("Trading Post" - "Marketplace") & ((bIsMarketPlace != 0) - 1)]);
  }
  else
  {
    if ( bLeftDenominated )
    {
      v5 = 1;
      v6 = iTradeRatio;
    }
    else
    {
      v5 = iTradeRatio;
      v6 = 1;
    }
    sprintf(
      gText,
      "{%s}\n\nI can offer you %d %s of %s for %d %s of %s.",
      &aMarketplace[("Trading Post" - "Marketplace") & ((bIsMarketPlace != 0) - 1)],
      v6,
      &aUnits_0[("unit" - "units") & ((v6 > 1) - 1)],
      gResourceNames[rightResource],
      v5,
      &aUnits[("unit" - "units") & ((v5 > 1) - 1)],
      gResourceNames[leftResource]);
  }
  evt = 512;
  v9 = 3;
  v10 = 1;
  v11 = (int)gText;
  heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
  for ( i = 20; i <= 31; ++i )
  {
    if ( leftResource == -1 || rightResource == -1 || rightResource == leftResource )
      v9 = 6;
    else
      v9 = 5;
    v10 = i;
    v11 = 6;
    heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
  }
  for ( j = 0; j < 2; ++j )
  {
    if ( leftResource != -1 && rightResource != -1 && rightResource != leftResource )
    {
      v9 = 4;
      if ( j )
        v10 = 21;
      else
        v10 = 20;
      if ( j )
        v11 = rightResource;
      else
        v11 = leftResource;
      heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
      v9 = 3;
      v11 = (int)gText;
      if ( j )
      {
        v10 = 24;
        if ( bLeftDenominated )
          sprintf(gText, "%d", iTradeRatio * qtyToTrade);
        else
          sprintf(gText, "%d", qtyToTrade);
      }
      else
      {
        v10 = 23;
        if ( bLeftDenominated )
          sprintf(gText, "%d", qtyToTrade);
        else
          sprintf(gText, "%d", iTradeRatio * qtyToTrade);
      }
      heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
    }
    for ( i = 0; i < 7; ++i )
    {
      v9 = 3;
      v11 = (int)gText;
      if ( j )
      {
        v10 = i + 100;
        if ( leftResource == -1 )
        {
          sprintf(gText, byte_4EE4A0);
        }
        else if ( leftResource == i )
        {
          sprintf(gText, "n/a");
        }
        else
        {
          ComputeTradeRatios(leftResource, i, (int)&v2, (int)&v3, (int)&v4);
          if ( v3 )
            sprintf(gText, "%d", v2);
          else
            sprintf(gText, "1/%d", v2);
        }
      }
      else
      {
        v10 = i + 60;
        sprintf(gText, "%d", gpCurPlayer->resources[i]);
      }
      heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
      if ( (j || leftResource != i) && (j != 1 || rightResource != i) )
        v9 = 6;
      else
        v9 = 5;
      if ( j )
        v10 = i + 90;
      else
        v10 = i + 50;
      v11 = 4;
      heroWindow::BroadcastMessage(tpWindow, (tag_message *)&evt);
    }
  }
  if ( iMaxUnitsToTrade )
    tradeKnob->offsetX = (unsigned int)(170 * qtyToTrade / iMaxUnitsToTrade) + 67;
  else
    tradeKnob->offsetX = 67;
  if ( v1 )
  {
    heroWindow::DrawWindow(tpWindow, 0);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, tpX + 32, tpY, 0x102u, 418);
  }
}
// 522BFC: using guessed type int bLeftDenominated;
// 522C00: using guessed type int leftResource;
// 522C04: using guessed type int iMaxUnitsToTrade;
// 522C10: using guessed type int bTradeMade;
// 522C14: using guessed type int qtyToTrade;
// 522C18: using guessed type int iTradeRatio;
// 522C1C: using guessed type int rightResource;
// 522C24: using guessed type int bIsMarketPlace;

//----- (0040F4C0) --------------------------------------------------------
int __fastcall ComputeTradeRatios(int a1, int a2, int a3, int a4, int a5)
{
  float v5; // ST24_4@1
  __int16 v6; // fps@1
  char v7; // c0@1
  int result; // eax@2
  float v9; // [sp+20h] [bp-Ch]@1

  v5 = (double)(unsigned __int16)coreRatio[a1] * *(float *)&fTradingPostEfficiency;
  UNDEF(v6);
  v9 = (double)(unsigned __int16)coreRatio[a2] / v5;
  if ( v7 )
  {
    *(_DWORD *)a4 = 1;
    *(_DWORD *)a3 = (signed __int64)(1.0 / v9);
    result = gpCurPlayer->resources[a1];
    *(_DWORD *)a5 = result;
  }
  else
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)a3 = (signed __int64)(v9 + 0.999);
    result = gpCurPlayer->resources[a1] / *(_DWORD *)a3;
    *(_DWORD *)a5 = result;
  }
  return result;
}
// 4EE2A8: using guessed type __int16 coreRatio[];
// 522BF8: using guessed type int fTradingPostEfficiency;

//----- (0040F5A0) --------------------------------------------------------
void __stdcall DoTradeKnob(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // [sp+Ch] [bp-90h]@12
  char v8; // [sp+28h] [bp-74h]@12
  char v9; // [sp+44h] [bp-58h]@10
  tag_message a2a; // [sp+60h] [bp-3Ch]@9
  int v11; // [sp+7Ch] [bp-20h]@10
  int v12; // [sp+98h] [bp-4h]@4

  while ( a1 != 16 && a1 != 64 )
  {
    if ( a1 == 4 )
    {
      v12 = a5 - tpX - 75;
      qtyToTrade = v12 * (iMaxUnitsToTrade + 1) / 187;
      if ( qtyToTrade < 0 )
        qtyToTrade = 0;
      if ( iMaxUnitsToTrade < qtyToTrade )
        qtyToTrade = iMaxUnitsToTrade;
      (*(void (__fastcall **)(mouseManager *, int))(LODWORD(gpMouseManager->vtable) + 8))(
        gpMouseManager,
        v12 * (iMaxUnitsToTrade + 1) % 187);
      UpdateTradingPost((void *)1);
    }
    Process1WindowsMessage();
    memcpy(&a1, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2a), 0x1Cu);
    if ( a1 == 4 )
    {
      memcpy(&v11, inputManager::PeekEvent(gpInputManager, &v9), 0x1Cu);
      while ( v11 == 4 )
      {
        memcpy(&a1, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v8), 0x1Cu);
        memcpy(&v11, inputManager::PeekEvent(gpInputManager, &v7), 0x1Cu);
      }
    }
  }
  UpdateTradingPost((void *)1);
}
// 522C04: using guessed type int iMaxUnitsToTrade;
// 522C14: using guessed type int qtyToTrade;

//----- (0040F6F0) --------------------------------------------------------
int __cdecl SetupNewTrade()
{
  qtyToTrade = 0;
  return ComputeTradeRatios(
           leftResource,
           rightResource,
           (int)&iTradeRatio,
           (int)&bLeftDenominated,
           (int)&iMaxUnitsToTrade);
}
// 522BFC: using guessed type int bLeftDenominated;
// 522C00: using guessed type int leftResource;
// 522C04: using guessed type int iMaxUnitsToTrade;
// 522C14: using guessed type int qtyToTrade;
// 522C18: using guessed type int iTradeRatio;
// 522C1C: using guessed type int rightResource;

//----- (0040F730) --------------------------------------------------------
signed int __thiscall TradingPostHandler(tag_message *this)
{
  signed int result; // eax@44
  int v2; // [sp-1Ch] [bp-48h]@10
  int v3; // [sp-18h] [bp-44h]@10
  int v4; // [sp-14h] [bp-40h]@10
  int v5; // [sp-10h] [bp-3Ch]@10
  int v6; // [sp-Ch] [bp-38h]@10
  int v7; // [sp-8h] [bp-34h]@10
  int v8; // [sp-4h] [bp-30h]@10
  int v9; // [sp+Ch] [bp-20h]@20
  int v10; // [sp+10h] [bp-1Ch]@3
  int v11; // [sp+14h] [bp-18h]@2
  tag_message *v12; // [sp+18h] [bp-14h]@1
  int v13; // [sp+1Ch] [bp-10h]@1
  int v14; // [sp+20h] [bp-Ch]@11
  int v15; // [sp+24h] [bp-8h]@5
  int v16; // [sp+28h] [bp-4h]@1

  v12 = this;
  v16 = 0;
  v13 = 0;
  if ( this->eventCode == 512 )
  {
    v11 = v12->xCoordOrKeycode;
    if ( v11 == 12 )
    {
      v10 = v12->yCoordOrFieldID - 27;
      switch ( v10 )
      {
        case 0:
          if ( iMaxUnitsToTrade )
          {
            v15 = v12->altXCoord - tpX - 75;
            qtyToTrade = v15 * (iMaxUnitsToTrade + 1) / 187;
            if ( qtyToTrade < 0 )
              qtyToTrade = 0;
            if ( iMaxUnitsToTrade < qtyToTrade )
              qtyToTrade = iMaxUnitsToTrade;
            v13 = 1;
          }
          break;
        case 4:
          memcpy(&v2, v12, 0x1Cu);
          DoTradeKnob(v2, v3, v4, v5, v6, v7, v8);
          break;
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
          v14 = v12->yCoordOrFieldID - 70;
          if ( leftResource != v14 )
          {
            leftResource = v14;
            v13 = 1;
            SetupNewTrade();
          }
          break;
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
          v14 = v12->yCoordOrFieldID - 110;
          if ( rightResource != v14 )
          {
            rightResource = v14;
            v13 = 1;
            if ( leftResource != -1 )
              SetupNewTrade();
          }
          break;
        default:
          break;
      }
    }
    else if ( v11 == 13 )
    {
      v9 = v12->yCoordOrFieldID;
      if ( v9 <= 30722 )
      {
        switch ( v9 )
        {
          case 30722:
            v16 = 1;
            break;
          case 25:
            if ( qtyToTrade > 0 )
            {
              --qtyToTrade;
              v13 = 1;
            }
            break;
          case 26:
            if ( iMaxUnitsToTrade > qtyToTrade )
            {
              ++qtyToTrade;
              v13 = 1;
            }
            break;
          default:
            if ( v9 == 29 && qtyToTrade )
            {
              if ( bLeftDenominated )
              {
                gpCurPlayer->resources[leftResource] -= qtyToTrade;
                gpCurPlayer->resources[rightResource] += iTradeRatio * qtyToTrade;
              }
              else
              {
                gpCurPlayer->resources[leftResource] -= iTradeRatio * qtyToTrade;
                gpCurPlayer->resources[rightResource] += qtyToTrade;
              }
              bTradeMade = 1;
              rightResource = -1;
              leftResource = -1;
              v13 = 1;
            }
            break;
        }
      }
    }
  }
  if ( v13 )
    UpdateTradingPost((void *)1);
  if ( v16 )
  {
    v12->yCoordOrFieldID = 10;
    v12->xCoordOrKeycode = v12->yCoordOrFieldID;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 522BFC: using guessed type int bLeftDenominated;
// 522C00: using guessed type int leftResource;
// 522C04: using guessed type int iMaxUnitsToTrade;
// 522C10: using guessed type int bTradeMade;
// 522C14: using guessed type int qtyToTrade;
// 522C18: using guessed type int iTradeRatio;
// 522C1C: using guessed type int rightResource;

//----- (0040FAF0) --------------------------------------------------------
int __thiscall combatManager::ViewGeneral(combatManager *this, int a2, int a3, int a4)
{
  int result; // eax@2
  int v5; // ST40_4@19
  int v6; // ST3C_4@19
  char *v7; // ST38_4@19
  char *v8; // ST34_4@19
  char *v9; // ST30_4@19
  char *v10; // ST2C_4@19
  char *v11; // ST28_4@19
  int v12; // ST24_4@19
  char *v13; // ST20_4@19
  int v14; // ST1C_4@19
  char *v15; // ST18_4@19
  int v16; // ST14_4@19
  char *v17; // ST10_4@19
  char v18; // al@19
  combatManager *v19; // [sp+Ch] [bp-78h]@1
  heroWindow *thisa; // [sp+18h] [bp-6Ch]@3
  tag_message evt; // [sp+20h] [bp-64h]@3
  __int16 v22; // [sp+3Ch] [bp-48h]@3
  heroWindow *a2a; // [sp+40h] [bp-44h]@4
  __int16 v24; // [sp+48h] [bp-3Ch]@3
  __int16 v25; // [sp+4Ch] [bp-38h]@3
  __int16 v26; // [sp+50h] [bp-34h]@3
  __int16 v27; // [sp+54h] [bp-30h]@3
  __int16 v28; // [sp+58h] [bp-2Ch]@3
  __int16 v29; // [sp+5Ch] [bp-28h]@3
  int v30; // [sp+60h] [bp-24h]@19
  int v31; // [sp+64h] [bp-20h]@19
  __int16 v32; // [sp+68h] [bp-1Ch]@3
  __int16 v33; // [sp+6Ch] [bp-18h]@3
  __int16 v34; // [sp+70h] [bp-14h]@3
  __int16 v35; // [sp+74h] [bp-10h]@3
  __int16 v36; // [sp+78h] [bp-Ch]@3
  __int16 v37; // [sp+7Ch] [bp-8h]@3
  __int16 v38; // [sp+80h] [bp-4h]@3

  v19 = this;
  if ( this->heroes[a2] )
  {
    iViewGeneralWhichSide = a2;
    v27 = 1;
    v32 = 2;
    v24 = 3;
    v37 = 4;
    v29 = 30;
    v25 = 0;
    v38 = 7;
    v34 = 8;
    v22 = 9;
    v26 = 10;
    v36 = 11;
    v33 = 12;
    v35 = 13;
    v28 = 14;
    giCurGeneral = a2;
    evt.eventCode = 512;
    thisa = (heroWindow *)operator new(68);
    if ( thisa )
      a2a = heroWindow::heroWindow(thisa, 179, 60, "vgenwin.bin");
    else
      a2a = 0;
    if ( !a2a )
      MemError();
    sprintf(gText, "port%04d.icn", v19->heroes[a2]->heroID);
    evt.xCoordOrKeycode = 9;
    evt.yCoordOrFieldID = 2;
    evt.payload = gText;
    heroWindow::BroadcastMessage(a2a, &evt);
    if ( v19->heroes[a2]->isCaptain )
      evt.xCoordOrKeycode = 5;
    else
      evt.xCoordOrKeycode = 6;
    evt.yCoordOrFieldID = 30;
    evt.payload = (void *)4;
    heroWindow::BroadcastMessage(a2a, &evt);
    if ( v19->heroes[a2]->isCaptain )
    {
      evt.xCoordOrKeycode = 4;
      if ( v19->playerID[a2] == -1 )
        evt.payload = (void *)6;
      else
        evt.payload = (void *)gpGame->players[v19->playerID[a2]].color;
      heroWindow::BroadcastMessage(a2a, &evt);
    }
    evt.xCoordOrKeycode = 4;
    evt.yCoordOrFieldID = 3;
    evt.payload = (void *)(gpGame->players[v19->heroes[a2]->ownerIdx].color + 1);
    heroWindow::BroadcastMessage(a2a, &evt);
    if ( v19->heroes[a2]->isCaptain )
      sprintf(gText, "Captain");
    else
      sprintf(gText, "%s the %s", v19->heroes[a2]->name, gAlignmentNames[v19->heroes[a2]->factionID]);
    evt.xCoordOrKeycode = 3;
    evt.yCoordOrFieldID = 1;
    evt.payload = gText;
    heroWindow::BroadcastMessage(a2a, &evt);
    v30 = armyGroup::GetMorale(
            (armyGroup *)((char *)&v19->heroes[a2 + 25] + 1),
            v19->heroes[a2],
            v19->castles[a2],
            gpCombatManager->armies[1 - a2]->creatureTypes);
    v31 = game::GetLuck(v19->heroes[a2], 0, v19->castles[a2]);
    v5 = 10 * hero::Stats(v19->heroes[a2], PRIMARY_SKILL_KNOWLEDGE);
    v6 = v19->heroes[a2]->spellpoints;
    v7 = off_4F6578;
    v8 = off_4F627C[v31];
    v9 = off_4F6574[0];
    v10 = off_4F629C[v30];
    v11 = off_4F6570[0];
    v12 = hero::Stats(v19->heroes[a2], PRIMARY_SKILL_KNOWLEDGE);
    v13 = off_4F656C[0];
    v14 = hero::Stats(v19->heroes[a2], PRIMARY_SKILL_SPELLPOWER);
    v15 = off_4F6568[0];
    v16 = hero::Stats(v19->heroes[a2], PRIMARY_SKILL_DEFENSE);
    v17 = off_4F6564[0];
    v18 = hero::Stats(v19->heroes[a2], 0);
    sprintf(
      gText,
      "\n%s%d\n%s%d\n%s%d\n%s%d\n%s%s\n%s%s\n\n%s%d/%d",
      off_4F6560[0],
      v18,
      v17,
      v16,
      v15,
      v14,
      v13,
      v12,
      v11,
      v10,
      v9,
      v8,
      v7,
      v6,
      v5);
    evt.xCoordOrKeycode = 3;
    evt.yCoordOrFieldID = 4;
    evt.payload = gText;
    heroWindow::BroadcastMessage(a2a, &evt);
    if ( !v19->heroes[a2]
      || !a3
      || !hero::HasArtifact(v19->heroes[a2], 81)
      || *(&v19->field_353F + a2)
      || v19->currentActionSide != giCurGeneral )
    {
      evt.xCoordOrKeycode = 6;
      evt.yCoordOrFieldID = 10;
      evt.payload = (void *)2;
      heroWindow::BroadcastMessage(a2a, &evt);
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4096;
      heroWindow::BroadcastMessage(a2a, &evt);
    }
    if ( !a3
      || !v19->heroes[1 - v19->currentActionSide]
      || v19->currentActionSide != giCurGeneral
      || v19->heroes[a2]->isCaptain )
    {
      evt.xCoordOrKeycode = 6;
      evt.yCoordOrFieldID = 12;
      evt.payload = (void *)2;
      heroWindow::BroadcastMessage(a2a, &evt);
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4096;
      heroWindow::BroadcastMessage(a2a, &evt);
    }
    if ( !a3
      || v19->currentActionSide != giCurGeneral
      || giCurGeneral == 1 && v19->castles[1]
      || v19->field_F377[0]
      || v19->field_F377[1]
      || v19->heroes[a2]->isCaptain )
    {
      evt.xCoordOrKeycode = 6;
      evt.yCoordOrFieldID = 11;
      evt.payload = (void *)2;
      heroWindow::BroadcastMessage(a2a, &evt);
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4096;
      heroWindow::BroadcastMessage(a2a, &evt);
    }
    if ( a4 )
    {
      heroWindowManager::AddWindow(gpWindowManager, a2a, -1, 1);
      QuickViewWait();
      heroWindowManager::RemoveWindow(gpWindowManager, a2a);
    }
    else
    {
      heroWindowManager::DoDialog(gpWindowManager, a2a, (int (__fastcall *)(tag_message *))HandleViewGeneral, 0);
    }
    operator delete(a2a);
    combatManager::DrawFrame(v19, 1, 0, 0, 0, 75, 1, 1);
    if ( !a4 )
      combatManager::DoCommand((int)v19, gpWindowManager->buttonPressedCode);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4EE4A4: using guessed type int iViewGeneralWhichSide;
// 4F627C: using guessed type char *off_4F627C[4];
// 4F629C: using guessed type char *off_4F629C[4];
// 4F6560: using guessed type char *off_4F6560[7];
// 4F6564: using guessed type char *off_4F6564[6];
// 4F6568: using guessed type char *off_4F6568[5];
// 4F656C: using guessed type char *off_4F656C[4];
// 4F6570: using guessed type char *off_4F6570[3];
// 4F6574: using guessed type char *off_4F6574[2];
// 4F6578: using guessed type char *off_4F6578;
// 524BE4: using guessed type int giCurGeneral;

//----- (004101D0) --------------------------------------------------------
signed int __thiscall HandleViewGeneral(tag_message *this)
{
  signed int result; // eax@28
  signed int v2; // [sp+Ch] [bp-5Ch]@29
  int v3; // [sp+10h] [bp-58h]@19
  int v4; // [sp+18h] [bp-50h]@5
  INPUT_EVENT_CODE v5; // [sp+1Ch] [bp-4Ch]@1
  tag_message *a2; // [sp+20h] [bp-48h]@1
  signed int v7; // [sp+24h] [bp-44h]@3
  signed int v8; // [sp+28h] [bp-40h]@30
  signed int v9; // [sp+5Ch] [bp-Ch]@1

  a2 = this;
  v9 = 0;
  v5 = this->eventCode;
  if ( v5 != 4 )
  {
    if ( v5 == 512 )
    {
      if ( BYTE1(this->inputTypeBitmask) & 2 )
      {
        v7 = -1;
        if ( this->xCoordOrKeycode == 12 || this->xCoordOrKeycode == 14 )
        {
          v4 = this->yCoordOrFieldID;
          if ( v4 <= 30720 )
          {
            switch ( v4 )
            {
              case 30720:
                v7 = 3;
                break;
              case 10:
                v7 = 0;
                break;
              case 11:
                v7 = 1;
                break;
              case 12:
                v7 = 2;
                break;
            }
          }
          if ( v7 != -1 )
            NormalDialog((&cViewGeneralLongHelp)[4 * v7], 4, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
      else if ( this->xCoordOrKeycode == 13 )
      {
        v3 = this->yCoordOrFieldID;
        if ( v3 >= 10 && (v3 <= 12 || v3 == 30720) )
        {
          gpWindowManager->buttonPressedCode = this->yCoordOrFieldID;
          v9 = 1;
        }
      }
    }
    if ( v9 )
    {
      a2->yCoordOrFieldID = 10;
      a2->xCoordOrKeycode = a2->yCoordOrFieldID;
      result = 2;
    }
    else
    {
      result = 1;
    }
    return result;
  }
  heroWindowManager::ConvertToHover(gpWindowManager, this);
  if ( gpWindowManager->hoveredFieldID == a2->yCoordOrFieldID )
    return 1;
  gpWindowManager->hoveredFieldID = a2->yCoordOrFieldID;
  v2 = a2->yCoordOrFieldID;
  if ( v2 <= 30720 )
  {
    if ( v2 == 30720 )
    {
      v8 = 4;
      goto LABEL_41;
    }
    if ( v2 == 10 )
    {
      v8 = 1;
      goto LABEL_41;
    }
    if ( v2 == 11 )
    {
      v8 = 2;
      goto LABEL_41;
    }
    if ( v2 == 12 )
    {
      v8 = 3;
      goto LABEL_41;
    }
  }
  v8 = 5;
LABEL_41:
  if ( v8 == 5 && gpCombatManager->heroes[iViewGeneralWhichSide]->isCaptain )
    v8 = 6;
  combatManager::CombatMessage(gpCombatManager, (&cViewGeneralHelp)[4 * v8], 1, 0, 0);
  return 1;
}
// 4EE4A4: using guessed type int iViewGeneralWhichSide;

//----- (00410530) --------------------------------------------------------
BOOL __thiscall combatManager::ViewArmy(void *this, int a2, int a3)
{
  BOOL result; // eax@10
  int a3a; // [sp+28h] [bp-8h]@6
  int a2a; // [sp+2Ch] [bp-4h]@2

  if ( a2 )
  {
    a2a = *((_WORD *)this + 49 * *(_DWORD *)(a2 + 122) + 650) - (*(_DWORD *)(a2 + 134) < 1u ? 123 : 80);
    if ( a2a < 0 )
      a2a = 0;
    if ( a2a + 488 > 640 )
      a2a = 151;
    a3a = *((_WORD *)this + 49 * *(_DWORD *)(a2 + 122) + 651) - 164;
    if ( a3a < 0 )
      a3a = 0;
    if ( a3a + 229 > 460 )
      a3a = 230;
    result = game::ViewArmy(
               gpGame,
               a2a,
               a3a,
               *(CREATURES *)(a2 + 118),
               *(_DWORD *)(a2 + 150),
               *(_DWORD *)((char *)this + 4 * *(_DWORD *)(a2 + 230) + 12927),
               1,
               *(_DWORD *)(a2 + 134),
               a3,
               *(hero **)((char *)this + 4 * *(_DWORD *)(a2 + 230) + 12935),
               a2,
               *(armyGroup **)((char *)this + 4 * *(_DWORD *)(a2 + 230) + 13201),
               0);
  }
  return result;
}

//----- (004106A0) --------------------------------------------------------
BuildingDisplay *__thiscall townObject::townObject(BuildingDisplay *this, int faction, int buildingCode, char *filename)
{
  BuildingDisplay *thisa; // [sp+Ch] [bp-30h]@1
  border *thisb; // [sp+10h] [bp-2Ch]@2
  char v7; // [sp+18h] [bp-24h]@1
  int y; // [sp+28h] [bp-14h]@1
  int x; // [sp+30h] [bp-Ch]@1
  int height; // [sp+34h] [bp-8h]@1
  int width; // [sp+38h] [bp-4h]@1

  thisa = this;
  this->animationIdx = 0;
  this->icon = 0;
  this->guiElement = 0;
  this->built = 1;
  this->animationLength = sBuildingInfo[faction][buildingCode].animationLength;
  x = sBuildingInfo[faction][buildingCode].x;
  y = sBuildingInfo[faction][buildingCode].y;
  width = sBuildingInfo[faction][buildingCode].width;
  height = sBuildingInfo[faction][buildingCode].height;
  this->buildingCode = buildingCode;
  sprintf(&v7, "%s.icn", filename);
  thisa->icon = resourceManager::GetIcon(gpResourceManager, &v7);
  if ( buildingCode != -1 )
  {
    thisb = (border *)operator new(42);
    if ( thisb )
      thisa->guiElement = border::border(thisb, x, y, width, height, buildingCode, 1, 0, 0);
    else
      thisa->guiElement = 0;
    if ( !thisa->guiElement )
      MemError();
  }
  return thisa;
}

//----- (00410810) --------------------------------------------------------
void __thiscall townObject::_townObject(BuildingDisplay *this)
{
  BuildingDisplay *thisa; // [sp+Ch] [bp-Ch]@1
  widget *v2; // [sp+14h] [bp-4h]@2

  thisa = this;
  if ( this->guiElement )
  {
    v2 = (widget *)this->guiElement;
    if ( v2 )
      v2->vtable->cleanUp(v2, 1);
  }
  resourceManager::Dispose(gpResourceManager, (resource *)thisa->icon);
}

//----- (00410870) --------------------------------------------------------
void __thiscall townObject::Draw(BuildingDisplay *this, int advanceAnimations)
{
  BuildingDisplay *thisa; // [sp+Ch] [bp-8h]@1
  int spriteIdx; // [sp+10h] [bp-4h]@48

  thisa = this;
  if ( this->built
    && this->buildingCode != BUILDING_TENT
    && (this->buildingCode != BUILDING_EXT_1
     || gpTownManager->castle->factionID
     || gpTownManager->castle->buildingsBuiltFlags & 4
     && (gpTownManager->castle->buildingsBuiltFlags & 1
      || BYTE3(gpTownManager->castle->buildingsBuiltFlags) & 1
      || BYTE3(gpTownManager->castle->buildingsBuiltFlags) & 0x20))
    && (this->buildingCode != BUILDING_EXT_2
     || gpTownManager->castle->factionID
     || gpTownManager->castle->buildingsBuiltFlags & 1
     && (BYTE3(gpTownManager->castle->buildingsBuiltFlags) & 1
      || BYTE3(gpTownManager->castle->buildingsBuiltFlags) & 0x20))
    && (this->buildingCode != BUILDING_EXT_2
     || gpTownManager->castle->factionID != 1
     || gpTownManager->castle->buildingsBuiltFlags & 1 && BYTE1(gpTownManager->castle->buildingsBuiltFlags) & 0x20)
    && (this->buildingCode != BUILDING_EXT_3
     || gpTownManager->castle->factionID != 1
     || gpTownManager->castle->buildingsBuiltFlags & 2 && BYTE2(gpTownManager->castle->buildingsBuiltFlags) & 0x20)
    && (gpTownManager->castle->factionID != 2
     || this->buildingCode != BUILDING_EXT_1
     || gpTownManager->castle->buildingsBuiltFlags & 0x80 && BYTE1(gpTownManager->castle->buildingsBuiltFlags) & 8)
    && (gpTownManager->castle->factionID != 2
     || this->buildingCode != BUILDING_STATUE && this->buildingCode != BUILDING_SPECIAL_GROWTH
     || !(gpTownManager->castle->buildingsBuiltFlags & 0x80)
     || !(BYTE1(gpTownManager->castle->buildingsBuiltFlags) & 8))
    && (this->buildingCode != BUILDING_EXT_0
     || gpTownManager->castle->factionID != 5
     && gpTownManager->castle->factionID != 3
     && gpTownManager->castle->factionID != 2
     && gpTownManager->castle->factionID
     || !(BYTE1(gpTownManager->castle->buildingsBuiltFlags) & 0x40) && !(gpTownManager->castle->buildingsBuiltFlags & 8))
    && (this->buildingCode != 3 || !(BYTE1(gpTownManager->castle->buildingsBuiltFlags) & 0x40)) )
  {
    if ( this->buildingCode )
    {
      icon::DrawToBuffer(this->icon, 0, 0, 0, 0);
      if ( thisa->animationLength )
      {
        icon::DrawToBuffer(thisa->icon, 0, 0, thisa->animationIdx + 1, 0);
        if ( advanceAnimations == 1 )
        {
          ++thisa->animationIdx;
          if ( thisa->animationIdx == thisa->animationLength )
            thisa->animationIdx = 0;
        }
      }
    }
    else
    {
      if ( gpTownManager->castle->factionID == FACTION_NECROMANCER )
        spriteIdx = 2 * (3 * gpTownManager->castle->mageGuildLevel - 3);
      else
        spriteIdx = gpTownManager->castle->mageGuildLevel - 1;
      icon::DrawToBuffer(this->icon, 0, 0, spriteIdx, 0);
      if ( thisa->animationLength
        && (gpTownManager->castle->factionID != FACTION_BARBARIAN || gpTownManager->castle->mageGuildLevel >= 5) )
      {
        icon::DrawToBuffer(thisa->icon, 0, 0, spriteIdx + thisa->animationIdx + 1, 0);
        if ( advanceAnimations == 1 )
        {
          ++thisa->animationIdx;
          if ( thisa->animationIdx == thisa->animationLength )
            thisa->animationIdx = 0;
        }
      }
    }
  }
}

//----- (00410CB0) --------------------------------------------------------
townManager *__thiscall townManager::townManager(townManager *this)
{
  townManager *thisa; // ST0C_4@1

  thisa = this;
  baseManager::baseManager((baseManager *)this);
  thisa->vtable = &townManager::_vftable_;
  thisa->castle = 0;
  thisa->curScreen = 0;
  thisa->field_C6 = 0;
  thisa->field_15E = -1;
  thisa->field_15A = 0;
  return thisa;
}

//----- (00410D20) --------------------------------------------------------
town *__thiscall townManager::SetupExtraStuff(townManager *this)
{
  town *result; // eax@17
  townManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  this->castle->buildingsBuiltFlags &= 0x7FF8BFFFu;
  if ( this->castle->factionID == FACTION_WIZARD )
    this->castle->buildingsBuiltFlags |= 0x10000u;
  if ( this->castle->factionID == FACTION_SORCERESS )
  {
    this->castle->buildingsBuiltFlags |= 0x10000u;
    this->castle->buildingsBuiltFlags |= 0x20000u;
  }
  if ( !this->castle->factionID )
  {
    this->castle->buildingsBuiltFlags |= 0x20000u;
    this->castle->buildingsBuiltFlags |= 0x40000u;
  }
  if ( this->castle->factionID == FACTION_BARBARIAN )
  {
    this->castle->buildingsBuiltFlags |= 0x20000u;
    this->castle->buildingsBuiltFlags |= 0x40000u;
    this->castle->buildingsBuiltFlags |= 0x80000000u;
  }
  if ( (this->castle->factionID == FACTION_WARLOCK
     || !this->castle->factionID
     || this->castle->factionID == FACTION_BARBARIAN
     || this->castle->factionID == FACTION_NECROMANCER)
    && town::CanBuildDock(this->castle) )
    thisa->castle->buildingsBuiltFlags |= 0x10000u;
  if ( thisa->castle->buildingsBuiltFlags & 8
    && advManager::GetCell(gpAdvManager, thisa->castle->buildDockRelated, thisa->castle->field_7)->objType )
  {
    result = thisa->castle;
    result->buildingsBuiltFlags |= 0x4000u;
  }
  else
  {
    result = thisa->castle;
    result->buildingsBuiltFlags &= 0xFFFFBFFFu;
  }
  return result;
}

//----- (00410EC0) --------------------------------------------------------
int __thiscall townManager::Open(townManager *this, int idx)
{
  townManager *thisa; // [sp+Ch] [bp-8h]@1
  heroWindow *window; // [sp+10h] [bp-4h]@4

  thisa = this;
  game::CheckHeroConsistency(gpGame);
  if ( *(_DWORD *)&useOpera || !*(_DWORD *)&useCDMusic )
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, townTheme[thisa->castle->factionID]);
  PollSound();
  window = (heroWindow *)operator new(68);
  if ( window )
    thisa->townScreen = heroWindow::heroWindow(window, 0, 0, "townwind.bin");
  else
    thisa->townScreen = 0;
  if ( !thisa->townScreen )
    MemError();
  glTimers = KBTickCount() + 150;
  thisa->factionID = -2;
  thisa->field_15A = 0;
  thisa->field_14E = 0;
  thisa->field_142 = -1;
  thisa->field_146 = 0;
  thisa->curBuilding = 0;
  thisa->field_C6 = 0;
  thisa->garrisonDisplay = 0;
  thisa->visitingArmyDisplay = 0;
  thisa->field_D6 = 0;
  thisa->field_DE = 0;
  thisa->field_E6 = 0;
  thisa->bankbox = 0;
  thisa->couldBeBackground = 0;
  townManager::SetupExtraStuff(thisa);
  townManager::SetupTown(thisa);
  KBChangeMenu(hmnuTown);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  thisa->type = 2048;
  thisa->idx = idx;
  thisa->ready = 1;
  strcpy(thisa->name, "townManager");
  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
  return 0;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (004110B0) --------------------------------------------------------
void __thiscall townManager::ChangeTown(townManager *this)
{
  townManager *thisa; // [sp+Ch] [bp-20h]@1
  GUIMessage evt; // [sp+10h] [bp-1Ch]@1

  thisa = this;
  townManager::SetupExtraStuff(this);
  townManager::SetupTown(thisa);
  evt.eventCode = 512;
  evt.fieldID = -1;
  townManager::SetCommandAndText(thisa, &evt);
  if ( *(_DWORD *)&useOpera || !*(_DWORD *)&useCDMusic )
  {
    if ( !*(_DWORD *)&useCDMusic )
      Sleep(0x64u);
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, townTheme[thisa->castle->factionID]);
  }
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00411140) --------------------------------------------------------
void __thiscall townManager::SetupTown(townManager *this)
{
  const char *v1; // eax@1
  armyGroup *v2; // ST14_4@46
  int v3; // ST10_4@46
  int v4; // eax@46
  armyGroup *visitorArmy; // ST14_4@52
  int v6; // eax@52
  int v7; // ST20_4@61
  int v8; // eax@61
  int v9; // eax@67
  townManager *thisa; // [sp+Ch] [bp-58h]@1
  strip *v11; // [sp+10h] [bp-54h]@66
  strip *v12; // [sp+14h] [bp-50h]@60
  strip *v13; // [sp+18h] [bp-4Ch]@51
  strip *ecx0; // [sp+1Ch] [bp-48h]@45
  strip *v15; // [sp+24h] [bp-40h]@39
  strip *v16; // [sp+2Ch] [bp-38h]@36
  BuildingDisplay *v17; // [sp+30h] [bp-34h]@14
  bankBox *thisb; // [sp+34h] [bp-30h]@6
  int v19; // [sp+38h] [bp-2Ch]@28
  int buildingCode; // [sp+3Ch] [bp-28h]@13
  GUIMessage evt; // [sp+40h] [bp-24h]@1
  int i; // [sp+5Ch] [bp-8h]@11
  int v23; // [sp+60h] [bp-4h]@42

  thisa = this;
  v1 = GetTownName(this->castle->idx);
  sprintf(gText, v1);
  evt.eventCode = 512;
  evt.messageType = GUI_MESSAGE_SET_TEXT;
  evt.fieldID = 137;
  evt.payload = gText;
  heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
  strcpy(gText, "Town Screen");
  evt.fieldID = 902;
  evt.payload = gText;
  heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
  heroWindow::DrawWindow(thisa->townScreen, 0, 800, 801);
  if ( gpCurPlayer->numCastles == 1 )
  {
    evt.messageType = 5;
    evt.payload = (void *)4096;
    evt.fieldID = 903;
    heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
    evt.fieldID = 904;
    heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
    evt.messageType = 6;
    evt.payload = (void *)2;
    evt.fieldID = 903;
    heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
    evt.fieldID = 904;
    heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
  }
  if ( thisa->castle->factionID == thisa->factionID )
  {
    thisa->curBuilding = 0;
    for ( i = 0; i < 32; ++i )
    {
      v19 = byte_4EA068[thisa->castle->factionID][i];
      if ( v19 != -1 )
      {
        if ( thisa->buildingDisplays[thisa->curBuilding]->guiElement )
        {
          if ( (1 << v19) & thisa->castle->buildingsBuiltFlags )
          {
            thisa->buildingDisplays[thisa->curBuilding]->guiElement->flagsRelatedToShouldDisplayAndPerhapsMouseCode |= 2u;
            thisa->buildingDisplays[thisa->curBuilding]->built = 1;
          }
          else
          {
            thisa->buildingDisplays[thisa->curBuilding]->guiElement->flagsRelatedToShouldDisplayAndPerhapsMouseCode &= 0xFFFDu;
            thisa->buildingDisplays[thisa->curBuilding]->built = 0;
          }
        }
        ++thisa->curBuilding;
      }
    }
    if ( thisa->visitingArmyDisplay )
    {
      v16 = thisa->visitingArmyDisplay;
      if ( v16 )
      {
        strip::_strip(v16);
        operator delete(v16);
      }
    }
    thisa->visitingArmyDisplay = 0;
    if ( thisa->garrisonDisplay )
    {
      v15 = thisa->garrisonDisplay;
      if ( v15 )
      {
        strip::_strip(v15);
        operator delete(v15);
      }
    }
    thisa->garrisonDisplay = 0;
  }
  else
  {
    if ( thisa->factionID != -1 )
      townManager::UnloadTown(thisa);
    thisb = (bankBox *)operator new(12);
    if ( thisb )
      thisa->bankbox = bankBox::bankBox(thisb, 546, 256, gpCurPlayer);
    else
      thisa->bankbox = 0;
    if ( !thisa->bankbox )
      MemError();
    sprintf(gText, "townbkg%d.icn", thisa->castle->factionID);
    thisa->couldBeBackground = resourceManager::GetIcon(gpResourceManager, gText);
    thisa->curBuilding = 0;
    for ( i = 0; i < 32; ++i )
    {
      buildingCode = byte_4EA068[thisa->castle->factionID][i];
      if ( buildingCode != -1 )
      {
        sprintf(gText, "%s%s", gTownPrefixNames[thisa->castle->factionID], gTownObjNames[buildingCode]);
        v17 = (BuildingDisplay *)operator new(24);
        if ( v17 )
          thisa->buildingDisplays[thisa->curBuilding] = townObject::townObject(
                                                          v17,
                                                          thisa->castle->factionID,
                                                          buildingCode,
                                                          gText);
        else
          thisa->buildingDisplays[thisa->curBuilding] = 0;
        if ( !thisa->buildingDisplays[thisa->curBuilding] )
          MemError();
        if ( thisa->buildingDisplays[thisa->curBuilding]->guiElement )
        {
          if ( !((1 << buildingCode) & thisa->castle->buildingsBuiltFlags) )
          {
            thisa->buildingDisplays[thisa->curBuilding]->guiElement->flagsRelatedToShouldDisplayAndPerhapsMouseCode &= 0xFFFDu;
            thisa->buildingDisplays[thisa->curBuilding]->built = 0;
          }
          heroWindow::AddWidget(
            thisa->townScreen,
            (widget *)thisa->buildingDisplays[thisa->curBuilding]->guiElement,
            -1);
        }
        ++thisa->curBuilding;
      }
    }
    heroWindowManager::AddWindow(gpWindowManager, thisa->townScreen, 0, 1);
  }
  v23 = gpCurPlayer->color;
  if ( thisa->castle->visitingHeroIdx == -1 )
  {
    v23 += 16;
  }
  else
  {
    v23 *= 4;
    v23 += gpGame->heroes[thisa->castle->visitingHeroIdx].factionID;
  }
  ecx0 = (strip *)operator new(132);
  if ( ecx0 )
  {
    v2 = &thisa->castle->garrison;
    v3 = gpCurPlayer->color;
    v4 = resourceManager::MakeId(gpResourceManager, "crest.icn", 1);
    thisa->garrisonDisplay = strip::strip(
                               ecx0,
                               0,
                               256,
                               (unsigned int)(thisa->castle->visitingHeroIdx + 1) < 1 ? 4 : 1,
                               v4,
                               v3,
                               v2,
                               116,
                               0,
                               -1);
  }
  else
  {
    thisa->garrisonDisplay = 0;
  }
  if ( !thisa->garrisonDisplay )
    MemError();
  if ( thisa->castle->visitingHeroIdx == -1 )
  {
    if ( BYTE1(thisa->castle->buildingsBuiltFlags) & 0x80 )
    {
      sprintf(gText, "port%04d.icn", thisa->castle->factionID + 90);
      v12 = (strip *)operator new(132);
      if ( v12 )
      {
        v7 = gpCurPlayer->color;
        v8 = resourceManager::MakeId(gpResourceManager, gText, 1);
        thisa->visitingArmyDisplay = strip::strip(v12, 0, 355, 3, v8, 0, 0, -1, 0, v7);
      }
      else
      {
        thisa->visitingArmyDisplay = 0;
      }
      if ( !thisa->visitingArmyDisplay )
        MemError();
    }
    else
    {
      v11 = (strip *)operator new(132);
      if ( v11 )
      {
        v9 = resourceManager::MakeId(gpResourceManager, "strip.icn", 1);
        thisa->visitingArmyDisplay = strip::strip(v11, 0, 355, 3, v9, 3, 0, -1, 0, -1);
      }
      else
      {
        thisa->visitingArmyDisplay = 0;
      }
      if ( !thisa->visitingArmyDisplay )
        MemError();
    }
  }
  else
  {
    sprintf(gText, "port%04d.icn", gpGame->heroes[thisa->castle->visitingHeroIdx].heroID);
    v13 = (strip *)operator new(132);
    if ( v13 )
    {
      visitorArmy = &gpGame->heroes[thisa->castle->visitingHeroIdx].army;
      v6 = resourceManager::MakeId(gpResourceManager, gText, 1);
      thisa->visitingArmyDisplay = strip::strip(v13, 0, 355, 3, v6, 0, visitorArmy, 122, 0, -1);
    }
    else
    {
      thisa->visitingArmyDisplay = 0;
    }
    if ( !thisa->visitingArmyDisplay )
      MemError();
    if ( thisa->castle->buildingsBuiltFlags & 1 )
      town::GiveSpells(thisa->castle, 0);
  }
  thisa->factionID = thisa->castle->factionID;
  thisa->field_E6 = 0;
  thisa->field_DE = thisa->field_E6;
  thisa->field_D6 = thisa->field_DE;
  thisa->field_EA = -1;
  thisa->field_E2 = thisa->field_EA;
  thisa->field_DA = thisa->field_E2;
  townManager::DrawTown(thisa, 0, 0);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
}
// 4F3CF8: using guessed type char *gTownPrefixNames[6];
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (00411AA0) --------------------------------------------------------
townManager *__thiscall townManager::UnloadTown(townManager *this)
{
  townManager *result; // eax@15
  townManager *thisa; // [sp+Ch] [bp-28h]@1
  BuildingDisplay *v3; // [sp+14h] [bp-20h]@12
  strip *v4; // [sp+1Ch] [bp-18h]@8
  strip *v5; // [sp+24h] [bp-10h]@5
  bankBox *thisb; // [sp+2Ch] [bp-8h]@2
  int i; // [sp+30h] [bp-4h]@10

  thisa = this;
  if ( this->bankbox )
  {
    thisb = this->bankbox;
    if ( thisb )
    {
      bankBox::_bankBox(thisb);
      operator delete(thisb);
    }
  }
  thisa->bankbox = 0;
  if ( thisa->visitingArmyDisplay )
  {
    v5 = thisa->visitingArmyDisplay;
    if ( v5 )
    {
      strip::_strip(v5);
      operator delete(v5);
    }
  }
  thisa->visitingArmyDisplay = 0;
  if ( thisa->garrisonDisplay )
  {
    v4 = thisa->garrisonDisplay;
    if ( v4 )
    {
      strip::_strip(v4);
      operator delete(v4);
    }
  }
  thisa->garrisonDisplay = 0;
  for ( i = 0; thisa->curBuilding > i; ++i )
  {
    heroWindow::RemoveWidget(thisa->townScreen, (widget *)thisa->buildingDisplays[i]->guiElement);
    v3 = thisa->buildingDisplays[i];
    if ( v3 )
    {
      townObject::_townObject(v3);
      operator delete(v3);
    }
    thisa->buildingDisplays[i] = 0;
  }
  result = thisa;
  if ( thisa->couldBeBackground )
  {
    resourceManager::Dispose(gpResourceManager, (resource *)thisa->couldBeBackground);
    result = thisa;
    thisa->couldBeBackground = 0;
  }
  return result;
}

//----- (00411C70) --------------------------------------------------------
void __thiscall townManager::Close(townManager *this)
{
  townManager *thisa; // [sp+Ch] [bp-Ch]@1

  thisa = this;
  townManager::UnloadTown(this);
  if ( thisa->townScreen )
  {
    heroWindowManager::RemoveWindow(gpWindowManager, thisa->townScreen);
    operator delete(thisa->townScreen);
  }
  thisa->townScreen = 0;
  if ( *(_DWORD *)&useOpera || !*(_DWORD *)&useCDMusic )
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  mouseManager::SetPointer(gpMouseManager, -1);
  thisa->ready = 0;
  thisa->castle->buildingsBuiltFlags &= 0xFFF8BFFFu;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00411D40) --------------------------------------------------------
void __thiscall townManager::SetArmyCommand(townManager *this, int a2)
{
  townManager *thisa; // [sp+Ch] [bp-Ch]@1
  signed int v3; // [sp+10h] [bp-8h]@8
  signed int v4; // [sp+14h] [bp-4h]@1

  thisa = this;
  this->field_14A = -1;
  v4 = 0;
  if ( armyGroup::GetNumArmies(this->field_DE->army) == 1
    && thisa->field_DE == thisa->visitingArmyDisplay
    && thisa->field_E6 != thisa->field_DE )
    v4 = 1;
  if ( thisa->field_E6 != thisa->field_DE || thisa->field_E2 != thisa->field_EA )
  {
    v3 = 0;
    if ( thisa->field_DE->army->creatureTypes[thisa->field_E2] == thisa->field_E6->army->creatureTypes[thisa->field_EA] )
      v3 = 1;
    if ( v3 )
    {
      if ( a2 )
      {
        sprintf(thisa->infoMessage, cTownCommand, gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]]);
        thisa->field_14A = 5;
      }
      else
      {
        if ( v4 )
        {
          strcpy(thisa->infoMessage, off_4F6624);
          return;
        }
        sprintf(thisa->infoMessage, off_4F6628, gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]]);
        thisa->field_14A = 2;
      }
    }
    else if ( a2 && thisa->field_E6->army->creatureTypes[thisa->field_EA] == -1 )
    {
      sprintf(thisa->infoMessage, off_4F662C, gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]]);
      thisa->field_14A = 5;
    }
  }
  else
  {
    sprintf(thisa->infoMessage, off_4F6630, gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]]);
    thisa->field_14A = 1;
  }
  if ( thisa->field_14A == -1 )
  {
    if ( thisa->field_E6->army->creatureTypes[thisa->field_EA] == -1 )
    {
      if ( v4 )
      {
        strcpy(thisa->infoMessage, off_4F6634);
      }
      else
      {
        sprintf(thisa->infoMessage, off_4F6638, gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]]);
        thisa->field_14A = 3;
      }
    }
    else
    {
      sprintf(
        thisa->infoMessage,
        off_4F663C,
        gArmyNames[thisa->field_DE->army->creatureTypes[thisa->field_E2]],
        gArmyNames[thisa->field_E6->army->creatureTypes[thisa->field_EA]]);
      thisa->field_14A = 3;
    }
  }
}

//----- (00412100) --------------------------------------------------------
void __thiscall townManager::SetCommandAndText(townManager *this, GUIMessage *evt)
{
  townManager *thisa; // [sp+10h] [bp-8h]@1
  int fieldID; // [sp+14h] [bp-4h]@1

  thisa = this;
  fieldID = evt->fieldID;
  this->field_14A = -1;
  if ( fieldID > 30 )
  {
    if ( fieldID > 122 )
    {
      if ( fieldID > 129 )
      {
        if ( fieldID == 30720 )
          strcpy(this->infoMessage, off_4F6640);
      }
      else if ( fieldID >= 128 )
      {
LABEL_3:
        strcpy(this->infoMessage, off_4F6644);
      }
      else if ( fieldID >= 123 && fieldID <= 127 )
      {
        if ( this->field_E2 == -1 )
        {
          this->field_D6 = this->visitingArmyDisplay;
          this->field_DA = fieldID - 123;
          if ( this->field_D6->army && this->field_D6->army->creatureTypes[this->field_DA] != -1 )
          {
            sprintf(this->infoMessage, off_4F6650, gArmyNames[this->field_D6->army->creatureTypes[this->field_DA]]);
            thisa->field_14A = 0;
          }
          else
          {
            strcpy(this->infoMessage, off_4F664C);
            thisa->field_14A = -1;
          }
        }
        else
        {
          this->field_E6 = this->visitingArmyDisplay;
          this->field_EA = fieldID - 123;
          townManager::SetArmyCommand(this, evt->inputTypeBitmask & 3);
        }
      }
    }
    else if ( fieldID == 122 )
    {
      strcpy(this->infoMessage, off_4F6654);
      thisa->field_14A = 4;
    }
    else if ( fieldID == 116 )
    {
      sprintf(
        this->infoMessage,
        "%s: %d, %s: %d, %s: %d",
        "Month",
        gpGame->month,
        "Week",
        gpGame->week,
        "Day",
        gpGame->day);
    }
    else if ( fieldID >= 117 && fieldID <= 121 )
    {
      if ( this->field_E2 == -1 )
      {
        this->field_D6 = this->garrisonDisplay;
        this->field_DA = fieldID - 117;
        if ( this->field_D6->army->creatureTypes[this->field_DA] == -1 )
        {
          strcpy(this->infoMessage, off_4F664C);
        }
        else
        {
          sprintf(this->infoMessage, off_4F6650, gArmyNames[this->field_D6->army->creatureTypes[this->field_DA]]);
          thisa->field_14A = 0;
        }
      }
      else
      {
        this->field_E6 = this->garrisonDisplay;
        this->field_EA = fieldID - 117;
        townManager::SetArmyCommand(this, evt->inputTypeBitmask & 3);
      }
    }
  }
  else if ( fieldID >= 19 )
  {
    sprintf(
      this->infoMessage,
      off_4F6674,
      gArmyNames[LOBYTE((&gTownObjNames[3 * this->castle->factionID + 27])[fieldID + 1])]);
  }
  else
  {
    switch ( fieldID + 1 )
    {
      case 0:
        goto LABEL_3;
      case 1:
        strcpy(this->infoMessage, off_4F6658);
        break;
      case 2:
        strcpy(this->infoMessage, off_4F665C);
        break;
      case 3:
        if ( this->castle->factionID == 5 )
          strcpy(this->infoMessage, xNecromancerShrine);
        else
          strcpy(this->infoMessage, off_4F6660);
        break;
      case 4:
      case 15:
        strcpy(this->infoMessage, off_4F6664);
        break;
      case 5:
        strcpy(this->infoMessage, off_4F6668);
        break;
      case 6:
        strcpy(this->infoMessage, off_4F666C);
        break;
      case 7:
        strcpy(this->infoMessage, off_4F6670);
        break;
      case 8:
        strcpy(this->infoMessage, off_4F6678);
        break;
      case 9:
        strcpy(this->infoMessage, off_4F667C);
        break;
      case 10:
        strcpy(this->infoMessage, off_4F6680);
        break;
      case 13:
        strcpy(this->infoMessage, off_4F6684);
        break;
      case 11:
        strcpy(this->infoMessage, off_4F6688);
        break;
      case 16:
        strcpy(this->infoMessage, off_4F668C);
        break;
      case 14:
        strcpy(this->infoMessage, gSpecialBuildingNames[this->castle->factionID]);
        break;
      case 12:
        strcpy(this->infoMessage, gWellExtraNames[this->castle->factionID]);
        break;
      default:
        break;
    }
  }
  townManager::ShowText(thisa, thisa->infoMessage);
}
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (00412730) --------------------------------------------------------
void __thiscall townManager::ShowText(townManager *this, char *msg)
{
  townManager *thisa; // ST1C_4@1
  GUIMessage evt; // [sp+10h] [bp-1Ch]@1

  thisa = this;
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.messageType = GUI_MESSAGE_SET_TEXT;
  evt.fieldID = 902;
  evt.payload = this->infoMessage;
  heroWindow::BroadcastMessage(this->townScreen, (tag_message *)&evt);
  heroWindow::DrawWindow(thisa->townScreen, 0, 900, 902);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 25, 464, 0x24Eu, 15);
}

//----- (004127B0) --------------------------------------------------------
signed int __thiscall townManager::Main(int ecx0, GUIMessage *evt)
{
  armyGroup *v2; // ST20_4@36
  int v3; // eax@36
  int v4; // ST2C_4@47
  int v5; // eax@47
  const char *v6; // eax@87
  signed int v7; // eax@93
  const char *v8; // eax@124
  const char *v9; // eax@125
  signed int result; // eax@169
  int v11; // [sp+Ch] [bp-250h]@176
  int v12; // [sp+10h] [bp-24Ch]@171
  int v13; // [sp+14h] [bp-248h]@153
  int v14; // [sp+18h] [bp-244h]@17
  int v15; // [sp+1Ch] [bp-240h]@16
  INPUT_EVENT_CODE v16; // [sp+20h] [bp-23Ch]@15
  int this; // [sp+24h] [bp-238h]@1
  heroWindow *v18; // [sp+44h] [bp-218h]@99
  heroWindow *v19; // [sp+4Ch] [bp-210h]@79
  heroWindow *v20; // [sp+54h] [bp-208h]@72
  heroWindow *v21; // [sp+5Ch] [bp-200h]@64
  strip *v22; // [sp+60h] [bp-1FCh]@46
  strip *v23; // [sp+68h] [bp-1F4h]@44
  strip *v24; // [sp+74h] [bp-1E8h]@35
  strip *v25; // [sp+7Ch] [bp-1E0h]@33
  heroWindow *v26; // [sp+84h] [bp-1D8h]@27
  recruitUnit *v27; // [sp+8Ch] [bp-1D0h]@20
  hero *hro; // [sp+94h] [bp-1C8h]@139
  signed int v29; // [sp+98h] [bp-1C4h]@130
  signed int v30; // [sp+A8h] [bp-1B4h]@115
  baseManager *a2; // [sp+B0h] [bp-1ACh]@21
  signed int v32; // [sp+B4h] [bp-1A8h]@2
  char msg; // [sp+B8h] [bp-1A4h]@87
  signed int buildingCode; // [sp+248h] [bp-14h]@3
  SAMPLE2 res; // [sp+24Ch] [bp-10h]@40
  int v36; // [sp+254h] [bp-8h]@1
  int v37; // [sp+258h] [bp-4h]@1

  this = ecx0;
  v36 = 0;
  v37 = (BYTE1(evt->inputTypeBitmask) & 2) != 0;
  if ( giDebugBuildingToBuild != -1 )
  {
    v32 = giDebugBuildingToBuild;
    giDebugBuildingToBuild = -1;
    if ( v32 == 100 )
    {
      for ( buildingCode = 0; buildingCode < 32; ++buildingCode )
      {
        if ( (1 << buildingCode) & gTownEligibleBuildMask[*(_BYTE *)(*(_DWORD *)(this + 54) + 3)] || buildingCode == 6 )
          townManager::BuildObj((townManager *)this, buildingCode);
      }
    }
    else if ( (1 << v32) & gTownEligibleBuildMask[*(_BYTE *)(*(_DWORD *)(ecx0 + 54) + 3)] || v32 == 6 )
    {
      townManager::BuildObj((townManager *)ecx0, v32);
    }
  }
  if ( KBTickCount() > glTimers )
  {
    townManager::DrawTown((townManager *)this, 1, 1);
    glTimers = KBTickCount() + 150;
  }
  v16 = evt->eventCode;
  if ( (signed int)v16 > 512 )
    goto LABEL_188;
  if ( v16 == 512 )
  {
    v15 = evt->messageType;
    if ( v15 == 12 )
      goto LABEL_201;
    if ( v15 == 13 )
    {
      v13 = evt->fieldID;
      if ( v13 >= 903 )
      {
        if ( v13 <= 904 )
        {
          if ( *(_BYTE *)(*(_DWORD *)(this + 54) + 1) == giCurPlayer && gpCurPlayer->numCastles > 1 )
          {
            *(_DWORD *)(this + 54) = (char *)gpGame
                                   + 100
                                   * gpCurPlayer->castlesOwned[(getCastleOwnedIdx(gpCurPlayer, **(_BYTE **)(this + 54))
                                                              + gpCurPlayer->numCastles
                                                              + ((unsigned int)(evt->fieldID - 903) < 1 ? -1 : 1))
                                                             % gpCurPlayer->numCastles]
                                   + 2899;
            townManager::ChangeTown((townManager *)this);
          }
        }
        else if ( v13 == 30720 && !v37 )
        {
          ++v36;
        }
      }
      goto LABEL_188;
    }
    if ( v15 == 14 )
    {
LABEL_201:
      v14 = evt->fieldID;
      if ( v14 > 15 )
      {
        if ( v14 >= 19 )
        {
          if ( v14 <= 30 )
          {
            if ( v37 )
            {
              QuickViewRecruit(*(town **)(this + 54), evt->fieldID - 19);
            }
            else
            {
              townManager::DrawTown((townManager *)this, 1, 1);
              v27 = (recruitUnit *)operator new(126);
              if ( v27 )
                a2 = (baseManager *)recruitUnit::recruitUnit(v27, *(_DWORD *)(this + 54), evt->fieldID - 19, 1);
              else
                a2 = 0;
              if ( !a2 )
                MemError();
              executive::DoDialog(gpExec, a2);
              operator delete(a2);
            }
            goto LABEL_188;
          }
          if ( v14 == 30720 )
          {
            if ( !v37 )
              townManager::SetCommandAndText((townManager *)this, evt);
            goto LABEL_188;
          }
        }
      }
      else
      {
        if ( v14 == 15 )
        {
LABEL_123:
          if ( v37 )
          {
LABEL_124:
            v8 = GetBuildingInfo(*(_BYTE *)(*(_DWORD *)(this + 54) + 3), evt->fieldID, 1);
            sprintf(&msg, v8);
            NormalDialog(&msg, 4, -1, -1, *(_BYTE *)(*(_DWORD *)(this + 54) + 3) + 19, evt->fieldID, -1, 0, -1, 0);
          }
          else
          {
            v9 = GetBuildingInfo(*(_BYTE *)(*(_DWORD *)(this + 54) + 3), evt->fieldID, 1);
            sprintf(&msg, v9);
            NormalDialog(&msg, 1, -1, -1, *(_BYTE *)(*(_DWORD *)(this + 54) + 3) + 19, evt->fieldID, -1, 0, -1, 0);
          }
          goto LABEL_188;
        }
        switch ( v14 )
        {
          case 6:
            if ( v37 )
              goto LABEL_124;
            v26 = (heroWindow *)operator new(68);
            if ( v26 )
              *(_DWORD *)(this + 354) = heroWindow::heroWindow(v26, 0, 0, "caslwind.bin");
            else
              *(_DWORD *)(this + 354) = 0;
            if ( !*(_DWORD *)(this + 354) )
              MemError();
            townManager::SetupCastle((townManager *)this, *(heroWindow **)(this + 354), 0);
            *(_DWORD *)(this + 346) = 1;
            *(_DWORD *)(this + 334) = 0;
            heroWindowManager::DoDialog(
              gpWindowManager,
              *(heroWindow **)(this + 354),
              (int (__fastcall *)(tag_message *))CastleHandler,
              0);
            *(_DWORD *)(this + 346) = 0;
            operator delete(*(void **)(this + 354));
            if ( *(_DWORD *)(this + 334) )
            {
              townManager::RedrawTownScreen((townManager *)this);
              heroWindowManager::SaveFizzleSource(gpWindowManager, 0, 256, 552, 204);
              v25 = *(strip **)(this + 210);
              if ( v25 )
              {
                strip::_strip(v25);
                operator delete(v25);
              }
              sprintf(gText, "port%04d.icn", *(_BYTE *)(*(_DWORD *)(this + 374) + 24));
              v24 = (strip *)operator new(132);
              if ( v24 )
              {
                v2 = (armyGroup *)(*(_DWORD *)(this + 374) + 101);
                v3 = resourceManager::MakeId(gpResourceManager, gText, 1);
                *(_DWORD *)(this + 210) = strip::strip(v24, 0, 355, 3, v3, 0, v2, 122, 0, -1);
              }
              else
              {
                *(_DWORD *)(this + 210) = 0;
              }
              if ( !*(_DWORD *)(this + 210) )
                MemError();
              res = (SAMPLE2)LoadPlaySample("buildtwn.82M");
              heroWindow::DrawWindow(*(heroWindow **)(this + 202), 0);
              strip::DrawIcons(*(strip **)(this + 206), 0);
              strip::DrawIcons(*(strip **)(this + 210), 0);
              heroWindowManager::FizzleForward(gpWindowManager, 0, 256, 552, 204, -1, 0, 0);
              WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
              *(_DWORD *)(this + 334) = 0;
              heroWindowManager::ReleaseFizzleSource(gpWindowManager);
            }
            else
            {
              if ( *(_DWORD *)(this + 350) == 15 && *(_BYTE *)(*(_DWORD *)(this + 54) + 23) == -1 )
              {
                if ( *(_DWORD *)(this + 210) )
                {
                  v23 = *(strip **)(this + 210);
                  if ( v23 )
                  {
                    strip::_strip(v23);
                    operator delete(v23);
                  }
                }
                *(_DWORD *)(this + 210) = 0;
                sprintf(gText, "port%04d.icn", *(_BYTE *)(*(_DWORD *)(this + 54) + 3) + 90);
                v22 = (strip *)operator new(132);
                if ( v22 )
                {
                  v4 = gpCurPlayer->color;
                  v5 = resourceManager::MakeId(gpResourceManager, gText, 1);
                  *(_DWORD *)(this + 210) = strip::strip(v22, 0, 355, 3, v5, 0, 0, -1, 0, v4);
                }
                else
                {
                  *(_DWORD *)(this + 210) = 0;
                }
                if ( !*(_DWORD *)(this + 210) )
                  MemError();
              }
              townManager::RedrawTownScreen((townManager *)this);
              if ( *(_DWORD *)(this + 350) != -1 )
                townManager::BuildObj((townManager *)this, *(_DWORD *)(this + 350));
            }
            goto LABEL_188;
          case 0:
            if ( v37 )
              goto LABEL_124;
            if ( *(_BYTE *)(*(_DWORD *)(this + 54) + 23) == -1
              || hero::HasArtifact(&gpGame->heroes[*(_BYTE *)(*(_DWORD *)(this + 54) + 23)], 81) )
            {
              v21 = (heroWindow *)operator new(68);
              if ( v21 )
                *(_DWORD *)(this + 354) = heroWindow::heroWindow(v21, 0, 0, "magewind.bin");
              else
                *(_DWORD *)(this + 354) = 0;
              if ( !*(_DWORD *)(this + 354) )
                MemError();
              SetWinText(*(heroWindow **)(this + 354), 17);
              townManager::SetupMage((townManager *)this, *(heroWindow **)(this + 354));
              heroWindowManager::DoDialog(gpWindowManager, *(heroWindow **)(this + 354), MageGuildHandler, 0);
              operator delete(*(void **)(this + 354));
            }
            else if ( hero::NumArtifacts(&gpGame->heroes[*(_BYTE *)(*(_DWORD *)(this + 54) + 23)]) == 14 )
            {
              NormalDialog(
                "You must purchase a spell book to use the mage guild, but you currently have no room for a spell book.  Try giving one of your artifacts to another hero.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else if ( gpCurPlayer->resources[6] >= 500 )
            {
              NormalDialog(
                "To cast spells, you must first buy a spell book for 500 gold.  Do you wish to buy one?",
                2,
                -1,
                -1,
                7,
                81,
                -1,
                0,
                -1,
                0);
              if ( gpWindowManager->buttonPressedCode == 30725 )
              {
                GiveArtifact(&gpGame->heroes[*(_BYTE *)(*(_DWORD *)(this + 54) + 23)], ARTIFACT_MAGIC_BOOK, 1, -1);
                gpCurPlayer->resources[6] -= 500;
                bankBox::Update(*(bankBox **)(this + 238), 1);
                heroWindow::DrawWindow(*(heroWindow **)(this + 202));
                town::GiveSpells(*(town **)(this + 54), 0);
              }
            }
            else
            {
              NormalDialog(
                "To cast spells, you must first buy a spell book for 500 gold.  Unfortunately, you seem to be a little short of cash at the moment.",
                1,
                -1,
                -1,
                7,
                81,
                -1,
                0,
                -1,
                0);
            }
            town::GiveSpells(*(town **)(this + 54), 0);
            townManager::RedrawTownScreen((townManager *)this);
            goto LABEL_188;
          case 4:
            if ( v37 )
              goto LABEL_124;
            v20 = (heroWindow *)operator new(68);
            if ( v20 )
              *(_DWORD *)(this + 354) = heroWindow::heroWindow(v20, 0, 0, "wellwind.bin");
            else
              *(_DWORD *)(this + 354) = 0;
            if ( !*(_DWORD *)(this + 354) )
              MemError();
            townManager::SetupWell((townManager *)this, *(heroWindow **)(this + 354));
            heroWindowManager::DoDialog(gpWindowManager, *(heroWindow **)(this + 354), TrueFalseDialogHandler, 0);
            operator delete(*(void **)(this + 354));
            townManager::RedrawTownScreen((townManager *)this);
            goto LABEL_188;
          case 1:
            if ( v37 )
              goto LABEL_124;
            v19 = (heroWindow *)operator new(68);
            if ( v19 )
              *(_DWORD *)(this + 354) = heroWindow::heroWindow(v19, 0, 0, "thiefwin.bin");
            else
              *(_DWORD *)(this + 354) = 0;
            if ( !*(_DWORD *)(this + 354) )
              MemError();
            SetWinText(*(heroWindow **)(this + 354), 14);
            townManager::SetupThievesGuild(*(heroWindow **)(this + 354), -1);
            heroWindowManager::DoDialog(gpWindowManager, *(heroWindow **)(this + 354), TrueFalseDialogHandler, 0);
            operator delete(*(void **)(this + 354));
            townManager::RedrawTownScreen((townManager *)this);
            goto LABEL_188;
          case 2:
            if ( v37 )
              goto LABEL_124;
            if ( *(_BYTE *)(*(_DWORD *)(this + 54) + 3) == 5 )
            {
              v6 = GetBuildingInfo(*(_BYTE *)(*(_DWORD *)(this + 54) + 3), evt->fieldID, 1);
              sprintf(&msg, v6);
              NormalDialog(&msg, 1, -1, -1, *(_BYTE *)(*(_DWORD *)(this + 54) + 3) + 19, evt->fieldID, -1, 0, -1, 0);
            }
            else
            {
              townManager::DoTavern((townManager *)this);
            }
            goto LABEL_188;
          case 5:
            if ( v37 )
              goto LABEL_124;
            if ( *(_BYTE *)(*(_DWORD *)(this + 54) + 55) )
            {
              NormalDialog("This town may not be upgraded to a castle.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
            else
            {
              v7 = CanBuy(*(_DWORD *)(this + 54), 6);
              if ( townManager::BuyBuild((void *)this, 6, (unsigned int)v7 < 1, v37) )
                townManager::BuildObj((townManager *)this, 6);
            }
            goto LABEL_188;
          case 3:
            if ( v37 )
              goto LABEL_124;
            heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 30720, 16392);
            if ( game::GetBoatsBuilt(gpGame) >= 48
              || advManager::GetCell(
                   gpAdvManager,
                   *(_BYTE *)(*(_DWORD *)(this + 54) + 6),
                   *(_BYTE *)(*(_DWORD *)(this + 54) + 7))->objType )
            {
              NormalDialog("Cannot build another boat.", 1, 208, 40, -1, 0, -1, 0, -1, 0);
            }
            else
            {
              v18 = (heroWindow *)operator new(68);
              if ( v18 )
                *(_DWORD *)(this + 354) = heroWindow::heroWindow(v18, 177, 20, "shipwind.bin");
              else
                *(_DWORD *)(this + 354) = 0;
              if ( !*(_DWORD *)(this + 354) )
                MemError();
              SetWinText(*(heroWindow **)(this + 354), 12);
              if ( gpGame->players[giCurPlayer].resources[6] < 1000 || gpGame->players[giCurPlayer].resources[0] < 10 )
              {
                evt->eventCode = 512;
                evt->messageType = 5;
                evt->fieldID = 30722;
                evt->payload = (void *)4096;
                heroWindow::BroadcastMessage(*(heroWindow **)(this + 354), (tag_message *)evt);
                evt->messageType = 6;
                evt->payload = (void *)2;
                heroWindow::BroadcastMessage(*(heroWindow **)(this + 354), (tag_message *)evt);
              }
              heroWindowManager::DoDialog(gpWindowManager, *(heroWindow **)(this + 354), TrueFalseDialogHandler, 0);
              operator delete(*(void **)(this + 354));
              if ( gpWindowManager->buttonPressedCode == 30722 )
              {
                if ( game::CreateBoat(
                       gpGame,
                       *(_BYTE *)(*(_DWORD *)(this + 54) + 6),
                       *(_BYTE *)(*(_DWORD *)(this + 54) + 7),
                       0) == -1 )
                {
                  LogStr("Can't create boat!");
                }
                else
                {
                  townManager::BuildObj((townManager *)this, 14);
                  gpGame->players[giCurPlayer].resources[6] -= 1000;
                  gpGame->players[giCurPlayer].resources[0] -= 10;
                  bankBox::Update(*(bankBox **)(this + 238), 1);
                }
              }
            }
            heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30720, 16392);
            goto LABEL_188;
          case 10:
            if ( v37 )
              goto LABEL_124;
            v30 = 0;
            for ( buildingCode = 0; gpCurPlayer->numCastles > buildingCode; ++buildingCode )
            {
              if ( BYTE1(gpGame->castles[gpCurPlayer->castlesOwned[buildingCode]].buildingsBuiltFlags) & 4 )
                ++v30;
            }
            if ( v30 > 10 )
              v30 = 10;
            DoTradingPost((void *)1, dword_4F5268[v30]);
            townManager::RedrawTownScreen((townManager *)this);
            goto LABEL_188;
          case 7:
          case 8:
          case 9:
          case 11:
          case 12:
          case 13:
            goto LABEL_123;
          default:
            break;
        }
      }
      if ( v37 )
      {
        v29 = 0;
        if ( evt->fieldID >= 117 && evt->fieldID <= 121 )
        {
          *(_DWORD *)(this + 214) = *(_DWORD *)(this + 206);
          *(_DWORD *)(this + 218) = evt->fieldID - 117;
          v29 = 1;
        }
        if ( evt->fieldID >= 123 && evt->fieldID <= 127 )
        {
          *(_DWORD *)(this + 214) = *(_DWORD *)(this + 210);
          *(_DWORD *)(this + 218) = evt->fieldID - 123;
          v29 = 1;
        }
        if ( v29 && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 214) + 128) + *(_DWORD *)(this + 218)) != -1 )
        {
          if ( *(_DWORD *)(this + 214) == *(_DWORD *)(this + 210) )
            hro = &gpGame->heroes[*(_BYTE *)(*(_DWORD *)(this + 54) + 23)];
          else
            hro = 0;
          game::ViewArmy(
            gpGame,
            119,
            20,
            (CREATURES)*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 214) + 128) + *(_DWORD *)(this + 218)),
            *(_WORD *)(*(_DWORD *)(*(_DWORD *)(this + 214) + 128) + 2 * *(_DWORD *)(this + 218) + 5),
            *(_DWORD *)(this + 54),
            1,
            1u,
            1,
            hro,
            0,
            *(armyGroup **)(*(_DWORD *)(this + 214) + 128),
            *(_DWORD *)(this + 218));
          bankBox::Update(*(bankBox **)(this + 238), 1);
        }
      }
      else
      {
        townManager::DoCommand((townManager *)this, *(_DWORD *)(this + 330));
        townManager::SetCommandAndText((townManager *)this, evt);
      }
    }
    goto LABEL_188;
  }
  if ( v16 == 1 )
  {
    v11 = evt->messageType;
    if ( v11 == 1 )
    {
      ++v36;
    }
    else if ( v11 == 42 || v11 == 54 )
    {
      townManager::ShiftQualChange();
    }
    goto LABEL_188;
  }
  if ( v16 == 2 )
  {
    v12 = evt->messageType;
    if ( v12 == 42 || v12 == 54 )
      townManager::ShiftQualChange();
    goto LABEL_188;
  }
  if ( v16 != 4 )
  {
LABEL_188:
    if ( v36 == 1 )
    {
      evt->eventCode = 16384;
      evt->messageType = 1;
      result = 2;
    }
    else
    {
      result = 1;
    }
    return result;
  }
  heroWindowManager::ConvertToHover(gpWindowManager, (tag_message *)evt);
  if ( evt->fieldID != *(_DWORD *)(this + 322) || evt->inputTypeBitmask != *(_DWORD *)(this + 326) )
  {
    *(_DWORD *)(this + 322) = evt->fieldID;
    *(_DWORD *)(this + 326) = evt->inputTypeBitmask;
    townManager::SetCommandAndText((townManager *)this, evt);
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F4B88: using guessed type int giDebugBuildingToBuild;
// 4F5268: using guessed type int dword_4F5268[];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (00413F80) --------------------------------------------------------
int __thiscall townManager::DoCommand(townManager *this, int a2)
{
  __int16 v2; // ST4C_2@23
  int result; // eax@27
  int thisa; // [sp+10h] [bp-14h]@1
  int a7; // [sp+14h] [bp-10h]@9
  hero *hro; // [sp+18h] [bp-Ch]@4
  int i; // [sp+20h] [bp-4h]@16

  thisa = (int)this;
  switch ( a2 )
  {
    case 0:
      this->field_DE = this->field_D6;
      this->field_E2 = this->field_DA;
      this->field_DE->drawBorder = this->field_E2;
      strip::Draw((int)this->field_DE);
      break;
    case 1:
      if ( this->field_D6 == this->visitingArmyDisplay )
        hro = &gpGame->heroes[this->castle->visitingHeroIdx];
      else
        hro = 0;
      a7 = this->field_15A == 1
        || this->field_D6 == this->visitingArmyDisplay && armyGroup::GetNumArmies(this->field_D6->army) == 1;
      game::ViewArmy(
        gpGame,
        119,
        20,
        (CREATURES)*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(thisa + 214) + 128) + *(_DWORD *)(thisa + 218)),
        *(_WORD *)(*(_DWORD *)(*(_DWORD *)(thisa + 214) + 128) + 2 * *(_DWORD *)(thisa + 218) + 5),
        *(_DWORD *)(thisa + 54),
        a7,
        1u,
        0,
        hro,
        0,
        *(armyGroup **)(*(_DWORD *)(thisa + 214) + 128),
        *(_DWORD *)(thisa + 218));
      bankBox::Update(*(bankBox **)(thisa + 238), 1);
      if ( gpWindowManager->buttonPressedCode == 30722 )
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(thisa + 214) + 128) + *(_DWORD *)(thisa + 218)) = -1;
        *(_WORD *)(*(_DWORD *)(*(_DWORD *)(thisa + 214) + 128) + 2 * *(_DWORD *)(thisa + 218) + 5) = 0;
      }
      townManager::ResetStrips(thisa);
      break;
    case 2:
      if ( this->field_E6 != this->field_DE
        && this->field_DE->army->creatureTypes[this->field_E2] != this->field_E6->army->creatureTypes[this->field_EA] )
      {
        for ( i = 0;
              i < 5 && this->field_DE->army->creatureTypes[this->field_E2] != this->field_E6->army->creatureTypes[i];
              ++i )
          ;
        if ( i < 5 )
          this->field_EA = i;
      }
      this->field_E6->army->quantities[this->field_EA] += this->field_DE->army->quantities[this->field_E2];
      this->field_DE->army->creatureTypes[this->field_E2] = -1;
      this->field_DE->army->quantities[this->field_E2] = 0;
      townManager::ResetStrips((int)this);
      break;
    case 3:
      v2 = this->field_E6->army->quantities[this->field_EA];
      this->field_E6->army->quantities[this->field_EA] = this->field_DE->army->quantities[this->field_E2];
      this->field_DE->army->quantities[this->field_E2] = v2;
      LOBYTE(v2) = this->field_E6->army->creatureTypes[this->field_EA];
      this->field_E6->army->creatureTypes[this->field_EA] = this->field_DE->army->creatureTypes[this->field_E2];
      this->field_DE->army->creatureTypes[this->field_E2] = v2;
      townManager::ResetStrips((int)this);
      break;
    case 4:
      HeroView(this->castle->visitingHeroIdx, 1, 0);
      townManager::RedrawTownScreen((townManager *)thisa);
      heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
      break;
    case 5:
      townManager::SplitArmy(this);
      townManager::ResetStrips(thisa);
      break;
    default:
      break;
  }
  result = thisa;
  *(_DWORD *)(thisa + 322) = -1;
  return result;
}

//----- (00414470) --------------------------------------------------------
void __thiscall townManager::RedrawTownScreen(townManager *this)
{
  townManager *thisa; // ST1C_4@1
  GUIMessage evt; // [sp+10h] [bp-1Ch]@1

  thisa = this;
  townManager::DrawTown(this, 0, 1);
  evt.eventCode = 512;
  evt.messageType = 3;
  evt.fieldID = 902;
  evt.payload = thisa->infoMessage;
  heroWindow::BroadcastMessage(thisa->townScreen, (tag_message *)&evt);
  heroWindow::DrawWindow(thisa->townScreen, 0);
  strip::DrawIcons(thisa->garrisonDisplay, 0);
  strip::DrawIcons(thisa->visitingArmyDisplay, 0);
  bankBox::Update(thisa->bankbox, 0);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
}

//----- (00414520) --------------------------------------------------------
heroWindowManager *__thiscall townManager::SplitArmy(void *this)
{
  heroWindowManager *result; // eax@9
  void *v2; // [sp+14h] [bp-38h]@1
  heroWindow *thisa; // [sp+20h] [bp-2Ch]@1
  signed int v4; // [sp+24h] [bp-28h]@10
  int evt; // [sp+28h] [bp-24h]@6
  int v6; // [sp+2Ch] [bp-20h]@9
  int v7; // [sp+30h] [bp-1Ch]@9
  char *v8; // [sp+40h] [bp-Ch]@9
  __int16 v9; // [sp+44h] [bp-8h]@1
  __int16 v10; // [sp+48h] [bp-4h]@1

  v2 = this;
  v10 = 1;
  v9 = 4;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    *(_DWORD *)((char *)v2 + 358) = heroWindow::heroWindow(thisa, 177, 20, "splitwin.bin");
  else
    *(_DWORD *)((char *)v2 + 358) = 0;
  if ( !*(_DWORD *)((char *)v2 + 358) )
    MemError();
  *(_DWORD *)((char *)v2 + 362) = 0;
  *(_DWORD *)((char *)v2 + 366) = *(_WORD *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128)
                                           + 2 * *(_DWORD *)((char *)v2 + 226)
                                           + 5);
  evt = 512;
  if ( *(_DWORD *)(*(_DWORD *)((char *)v2 + 230) + 128) == *(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128) )
    sprintf(gText, "Move how many troops?");
  else
    sprintf(
      gText,
      "Move how many %s troops from %s to %s?",
      gArmyNames[*(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128) + *(_DWORD *)((char *)v2 + 226))],
      &aHeroSArmy_0[("Garrison" - "Hero's Army") & ((*(_DWORD *)((char *)v2 + 222) == *(_DWORD *)((char *)v2 + 210)) - 1)],
      &aHeroSArmy[("Garrison" - "Hero's Army") & ((*(_DWORD *)((char *)v2 + 230) == *(_DWORD *)((char *)v2 + 210)) - 1)]);
  v6 = 3;
  v7 = 1;
  v8 = gText;
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v2 + 358), (tag_message *)&evt);
  sprintf(gText, "%d", *(_DWORD *)((char *)v2 + 362));
  v7 = 4;
  v8 = gText;
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v2 + 358), (tag_message *)&evt);
  heroWindowManager::DoDialog(
    gpWindowManager,
    *(heroWindow **)((char *)v2 + 358),
    (int (__fastcall *)(tag_message *))SplitArmyHandler,
    0);
  operator delete(*(void **)((char *)v2 + 358));
  result = gpWindowManager;
  if ( gpWindowManager->buttonPressedCode == 30722 )
  {
    v4 = 0;
    if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128) + *(_DWORD *)((char *)v2 + 226)) == *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 230) + 128) + *(_DWORD *)((char *)v2 + 234)) )
      v4 = 1;
    if ( v4 )
    {
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 230) + 128) + 2 * *(_DWORD *)((char *)v2 + 234) + 5) += *((_WORD *)v2 + 181);
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 230) + 128) + *(_DWORD *)((char *)v2 + 234)) = *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128) + *(_DWORD *)((char *)v2 + 226));
      *(_WORD *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 230) + 128) + 2 * *(_DWORD *)((char *)v2 + 234) + 5) = *(_DWORD *)((char *)v2 + 362);
    }
    result = (heroWindowManager *)(*(_WORD *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128)
                                            + 2 * *(_DWORD *)((char *)v2 + 226)
                                            + 5)
                                 - *(_DWORD *)((char *)v2 + 362));
    *(_WORD *)(*(_DWORD *)(*(_DWORD *)((char *)v2 + 222) + 128) + 2 * *(_DWORD *)((char *)v2 + 226) + 5) = (_WORD)result;
  }
  return result;
}

//----- (004148A0) --------------------------------------------------------
void __cdecl townManager::ShiftQualChange()
{
  inputManager::ForceMouseMove();
}

//----- (004148D0) --------------------------------------------------------
int __thiscall townManager::ResetStrips(int this)
{
  int result; // eax@5
  int v2; // [sp+Ch] [bp-4h]@1

  v2 = this;
  if ( *(_DWORD *)(this + 222) )
    *(_DWORD *)(*(_DWORD *)(this + 222) + 40) = -1;
  if ( *(_DWORD *)(this + 230) )
    *(_DWORD *)(*(_DWORD *)(this + 230) + 40) = -1;
  strip::Draw(*(_DWORD *)(this + 210));
  strip::Draw(*(_DWORD *)(v2 + 206));
  *(_DWORD *)(v2 + 230) = 0;
  *(_DWORD *)(v2 + 222) = *(_DWORD *)(v2 + 230);
  *(_DWORD *)(v2 + 234) = -1;
  result = *(_DWORD *)(v2 + 234);
  *(_DWORD *)(v2 + 226) = result;
  return result;
}

//----- (00414980) --------------------------------------------------------
int __thiscall sub_414980(int this, int a2)
{
  int result; // eax@1
  int i; // [sp+10h] [bp-4h]@2

  result = *(_DWORD *)(this + 54);
  if ( (1 << a2) & *(_DWORD *)(result + 24) )
  {
    for ( i = 0; ; ++i )
    {
      result = this;
      if ( *(_DWORD *)(this + 190) <= i )
        break;
      if ( *(_DWORD *)(*(_DWORD *)(this + 4 * i + 62) + 12) == a2 )
        *(_DWORD *)(*(_DWORD *)(this + 4 * i + 62) + 8) ^= 1u;
    }
  }
  return result;
}

//----- (00414A00) --------------------------------------------------------
void __thiscall townManager::DrawTown(townManager *this, int a2, int a3)
{
  townManager *thisa; // [sp+Ch] [bp-8h]@1
  int i; // [sp+10h] [bp-4h]@1

  thisa = this;
  PollSound();
  icon::DrawToBuffer(thisa->couldBeBackground, 0, 0, 0, 0);
  PollSound();
  for ( i = 0; thisa->curBuilding > i; ++i )
  {
    townObject::Draw(thisa->buildingDisplays[i], a3);
    PollSound();
  }
  heroWindow::DrawWindow(thisa->townScreen, 0, 136, 137);
  PollSound();
  if ( a2 )
    BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 256, 0, 0);
  PollSound();
}

//----- (00414AC0) --------------------------------------------------------
bool __thiscall townManager::BuyBuild(void *this, signed int a2, int a3, int a4)
{
  int v4; // eax@18
  int v5; // eax@21
  const char *v6; // eax@58
  char *v7; // eax@64
  int v8; // eax@85
  char *v9; // eax@88
  IconEntry *v10; // eax@110
  int v11; // eax@111
  __int16 v12; // ST14_2@119
  __int16 v13; // ST08_2@119
  __int16 v14; // ST04_2@119
  __int16 v15; // bx@119
  IconEntry *v16; // eax@119
  bool result; // eax@138
  void *v18; // [sp+Ch] [bp-14Ch]@1
  iconWidget *thisa; // [sp+18h] [bp-140h]@118
  textWidget *v20; // [sp+1Ch] [bp-13Ch]@113
  textWidget *v21; // [sp+20h] [bp-138h]@89
  heroWindow *v22; // [sp+24h] [bp-134h]@79
  int v23; // [sp+2Ch] [bp-12Ch]@59
  int v24; // [sp+30h] [bp-128h]@59
  char *content; // [sp+34h] [bp-124h]@1
  int v26[7]; // [sp+3Ch] [bp-11Ch]@114
  char v27[28]; // [sp+58h] [bp-100h]@113
  int v28[7]; // [sp+74h] [bp-E4h]@119
  int n[4]; // [sp+90h] [bp-C8h]@105
  int v30; // [sp+A0h] [bp-B8h]@45
  int evt; // [sp+A4h] [bp-B4h]@84
  int v32; // [sp+A8h] [bp-B0h]@84
  int v33; // [sp+ACh] [bp-ACh]@84
  int v34; // [sp+BCh] [bp-9Ch]@84
  int v35; // [sp+C0h] [bp-98h]@45
  int v36; // [sp+C4h] [bp-94h]@111
  __int16 v37; // [sp+C8h] [bp-90h]@45
  __int16 v38; // [sp+CCh] [bp-8Ch]@45
  int j; // [sp+D0h] [bp-88h]@94
  int v40; // [sp+D4h] [bp-84h]@97
  __int16 y[2]; // [sp+D8h] [bp-80h]@96
  int v42; // [sp+DCh] [bp-7Ch]@70
  char v43[8]; // [sp+E0h] [bp-78h]@3
  int v44; // [sp+E8h] [bp-70h]@1
  __int16 v45; // [sp+ECh] [bp-6Ch]@45
  int i; // [sp+F0h] [bp-68h]@1
  int v47; // [sp+F4h] [bp-64h]@111
  int v48; // [sp+F8h] [bp-60h]@45
  heroWindow *a2a; // [sp+FCh] [bp-5Ch]@80
  char v50; // [sp+100h] [bp-58h]@84
  int v51; // [sp+110h] [bp-48h]@100
  __int16 v52; // [sp+114h] [bp-44h]@45
  int v53; // [sp+118h] [bp-40h]@70
  int v54; // [sp+11Ch] [bp-3Ch]@70
  icon *res; // [sp+120h] [bp-38h]@94
  __int16 v56; // [sp+124h] [bp-34h]@45
  int v57; // [sp+128h] [bp-30h]@75
  int v58; // [sp+12Ch] [bp-2Ch]@1
  int v59; // [sp+130h] [bp-28h]@111
  int v60; // [sp+134h] [bp-24h]@45
  int v61; // [sp+138h] [bp-20h]@4
  __int16 v62; // [sp+13Ch] [bp-1Ch]@45
  __int16 width[2]; // [sp+140h] [bp-18h]@113
  __int16 v64[8]; // [sp+144h] [bp-14h]@3
  widget *guiObj; // [sp+154h] [bp-4h]@90

  v18 = this;
  v58 = 0;
  v44 = 0;
  content = (char *)BaseAlloc(0x190u, "F:\\h2xsrc\\Source\\TOWNMGR.CPP", word_4EEF50 + 8);
  for ( i = 0; i < 7; ++i )
  {
    v64[i] = -1;
    v43[i] = LOBYTE(v64[i]);
  }
  v61 = -1;
  if ( a2 >= 19 && a2 <= 30 )
    v61 = a2 - 19;
  if ( a2 != 2 || *(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3) != 5 )
  {
    if ( a2 )
    {
      if ( a2 == 13 )
      {
        for ( i = 0; i < 7; ++i )
        {
          if ( *((_DWORD *)&gSpecialBuildingCosts + 7 * gpTownManager->castle->factionID + i) > 0 )
          {
            v43[v44] = i;
            v64[v44++] = *((_DWORD *)&gSpecialBuildingCosts + 7 * gpTownManager->castle->factionID + i);
          }
        }
      }
      else if ( a2 > 15 )
      {
        for ( i = 0; i < 7; ++i )
        {
          if ( *(&gDwellingCosts[12 * (signed int)gpTownManager->castle->factionID].wood + 7 * v61 + i) > 0 )
          {
            v43[v44] = i;
            v64[v44++] = *(&gDwellingCosts[12 * (signed int)gpTownManager->castle->factionID].wood + 7 * v61 + i);
          }
        }
      }
      else
      {
        for ( i = 0; i < 7; ++i )
        {
          if ( *((_DWORD *)&gNeutralBuildingCosts + 7 * a2 + i) > 0 )
          {
            v43[v44] = i;
            v64[v44++] = *((_DWORD *)&gNeutralBuildingCosts + 7 * a2 + i);
          }
        }
      }
    }
    else
    {
      v58 = gpTownManager->castle->mageGuildLevel;
      for ( i = 0; i < 7; ++i )
      {
        v4 = v58 + 1;
        if ( v58 + 1 >= 5 )
          v4 = 5;
        if ( *(&gMageBuildingCosts[7 * v4] + i) > 0 )
        {
          v43[v44] = i;
          v5 = v58 + 1;
          if ( v58 + 1 >= 5 )
            v5 = 5;
          v64[v44++] = *(&gMageBuildingCosts[7 * v5] + i);
        }
      }
    }
  }
  else
  {
    for ( i = 0; i < 7; ++i )
    {
      if ( *((_DWORD *)&xShrineBuildingCost + i) > 0 )
      {
        v43[v44] = i;
        v64[v44++] = *((_DWORD *)&xShrineBuildingCost + i);
      }
    }
  }
  v62 = 40;
  v37 = 32;
  v56 = 289;
  v45 = 0;
  v52 = 2;
  v38 = 3;
  v35 = 0;
  v60 = 0;
  v30 = 0;
  v48 = 0;
  for ( i = 0; i < 7; ++i )
  {
    if ( v43[i] != -1 )
      ++v60;
  }
  if ( v60 > 4 )
  {
    switch ( v60 )
    {
      case 5:
        v30 = 2;
        v48 = 3;
        break;
      case 6:
        v30 = 3;
        v48 = 3;
        break;
      case 7:
        v30 = 3;
        v48 = 4;
        break;
    }
  }
  else
  {
    v30 = v60;
  }
  v6 = GetBuildingInfo(*(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3), a2, 0);
  sprintf(content, v6);
  if ( v61 >= 0 )
  {
    v24 = 0;
    v23 = *(&gHierarchyMask[12 * *(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3)] + v61);
    for ( i = 0; i < 32; ++i )
    {
      if ( (1 << i) & v23 )
      {
        if ( !v24 )
          strcat(content, "\n\nRequires:");
        ++v24;
        strcat(content, L"\n");
        v7 = GetBuildingName(*(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3), i);
        strcat(content, v7);
      }
    }
    if ( *(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3) == 5
      && a2 == 28
      && (signed int)*(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 28) <= 2 )
      strcat(content, "\nLevel 2 Mage Guild");
  }
  strcat(content, "\n ");
  v53 = font::LineLength(bigFont, content, 240);
  v42 = 151;
  v54 = 16 * v53 + 151;
  if ( v60 > 4 )
    v54 += 88;
  else
    v54 += 44;
  if ( !a4 )
    v54 += 39;
  v57 = (v54 - 69) / 45;
  if ( v57 < 3 )
    v57 = 3;
  if ( v57 > 6 )
    v57 = 6;
  sprintf(gText, "buybuil%d.bin", v57);
  v22 = (heroWindow *)operator new(68);
  if ( v22 )
    a2a = heroWindow::heroWindow(v22, 158, 16, gText);
  else
    a2a = 0;
  if ( !a2a )
    MemError();
  evt = 512;
  v32 = 9;
  v33 = 2;
  sprintf(&v50, "cstl%s.icn", cHeroTypeShortName[*(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3)]);
  v34 = (int)&v50;
  heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
  v32 = 4;
  v33 = 2;
  v34 = a2;
  heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
  if ( a2 )
  {
    v9 = GetBuildingName(*(_BYTE *)(*(_DWORD *)((char *)v18 + 54) + 3), a2);
    strcpy(gText, v9);
  }
  else
  {
    v8 = v58 + 1;
    if ( v58 + 1 >= 5 )
      v8 = 5;
    sprintf(gText, "Mage Guild, Level %d", v8);
  }
  v32 = 3;
  v33 = 3;
  v34 = (int)gText;
  heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
  v21 = (textWidget *)operator new(43);
  if ( v21 )
    guiObj = (widget *)textWidget::textWidget(v21, 43, v42 + 24, 240, 16 * v53, content, "bigfont.fnt", 1, -1, 8, 1);
  else
    guiObj = 0;
  if ( !guiObj )
    MemError();
  heroWindow::AddWidget(a2a, guiObj, -1);
  v35 = 0;
  res = resourceManager::GetIcon(gpResourceManager, "resource.icn");
  for ( j = 0; j < 2; ++j )
  {
    *(_DWORD *)y = v42 + 16 * v53 + 44 * j + 12;
    if ( j )
      v40 = v48;
    else
      v40 = v30;
    if ( v40 > 0 )
    {
      v51 = 0;
      v44 = v35;
      for ( i = 0; i < 4; ++i )
      {
        if ( i >= v40 )
        {
          n[i] = -1;
        }
        else
        {
          while ( v43[v44] == -1 )
            ++v44;
          n[i] = v43[v44++];
        }
      }
      for ( i = 0; i < v40; ++i )
      {
        v10 = GetIconEntry(res, n[i]);
        v51 += v10->width;
      }
      v47 = (256 - v51) / (v40 + 1);
      v11 = (256 - v51) / (v40 + 1);
      v36 = v11 + 32;
      v59 = v11 + 32;
      for ( i = 0; i < v40; ++i )
      {
        *(_DWORD *)width = GetIconEntry(res, n[i])->width;
        *(_DWORD *)&v27[4 * v35] = BaseAlloc(0xAu, "F:\\h2xsrc\\Source\\TOWNMGR.CPP", word_4EEF50 + 296);
        sprintf(*(char **)&v27[4 * v35], "%d", v64[v35]);
        v20 = (textWidget *)operator new(43);
        if ( v20 )
          v26[v35] = (int)textWidget::textWidget(
                            v20,
                            v59,
                            y[0] + 35,
                            width[0],
                            12,
                            *(char **)&v27[4 * v35],
                            "smalfont.fnt",
                            1,
                            -1,
                            8,
                            1);
        else
          v26[v35] = 0;
        if ( !v26[v35] )
          MemError();
        thisa = (iconWidget *)operator new(45);
        if ( thisa )
        {
          v12 = v43[v35];
          v13 = width[0];
          v14 = y[0];
          v15 = v59;
          v16 = GetIconEntry(res, n[i]);
          v28[v35] = (int)iconWidget::iconWidget(
                            thisa,
                            v15 - v16->offsetX,
                            v14,
                            v13,
                            12,
                            "resource.icn",
                            v12,
                            0,
                            -1,
                            16,
                            1);
        }
        else
        {
          v28[v35] = 0;
        }
        if ( !v28[v35] )
          MemError();
        heroWindow::AddWidget(a2a, (widget *)v26[v35], -1);
        heroWindow::AddWidget(a2a, (widget *)v28[v35++], -1);
        v59 += *(_DWORD *)width + v47;
      }
    }
  }
  resourceManager::Dispose(gpResourceManager, (resource *)res);
  if ( !a4 )
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 30720, 16392);
  *(_DWORD *)((char *)v18 + 350) = -1;
  if ( a4 )
  {
    v32 = 6;
    v34 = 6;
    v33 = 30722;
    heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
    v32 = 6;
    v34 = 6;
    v33 = 30721;
    heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
    v32 = 6;
    v34 = 6;
    v33 = 0;
    heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
    heroWindowManager::AddWindow(gpWindowManager, a2a, -1, 1);
    QuickViewWait();
    heroWindowManager::RemoveWindow(gpWindowManager, a2a);
  }
  else
  {
    if ( a3 )
    {
      v32 = 6;
      v33 = 30722;
      v34 = 2;
      heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
      v32 = 5;
      v33 = 30722;
      v34 = 4096;
      heroWindow::BroadcastMessage(a2a, (tag_message *)&evt);
    }
    heroWindowManager::DoDialog(gpWindowManager, a2a, TrueFalseDialogHandler, 0);
    if ( gpWindowManager->buttonPressedCode == 30722 )
    {
      *(_DWORD *)((char *)v18 + 350) = a2;
      for ( i = 0; i < v60; ++i )
        gpCurPlayer->resources[v43[i]] -= v64[i];
    }
  }
  if ( !a4 )
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30720, 16392);
  operator delete(a2a);
  if ( a4 )
    result = 0;
  else
    result = gpWindowManager->buttonPressedCode == 30722;
  return result;
}
// 4EEF50: using guessed type __int16 word_4EEF50;
// 4F4288: using guessed type building_cost gDwellingCosts[];
// 4F4A68: using guessed type int gHierarchyMask[];
// 4F4BA0: using guessed type char *cHeroTypeShortName[6];
// 414AC0: using guessed type __int16 var_14[8];
// 414AC0: using guessed type char var_78[8];
// 414AC0: using guessed type int n[4];
// 414AC0: using guessed type int var_11C[7];
// 414AC0: using guessed type int var_E4[7];

//----- (004158D0) --------------------------------------------------------
void __thiscall townManager::BuildObj(townManager *this, signed int buildingCode)
{
  townManager *thisa; // [sp+Ch] [bp-30h]@1
  int imageIdx; // [sp+18h] [bp-24h]@20
  signed int buildingDispForNewBuildingIdx; // [sp+1Ch] [bp-20h]@13
  H2RECT rect; // [sp+20h] [bp-1Ch]@22
  int i; // [sp+30h] [bp-Ch]@7
  SAMPLE2 res; // [sp+34h] [bp-8h]@27

  thisa = this;
  if ( (!((1 << buildingCode) & this->castle->buildingsBuiltFlags) || !buildingCode && this->castle->mageGuildLevel != 5)
    && (buildingCode != BUILDING_DOCK || town::CanBuildDock(this->castle)) )
  {
    townManager::DrawTown(thisa, 1, 1);
    town::BuildBuilding(thisa->castle, buildingCode);
    for ( i = 0; thisa->curBuilding > i; ++i )
    {
      if ( (1 << LOBYTE(thisa->buildingDisplays[i]->buildingCode)) & thisa->castle->buildingsBuiltFlags )
      {
        thisa->buildingDisplays[i]->built = 1;
        thisa->buildingDisplays[i]->guiElement->flagsRelatedToShouldDisplayAndPerhapsMouseCode |= 2u;
      }
      else
      {
        thisa->buildingDisplays[i]->built = 0;
        thisa->buildingDisplays[i]->guiElement->flagsRelatedToShouldDisplayAndPerhapsMouseCode &= 0xFFFDu;
      }
    }
    buildingDispForNewBuildingIdx = -1;
    for ( i = 0; thisa->curBuilding > i; ++i )
    {
      if ( thisa->buildingDisplays[i]->buildingCode == buildingCode )
        buildingDispForNewBuildingIdx = i;
    }
    giMaxExtentY = 0;
    giMaxExtentX = 0;
    giMinExtentX = 639;
    giMinExtentY = 255;
    gbComputeExtent = 1;
    gbSaveBiggestExtent = 1;
    gbReturnAfterComputeExtent = 1;
    if ( buildingCode )
    {
      icon::CombatClipDrawToBuffer(
        thisa->buildingDisplays[buildingDispForNewBuildingIdx]->icon,
        0,
        0,
        0,
        &rect,
        0,
        0,
        0,
        0);
      if ( thisa->buildingDisplays[buildingDispForNewBuildingIdx]->animationLength )
        icon::CombatClipDrawToBuffer(
          thisa->buildingDisplays[buildingDispForNewBuildingIdx]->icon,
          0,
          0,
          1,
          &rect,
          0,
          0,
          0,
          0);
    }
    else
    {
      if ( gpTownManager->castle->factionID == FACTION_NECROMANCER )
        imageIdx = 2 * (3 * gpTownManager->castle->mageGuildLevel - 3);
      else
        imageIdx = gpTownManager->castle->mageGuildLevel - 1;
      icon::CombatClipDrawToBuffer(
        thisa->buildingDisplays[buildingDispForNewBuildingIdx]->icon,
        0,
        0,
        imageIdx,
        &rect,
        0,
        0,
        0,
        0);
      if ( thisa->buildingDisplays[buildingDispForNewBuildingIdx]->animationLength )
        icon::CombatClipDrawToBuffer(
          thisa->buildingDisplays[buildingDispForNewBuildingIdx]->icon,
          0,
          0,
          imageIdx + 1,
          &rect,
          0,
          0,
          0,
          0);
    }
    gbComputeExtent = 0;
    gbSaveBiggestExtent = 0;
    gbReturnAfterComputeExtent = 0;
    heroWindowManager::SaveFizzleSource(
      gpWindowManager,
      giMinExtentX,
      giMinExtentY,
      giMaxExtentX - giMinExtentX + 1,
      giMaxExtentY - giMinExtentY + 1);
    townManager::DrawTown(thisa, 0, 1);
    res = NULL_SAMPLE2;
    res = (SAMPLE2)LoadPlaySample("buildtwn.82M");
    heroWindowManager::FizzleForward(
      gpWindowManager,
      giMinExtentX,
      giMinExtentY,
      giMaxExtentX - giMinExtentX + 1,
      giMaxExtentY - giMinExtentY + 1,
      -1,
      0,
      0);
    WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
    PollSound();
    thisa->field_15E = -1;
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30720, 16392);
    townManager::RedrawTownScreen(thisa);
  }
}
// 4F1998: using guessed type int gbReturnAfterComputeExtent;
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00415CC0) --------------------------------------------------------
void __thiscall townManager::SetupMage(townManager *this, heroWindow *mageGuildWindow)
{
  int v2; // eax@22
  int v3; // eax@23
  void *v4; // ST2C_4@27
  bool v6; // [sp+10h] [bp-5Ch]@9
  tag_message evt; // [sp+20h] [bp-4Ch]@1
  int j; // [sp+3Ch] [bp-30h]@5
  __int16 v9; // [sp+40h] [bp-2Ch]@1
  __int16 v10; // [sp+44h] [bp-28h]@1
  int i; // [sp+4Ch] [bp-20h]@3
  bool v12; // [sp+50h] [bp-1Ch]@12
  __int16 v13; // [sp+54h] [bp-18h]@1
  __int16 v14; // [sp+58h] [bp-14h]@1
  __int16 v15; // [sp+5Ch] [bp-10h]@1
  __int16 v16; // [sp+60h] [bp-Ch]@1
  __int16 v17; // [sp+64h] [bp-8h]@1
  __int16 v18; // [sp+68h] [bp-4h]@1

  v18 = 0;
  v13 = 1;
  v9 = 999;
  v10 = 2;
  v17 = 10;
  v14 = 40;
  v15 = 70;
  v16 = 100;
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  if ( this->castle->visitingHeroIdx == -1 )
  {
    strcpy(gText, "The above spells are available here.");
    evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
    evt.yCoordOrFieldID = 110;
    evt.payload = gText;
    heroWindow::BroadcastMessage(mageGuildWindow, &evt);
  }
  for ( i = 0; i < 5; ++i )
  {
    for ( j = 0; j < 4; ++j )
    {
      v6 = this->castle->factionID == FACTION_WIZARD && BYTE1(this->castle->buildingsBuiltFlags) & 0x20;
      if ( v6 + gSpellLimits[i] > j )
        v12 = this->castle->numSpellsOfLevel[i] <= j;
      else
        v12 = 999;
      if ( v12 == 999 )
        evt.xCoordOrKeycode = 6;
      else
        evt.xCoordOrKeycode = 5;
      evt.yCoordOrFieldID = j + 4 * i + 10;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(mageGuildWindow, &evt);
      if ( v12 != 999 )
      {
        evt.xCoordOrKeycode = GUI_MESSAGE_SET_IMG_IDX;
        evt.yCoordOrFieldID = j + 4 * i + 10;
        evt.payload = (void *)v12;
        heroWindow::BroadcastMessage(mageGuildWindow, &evt);
      }
      if ( v12 )
      {
        evt.xCoordOrKeycode = 6;
        evt.payload = (void *)ICON_GUI_VISIBLE;
        evt.yCoordOrFieldID = j + 4 * i + 40;
        heroWindow::BroadcastMessage(mageGuildWindow, &evt);
        evt.yCoordOrFieldID = j + 4 * i + 70;
        heroWindow::BroadcastMessage(mageGuildWindow, &evt);
      }
      else
      {
        evt.xCoordOrKeycode = GUI_MESSAGE_SET_IMG_IDX;
        evt.yCoordOrFieldID = j + 4 * i + 40;
        evt.payload = (void *)gsSpellInfo[this->castle->mageGuildSpells[i][j]].spriteIdx;
        heroWindow::BroadcastMessage(mageGuildWindow, &evt);
        if ( font::LineLength(smallFont, gSpellNames[this->castle->mageGuildSpells[i][j]], 74) == 1 )
        {
          v2 = GetManaCost(this->castle->mageGuildSpells[i][j], 0);
          sprintf(gText, "%s\n[%d]", gSpellNames[this->castle->mageGuildSpells[i][j]], v2);
        }
        else
        {
          v3 = GetManaCost(this->castle->mageGuildSpells[i][j], 0);
          sprintf(gText, "%s  [%d]", gSpellNames[this->castle->mageGuildSpells[i][j]], v3);
        }
        evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
        evt.yCoordOrFieldID = j + 4 * i + 70;
        evt.payload = gText;
        heroWindow::BroadcastMessage(mageGuildWindow, &evt);
      }
    }
  }
  v4 = (void *)(this->castle->mageGuildLevel - 1);
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_IMG_IDX;
  evt.yCoordOrFieldID = 100;
  evt.payload = v4;
  heroWindow::BroadcastMessage(mageGuildWindow, &evt);
  sprintf(gText, "magegld%c.icn", cHeroTypeInitial[this->castle->factionID]);
  evt.xCoordOrKeycode = 9;
  evt.yCoordOrFieldID = 100;
  evt.payload = gText;
  heroWindow::BroadcastMessage(mageGuildWindow, &evt);
}

//----- (004160A0) --------------------------------------------------------
signed int __fastcall MageGuildHandler(tag_message *evt)
{
  signed int result; // eax@14
  int spell; // ST0C_4@15
  int v3; // [sp+Ch] [bp-28h]@2
  signed int col; // [sp+18h] [bp-1Ch]@13
  signed int rowTimesFour; // [sp+2Ch] [bp-8h]@3

  if ( evt->eventCode != 512 )
    goto LABEL_22;
  v3 = evt->xCoordOrKeycode;
  if ( v3 != 12 && v3 != 14 )
    goto LABEL_22;
  rowTimesFour = -1;
  if ( evt->yCoordOrFieldID >= 10 && evt->yCoordOrFieldID < 30 )
    rowTimesFour = evt->yCoordOrFieldID - 10;
  if ( evt->yCoordOrFieldID >= 40 && evt->yCoordOrFieldID < 60 )
    rowTimesFour = evt->yCoordOrFieldID - 40;
  if ( evt->yCoordOrFieldID >= 70 && evt->yCoordOrFieldID < 90 )
    rowTimesFour = evt->yCoordOrFieldID - 70;
  if ( rowTimesFour == -1 )
  {
LABEL_22:
    result = EventWindowHandler(evt);
  }
  else
  {
    col = (((unsigned __int64)rowTimesFour >> 32) ^ abs(rowTimesFour) & 3) - ((unsigned __int64)rowTimesFour >> 32);
    if ( gpTownManager->castle->numSpellsOfLevel[rowTimesFour / 4] > col )
    {
      spell = gpTownManager->castle->mageGuildSpells[rowTimesFour / 4][col];
      NormalDialog(gSpellDesc[spell], (evt->inputTypeBitmask & 0x200u) < 1 ? 1 : 4, -1, -1, 8, spell, -1, 0, -1, 0);
      result = 1;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}

//----- (00416230) --------------------------------------------------------
bool __thiscall townManager::RecruitHero(townManager *this, int a2, int a3)
{
  int x; // ST40_4@15
  int y; // ST3C_4@15
  int v5; // eax@15
  mapCell *v6; // ST28_4@15
  int v7; // ST44_4@17
  int v8; // eax@17
  char v9; // al@17
  heroWindow *thisa; // [sp+20h] [bp-54h]@1
  tag_message evt; // [sp+38h] [bp-3Ch]@6
  __int16 v14; // [sp+54h] [bp-20h]@1
  __int16 v15; // [sp+58h] [bp-1Ch]@1
  __int16 v16; // [sp+5Ch] [bp-18h]@1
  __int16 v17; // [sp+60h] [bp-14h]@1
  __int16 v18; // [sp+64h] [bp-10h]@1
  HERO_CONSTANTS i; // [sp+68h] [bp-Ch]@8
  __int16 v20; // [sp+6Ch] [bp-8h]@1
  int v21; // [sp+70h] [bp-4h]@8

  v15 = 2;
  v16 = 3;
  v20 = 4;
  v18 = 6;
  v17 = 8;
  v14 = 9;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    this->dialog = heroWindow::heroWindow(thisa, 177, 16, "rcrthero.bin");
  else
    this->dialog = 0;
  if ( !this->dialog )
    MemError();
  SetWinText(this->dialog, 20);
  this->heroBeingRecruited = &gpGame->heroes[gpCurPlayer->heroesForPurchase[a2]];
  this->heroBeingRecruited->ownerIdx = giCurPlayer;
  evt.eventCode = 512;
  if ( a3 )
  {
    evt.xCoordOrKeycode = 6;
    evt.payload = (void *)2;
    evt.yCoordOrFieldID = 8;
    heroWindow::BroadcastMessage(this->dialog, &evt);
    evt.yCoordOrFieldID = 9;
    heroWindow::BroadcastMessage(this->dialog, &evt);
    evt.yCoordOrFieldID = 30722;
    heroWindow::BroadcastMessage(this->dialog, &evt);
    evt.xCoordOrKeycode = 5;
    evt.payload = (void *)4096;
    evt.yCoordOrFieldID = 8;
    heroWindow::BroadcastMessage(this->dialog, &evt);
    evt.yCoordOrFieldID = 9;
    heroWindow::BroadcastMessage(this->dialog, &evt);
    evt.yCoordOrFieldID = 30722;
    heroWindow::BroadcastMessage(this->dialog, &evt);
  }
  v21 = 0;
  for ( i = 0; i < MAX_ARTIFACTS; ++i )
  {
    if ( this->heroBeingRecruited->artifacts[i] != -1 )
    {
      if ( this->heroBeingRecruited->artifacts[i] != ARTIFACT_MAGIC_BOOK )
        ++v21;
    }
  }
  sprintf(
    gText,
    "%s is a level %d %s with %d artifacts.",
    this->heroBeingRecruited->name,
    this->heroBeingRecruited->oldLevel,
    gAlignmentNames[this->heroBeingRecruited->factionID],
    v21);
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 1;
  evt.payload = gText;
  heroWindow::BroadcastMessage(this->dialog, &evt);
  sprintf(gText, "port%04d.icn", this->heroBeingRecruited->heroID);
  evt.xCoordOrKeycode = 9;
  evt.yCoordOrFieldID = 2;
  evt.payload = gText;
  heroWindow::BroadcastMessage(this->dialog, &evt);
  this->recruitHeroConfirmed = -1;
  heroWindowManager::DoDialog(gpWindowManager, this->dialog, RecruitHeroHandler, 0);
  operator delete(this->dialog);
  if ( this->recruitHeroConfirmed == -1 )
  {
    if ( this->field_15A )
      townManager::SetupCastle(this, this->curScreen, 0);
    if ( this->field_15A )
      heroWindow::DrawWindow(this->curScreen);
  }
  else
  {
    this->recruitHeroConfirmed = a2;
    gpCurPlayer->resources[6] -= gHeroGoldCost;
    gpCurPlayer->heroesOwned[gpCurPlayer->numHeroes++] = gpCurPlayer->heroesForPurchase[this->recruitHeroConfirmed];
    x = this->castle->x;
    y = this->castle->y;
    this->heroBeingRecruited->x = x;
    this->heroBeingRecruited->y = y;
    v5 = this->heroBeingRecruited->flags;
    this->heroBeingRecruited->flags = v5 & 0x600000;
    HIBYTE(this->heroBeingRecruited->field_2B) = 2;
    this->heroBeingRecruited->remainingMobility = hero::CalcMobility(this->heroBeingRecruited);
    this->heroBeingRecruited->mobility = this->heroBeingRecruited->remainingMobility;
    this->heroBeingRecruited->occupiedObjType = *(&gpGame->map.tiles[x].objType + 12 * y * gpGame->map.width);
    this->heroBeingRecruited->occupiedObjVal = (unsigned __int8)((unsigned __int8)(*(&gpGame->map.tiles[x].field_4_1_1_isShadow_1_13_extraInfo
                                                                                   + 6 * y * gpGame->map.width) >> 8) >> -5);
    *(&gpGame->map.tiles[x].objType + 12 * y * gpGame->map.width) = -86;
    v6 = &gpGame->map.tiles[y * gpGame->map.width] + x;
    v6->field_4_1_1_isShadow_1_13_extraInfo = v6->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                          * gpCurPlayer->heroesForPurchase[this->recruitHeroConfirmed];
    SendMapChange(3, this->heroBeingRecruited->idx, x, y, -999, 0, 0);
    this->field_14E = 1;
    this->castle->visitingHeroIdx = this->heroBeingRecruited->idx;
    gpGame->relatedToHeroForHireStatus[gpCurPlayer->heroesForPurchase[this->recruitHeroConfirmed]] = giCurPlayer;
    CheckValidAvailableHeroes();
    if ( this->castle->buildingsBuiltFlags & 1 )
      town::GiveSpells(this->castle, 0);
    v7 = gpCurPlayer->heroesForPurchase[1 - this->recruitHeroConfirmed] / 9;
    v8 = Random(1, 5);
    v9 = game::GetNewHeroId(gpGame, giCurPlayer, (v7 + v8) % 6, 0);
    gpCurPlayer->heroesForPurchase[this->recruitHeroConfirmed] = v9;
    gpGame->relatedToHeroForHireStatus[gpCurPlayer->heroesForPurchase[this->recruitHeroConfirmed]] = 64;
  }
  bankBox::Update(this->bankbox, 1);
  heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, 30720, 16392);
  this->heroBeingRecruited->ownerIdx = -1;
  if ( this->recruitHeroConfirmed != -1 )
    this->heroBeingRecruited->ownerIdx = giCurPlayer;
  return this->recruitHeroConfirmed != -1;
}
// 4F1DA8: using guessed type int gHeroGoldCost;

//----- (00416950) --------------------------------------------------------
signed int __fastcall TavernHandler(Event *this)
{
  signed int result; // eax@4
  int v2; // [sp+Ch] [bp-14h]@3

  if ( this->inputEvt.eventCode == 512
    && this->guiMsg.messageType == 13
    && (v2 = this->inputEvt.yCoordOrFieldID, v2 >= 30720 && v2 <= 30722) )
  {
    gpWindowManager->buttonPressedCode = this->guiMsg.fieldID;
    this->guiMsg.fieldID = 10;
    this->guiMsg.messageType = this->guiMsg.fieldID;
    result = 2;
  }
  else
  {
    if ( KBTickCount() > glTimers )
    {
      this->inputEvt.eventCode = INPUT_GUI_MESSAGE_CODE;
      this->inputEvt.xCoordOrKeycode = 4;
      this->inputEvt.yCoordOrFieldID = 2;
      ++*(_DWORD *)&gpGame->mapEventIndices[52];
      this->inputEvt.payload = (void *)(*(_DWORD *)&gpGame->mapEventIndices[52] % 20 + 2);
      heroWindow::BroadcastMessage(gpTownManager->curScreen, &this->inputEvt);
      heroWindow::MoveWindow(gpTownManager->curScreen, 0, 0);
      glTimers = KBTickCount() + 75;
    }
    result = 1;
  }
  return result;
}

//----- (00416AB0) --------------------------------------------------------
BOOL __thiscall townManager::DoTavern(townManager *this)
{
  townManager *thisa; // [sp+Ch] [bp-30h]@1
  heroWindow *window; // [sp+18h] [bp-24h]@1
  int evt; // [sp+1Ch] [bp-20h]@6
  int v5; // [sp+20h] [bp-1Ch]@6
  int v6; // [sp+24h] [bp-18h]@6
  char *v7; // [sp+34h] [bp-8h]@6
  int v8; // [sp+38h] [bp-4h]@1

  thisa = this;
  v8 = 0;
  window = (heroWindow *)operator new(68);
  if ( window )
    thisa->curScreen = heroWindow::heroWindow(window, 162, 10, "tavwin.bin");
  else
    thisa->curScreen = 0;
  if ( !thisa->curScreen )
    MemError();
  SetWinText(thisa->curScreen, 22);
  sprintf(gText, "A generous tip for the barkeep yields the following rumor:\n\n%s", gpGame->currentRumor);
  evt = 512;
  v5 = 3;
  v6 = 601;
  v7 = gText;
  heroWindow::BroadcastMessage(thisa->curScreen, (tag_message *)&evt);
  heroWindowManager::DoDialog(gpWindowManager, thisa->curScreen, (int (__fastcall *)(tag_message *))TavernHandler, 0);
  return operator delete(thisa->curScreen);
}

//----- (00416BC0) --------------------------------------------------------
signed int __thiscall SplitArmyHandler(Event *this)
{
  signed int result; // eax@33
  int v2; // [sp+Ch] [bp-24h]@11
  int v3; // [sp+14h] [bp-1Ch]@2
  Event *evt; // [sp+18h] [bp-18h]@1
  signed int v5; // [sp+2Ch] [bp-4h]@1

  evt = this;
  v5 = 0;
  if ( this->inputEvt.eventCode != 512 )
    goto LABEL_32;
  v3 = this->inputEvt.xCoordOrKeycode;
  if ( v3 == 12 )
  {
    if ( this->inputEvt.yCoordOrFieldID != 68 )
      goto LABEL_32;
    this->inputEvt.xCoordOrKeycode = 7;
    heroWindow::BroadcastMessage(gpTownManager->dialog, &this->inputEvt);
    gpTownManager->field_16A = atoi((int *)evt->inputEvt.payload);
    if ( gpTownManager->field_16A < 0 )
      gpTownManager->field_16A = 0;
    if ( gpTownManager->field_16A >= gpTownManager->field_16E )
      gpTownManager->field_16A = gpTownManager->field_16E - 1;
LABEL_35:
    sprintf(gText, "%d", gpTownManager->field_16A);
    evt->inputEvt.eventCode = 512;
    evt->inputEvt.xCoordOrKeycode = 3;
    evt->inputEvt.yCoordOrFieldID = 68;
    evt->inputEvt.payload = gText;
    heroWindow::BroadcastMessage(gpTownManager->dialog, &evt->inputEvt);
    heroWindow::DrawWindow(gpTownManager->dialog, 1, 68, 68);
    return 1;
  }
  if ( v3 != 13 )
    goto LABEL_32;
  v2 = this->inputEvt.yCoordOrFieldID;
  if ( v2 > 30721 )
  {
    if ( v2 == 30722 )
    {
      if ( gpTownManager->field_16A )
        gpWindowManager->buttonPressedCode = 30722;
      else
        gpWindowManager->buttonPressedCode = 30721;
      v5 = 1;
    }
    goto LABEL_32;
  }
  if ( v2 >= 30720 )
  {
    gpTownManager->field_16A = 0;
    gpWindowManager->buttonPressedCode = this->inputEvt.yCoordOrFieldID;
    v5 = 1;
    goto LABEL_32;
  }
  if ( v2 == 69 )
  {
    ++gpTownManager->field_16A;
    if ( gpTownManager->field_16A >= gpTownManager->field_16E )
      gpTownManager->field_16A = gpTownManager->field_16E - 1;
    goto LABEL_35;
  }
  if ( v2 == 70 )
  {
    --gpTownManager->field_16A;
    if ( gpTownManager->field_16A < 0 )
      gpTownManager->field_16A = 0;
    goto LABEL_35;
  }
LABEL_32:
  if ( v5 == 1 )
  {
    this->inputEvt.yCoordOrFieldID = 10;
    this->inputEvt.xCoordOrKeycode = this->inputEvt.yCoordOrFieldID;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00416EF0) --------------------------------------------------------
void __thiscall townManager::SetupWell(townManager *this, heroWindow *window)
{
  const char *v2; // eax@19
  tag_monsterInfo *v3; // esi@24
  townManager *thisa; // [sp+Ch] [bp-A4h]@1
  int v5; // [sp+10h] [bp-A0h]@27
  tag_monsterInfo v6; // [sp+14h] [bp-9Ch]@24
  GUIMessage evt; // [sp+30h] [bp-80h]@11
  char a2; // [sp+4Ch] [bp-64h]@24
  __int16 v9; // [sp+74h] [bp-3Ch]@1
  int v10; // [sp+78h] [bp-38h]@20
  int i; // [sp+7Ch] [bp-34h]@1
  char v12; // [sp+80h] [bp-30h]@11
  __int16 v13; // [sp+90h] [bp-20h]@1
  __int16 v14; // [sp+94h] [bp-1Ch]@1
  char dwellingOffsetsForTier[8]; // [sp+98h] [bp-18h]@5
  __int16 v16; // [sp+A0h] [bp-10h]@1
  __int16 v17; // [sp+A4h] [bp-Ch]@1
  __int16 v18; // [sp+A8h] [bp-8h]@1
  __int16 v19; // [sp+ACh] [bp-4h]@1

  thisa = this;
  v14 = 1;
  v9 = 7;
  v13 = 13;
  v17 = 19;
  v16 = 25;
  v18 = 31;
  v19 = 37;
  for ( i = 0; i < 6; ++i )
  {
    if ( i == 5 && BYTE3(this->castle->buildingsBuiltFlags) & 0x40 )
    {
      dwellingOffsetsForTier[i] = 11;
    }
    else if ( i >= 1 && (1 << (i + 24)) & this->castle->buildingsBuiltFlags )
    {
      dwellingOffsetsForTier[i] = i + 5;
    }
    else
    {
      dwellingOffsetsForTier[i] = i;
    }
  }
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.messageType = GUI_MESSAGE_SET_ICON;
  sprintf(&v12, "cstl%s.icn", cHeroTypeShortName[this->castle->factionID]);
  evt.payload = &v12;
  for ( i = 0; i < 6; ++i )
  {
    evt.fieldID = i + 1;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
  for ( i = 0; i < 6; ++i )
  {
    evt.messageType = GUI_MESSAGE_SET_IMG_IDX;
    evt.fieldID = i + 1;
    evt.payload = (void *)((unsigned __int8)dwellingOffsetsForTier[i] + 19);
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
    sprintf(gText, "monh%04d.icn", gDwellingType[thisa->castle->factionID][(unsigned __int8)dwellingOffsetsForTier[i]]);
    evt.messageType = 9;
    evt.fieldID = i + 13;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.messageType = GUI_MESSAGE_SET_TEXT;
  for ( i = 0; i < 6; ++i )
  {
    v2 = GetBuildingName(thisa->castle->factionID, (unsigned __int8)dwellingOffsetsForTier[i] + 19);
    sprintf(gText, v2);
    evt.fieldID = i + 7;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
    if ( (1 << (dwellingOffsetsForTier[i] + 19)) & thisa->castle->buildingsBuiltFlags )
    {
      v10 = thisa->castle->numCreaturesInDwelling[(unsigned __int8)dwellingOffsetsForTier[i]];
      sprintf(gText, "Available:");
      evt.fieldID = i + 31;
      evt.payload = gText;
      heroWindow::BroadcastMessage(window, (tag_message *)&evt);
      sprintf(gText, "%d", v10);
      evt.fieldID = i + 37;
      evt.payload = gText;
      heroWindow::BroadcastMessage(window, (tag_message *)&evt);
    }
    evt.fieldID = i + 19;
    strcpy(gText, gArmyNamesPlural[gDwellingType[thisa->castle->factionID][(unsigned __int8)dwellingOffsetsForTier[i]]]);
    gText[0] -= 32;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
  for ( i = 0; i < 6; ++i )
  {
    v3 = &gMonsterDatabase[gDwellingType[thisa->castle->factionID][(unsigned __int8)dwellingOffsetsForTier[i]]];
    memcpy(&v6, v3, 0x18u);
    v6._ = v3->_;
    strcpy(gText, byte_4EF150);
    sprintf(&a2, "%s%d", cWellDetail[0], v6.attack);
    strcat(gText, &a2);
    sprintf(&a2, "\n%s%d", off_4F650C[0], v6.defense);
    strcat(gText, &a2);
    sprintf(&a2, "\n%s%d", off_4F6514[0], v6.min_damage);
    strcat(gText, &a2);
    if ( v6.min_damage != v6.max_damage )
    {
      sprintf(&a2, "-%d", v6.max_damage);
      strcat(gText, &a2);
    }
    sprintf(&a2, "\n%s%d", off_4F6518[0], (unsigned __int16)v6.hp);
    strcat(gText, &a2);
    sprintf(&a2, off_4F6524, speedText[v6.speed]);
    strcat(gText, &a2);
    if ( (1 << (dwellingOffsetsForTier[i] + 19)) & thisa->castle->buildingsBuiltFlags )
    {
      v5 = gMonsterDatabase[gDwellingType[thisa->castle->factionID][(unsigned __int8)dwellingOffsetsForTier[i]]].growth
         + 2;
      if ( !i && BYTE1(thisa->castle->buildingsBuiltFlags) & 8 )
        v5 = gMonsterDatabase[gDwellingType[thisa->castle->factionID][(unsigned __int8)dwellingOffsetsForTier[i]]].growth
           + 10;
      sprintf(&a2, off_4F6528, v5);
      strcat(gText, &a2);
    }
    evt.messageType = 3;
    evt.fieldID = i + 25;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
}
// 4F4BA0: using guessed type char *cHeroTypeShortName[6];
// 4F6508: using guessed type char *cWellDetail[9];
// 4F650C: using guessed type char *off_4F650C[8];
// 4F6514: using guessed type char *off_4F6514[6];
// 4F6518: using guessed type char *off_4F6518[5];
// 416EF0: using guessed type char dwellingOffsetsForTier[8];

//----- (004174C0) --------------------------------------------------------
int __stdcall townManager::SetupThievesGuild(heroWindow *window, int strength)
{
  int result; // eax@38
  int v3; // ST24_4@61
  unsigned int v4; // eax@61
  char v5; // al@66
  int v6; // ST24_4@67
  unsigned int v7; // eax@67
  int v8; // ST24_4@72
  unsigned int v9; // eax@72
  iconWidget *v10; // [sp+10h] [bp-1ACh]@97
  textWidget *v11; // [sp+14h] [bp-1A8h]@72
  textWidget *v12; // [sp+18h] [bp-1A4h]@67
  textWidget *v13; // [sp+1Ch] [bp-1A0h]@61
  iconWidget *v14; // [sp+20h] [bp-19Ch]@53
  iconWidget *v15; // [sp+24h] [bp-198h]@48
  iconWidget *this; // [sp+28h] [bp-194h]@29
  signed int v17; // [sp+2Ch] [bp-190h]@23
  int v18; // [sp+30h] [bp-18Ch]@27
  int v19; // [sp+34h] [bp-188h]@20
  int v20; // [sp+38h] [bp-184h]@20
  char *content; // [sp+44h] [bp-178h]@61
  char *contenta; // [sp+44h] [bp-178h]@67
  char *contentb; // [sp+44h] [bp-178h]@72
  char a2; // [sp+48h] [bp-174h]@66
  GUIMessage evt; // [sp+110h] [bp-ACh]@14
  __int16 v26; // [sp+12Ch] [bp-90h]@1
  __int16 v27; // [sp+130h] [bp-8Ch]@1
  int k; // [sp+134h] [bp-88h]@78
  char playerIndices[8]; // [sp+138h] [bp-84h]@20
  int row; // [sp+140h] [bp-7Ch]@18
  PRIMARY_SKILL skill; // [sp+144h] [bp-78h]@42
  textWidget *v32; // [sp+148h] [bp-74h]@62
  PRIMARY_SKILL v33; // [sp+14Ch] [bp-70h]@42
  __int16 v34; // [sp+154h] [bp-68h]@1
  int j; // [sp+158h] [bp-64h]@20
  int numRows; // [sp+15Ch] [bp-60h]@4
  __int16 v37; // [sp+160h] [bp-5Ch]@1
  __int16 v38; // [sp+164h] [bp-58h]@1
  int i; // [sp+168h] [bp-54h]@12
  __int16 v40; // [sp+16Ch] [bp-50h]@1
  int v41; // [sp+170h] [bp-4Ch]@76
  hero *hro; // [sp+174h] [bp-48h]@44
  __int16 v43; // [sp+178h] [bp-44h]@1
  int v44; // [sp+17Ch] [bp-40h]@44
  __int16 v45; // [sp+180h] [bp-3Ch]@1
  __int16 v46; // [sp+184h] [bp-38h]@1
  widget *guiObj; // [sp+188h] [bp-34h]@30
  __int16 v48; // [sp+18Ch] [bp-30h]@1
  int a7; // [sp+190h] [bp-2Ch]@76
  __int16 v50; // [sp+194h] [bp-28h]@1
  town *v51; // [sp+198h] [bp-24h]@78
  __int16 v52; // [sp+19Ch] [bp-20h]@1
  int playerStats[6]; // [sp+1A0h] [bp-1Ch]@20
  int v54; // [sp+1B8h] [bp-4h]@42

  v37 = 258;
  v26 = 68;
  v27 = 27;
  v50 = 22;
  v45 = 18;
  v52 = 22;
  v46 = 72;
  v34 = 800;
  v38 = 900;
  v48 = 300;
  v40 = 339;
  v43 = 397;
  if ( strength == -1 )
    strength = game::getNumberOfThievesGuilds(gpGame, giCurPlayer);
  if ( strength < 5 )
  {
    switch ( strength )
    {
      case 4:
        numRows = 9;
        break;
      case 3:
        numRows = 7;
        break;
      case 2:
        numRows = 5;
        break;
      default:
        numRows = 3;
        break;
    }
  }
  else
  {
    numRows = 10;
  }
  for ( i = gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers; i < 6; ++i )
  {
    evt.eventCode = INPUT_GUI_MESSAGE_CODE;
    evt.messageType = 6;
    evt.fieldID = i + 800;
    evt.payload = (void *)4;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
    evt.fieldID = i + 900;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
  for ( i = gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers; i < 6; ++i )
  {
    evt.eventCode = 512;
    evt.messageType = 6;
    evt.fieldID = i + 900;
    evt.payload = (void *)4;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
  }
  for ( row = 0; row < numRows; ++row )
  {
    GetCategoryStats(row, playerStats, playerIndices);
    SortStats(playerStats, playerIndices);
    v20 = 0;
    v19 = 0;
    for ( j = 0; j < 6 && gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers != v20; ++j )
    {
      v17 = 1;
      while ( gpGame->numPlayers > v19 + 1 && playerStats[v19 + 1] == playerStats[v19] )
      {
        ++v17;
        ++v19;
      }
      v18 = 68 * j + 258 - (9 * v17 - 9);
      for ( i = v20; v19 >= i; ++i )
      {
        this = (iconWidget *)operator new(45);
        if ( this )
          guiObj = (widget *)iconWidget::iconWidget(
                               this,
                               v18 + 18 * (i - (_WORD)v20),
                               24 * row + 27,
                               18,
                               22,
                               "townwind.icn",
                               gpGame->players[playerIndices[i]].color + 22,
                               0,
                               -1,
                               16,
                               1);
        else
          guiObj = 0;
        if ( !guiObj )
          MemError();
        heroWindow::AddWidget(window, guiObj, -1);
      }
      ++v19;
      v20 = v19;
    }
  }
  j = 0;
  for ( i = 0; ; ++i )
  {
    result = gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers;
    if ( result <= i )
      break;
    while ( gpGame->playerDead[j] )
      ++j;
    sprintf(gText, (&gColors)[4 * gpGame->players[j].color]);
    gText[0] -= 32;
    evt.eventCode = 512;
    evt.messageType = 3;
    evt.fieldID = i + 900;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, (tag_message *)&evt);
    if ( strength >= 1 )
    {
      v33 = -1;
      v54 = 0;
      for ( skill = 0; gpGame->players[j].numHeroes > (signed int)skill; ++skill )
      {
        hro = &gpGame->heroes[gpGame->players[j].heroesOwned[skill]];
        v44 = philAI::FightValueOfStack(&hro->army, hro, 0, 0, 0, 0);
        if ( v44 > v54 )
        {
          v54 = v44;
          v33 = skill;
        }
      }
      if ( v33 != -1 )
      {
        v15 = (iconWidget *)operator new(45);
        if ( v15 )
          guiObj = (widget *)iconWidget::iconWidget(v15, 68 * i + 246, 301, 0, 0, "locators.icn", 22, 0, -1, 16, 1);
        else
          guiObj = 0;
        if ( !guiObj )
          MemError();
        heroWindow::AddWidget(window, guiObj, -1);
        v14 = (iconWidget *)operator new(45);
        if ( v14 )
          guiObj = (widget *)iconWidget::iconWidget(
                               v14,
                               68 * i + 237,
                               300,
                               0,
                               0,
                               "miniport.icn",
                               gpGame->heroes[gpGame->players[j].heroesOwned[v33]].heroID,
                               0,
                               -1,
                               16,
                               1);
        else
          guiObj = 0;
        if ( !guiObj )
          MemError();
        heroWindow::AddWidget(window, guiObj, -1);
      }
      if ( strength >= 2 )
      {
        if ( v33 != -1 )
        {
          hro = &gpGame->heroes[gpGame->players[j].heroesOwned[v33]];
          sprintf(gText, "Att.\nDef.\nPower\nKnowl.");
          v3 = word_4EF178 + 190;
          v4 = strlen(gText);
          content = (char *)BaseAlloc(v4 + 1, "F:\\h2xsrc\\Source\\TOWNMGR.CPP", v3);
          strcpy(content, gText);
          v13 = (textWidget *)operator new(43);
          if ( v13 )
            v32 = textWidget::textWidget(v13, 68 * i + 239, 339, 40, 48, content, "smalfont.fnt", 1, -1, 512, 0);
          else
            v32 = 0;
          heroWindow::AddWidget(window, (widget *)v32, -1);
          sprintf(gText, byte_4EF1F4);
          for ( skill = 0; (signed int)skill < 4; ++skill )
          {
            v5 = hero::Stats(hro, skill);
            sprintf(&a2, "%d\n", v5);
            strcat(gText, &a2);
          }
          v6 = word_4EF178 + 216;
          v7 = strlen(gText);
          contenta = (char *)BaseAlloc(v7 + 1, "F:\\h2xsrc\\Source\\TOWNMGR.CPP", v6);
          strcpy(contenta, gText);
          v12 = (textWidget *)operator new(43);
          if ( v12 )
            v32 = textWidget::textWidget(v12, 68 * i + 284, 339, 15, 48, contenta, "smalfont.fnt", 1, -1, 512, 0);
          else
            v32 = 0;
          heroWindow::AddWidget(window, (widget *)v32, -1);
        }
        if ( strength >= 3 )
        {
          strcpy(gText, personality_types[gpGame->players[j].personality]);
          v8 = word_4EF178 + 240;
          v9 = strlen(gText);
          contentb = (char *)BaseAlloc(v9 + 1, "F:\\h2xsrc\\Source\\TOWNMGR.CPP", v8);
          strcpy(contentb, gText);
          v11 = (textWidget *)operator new(43);
          v32 = v11 ? textWidget::textWidget(v11, 68 * i + 227, 397, 74, 16, contentb, "smalfont.fnt", 1, -1, 8, 1) : 0;
          heroWindow::AddWidget(window, (widget *)v32, -1);
          if ( strength >= 4 )
          {
            a7 = -1;
            v41 = 0;
            for ( skill = 0; gpGame->players[j].numCastles > (signed int)skill; ++skill )
            {
              v51 = &gpGame->castles[gpGame->players[j].castlesOwned[skill]];
              for ( k = 0; k < 5; ++k )
              {
                if ( v51->garrison.creatureTypes[k] != -1
                  && v51->garrison.quantities[k] > 0
                  && gMonsterDatabase[v51->garrison.creatureTypes[k]].fight_value > v41 )
                {
                  a7 = v51->garrison.creatureTypes[k];
                  v41 = gMonsterDatabase[v51->garrison.creatureTypes[k]].fight_value;
                }
              }
            }
            for ( skill = 0; gpGame->players[j].numHeroes > (signed int)skill; ++skill )
            {
              hro = &gpGame->heroes[gpGame->players[j].heroesOwned[skill]];
              for ( k = 0; k < 5; ++k )
              {
                if ( hro->army.creatureTypes[k] != -1
                  && hro->army.quantities[k] > 0
                  && gMonsterDatabase[hro->army.creatureTypes[k]].fight_value > v41 )
                {
                  a7 = hro->army.creatureTypes[k];
                  v41 = gMonsterDatabase[hro->army.creatureTypes[k]].fight_value;
                }
              }
            }
            if ( a7 != -1 )
            {
              v10 = (iconWidget *)operator new(45);
              if ( v10 )
                guiObj = (widget *)iconWidget::iconWidget(
                                     v10,
                                     68 * i + 244,
                                     418,
                                     40,
                                     34,
                                     "mons32.icn",
                                     a7,
                                     0,
                                     -1,
                                     17,
                                     1);
              else
                guiObj = 0;
              if ( !guiObj )
                MemError();
              heroWindow::AddWidget(window, guiObj, -1);
            }
          }
        }
      }
    }
    ++j;
  }
  return result;
}
// 39: found interdependent unknown calls
// 4EF178: using guessed type __int16 word_4EF178;
// 4174C0: using guessed type char playerIndices[8];

//----- (00418220) --------------------------------------------------------
void __fastcall GetCategoryStats(int row, int *playerStats, char *playerIndices)
{
  int *playerAmt; // [sp+10h] [bp-28h]@1
  int rowa; // [sp+14h] [bp-24h]@1
  town *this; // [sp+18h] [bp-20h]@41
  int v6; // [sp+1Ch] [bp-1Ch]@36
  int numTowns; // [sp+20h] [bp-18h]@4
  int numCastles; // [sp+24h] [bp-14h]@4
  signed int l; // [sp+28h] [bp-10h]@28
  signed int m; // [sp+28h] [bp-10h]@36
  signed int n; // [sp+28h] [bp-10h]@39
  signed int i; // [sp+2Ch] [bp-Ch]@7
  signed int j; // [sp+2Ch] [bp-Ch]@14
  signed int k; // [sp+2Ch] [bp-Ch]@26
  int playerIdx; // [sp+30h] [bp-8h]@1
  hero *hro; // [sp+34h] [bp-4h]@28

  playerAmt = playerStats;
  rowa = row;
  for ( playerIdx = 0; gpGame->numPlayers > playerIdx; ++playerIdx )
  {
    numTowns = 0;
    numCastles = 0;
    playerIndices[playerIdx] = playerIdx;
    if ( gpGame->playerDead[playerIdx] )
    {
      playerAmt[playerIdx] = -1;
    }
    else
    {
      switch ( rowa )
      {
        case 0:
          for ( i = 0; i < 72; ++i )
          {
            if ( gpGame->castles[i].ownerIdx == playerIdx )
            {
              if ( gpGame->castles[i].buildingsBuiltFlags & 0x20 )
                ++numTowns;
            }
          }
          playerAmt[playerIdx] = numTowns;
          break;
        case 1:
          for ( j = 0; j < 72; ++j )
          {
            if ( gpGame->castles[j].ownerIdx == playerIdx && gpGame->castles[j].buildingsBuiltFlags & 0x40 )
              ++numCastles;
          }
          playerAmt[playerIdx] = numCastles;
          break;
        case 2:
          playerAmt[playerIdx] = gpGame->players[playerIdx].numHeroes;
          break;
        case 3:
          playerAmt[playerIdx] = gpGame->players[playerIdx].resources[6];
          break;
        case 4:
          playerAmt[playerIdx] = gpGame->players[playerIdx].resources[0] + gpGame->players[playerIdx].resources[2];
          break;
        case 5:
          playerAmt[playerIdx] = gpGame->players[playerIdx].resources[4]
                               + gpGame->players[playerIdx].resources[3]
                               + gpGame->players[playerIdx].resources[1]
                               + gpGame->players[playerIdx].resources[5];
          break;
        case 6:
          playerAmt[playerIdx] = GetNumObelisks(playerIdx);
          break;
        case 7:
          playerAmt[playerIdx] = 0;
          for ( k = 0; gpGame->players[playerIdx].numHeroes > k; ++k )
          {
            hro = &gpGame->heroes[gpGame->players[playerIdx].heroesOwned[k]];
            for ( l = 0; l < 14; ++l )
            {
              if ( hro->artifacts[l] != -1 && hro->artifacts[l] != ARTIFACT_MAGIC_BOOK )
                ++playerAmt[playerIdx];
            }
          }
          break;
        case 8:
          v6 = 0;
          for ( m = 0; gpGame->players[playerIdx].numHeroes > m; ++m )
            v6 += philAI::FightValueOfStack(
                    &gpGame->heroes[*(&gpGame->players[0].heroesOwned[284 * playerIdx] + m - playerIdx)].army,
                    &gpGame->heroes[*(&gpGame->players[0].heroesOwned[284 * playerIdx] + m - playerIdx)],
                    0,
                    0,
                    0,
                    0);
          for ( n = 0; gpGame->players[playerIdx].numCastles > n; ++n )
          {
            this = &gpGame->castles[*(&gpGame->players[0].castlesOwned[284 * playerIdx] + n - playerIdx)];
            if ( town::HasGarrison(&gpGame->castles[*(&gpGame->players[0].castlesOwned[284 * playerIdx] + n - playerIdx)]) )
              v6 += philAI::FightValueOfStack(&this->garrison, 0, 0, 0, 0, 0);
          }
          playerAmt[playerIdx] = v6;
          break;
        case 9:
          playerAmt[playerIdx] = game::ComputeDailyGold(gpGame, playerIdx);
          break;
        default:
          continue;
      }
    }
  }
}

//----- (00418790) --------------------------------------------------------
int __fastcall SortStats(int *playerStats, char *playerIndices)
{
  int result; // eax@2
  int tmp1; // ST14_4@6
  char tmp2; // ST20_1@6
  int i; // [sp+18h] [bp-Ch]@1
  int j; // [sp+1Ch] [bp-8h]@3

  for ( i = 0; ; ++i )
  {
    result = gpGame->numPlayers - 1;
    if ( result <= i )
      break;
    for ( j = i + 1; gpGame->numPlayers > j; ++j )
    {
      if ( playerStats[j] > playerStats[i] )
      {
        tmp1 = playerStats[i];
        playerStats[i] = playerStats[j];
        playerStats[j] = tmp1;
        tmp2 = playerIndices[i];
        playerIndices[i] = playerIndices[j];
        playerIndices[j] = tmp2;
      }
    }
  }
  return result;
}

//----- (00418870) --------------------------------------------------------
signed int __thiscall playerData::Write(playerData *this, int fd)
{
  char v4; // [sp+10h] [bp-34h]@1

  _write(fd, this, 1);
  _write(fd, &this->numHeroes, 1);
  _write(fd, &this->curHeroIdx, 1);
  _write(fd, &this->field_3, 1);
  _write(fd, this->heroesOwned, 8);
  _write(fd, this->heroesForPurchase, 2);
  memset(&v4, 0, 0x30u);
  _write(fd, &v4, 42);
  _write(fd, &gpGame->_B[1], 1);
  _write(fd, this->_3, 1);
  _write(fd, &this->personality, 4);
  _write(fd, &this->_2, 1);
  _write(fd, &this->_4_1, 1);
  _write(fd, &this->field_40, 1);
  _write(fd, &this->field_41, 1);
  _write(fd, (char *)&this->field_41 + 1, 1);
  _write(fd, &this->field_43, 1);
  _write(fd, &this->numCastles, 1);
  _write(fd, &this->field_45, 1);
  _write(fd, (char *)&this->field_45 + 1, 1);
  _write(fd, this->castlesOwned, 72);
  _write(fd, this->resources, 28);
  _write(fd, this->field_E7, 28);
  _write(fd, &this->barrierTentsVisited, 1);
  _write(fd, &this->barrierTentsVisited, 1);
  return _write(fd, this->_4_2, 6);
}

//----- (00418AB0) --------------------------------------------------------
signed int __thiscall playerData::Read(playerData *this, int fd)
{
  char v4; // [sp+10h] [bp-34h]@1

  _read(fd, this, 1u);
  _read(fd, &this->numHeroes, 1u);
  _read(fd, &this->curHeroIdx, 1u);
  _read(fd, &this->field_3, 1u);
  _read(fd, this->heroesOwned, 8u);
  _read(fd, this->heroesForPurchase, 2u);
  _read(fd, &v4, 0x2Au);
  _read(fd, &gpGame->_B[1], 1u);
  _read(fd, this->_3, 1u);
  _read(fd, &this->personality, 4u);
  _read(fd, &this->_2, 1u);
  _read(fd, &this->_4_1, 1u);
  _read(fd, &this->field_40, 1u);
  _read(fd, &this->field_41, 1u);
  _read(fd, (char *)&this->field_41 + 1, 1u);
  _read(fd, &this->field_43, 1u);
  _read(fd, &this->numCastles, 1u);
  _read(fd, &this->field_45, 1u);
  _read(fd, (char *)&this->field_45 + 1, 1u);
  _read(fd, this->castlesOwned, 0x48u);
  _read(fd, this->resources, 0x1Cu);
  _read(fd, this->field_E7, 0x1Cu);
  _read(fd, &this->barrierTentsVisited, 1u);
  _read(fd, &this->barrierTentsVisited, 1u);
  return _read(fd, this->_4_2, 6u);
}

//----- (00418CE0) --------------------------------------------------------
signed int __thiscall playerData::NextHero(playerData *this, int a2)
{
  signed int v4; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@2
  int j; // [sp+14h] [bp-4h]@7
  int k; // [sp+14h] [bp-4h]@12

  v4 = -1;
  if ( gpCurPlayer->curHeroIdx != -1 )
  {
    for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
    {
      if ( gpCurPlayer->heroesOwned[i] == gpCurPlayer->curHeroIdx )
        v4 = i;
    }
  }
  for ( j = v4 + 1; gpCurPlayer->numHeroes > j; ++j )
  {
    if ( game::IsMobile(gpGame, gpCurPlayer->heroesOwned[j]) )
      return this->heroesOwned[j];
  }
  for ( k = 0; v4 + 1 > k; ++k )
  {
    if ( game::IsMobile(gpGame, gpCurPlayer->heroesOwned[k]) )
      return this->heroesOwned[k];
  }
  return -1;
}

//----- (00418E10) --------------------------------------------------------
signed int __thiscall playerData::HasMobileHero(playerData *this)
{
  playerData *thisa; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  thisa = this;
  for ( i = 0; thisa->numHeroes > i; ++i )
  {
    if ( game::IsMobile(gpGame, thisa->heroesOwned[i]) )
      return 1;
  }
  return 0;
}

//----- (00418E80) --------------------------------------------------------
int __fastcall GetNumObelisks(int playerIdx)
{
  int numVisited; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  numVisited = 0;
  for ( i = 0; i < 48; ++i )
  {
    if ( gpGame->obeliskVisitedMasks[i] & (1 << playerIdx) )
      ++numVisited;
  }
  return numVisited;
}

//----- (00418EF0) --------------------------------------------------------
int __thiscall playerData::BuildingsOwned(int this, int a2, signed int a3, int a4)
{
  signed int i; // [sp+14h] [bp-8h]@1
  int v6; // [sp+18h] [bp-4h]@1

  v6 = 0;
  for ( i = 0; *(_BYTE *)(this + 68) > i; ++i )
  {
    if ( a3 < 19 || gpGame->castles[*(_BYTE *)(i + this + 71)].factionID == a2 )
    {
      if ( a3 )
      {
        if ( (1 << a3) & gpGame->castles[*(_BYTE *)(i + this + 71)].buildingsBuiltFlags )
          ++v6;
      }
      else if ( gpGame->castles[*(_BYTE *)(i + this + 71)].buildingsBuiltFlags & 1 )
      {
        if ( gpGame->castles[*(_BYTE *)(i + this + 71)].mageGuildLevel == a4 )
          ++v6;
      }
    }
  }
  return v6;
}

//----- (00418FC0) --------------------------------------------------------
int __thiscall playerData::NumOfGivenArtifact(playerData *this, ARTIFACT artifact)
{
  signed int i; // [sp+10h] [bp-Ch]@1
  signed int j; // [sp+14h] [bp-8h]@3
  int count; // [sp+18h] [bp-4h]@1

  count = 0;
  for ( i = 0; this->numHeroes > i; ++i )
  {
    for ( j = 0; j < 14; ++j )
    {
      if ( gpGame->heroes[this->heroesOwned[i]].artifacts[j] == artifact )
        ++count;
    }
  }
  return count;
}

//----- (00419060) --------------------------------------------------------
int __thiscall game::MineTypesOwned(game *this, int a2, int a3)
{
  signed int i; // [sp+10h] [bp-8h]@1
  int v5; // [sp+14h] [bp-4h]@1

  v5 = 0;
  for ( i = 0; i < 144; ++i )
  {
    if ( this->mines[i].owner == a2 )
    {
      if ( this->mines[i].type == a3 )
        ++v5;
    }
  }
  return v5;
}

//----- (004190F0) --------------------------------------------------------
char __fastcall ComputeUALoc(int a1)
{
  char result; // al@3
  int v2; // ebx@21
  int v3; // ebx@21
  int v4; // ebx@24
  int v5; // ebx@24
  int playerNo; // [sp+Ch] [bp-1Ch]@1
  int v7; // [sp+10h] [bp-18h]@10
  int v8; // [sp+14h] [bp-14h]@10
  signed int v9; // [sp+18h] [bp-10h]@10
  int i; // [sp+1Ch] [bp-Ch]@19
  int j; // [sp+1Ch] [bp-Ch]@22
  int v12; // [sp+20h] [bp-8h]@4
  int v13; // [sp+24h] [bp-4h]@1

  playerNo = a1;
  v13 = game::SetupPuzzlePieces(gpGame, a1, 1);
  if ( v13 >= 8 && gpGame->field_6397 != -1 )
  {
    v12 = 4 * v13 - 32;
    if ( v12 > 100 )
      v12 = 100;
    if ( v12 < 1 )
      LOBYTE(v12) = 1;
    gpGame->players[playerNo].field_40 = v12;
    if ( gpGame->players[playerNo].field_40 < Random(1, 100) )
    {
      v8 = -1;
      v7 = -1;
      v9 = 0;
      while ( v8 < 0
           || v8 >= MAP_WIDTH
           || v7 < 0
           || v7 >= MAP_HEIGHT
           || *(&gpGame->map.tiles[v8].objType + 12 * v7 * gpGame->map.width)
           || *(&gpGame->map.tiles[v8].objectIndex + 12 * v7 * gpGame->map.width) != 255
           || *(&gpGame->map.tiles[v8].overlayIndex + 12 * v7 * gpGame->map.width) != 255
           || !giGroundToTerrain[*(&gpGame->map.tiles[v7 * gpGame->map.width].groundIndex + 6 * v8)] )
      {
        ++v9;
        for ( i = 0; !i; i = v3 - Random(0, 2) )
        {
          v2 = 3 - Random(0, 2);
          v3 = v2 - Random(0, 2);
        }
        v8 = i + gpGame->field_6395;
        for ( j = 0; !j; j = v5 - Random(0, 2) )
        {
          v4 = 3 - Random(0, 2);
          v5 = v4 - Random(0, 2);
        }
        v7 = j + gpGame->field_6396;
        if ( v9 >= 200 )
        {
          LOBYTE(v8) = gpGame->field_6395;
          LOBYTE(v7) = gpGame->field_6396;
          break;
        }
      }
      LOBYTE(gpGame->players[playerNo].field_41) = v8;
      result = v7;
      HIBYTE(gpGame->players[playerNo].field_41) = v7;
    }
    else
    {
      LOBYTE(gpGame->players[playerNo].field_41) = gpGame->field_6395;
      result = gpGame->field_6396;
      HIBYTE(gpGame->players[playerNo].field_41) = result;
    }
  }
  else
  {
    gpGame->players[playerNo].field_40 = 0;
    LOBYTE(gpGame->players[playerNo].field_41) = -1;
    result = 27 * playerNo;
    HIBYTE(gpGame->players[playerNo].field_41) = -1;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00419500) --------------------------------------------------------
int __thiscall game::SetupPuzzlePieces(game *this, int playerNo, int isAi)
{
  int v3; // ST38_4@1
  int wildPuzzlePieces; // ST3C_4@1
  double fractionVisited; // st7@1
  float v6; // ST48_4@1
  float fractionWild; // ST44_4@1
  int result; // eax@6
  unsigned int l; // [sp+20h] [bp-20h]@9
  signed int k; // [sp+24h] [bp-1Ch]@13
  unsigned int i; // [sp+28h] [bp-18h]@0
  signed int numToReveal; // [sp+2Ch] [bp-14h]@1
  int numToReveala; // [sp+2Ch] [bp-14h]@3
  int j; // [sp+34h] [bp-Ch]@7

  v3 = GetNumObelisks(playerNo);
  wildPuzzlePieces = 48 - this->numObelisks;
  fractionVisited = (double)GetNumObelisks(playerNo) / (double)this->numObelisks;
  v6 = fractionVisited;
  fractionWild = (fractionVisited * v6 + v6) / 2.0;
  numToReveal = (signed __int64)((double)wildPuzzlePieces * fractionWild + (double)v3);
  if ( GetNumObelisks(playerNo) == this->numObelisks )
    numToReveal = 48;
  numToReveala = this->players[playerNo]._3[0] + numToReveal;
  if ( numToReveala > 48 )
    numToReveala = 48;
  if ( isAi )
  {
    result = numToReveala;
  }
  else
  {
    memset(&puzzlePiecesRemoved, 0, 6u);
    SRand(3 * this->players[playerNo]._4_1 + this->players[playerNo].color);
    for ( j = 0; j < numToReveala; ++j )
    {
      for ( l = 0; (signed int)l < 48 && BitTest((char *)&puzzlePiecesRemoved, l); l += SRandom(1, 5) )
        ;
      for ( k = 0; ; ++k )
      {
        if ( k < 100 )
        {
          i = SRandom(0, 47);
          if ( BitTest((char *)&puzzlePiecesRemoved, i) )
            continue;
        }
        break;
      }
      if ( k >= 100 )
      {
        for ( i = 0; (signed int)i < 48 && BitTest((char *)&puzzlePiecesRemoved, i); ++i )
          ;
      }
      if ( (signed int)i >= 48 )
        i = 0;
      if ( (signed int)l >= 48 )
        BitSet((char *)&puzzlePiecesRemoved, i);
      else
        BitSet((char *)&puzzlePiecesRemoved, l);
    }
    result = numToReveala;
  }
  return result;
}

//----- (00419790) --------------------------------------------------------
bool __thiscall game::IsMobile(game *this, int a2)
{
  bool result; // eax@2
  char *v3; // eax@3
  int v4; // ST24_4@3
  mapCell *v5; // ST20_4@3

  if ( a2 == -1 )
  {
    result = 0;
  }
  else
  {
    v3 = (char *)this + 250 * a2;
    v4 = (int)(v3 + 10180);
    v5 = advManager::GetCell(gpAdvManager, *(_DWORD *)(v3 + 10205), *(_DWORD *)(v3 + 10209));
    result = CalcTerrainCost(
               (unsigned __int8)giGroundToTerrain[v5->groundIndex],
               1,
               *(_DWORD *)(v4 + 53),
               *(_BYTE *)(v4 + 116),
               ((unsigned __int8)v5->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1,
               0) <= *(_DWORD *)(v4 + 53);
  }
  return result;
}

//----- (00419850) --------------------------------------------------------
fullMap *__thiscall game::GetWorldMapData(game *this)
{
  return &this->map;
}

//----- (00419870) --------------------------------------------------------
signed int __thiscall game::CreateBoat(game *ecx0, unsigned int x, unsigned int y, int doSend)
{
  boat *boat; // ST24_4@4
  mapCell *cell; // ST28_4@4
  signed int boatIdx; // [sp+18h] [bp-4h]@1

  boatIdx = game::Scan(ecx0, ecx0->boatBuilt, 0, 48);
  if ( boatIdx != -1 )
  {
    if ( !doSend )
      SendMapChange(4, 0, x, y, -999, 0, 0);
    ecx0->boatBuilt[boatIdx] = boatIdx;
    boat = &ecx0->boats[boatIdx];
    boat->idx = boatIdx;
    boat->x = x;
    boat->y = y;
    boat->field_3 = 2;
    boat->owner = giCurPlayer;
    cell = &ecx0->map.tiles[y * ecx0->map.width] + x;
    boat->underlyingObjType = cell->objType;
    boat->underlyingObjExtra = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
    cell->objType = -85;
    cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * boatIdx | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
  }
  return boatIdx;
}

//----- (00419990) --------------------------------------------------------
signed int __thiscall game::Scan(game *this, signed __int8 *a1, int start, int len)
{
  int i; // [sp+10h] [bp-4h]@1

  for ( i = start; start + len > i; ++i )
  {
    if ( a1[i] == -1 )
      return i;
  }
  return -1;
}

//----- (004199F0) --------------------------------------------------------
signed int __stdcall game::RandomScan(int a1, int a2, int a3, int a4, char a5)
{
  signed int i; // [sp+10h] [bp-8h]@1
  int v7; // [sp+14h] [bp-4h]@3

  for ( i = 0; i < 10000; ++i )
  {
    v7 = Random(0, a3 - 1) + a2;
    if ( *(_BYTE *)(v7 + a1) == a5 )
      return v7;
  }
  return -1;
}

//----- (00419A70) --------------------------------------------------------
int __thiscall game::GetNewHeroId(game *this, int playerIdx, signed int faction, int getPowerfulHero)
{
  signed int tries; // [sp+14h] [bp-10h]@1
  int heroIdx; // [sp+20h] [bp-4h]@1

  heroIdx = -1;
  tries = 0;
  while ( tries < 2000 )
  {
    ++tries;
    heroIdx = Random(0, 53);
    if ( this->relatedToHeroForHireStatus[heroIdx] == -1 || this->relatedToHeroForHireStatus[heroIdx] == 64 )
    {
      if ( (this->relatedToHeroForHireStatus[heroIdx] != 64 || tries >= 1500)
        && (faction < 0 || faction > 5 || tries >= 100 || this->heroes[heroIdx].factionID == faction)
        && (!getPowerfulHero
         || tries >= 40
         || this->heroes[heroIdx].experience >= 1000
         || this->heroes[heroIdx].artifacts[0] != -1 && this->heroes[heroIdx].artifacts[0] != ARTIFACT_MAGIC_BOOK
         || this->heroes[heroIdx].artifacts[1] != -1 && this->heroes[heroIdx].artifacts[1] != ARTIFACT_MAGIC_BOOK) )
      {
        if ( !gbInCampaign || tries >= 500 || this->heroes[heroIdx].heroID < 54 || this->heroes[heroIdx].heroID > 59 )
          break;
      }
    }
  }
  return heroIdx;
}

//----- (00419C90) --------------------------------------------------------
signed int __thiscall game::GetTownId(game *this, int x, int y)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 72; ++i )
  {
    if ( this->castles[i].x == x && this->castles[i].y == y )
      return i;
  }
  return -1;
}

//----- (00419D20) --------------------------------------------------------
signed int __thiscall game::GetMineId(game *this, int a2, int a3)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 144; ++i )
  {
    if ( this->mines[i].x == a2 && this->mines[i].y == a3 )
      return i;
  }
  return -1;
}

//----- (00419DB0) --------------------------------------------------------
void __fastcall GenerateStandardFileName(char *a1, char *a2)
{
  char *v4; // [sp+14h] [bp-14h]@1
  signed int i; // [sp+18h] [bp-10h]@3
  char v6; // [sp+1Ch] [bp-Ch]@5
  signed int v7; // [sp+20h] [bp-8h]@3
  unsigned int v8; // [sp+24h] [bp-4h]@3

  v4 = (char *)FindLastToken(a1, 46);
  if ( v4 )
  {
    *v4 = 0;
    v7 = 0;
    v8 = strlen(a1);
    for ( i = 0; (signed int)v8 > i; ++i )
    {
      v6 = a1[i];
      if ( v6 >= 97 && v6 <= 122 )
        v6 -= 32;
      if ( v6 >= 65 && v6 <= 90 || v6 >= 48 && v6 <= 57 || v6 == 95 )
        a2[v7++] = v6;
      if ( v7 >= 8 )
        i = 999;
    }
    *v4 = 46;
    strcpy(&a2[v7], v4);
  }
  else
  {
    strcpy(a2, a1);
  }
}

//----- (00419EE0) --------------------------------------------------------
signed int __thiscall game::SaveGame(game *ecx0, const char *saveFile, int autosave, char baseGame)
{
  int v6; // [sp+10h] [bp-434h]@30
  int numPlayers; // [sp+14h] [bp-430h]@8
  char buf[40]; // [sp+1Ch] [bp-428h]@29
  char this; // [sp+98h] [bp-3ACh]@21
  int fd; // [sp+25Ch] [bp-1E8h]@25
  int i; // [sp+260h] [bp-1E4h]@8
  char path; // [sp+264h] [bp-1E0h]@5
  char playerAlive[8]; // [sp+428h] [bp-1Ch]@37
  char v14; // [sp+430h] [bp-14h]@35
  void *extraMemory; // [sp+434h] [bp-10h]@1
  int v16; // [sp+438h] [bp-Ch]@49
  int v17; // [sp+43Ch] [bp-8h]@49
  int v18; // [sp+440h] [bp-4h]@27

  extraMemory = BaseAlloc(50000u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF26C + 10);
  memset(extraMemory, 0, 50000u);
  if ( !xIsExpansionMap )
    baseGame = 1;
  advManager::DemobilizeCurrHero(gpAdvManager);
  if ( autosave )
  {
    if ( gbInCampaign )
    {
      sprintf(&path, "%s.%s", saveFile, "GMC");
    }
    else if ( xIsPlayingExpansionCampaign )
    {
      sprintf(&path, "%s.%s", saveFile, "GXC");
    }
    else
    {
      numPlayers = 0;
      for ( i = 0; i < 6; ++i )
      {
        if ( !ecx0->playerDead[i] && gbHumanPlayer[i] )
          ++numPlayers;
      }
      if ( !xIsExpansionMap || baseGame )
        sprintf(&path, "%s.GM%d", saveFile, numPlayers);
      else
        sprintf(&path, "%s.GX%d", saveFile, numPlayers);
    }
  }
  else
  {
    sprintf(&path, saveFile);
  }
  if ( strnicmp((unsigned __int8 *)&path, (unsigned __int8 *)"RMT", 3) )
  {
    sprintf(&this, "%s%s", ".\\GAMES\\", &path);
    if ( strnicmp((unsigned __int8 *)&path, (unsigned __int8 *)"AUTOSAVE", 8)
      && strnicmp((unsigned __int8 *)&path, (unsigned __int8 *)"PLYREXIT", 8) )
      strcpy(gpGame->lastSaveFile, (char *)saveFile);
  }
  else
  {
    sprintf(&this, "%s%s", ".\\DATA\\", &path);
  }
  fd = open(&this, 33537, 128);
  if ( fd == -1 )
    FileError(&this);
  v18 = -1;
  if ( !baseGame )
    _write(fd, &v18, 4);
  _write(fd, &ecx0->map.width, 4);
  _write(fd, &ecx0->map.height, 4);
  _write(fd, &ecx0->mapHeader, 420);
  _write(fd, &ecx0->field_44D, 65);
  _write(fd, &gbIAmGreatest, 1);
  _write(fd, ecx0, 2);
  _write(fd, &giMonthType, 1);
  _write(fd, &giMonthTypeExtra, 1);
  _write(fd, &giWeekType, 1);
  _write(fd, &giWeekTypeExtra, 1);
  _write(fd, cPlayerNames, 126);
  memset(buf, 0, 40u);
  _write(fd, buf, 36);
  if ( xIsPlayingExpansionCampaign )
  {
    v6 = 2;
    _write(fd, &v6, 4);
    _write(fd, &xCampaign, 79);
  }
  else
  {
    _write(fd, &gbInCampaign, 4);
    if ( gbInCampaign )
      _write(fd, &ecx0->field_2, 327);
  }
  if ( !baseGame )
    _write(fd, &xIsExpansionMap, 1);
  advManager::PurgeMapChangeQueue(gpAdvManager);
  _write(fd, &giMapChangeCtr, 4);
  GenerateStandardFileName(ecx0->lastSaveFile, buf);
  _write(fd, buf, 14);
  _write(fd, &ecx0->numPlayers, 1);
  v14 = giCurPlayer;
  _write(fd, &v14, 1);
  _write(fd, &ecx0->couldBeNumDefeatedPlayers, 1);
  _write(fd, ecx0->playerDead, 6);
  for ( i = 0; i < 6; ++i )
  {
    playerAlive[i] = LOBYTE(gbHumanPlayer[i]);
    if ( ecx0->playerDead[i] )
      playerAlive[i] = 0;
  }
  _write(fd, playerAlive, 6);
  _write(fd, &ecx0->day, 2);
  _write(fd, &ecx0->week, 2);
  _write(fd, &ecx0->month, 2);
  for ( i = 0; i < 6; ++i )
    playerData::Write(&ecx0->players[i], fd);
  _write(fd, &ecx0->numObelisks, 1);
  for ( i = 0; i < 54; ++i )
    hero::Write(&ecx0->heroes[i], fd, (unsigned int)baseGame < 1);
  _write(fd, ecx0->relatedToHeroForHireStatus, 54);
  _write(fd, ecx0->castles, 7200);
  _write(fd, ecx0->field_2773, 72);
  _write(fd, ecx0->field_27BB, 9);
  _write(fd, ecx0->mines, 1008);
  _write(fd, ecx0->field_60A6, 144);
  if ( baseGame )
    _write(fd, ecx0->artifactGeneratedRandomly, 82);
  else
    _write(fd, ecx0->artifactGeneratedRandomly, 103);
  _write(fd, ecx0->boats, 384);
  _write(fd, ecx0->boatBuilt, 48);
  _write(fd, ecx0->obeliskVisitedMasks, 48);
  _write(fd, &ecx0->field_6395, 1);
  _write(fd, &ecx0->field_6396, 1);
  _write(fd, &ecx0->field_6397, 1);
  _write(fd, ecx0->currentRumor, 301);
  _write(fd, ecx0->field_637D, 24);
  _write(fd, &ecx0->numRumors, 4);
  _write(fd, ecx0->rumorIndices, 2 * ecx0->numRumors);
  _write(fd, &ecx0->numEvents, 4);
  _write(fd, ecx0->eventIndices, 2 * ecx0->numEvents);
  _write(fd, &ecx0->numMapEvents, 4);
  _write(fd, ecx0->mapEventIndices, 2 * ecx0->numMapEvents);
  v17 = 1234;
  v16 = 9999;
  _write(fd, &v17, 4);
  _write(fd, &iMaxMapExtra, 4);
  _write(fd, &v17, 4);
  for ( i = 1; i < iMaxMapExtra; ++i )
  {
    _write(fd, &v17, 4);
    _write(fd, &pwSizeOfMapExtra[i], 2);
    if ( ppMapExtra[i] )
      _write(fd, ppMapExtra[i], pwSizeOfMapExtra[i]);
    else
      _write(fd, extraMemory, pwSizeOfMapExtra[i]);
  }
  _write(fd, &v17, 4);
  _write(fd, mapRevealed, MAP_HEIGHT * MAP_WIDTH);
  _write(fd, &v17, 4);
  fullMap::Write(&ecx0->map, fd);
  _write(fd, &v17, 4);
  _close(fd);
  BaseFree(extraMemory, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF26C + 237);
  return 1;
}
// 4EF26C: using guessed type __int16 word_4EF26C;
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 419EE0: using guessed type char playerAlive[8];

//----- (0041AAA0) --------------------------------------------------------
int __thiscall game::SetupOrigData(game *this)
{
  int result; // eax@50
  signed int k; // [sp+10h] [bp-8h]@13
  signed int l; // [sp+10h] [bp-8h]@16
  signed int m; // [sp+10h] [bp-8h]@19
  signed int ii; // [sp+10h] [bp-8h]@37
  signed int i; // [sp+14h] [bp-4h]@1
  signed int j; // [sp+14h] [bp-4h]@11
  signed int n; // [sp+14h] [bp-4h]@35
  signed int jj; // [sp+14h] [bp-4h]@41
  signed int kk; // [sp+14h] [bp-4h]@44

  ClearMapExtra();
  *(_DWORD *)&gbIAmGreatest = 0;
  this->gameDifficulty = 1;
  giMonthType = 0;
  giMonthTypeExtra = 0;
  giWeekType = 0;
  giWeekTypeExtra = 0;
  this->_B[1] = 0;
  advManager::PurgeMapChangeQueue(gpAdvManager);
  *(_DWORD *)&giMapChangeCtr = 1;
  strcpy(this->lastSaveFile, "NEWGAME");
  this->numPlayers = 4;
  this->couldBeNumDefeatedPlayers = 0;
  memset(this->playerDead, 0, 6u);
  this->month = 1;
  this->week = this->month;
  this->day = this->week;
  giCurTurn = 1;
  for ( i = 0; i < 6; ++i )
  {
    strcpy(&this->field_637D[4 * i], byte_4EF30C);
    if ( iLastMsgNumHumanPlayers <= i )
    {
      gbThisNetHumanPlayer[i] = 0;
      gbHumanPlayer[i] = 0;
    }
    else
    {
      gbThisNetHumanPlayer[i] = !i || iMPBaseType == 2;
      gbHumanPlayer[i] = 1;
    }
    memset(&this->players[i], 0, 0x11Bu);
    this->players[i].color = i;
    this->players[i].numHeroes = 0;
    this->players[i].numCastles = 0;
    this->players[i].field_43 = -1;
    this->players[i]._3[0] = 0;
    memset(this->players[i].heroesForPurchase, 0xFFu, 2u);
    memset(this->players[i].heroesOwned, 0xFFu, 8u);
    memset(this->players[i].castlesOwned, 0xFFu, 0x48u);
  }
  this->numObelisks = 0;
  gpAdvManager->heroMobilized = 0;
  memset(this->relatedToHeroForHireStatus, 0xFFu, 0x36u);
  for ( j = 0; j < 54; ++j )
  {
    memset(&this->heroes[j], 0, 0xFAu);
    memset(this->heroes[j].spellsLearned, 0, 0x41u);
    memset(this->heroes[j].artifacts, 0xFFu, 0xEu);
    HIBYTE(this->heroes[j].field_29) = -1;
    LOBYTE(this->heroes[j].field_29) = HIBYTE(this->heroes[j].field_29);
    this->heroes[j].idx = j;
    this->heroes[j].heroID = j;
    this->heroes[j].ownerIdx = -1;
    HIBYTE(this->heroes[j].field_2B) = 2;
    strcpy(this->heroes[j].name, (&gHeroDefaultNames)[4 * j]);
    this->heroes[j].factionID = j / 9;
    for ( k = 0; k < 5; ++k )
      this->heroes[j].primarySkills[k] = *(&gStartingHeroStats[this->heroes[j].factionID].attack + k);
    for ( l = 0; l < 5; ++l )
      this->heroes[j].army.creatureTypes[l] = -1;
    *(_DWORD *)&this->heroes[j].field_25 = -1;
    *(_DWORD *)&this->heroes[j].field_21 = *(_DWORD *)&this->heroes[j].field_25;
    this->heroes[j].oldLevel = 1;
    this->heroes[j].spellpoints = 10 * hero::Stats(&this->heroes[j], PRIMARY_SKILL_KNOWLEDGE);
    this->heroes[j].numSecSkillsKnown = 0;
    for ( m = 0; m < 14; ++m )
    {
      this->heroes[j].secondarySkillLevel[m] = 0;
      this->heroes[j].skillIndex[m] = 0;
    }
    if ( !this->heroes[j].factionID )
    {
      hero::GiveSS(&this->heroes[j], SECONDARY_SKILL_LEADERSHIP, 1);
      hero::GiveSS(&this->heroes[j], 10, 1);
    }
    if ( this->heroes[j].factionID == FACTION_SORCERESS )
    {
      this->heroes[j].artifacts[0] = ARTIFACT_MAGIC_BOOK;
      hero::GiveSS(&this->heroes[j], SECONDARY_SKILL_NAVIGATION, 2);
      hero::GiveSS(&this->heroes[j], SECONDARY_SKILL_WISDOM, 1);
    }
    if ( this->heroes[j].factionID == FACTION_BARBARIAN )
      hero::GiveSS(&this->heroes[j], 0, 2);
    if ( this->heroes[j].factionID == FACTION_WARLOCK )
    {
      this->heroes[j].artifacts[0] = ARTIFACT_MAGIC_BOOK;
      hero::GiveSS(&this->heroes[j], SECONDARY_SKILL_SCOUTING, 2);
      hero::GiveSS(&this->heroes[j], SECONDARY_SKILL_WISDOM, 1);
    }
    if ( this->heroes[j].factionID == 4 )
    {
      this->heroes[j].artifacts[0] = 81;
      hero::GiveSS(&this->heroes[j], 7, 2);
    }
    if ( this->heroes[j].factionID == 5 )
    {
      this->heroes[j].artifacts[0] = 81;
      hero::GiveSS(&this->heroes[j], 7, 1);
      hero::GiveSS(&this->heroes[j], 12, 1);
    }
  }
  memset(this->field_2773, 0xFFu, 0x48u);
  for ( n = 0; n < 72; ++n )
  {
    memset(&this->castles[n], 0, 0x64u);
    this->castles[n].exists = 0;
    this->castles[n].idx = n;
    this->castles[n].ownerIdx = -1;
    this->castles[n].factionID = n / 9;
    this->castles[n].visitingHeroIdx = -1;
    for ( ii = 0; ii < 5; ++ii )
      this->castles[n].garrison.creatureTypes[ii] = -1;
  }
  for ( jj = 0; jj < 144; ++jj )
    memset(&this->mines[jj], 0xFFu, 7u);
  memset(this->field_60A6, 0xFFu, 0x90u);
  for ( kk = 0; kk < 48; ++kk )
  {
    memset(&this->boats[kk], 0, 8u);
    this->boats[kk].idx = kk;
    this->boats[kk].field_6 = -1;
  }
  memset(this->field_27BB, 0, 9u);
  memset(this->boatBuilt, 0xFFu, 0x30u);
  this->field_6396 = -1;
  this->field_6395 = this->field_6396;
  memset(this->obeliskVisitedMasks, 0, 0x30u);
  strcpy(gpGame->lastSaveFile, "NEWGAME");
  giCurPlayer = 0;
  gpCurPlayer = gpGame->players;
  giCurPlayerBit = 1;
  for ( giCurWatchPlayer = 0;
        !gbThisNetHumanPlayer[giCurWatchPlayer];
        giCurWatchPlayer = (giCurWatchPlayer + 1) % this->numPlayers )
    ;
  giCurWatchPlayerBit = 1 << giCurWatchPlayer;
  advManager::CheckSetEvilInterface(gpAdvManager, 0, -1);
  result = gbThisNetHumanPlayer[giCurPlayer];
  bShowIt = gbThisNetHumanPlayer[giCurPlayer];
  return result;
}
// 4F3B18: using guessed type primary_skills gStartingHeroStats[];
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523EDC: using guessed type int giCurWatchPlayer;
// 524778: using guessed type int iMPBaseType;
// 524C14: using guessed type int bShowIt;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532C54: using guessed type int giCurTurn;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (0041B5F0) --------------------------------------------------------
void __thiscall game::LoadGame(game *ecx0, char *filnam, int isNewGame, int a4)
{
  char v5; // [sp+10h] [bp-244h]@11
  char hasPlayer[12]; // [sp+3Ch] [bp-218h]@19
  int buf; // [sp+48h] [bp-20Ch]@11
  char v8; // [sp+4Ch] [bp-208h]@5
  char expansion; // [sp+210h] [bp-44h]@9
  int fd; // [sp+214h] [bp-40h]@7
  int i; // [sp+240h] [bp-14h]@19
  char v12; // [sp+244h] [bp-10h]@19
  char v13; // [sp+248h] [bp-Ch]@45
  int v14; // [sp+24Ch] [bp-8h]@3
  int firstByte; // [sp+250h] [bp-4h]@9

  LogStr("LG1");
  if ( isNewGame )
  {
    game::SetupOrigData(ecx0);
  }
  else
  {
    LogStr("LG2");
    v14 = 0;
    gbGameOver = 0;
    ecx0->field_660E = 1;
    if ( strnicmp((unsigned __int8 *)filnam, (unsigned __int8 *)"RMT", 3) )
      sprintf(&v8, "%s%s", ".\\GAMES\\", filnam);
    else
      sprintf(&v8, "%s%s", ".\\DATA\\", filnam);
    fd = open(&v8, O_BINARY);
    if ( fd == -1 )
      FileError(&v8);
    ClearMapExtra();
    expansion = 0;
    _read(fd, &firstByte, 4u);
    if ( firstByte == -1 )
    {
      expansion = 1;
      _read(fd, &firstByte, 4u);
    }
    _read(fd, &buf, 4u);
    game::SetMapSize(ecx0, firstByte, buf);
    _read(fd, &ecx0->mapHeader, sizeof(SMapHeader));
    _read(fd, &ecx0->field_44D, 65u);
    _read(fd, &gbIAmGreatest, 1u);
    _read(fd, ecx0, 2u);
    _read(fd, &giMonthType, 1u);
    _read(fd, &giMonthTypeExtra, 1u);
    _read(fd, &giWeekType, 1u);
    _read(fd, &giWeekTypeExtra, 1u);
    _read(fd, cPlayerNames, 126u);
    _read(fd, &v5, 36u);
    _read(fd, &gbInCampaign, 4u);
    if ( gbInCampaign == 1 )
    {
      _read(fd, &ecx0->field_2, 0x147u);
    }
    else if ( gbInCampaign == 2 )
    {
      xIsPlayingExpansionCampaign = 1;
      gbInCampaign = 0;
      _read(fd, &xCampaign, 0x4Fu);
    }
    if ( expansion )
      _read(fd, &xIsExpansionMap, 1u);
    advManager::PurgeMapChangeQueue(gpAdvManager);
    _read(fd, &giMapChangeCtr, 4u);
    _read(fd, &v5, 0xEu);
    if ( strnicmp((unsigned __int8 *)filnam, (unsigned __int8 *)"RMT", 3) )
      sprintf(gpGame->lastSaveFile, filnam);
    _read(fd, &ecx0->numPlayers, 1u);
    _read(fd, &v12, 1u);
    giCurPlayer = v12;
    _read(fd, &ecx0->couldBeNumDefeatedPlayers, 1u);
    _read(fd, ecx0->playerDead, 6u);
    _read(fd, hasPlayer, 6u);
    for ( i = 0; i < 6; ++i )
    {
      if ( hasPlayer[i] && v14 < iLastMsgNumHumanPlayers )
      {
        ++v14;
        gbHumanPlayer[i] = 1;
      }
      else
      {
        gbHumanPlayer[i] = 0;
      }
    }
    for ( i = 0; i < 6; ++i )
    {
      if ( gbHumanPlayer[i] )
        gbThisNetHumanPlayer[i] = !gbRemoteOn || i == giThisGamePos;
      else
        gbThisNetHumanPlayer[i] = 0;
    }
    _read(fd, &ecx0->day, 2u);
    _read(fd, &ecx0->week, 2u);
    _read(fd, &ecx0->month, 2u);
    giCurTurn = ecx0->day + 7 * (ecx0->week - 1) + 28 * (ecx0->month - 1);
    for ( i = 0; i < 6; ++i )
      playerData::Read(&ecx0->players[i], fd);
    _read(fd, &ecx0->numObelisks, 1u);
    for ( i = 0; i < 54; ++i )
      hero::Read(&ecx0->heroes[i], fd, expansion);
    _read(fd, ecx0->relatedToHeroForHireStatus, 0x36u);
    _read(fd, ecx0->castles, 7200u);
    _read(fd, ecx0->field_2773, 0x48u);
    _read(fd, ecx0->field_27BB, 9u);
    _read(fd, ecx0->mines, 0x3F0u);
    _read(fd, ecx0->field_60A6, 144u);
    if ( expansion )
      _read(fd, ecx0->artifactGeneratedRandomly, 0x67u);
    else
      _read(fd, ecx0->artifactGeneratedRandomly, 0x52u);
    _read(fd, ecx0->boats, 0x180u);
    _read(fd, ecx0->boatBuilt, 0x30u);
    _read(fd, ecx0->obeliskVisitedMasks, 0x30u);
    _read(fd, &ecx0->field_6395, 1u);
    _read(fd, &ecx0->field_6396, 1u);
    _read(fd, &ecx0->field_6397, 1u);
    _read(fd, ecx0->currentRumor, 301u);
    _read(fd, ecx0->field_637D, 0x18u);
    _read(fd, &ecx0->numRumors, 4u);
    _read(fd, ecx0->rumorIndices, 2 * ecx0->numRumors);
    _read(fd, &ecx0->numEvents, 4u);
    _read(fd, ecx0->eventIndices, 2 * ecx0->numEvents);
    _read(fd, &ecx0->numMapEvents, 4u);
    _read(fd, ecx0->mapEventIndices, 2 * ecx0->numMapEvents);
    _read(fd, &v13, 4u);
    _read(fd, &iMaxMapExtra, 4u);
    _read(fd, &v13, 4u);
    ppMapExtra = (void **)BaseAlloc(4 * iMaxMapExtra, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF318 + 203);
    pwSizeOfMapExtra = (__int16 *)BaseAlloc(2 * iMaxMapExtra, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF318 + 204);
    memset(ppMapExtra, 0, 4 * iMaxMapExtra);
    memset(pwSizeOfMapExtra, 0, 2 * iMaxMapExtra);
    for ( i = 1; i < iMaxMapExtra; ++i )
    {
      _read(fd, &v13, 4u);
      _read(fd, &pwSizeOfMapExtra[i], 2u);
      ppMapExtra[i] = BaseAlloc(pwSizeOfMapExtra[i], "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF318 + 213);
      _read(fd, ppMapExtra[i], pwSizeOfMapExtra[i]);
    }
    _read(fd, &v13, 4u);
    _read(fd, mapRevealed, MAP_HEIGHT * MAP_WIDTH);
    _read(fd, &v13, 4u);
    fullMap::Read(&ecx0->map, fd, 0);
    _read(fd, &v13, 4u);
    _close(fd);
    gpAdvManager->heroMobilized = 0;
    gpCurPlayer = &gpGame->players[giCurPlayer];
    giCurPlayerBit = 1 << giCurPlayer;
    for ( giCurWatchPlayer = giCurPlayer;
          !gbThisNetHumanPlayer[giCurWatchPlayer];
          giCurWatchPlayer = (giCurWatchPlayer + 1) % ecx0->numPlayers )
      ;
    giCurWatchPlayerBit = 1 << giCurWatchPlayer;
    bShowIt = gbThisNetHumanPlayer[giCurPlayer];
    game::SetupAdjacentMons(ecx0);
    LogStr("LG3");
    advManager::CheckSetEvilInterface(gpAdvManager, 0, -1);
  }
}
// 4EF268: using guessed type int gbGameOver;
// 4EF318: using guessed type __int16 word_4EF318;
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F7494: using guessed type int gbRemoteOn;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523EDC: using guessed type int giCurWatchPlayer;
// 524730: using guessed type int giThisGamePos;
// 524C14: using guessed type int bShowIt;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532C54: using guessed type int giCurTurn;
// 532C5C: using guessed type char giCurPlayerBit;
// 41B5F0: using guessed type char hasPlayer[12];

//----- (0041C0E0) --------------------------------------------------------
void __thiscall game::GiveTroopsToNeutralTown(game *this, int castleIdx)
{
  int randomQuantity; // [sp+18h] [bp-14h]@7
  int quantity; // [sp+18h] [bp-14h]@15
  signed int factionOffset; // [sp+1Ch] [bp-10h]@7
  int creatureType; // [sp+24h] [bp-8h]@0
  int v7; // [sp+28h] [bp-4h]@4

  if ( (this->castles[castleIdx].x > 0 || this->castles[castleIdx].y > 0) && this->castles[castleIdx].ownerIdx < 0 )
  {
    v7 = Random(1, 15);
    if ( giCurTurn / 10 )
      v7 += Random(0, giCurTurn / 10);
    if ( v7 > 5 )
    {
      if ( v7 > 10 )
      {
        if ( v7 > 13 )
        {
          if ( v7 > 15 )
          {
            factionOffset = 50;
            randomQuantity = 1;
          }
          else
          {
            factionOffset = 40;
            randomQuantity = Random(1, 3);
          }
        }
        else
        {
          factionOffset = 30;
          randomQuantity = Random(3, 5);
        }
      }
      else
      {
        factionOffset = 20;
        randomQuantity = Random(5, 7);
      }
    }
    else
    {
      factionOffset = 10;
      randomQuantity = Random(8, 15);
    }
    quantity = giCurTurn / 20 + randomQuantity;
    switch ( factionOffset + this->castles[castleIdx].factionID )
    {
      case 10:
        creatureType = CREATURE_PEASANT;
        break;
      case 20:
        creatureType = CREATURE_ARCHER;
        break;
      case 30:
        creatureType = CREATURE_PIKEMAN;
        break;
      case 40:
        creatureType = CREATURE_SWORDSMAN;
        break;
      case 50:
        creatureType = CREATURE_CAVALRY;
        break;
      case 11:
        creatureType = CREATURE_GOBLIN;
        break;
      case 21:
        creatureType = CREATURE_ORC;
        break;
      case 31:
        creatureType = CREATURE_WOLF;
        break;
      case 41:
        creatureType = CREATURE_OGRE;
        break;
      case 51:
        creatureType = CREATURE_TROLL;
        break;
      case 12:
        creatureType = CREATURE_SPRITE;
        break;
      case 22:
        creatureType = CREATURE_DWARF;
        break;
      case 32:
        creatureType = CREATURE_ELF;
        break;
      case 42:
        creatureType = CREATURE_DRUID;
        break;
      case 52:
        creatureType = CREATURE_UNICORN;
        break;
      case 13:
        creatureType = CREATURE_CENTAUR;
        break;
      case 23:
        creatureType = CREATURE_GARGOYLE;
        break;
      case 33:
        creatureType = CREATURE_GRIFFIN;
        break;
      case 43:
        creatureType = CREATURE_MINOTAUR;
        break;
      case 53:
        creatureType = CREATURE_HYDRA;
        break;
      case 14:
        creatureType = CREATURE_HALFLING;
        break;
      case 24:
        creatureType = CREATURE_BOAR;
        break;
      case 34:
        creatureType = CREATURE_IRON_GOLEM;
        break;
      case 44:
        creatureType = CREATURE_ROC;
        break;
      case 54:
        creatureType = CREATURE_MAGE;
        break;
      case 15:
        creatureType = CREATURE_SKELETON;
        break;
      case 25:
        creatureType = CREATURE_ZOMBIE;
        break;
      case 35:
        creatureType = CREATURE_MUMMY;
        break;
      case 45:
        creatureType = CREATURE_VAMPIRE;
        break;
      case 55:
        creatureType = CREATURE_LICH;
        break;
      case 16:
      case 17:
      case 18:
      case 19:
      case 26:
      case 27:
      case 28:
      case 29:
      case 36:
      case 37:
      case 38:
      case 39:
      case 46:
      case 47:
      case 48:
      case 49:
        break;
    }
    game::GiveArmy(&this->castles[castleIdx].garrison, creatureType, quantity, -1);
  }
}
// 532C54: using guessed type int giCurTurn;

//----- (0041C4D0) --------------------------------------------------------
void __thiscall game::GiveTroopsToNeutralTowns(game *this)
{
  int castleIdx; // [sp+10h] [bp-4h]@1

  for ( castleIdx = 0; castleIdx < 72; ++castleIdx )
  {
    game::GiveTroopsToNeutralTown(this, castleIdx);
    if ( this->castles[castleIdx].buildingsBuiltFlags & 0x40 )
    {
      if ( Random(0, 100) < 80 )
        game::GiveTroopsToNeutralTown(this, castleIdx);
    }
    else if ( Random(0, 100) < 40 )
    {
      game::GiveTroopsToNeutralTown(this, castleIdx);
    }
  }
}

//----- (0041C580) --------------------------------------------------------
void __thiscall game::NewMap(game *this, char *name)
{
  int v2; // eax@105
  int v3; // ST74_4@110
  int v4; // ST6C_4@110
  mapCell *v5; // ST34_4@110
  int v6; // ebx@116
  int v7; // ebx@116
  int v8; // ebx@126
  int v9; // ebx@137
  int v10; // ebx@137
  int v11; // ecx@158
  int v12; // ecx@164
  double v14; // [sp+14h] [bp-68h]@151
  int v15; // [sp+1Ch] [bp-60h]@133
  int v16; // [sp+20h] [bp-5Ch]@130
  int v17; // [sp+2Ch] [bp-50h]@171
  char *a2; // [sp+30h] [bp-4Ch]@0
  char v19; // [sp+34h] [bp-48h]@0
  signed int v20; // [sp+38h] [bp-44h]@76
  signed int v21; // [sp+38h] [bp-44h]@90
  signed int j; // [sp+3Ch] [bp-40h]@78
  signed int k; // [sp+3Ch] [bp-40h]@95
  signed int v24; // [sp+44h] [bp-38h]@53
  int v25; // [sp+4Ch] [bp-30h]@7
  signed int faction; // [sp+50h] [bp-2Ch]@87
  int numPlayers; // [sp+54h] [bp-28h]@42
  signed int numPlayersa; // [sp+54h] [bp-28h]@57
  signed int numPlayersb; // [sp+54h] [bp-28h]@108
  int numPlayersc; // [sp+54h] [bp-28h]@116
  signed int numPlayersd; // [sp+54h] [bp-28h]@148
  signed int numPlayerse; // [sp+54h] [bp-28h]@188
  signed int playerIdx; // [sp+58h] [bp-24h]@7
  signed int playerIdxa; // [sp+58h] [bp-24h]@15
  signed int playerIdxb; // [sp+58h] [bp-24h]@20
  signed int playerIdxc; // [sp+58h] [bp-24h]@23
  signed int playerIdxd; // [sp+58h] [bp-24h]@26
  signed int playerIdxe; // [sp+58h] [bp-24h]@29
  signed int playerIdxf; // [sp+58h] [bp-24h]@32
  signed int playerIdxg; // [sp+58h] [bp-24h]@35
  signed int playerIdxh; // [sp+58h] [bp-24h]@42
  signed int playerIdxi; // [sp+58h] [bp-24h]@51
  int playerIdxj; // [sp+58h] [bp-24h]@69
  signed int playerIdxk; // [sp+58h] [bp-24h]@106
  int playerIdxl; // [sp+58h] [bp-24h]@116
  signed int playerIdxm; // [sp+58h] [bp-24h]@144
  signed int playerIdxn; // [sp+58h] [bp-24h]@169
  int v48; // [sp+5Ch] [bp-20h]@158
  int v49; // [sp+5Ch] [bp-20h]@164
  signed int v50; // [sp+60h] [bp-1Ch]@116
  int v51; // [sp+68h] [bp-14h]@7
  int v52; // [sp+6Ch] [bp-10h]@1
  signed int i; // [sp+74h] [bp-8h]@55
  int v54; // [sp+78h] [bp-4h]@116

  v52 = FindLastToken(gMapName, 46);
  if ( v52 && StrEqNoCase((int *)(v52 + 1), (int *)"MX2") )
    LOBYTE(xIsExpansionMap) = 1;
  if ( xIsExpansionMap )
    gTownEligibleBuildMask[5] |= 4u;
  else
    gTownEligibleBuildMask[5] &= 0xFFFFFFFBu;
  gbInNewGameSetup = 1;
  giCurPlayer = 0;
  gpCurPlayer = gpGame->players;
  giCurPlayerBit = 1;
  giCurWatchPlayerBit = 1;
  giCurWatchPlayer = 0;
  v51 = Random(0, 5);
  v25 = iLastMsgNumHumanPlayers;
  for ( playerIdx = 0; playerIdx < 6; ++playerIdx )
  {
    if ( gpGame->mapHeader.numPlayers > playerIdx )
    {
      if ( this->somePlayerCodeOr10IfMayBeHuman[playerIdx] == 10 )
        gbSetupGamePosToRealGamePos[playerIdx] = v25++;
      else
        gbSetupGamePosToRealGamePos[playerIdx] = this->somePlayerCodeOr10IfMayBeHuman[playerIdx];
    }
    else
    {
      gbSetupGamePosToRealGamePos[playerIdx] = -1;
    }
  }
  for ( playerIdxa = 0; playerIdxa < 6; ++playerIdxa )
  {
    this->players[playerIdxa].color = -1;
    gcColorToPlayerPos[playerIdxa] = -1;
    gcColorToSetupPos[playerIdxa] = -1;
    if ( gpGame->field_459[playerIdxa] == 7 )
      gpGame->field_459[playerIdxa] = v51;
    v51 = (v51 + 1) % 6;
  }
  for ( playerIdxb = 0; this->numPlayers > playerIdxb; ++playerIdxb )
    gcColorToSetupPos[*((_BYTE *)&this->field_44D + playerIdxb)] = playerIdxb;
  for ( playerIdxc = 0; this->numPlayers > playerIdxc; ++playerIdxc )
    this->players[gbSetupGamePosToRealGamePos[playerIdxc]].color = *((_BYTE *)&this->field_44D + playerIdxc);
  for ( playerIdxd = 0; this->numPlayers > playerIdxd; ++playerIdxd )
    gcColorToPlayerPos[this->players[playerIdxd].color] = playerIdxd;
  for ( playerIdxe = 0; this->numPlayers > playerIdxe; ++playerIdxe )
  {
    this->players[playerIdxe].numCastles = 0;
    HIBYTE(this->players[playerIdxe].field_45) = 0;
    LOBYTE(this->players[playerIdxe].field_45) = -1;
    this->players[playerIdxe].numHeroes = 0;
    this->players[playerIdxe].field_3 = 0;
    this->players[playerIdxe].curHeroIdx = -1;
  }
  game::RandomizeHeroPool(this);
  strcpy(gMapName, name);
  game::LoadMap(this, gMapName);
  game::InitRandomArtifacts(this);
  game::ProcessRandomObjects(this);
  game::ProcessMapExtra(this);
  game::SetupTowns(this);
  game::InitializePasswords();
  for ( playerIdxf = 0; playerIdxf < 6; ++playerIdxf )
    this->players[playerIdxf].barrierTentsVisited = 0;
  game::RandomizeEvents(this);
  game::ProcessOnMapHeroes(this);
  this->couldBeNumDefeatedPlayers = 0;
  for ( playerIdxg = this->numPlayers; playerIdxg < 6; ++playerIdxg )
    this->playerDead[playerIdxg] = 1;
  if ( this->mapHeader.winConditionType == WIN_CONDITION_DEFEAT_COLOR
    || this->mapHeader.winConditionType == WIN_CONDITION_DEFEAT_HERO )
  {
    this->mapHeader.field_1E = 1;
    this->mapHeader.allowDefeatAllVictory = 0;
  }
  if ( this->mapHeader.winConditionType == WIN_CONDITION_DEFEAT_COLOR )
  {
    numPlayers = 0;
    for ( playerIdxh = 0; playerIdxh < 6; ++playerIdxh )
    {
      if ( this->mapHeader.hasPlayer[playerIdxh] )
        ++numPlayers;
      if ( this->mapHeader.winConditionArgument + 1 == numPlayers )
      {
        HIWORD(this->mapHeader.field_2E) = playerIdxh;
        playerIdxh = 99;
      }
    }
  }
  if ( this->mapHeader.winConditionType == 3 )
    this->mapHeader.field_1E = 1;
  for ( playerIdxi = 0; this->numPlayers > playerIdxi; ++playerIdxi )
  {
    this->players[playerIdxi].field_40 = 0;
    LOBYTE(this->players[playerIdxi].field_41) = -1;
    HIBYTE(this->players[playerIdxi].field_41) = -1;
    v24 = -1;
    if ( !this->mapHeader.noStartingHeroInCastle && this->players[playerIdxi].numCastles > 0 )
    {
      for ( i = 0; i < 2; ++i )
      {
        for ( numPlayersa = 0; this->players[playerIdxi].numCastles > numPlayersa; ++numPlayersa )
        {
          if ( v24 == -1
            && this->castles[this->players[playerIdxi].castlesOwned[numPlayersa]].visitingHeroIdx == -1
            && (this->castles[this->players[playerIdxi].castlesOwned[numPlayersa]].buildingsBuiltFlags & 0x40 || i == 1) )
            v24 = numPlayersa;
        }
      }
    }
    if ( v24 != -1 )
    {
      *(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes - playerIdxi) = game::GetNewHeroId(this, playerIdxi, this->castles[this->players[playerIdxi].castlesOwned[v24]].factionID, 0);
      this->relatedToHeroForHireStatus[*(&this->players[0].heroesOwned[284 * playerIdxi]
                                       + this->players[playerIdxi].numHeroes
                                       - playerIdxi)] = playerIdxi;
      this->heroes[*(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes - playerIdxi)].ownerIdx = playerIdxi;
      this->heroes[*(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes - playerIdxi)].x = this->castles[this->players[playerIdxi].castlesOwned[v24]].x;
      this->heroes[*(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes - playerIdxi)].y = this->castles[this->players[playerIdxi].castlesOwned[v24]].y;
      this->castles[this->players[playerIdxi].castlesOwned[v24]].visitingHeroIdx = *(&this->players[0].heroesOwned[284 * playerIdxi]
                                                                                   + this->players[playerIdxi].numHeroes
                                                                                   - playerIdxi);
      game::SetVisibility(
        this,
        this->heroes[*(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes
                                                                       - playerIdxi)].x,
        this->heroes[*(&this->players[0].heroesOwned[284 * playerIdxi] + this->players[playerIdxi].numHeroes
                                                                       - playerIdxi)].y,
        playerIdxi,
        giVisRange[this->heroes[this->players[playerIdxi].heroesOwned[0]].secondarySkillLevel[3]]);
      ++this->players[playerIdxi].numHeroes;
    }
  }
  for ( playerIdxj = 0; this->numPlayers > playerIdxj; ++playerIdxj )
  {
    if ( playerIdxj || !gbInCampaign || !this->field_7F && !this->field_84 )
      goto LABEL_195;
    v20 = this->field_7F ? 2 : 5;
    for ( j = 0; j < 54 && (this->heroes[j].factionID != v20 || this->relatedToHeroForHireStatus[j] != -1); ++j )
      ;
    if ( j < 54 )
    {
      if ( this->field_7F )
      {
        this->heroes[j].experience += 5000;
        hero::CheckLevel(&this->heroes[j]);
        strcpy(this->heroes[j].name, "Sister Eliza");
        this->heroes[j].heroID = 56;
      }
      else
      {
        this->heroes[j].experience += 5000;
        hero::CheckLevel(&this->heroes[j]);
        strcpy(this->heroes[j].name, "Brother Brax");
        this->heroes[j].heroID = 59;
      }
      this->players[0].heroesForPurchase[0] = j;
      this->relatedToHeroForHireStatus[this->players[0].heroesForPurchase[0]] = 64;
      faction = this->heroes[j].factionID;
    }
    else
    {
LABEL_195:
      if ( !xIsPlayingExpansionCampaign || playerIdxj )
        goto LABEL_196;
      v21 = -1;
      if ( ExpCampaign::HasAward(&xCampaign, 6) )
      {
        v21 = 4;
        a2 = ExpCampaign::JosephName((int)&xCampaign);
        v19 = 64;
      }
      else if ( ExpCampaign::HasAward(&xCampaign, 7) )
      {
        v21 = 1;
        a2 = ExpCampaign::IvanName((int)&xCampaign);
        v19 = 63;
      }
      if ( v21 == -1 )
        goto LABEL_196;
      for ( k = 0; k < 54 && (this->heroes[k].factionID != v21 || this->relatedToHeroForHireStatus[k] != -1); ++k )
        ;
      if ( k >= 54 )
      {
LABEL_196:
        faction = Random(0, 5);
        if ( this->field_459[gcColorToSetupPos[this->players[playerIdxj].color]] < 6 )
          faction = this->field_459[gcColorToSetupPos[this->players[playerIdxj].color]];
        this->players[playerIdxj].heroesForPurchase[0] = game::GetNewHeroId(this, playerIdxj, faction, 0);
        this->relatedToHeroForHireStatus[this->players[playerIdxj].heroesForPurchase[0]] = 64;
      }
      else
      {
        this->heroes[k].experience = 5000;
        hero::CheckLevel(&this->heroes[k]);
        strcpy(this->heroes[k].name, a2);
        this->heroes[k].heroID = v19;
        this->players[0].heroesForPurchase[0] = k;
        this->relatedToHeroForHireStatus[this->players[0].heroesForPurchase[0]] = 64;
        faction = this->heroes[k].factionID;
      }
    }
    v2 = Random(1, 5);
    this->players[playerIdxj].heroesForPurchase[1] = game::GetNewHeroId(this, playerIdxj, (faction + v2) % 6, 0);
    this->relatedToHeroForHireStatus[this->players[playerIdxj].heroesForPurchase[1]] = 64;
  }
  for ( playerIdxk = 0; this->numPlayers > playerIdxk; ++playerIdxk )
  {
    for ( numPlayersb = 0; this->players[playerIdxk].numHeroes > numPlayersb; ++numPlayersb )
    {
      v3 = this->heroes[this->players[playerIdxk].heroesOwned[numPlayersb]].x;
      v4 = this->heroes[this->players[playerIdxk].heroesOwned[numPlayersb]].y;
      this->heroes[this->players[playerIdxk].heroesOwned[numPlayersb]].occupiedObjType = *(&this->map.tiles[v3].objType
                                                                                         + 12 * v4 * this->map.width);
      this->heroes[this->players[playerIdxk].heroesOwned[numPlayersb]].occupiedObjVal = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[v3].field_4_1_1_isShadow_1_13_extraInfo + 6 * v4 * this->map.width) >> 8) >> -5);
      *(&this->map.tiles[v3].objType + 12 * v4 * this->map.width) = -86;
      v5 = &this->map.tiles[v4 * this->map.width] + v3;
      v5->field_4_1_1_isShadow_1_13_extraInfo = v5->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                            * this->players[playerIdxk].heroesOwned[numPlayersb];
    }
    if ( this->players[playerIdxk].numHeroes <= 0 )
    {
      if ( this->players[playerIdxk].numCastles > 0 )
        LOBYTE(this->players[playerIdxk].field_45) = this->players[playerIdxk].castlesOwned[0];
    }
    else
    {
      this->players[playerIdxk].curHeroIdx = this->players[playerIdxk].heroesOwned[0];
    }
  }
  playerIdxl = -1;
  numPlayersc = -1;
  v50 = 0;
  v6 = Random(1, 30);
  v7 = Random(1, 20) + v6;
  v54 = Random(1, 20) + v7;
  while ( 1 )
  {
    if ( playerIdxl >= 9 )
    {
      if ( numPlayersc >= 9 )
      {
        if ( MAP_WIDTH - 10 >= playerIdxl )
        {
          if ( MAP_HEIGHT - 10 >= numPlayersc )
          {
            if ( *(&this->map.tiles[playerIdxl].objectIndex + 12 * numPlayersc * this->map.width) == 255 )
            {
              if ( *(&this->map.tiles[playerIdxl].overlayIndex + 12 * numPlayersc * this->map.width) == 255 )
              {
                if ( giGroundToTerrain[*(&this->map.tiles[numPlayersc * this->map.width].groundIndex + 6 * playerIdxl)] )
                {
                  if ( iLastMsgNumHumanPlayers != 1 )
                    break;
                  if ( v50 >= 200 )
                    break;
                  v8 = abs(numPlayersc - this->heroes[this->players[0].heroesOwned[0]].y);
                  if ( abs(playerIdxl - this->heroes[this->players[0].heroesOwned[0]].x) + v8 > v54 )
                    break;
                }
              }
            }
          }
        }
      }
    }
    if ( v50 >= 400 || giUABaseX <= 0 )
    {
      playerIdxl = Random(9, MAP_WIDTH - 10);
      numPlayersc = Random(9, MAP_HEIGHT - 10);
    }
    else
    {
      if ( giUARadius )
        v16 = Random(-giUARadius, giUARadius);
      else
        v16 = 0;
      playerIdxl = v16 + giUABaseX;
      if ( giUARadius )
        v15 = Random(-giUARadius, giUARadius);
      else
        v15 = 0;
      numPlayersc = v15 + giUABaseY;
    }
    v9 = Random(1, 30);
    v10 = Random(1, 20) + v9;
    v54 = Random(1, 20) + v10;
    ++v50;
  }
  this->field_6395 = playerIdxl;
  this->field_6396 = numPlayersc;
  this->field_6397 = Random(0, 7);
  if ( gbInCampaign && (!this->field_2 && this->field_4 == 7 || this->field_2 == 1 && this->field_4 == 8) )
    this->field_6397 = 6;
  for ( playerIdxm = 0; this->numPlayers > playerIdxm; ++playerIdxm )
  {
    if ( gbHumanPlayer[playerIdxm] )
    {
      this->players[playerIdxm].personality = 3;
      memcpy(this->players[playerIdxm].resources, (char *)&unk_4F1E00 + 28 * this->difficulty, 0x1Cu);
      if ( this->playerHandicap[playerIdxm] )
      {
        for ( numPlayersd = 0; numPlayersd < 7; ++numPlayersd )
        {
          if ( this->playerHandicap[playerIdxm] == 1 )
            v14 = 0.85;
          else
            v14 = 0.7;
          this->players[playerIdxm].resources[numPlayersd] = (signed __int64)((double)this->players[playerIdxm].resources[numPlayersd]
                                                                            * v14);
        }
      }
    }
    else
    {
      this->players[playerIdxm].personality = Random(0, 2);
      memcpy(this->players[playerIdxm].resources, (char *)&unk_4F1E90 + 28 * this->difficulty, 0x1Cu);
    }
  }
  game::SetupAdjacentMons(this);
  if ( this->mapHeader.field_22 == 2 )
  {
    v11 = *(_WORD *)&this->mapHeader.field_23;
    v48 = LOWORD(this->mapHeader.field_2E);
    *(_WORD *)&this->mapHeader.field_23 = 0;
    if ( *(&this->map.tiles[v11].objType + 12 * v48 * this->map.width) == 170 )
    {
      *(_WORD *)&this->mapHeader.field_23 = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[v11].field_4_1_1_isShadow_1_13_extraInfo
                                                                                + 6 * v48 * this->map.width) >> 8) >> -5);
    }
    else if ( *(&this->map.tiles[v11].objType + 12 * (v48 - 1) * this->map.width) == 170 )
    {
      *(_WORD *)&this->mapHeader.field_23 = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[v11].field_4_1_1_isShadow_1_13_extraInfo
                                                                                + 6 * (v48 - 1) * this->map.width) >> 8) >> -5);
    }
    else
    {
      this->mapHeader.field_22 = 0;
    }
  }
  if ( this->mapHeader.winConditionType == 2 )
  {
    v12 = this->mapHeader.winConditionArgument;
    v49 = this->mapHeader.field_2C;
    this->mapHeader.winConditionArgument = 0;
    if ( *(&this->map.tiles[v12].objType + 12 * v49 * this->map.width) == 170 )
    {
      this->mapHeader.winConditionArgument = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[v12].field_4_1_1_isShadow_1_13_extraInfo
                                                                                 + 6 * v49 * this->map.width) >> 8) >> -5);
    }
    else if ( *(&this->map.tiles[v12].objType + 12 * (v49 - 1) * this->map.width) == 170 )
    {
      this->mapHeader.winConditionArgument = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[v12].field_4_1_1_isShadow_1_13_extraInfo
                                                                                 + 6 * (v49 - 1) * this->map.width) >> 8) >> -5);
    }
    else
    {
      this->mapHeader.winConditionType = 0;
    }
  }
  for ( playerIdxn = 0; this->numPlayers > playerIdxn; ++playerIdxn )
  {
    v17 = 0;
    if ( this->field_459[gcColorToSetupPos[this->players[playerIdxn].color]] < 0
      || this->field_459[gcColorToSetupPos[this->players[playerIdxn].color]] >= 6 )
    {
      if ( this->players[playerIdxn].numCastles )
      {
        v17 = gpGame->castles[this->players[playerIdxn].castlesOwned[0]].factionID;
      }
      else if ( this->players[playerIdxn].numHeroes )
      {
        v17 = gpGame->heroes[this->players[playerIdxn].heroesOwned[0]].factionID;
      }
    }
    else
    {
      v17 = this->field_459[gcColorToSetupPos[this->players[playerIdxn].color]];
    }
    this->players[playerIdxn]._4_1 = v17 == 1 || v17 == 3 || v17 == 5;
    if ( gbInCampaign && !playerIdxn )
      this->players[0]._4_1 = this->field_2 == 1;
    for ( numPlayerse = 0; gpGame->players[playerIdxn].numCastles > numPlayerse; ++numPlayerse )
      town::GiveSpells(&gpGame->castles[gpGame->players[playerIdxn].castlesOwned[numPlayerse]], 0);
    gpGame->players[playerIdxn]._2 = gpGame->players[playerIdxn].numHeroes;
  }
  philAI::GetGameAIVars(gpPhilAI);
  gbInNewGameSetup = 0;
  game::SetupNewRumour(this);
  advManager::CheckSetEvilInterface(gpAdvManager, 0, -1);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 522F90: using guessed type __int16 giUARadius;
// 522FB4: using guessed type __int16 giUABaseX;
// 522FB8: using guessed type __int16 giUABaseY;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523EDC: using guessed type int giCurWatchPlayer;
// 523F1C: using guessed type int gbInNewGameSetup;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (0041E350) --------------------------------------------------------
int __thiscall game::RandomizeEvents(game *this)
{
  unsigned __int16 v1; // ax@7
  unsigned __int16 v2; // ax@35
  __int16 v3; // ST100_2@36
  __int16 v4; // STFC_2@41
  __int16 v5; // STF8_2@42
  __int16 v6; // STF0_2@44
  unsigned __int16 v7; // ax@45
  unsigned __int16 v8; // ax@46
  unsigned __int16 v9; // ax@47
  unsigned __int16 v10; // ax@48
  unsigned __int16 v11; // ax@55
  __int16 v12; // STE8_2@56
  unsigned __int16 v13; // ax@59
  unsigned __int16 v14; // ax@61
  unsigned __int16 v15; // ax@63
  __int16 v16; // STE4_2@64
  __int16 v17; // STD4_2@69
  __int16 v18; // STD0_2@71
  __int16 v19; // STCC_2@72
  unsigned __int16 v20; // ax@74
  unsigned __int16 v21; // ax@75
  unsigned __int16 v22; // ax@76
  unsigned __int16 v23; // ax@77
  unsigned __int16 v24; // ax@85
  unsigned __int16 v25; // ax@86
  unsigned __int16 v26; // ax@88
  unsigned __int16 v27; // ax@89
  __int16 v28; // STB0_2@93
  unsigned __int16 v29; // ax@143
  unsigned __int16 v30; // ax@145
  unsigned __int16 v31; // ax@146
  unsigned __int16 v32; // ax@150
  unsigned __int16 v33; // ax@156
  mapCell *v34; // ST40_4@167
  mapCell *v35; // ST3C_4@176
  mapCell *v36; // ST34_4@187
  int result; // eax@216
  int v38; // [sp+Ch] [bp-1D8h]@101
  mapCell *v40; // [sp+100h] [bp-E4h]@249
  int v41[5]; // [sp+104h] [bp-E0h]@236
  int v42[5]; // [sp+118h] [bp-CCh]@236
  int v43[5]; // [sp+12Ch] [bp-B8h]@250
  int v44; // [sp+140h] [bp-A4h]@227
  int v45; // [sp+144h] [bp-A0h]@227
  int v46[5]; // [sp+148h] [bp-9Ch]@250
  mapCell *v47; // [sp+15Ch] [bp-88h]@171
  int v48[10]; // [sp+160h] [bp-84h]@156
  town *v49; // [sp+188h] [bp-5Ch]@170
  void *v50; // [sp+18Ch] [bp-58h]@18
  void *v51; // [sp+190h] [bp-54h]@13
  int v52; // [sp+194h] [bp-50h]@162
  int v53; // [sp+198h] [bp-4Ch]@1
  int nWithDoctorHut; // [sp+19Ch] [bp-48h]@1
  int v55; // [sp+1A0h] [bp-44h]@1
  int nXanadu; // [sp+1A4h] [bp-40h]@1
  int i; // [sp+1A8h] [bp-3Ch]@162
  int v58; // [sp+1ACh] [bp-38h]@1
  int m; // [sp+1B0h] [bp-34h]@265
  mapCell *cell; // [sp+1B4h] [bp-30h]@6
  int y; // [sp+1B8h] [bp-2Ch]@1
  int l; // [sp+1BCh] [bp-28h]@38
  int j; // [sp+1C0h] [bp-24h]@164
  mapCellExtra *extra; // [sp+1C4h] [bp-20h]@207
  int x; // [sp+1C8h] [bp-1Ch]@3
  int artId; // [sp+1CCh] [bp-18h]@140
  int v67; // [sp+1D0h] [bp-14h]@1
  int v68; // [sp+1D4h] [bp-10h]@205
  int k; // [sp+1D8h] [bp-Ch]@205
  int nObelisk; // [sp+1DCh] [bp-8h]@1
  int v71; // [sp+1E0h] [bp-4h]@1

  nObelisk = 1;
  v53 = 1;
  v58 = 1;
  nWithDoctorHut = 1;
  v55 = 1;
  v71 = 1;
  v67 = 1;
  nXanadu = 1;
  this->numMapEvents = 0;
  memset(this->mapEventIndices, 0, 0x64u);
  for ( y = 0; y < MAP_HEIGHT; ++y )
  {
    for ( x = 0; MAP_WIDTH > x; ++x )
    {
      cell = &this->map.tiles[y * this->map.width] + x;
      switch ( cell->objType )
      {
        case TILE_HAS_EVENT|LOCATION_WITCH_HUT:
          v1 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          LOBYTE(v1) = v1 | 0x60;
          for ( cell->field_4_1_1_isShadow_1_13_extraInfo = v1;
                (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 12
             || (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 6;
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(0, 13) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_BOAT:
          cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 3u;
          cell->objectIndex = -1;
          cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          cell->objType = 0;
          game::CreateBoat(this, x, y, 1);
          break;
        case TILE_HAS_EVENT|LOCATION_SPHINX:
          v51 = ppMapExtra[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
          *(_BYTE *)v51 = strlen((char *)v51 + 136) > 1 && (signed int)*((_BYTE *)v51 + 31) >= 1;
          break;
        case TILE_HAS_EVENT|LOCATION_EVENT:
          this->mapEventIndices[this->numMapEvents] = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          v50 = ppMapExtra[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
          *((_WORD *)v50 + 19) = x;
          *((_WORD *)v50 + 20) = y;
          *((_BYTE *)v50 + 37) = 1;
          cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          cell->objType = 0;
          cell->objectIndex = -1;
          cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 3u;
          ++this->numMapEvents;
          break;
        case TILE_HAS_EVENT|LOCATION_GAZEBO:
          cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * v53++ | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          break;
        case TILE_HAS_EVENT|LOCATION_FORT:
          cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * v58++ | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          break;
        case TILE_HAS_EVENT|LOCATION_WITCH_DOCTORS_HUT:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * nWithDoctorHut++;
          break;
        case TILE_HAS_EVENT|LOCATION_MERCENARY_CAMP:
          cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * v55++ | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          break;
        case TILE_HAS_EVENT|LOCATION_STANDING_STONES:
          if ( x <= 0 || *(&this->map.tiles[y * this->map.width].objType + 4 * (3 * x - 3)) != 194 )
            cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * v71++ | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          else
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (*(&this->map.tiles[y * this->map.width].field_4_1_1_isShadow_1_13_extraInfo + 2 * (3 * x - 3)) >> 3);
          break;
        case TILE_HAS_EVENT|LOCATION_XANADU:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * nXanadu++;
          break;
        case LOCATION_WHIRLPOOL:
          cell->objType |= 0x80u;
          break;
        case TILE_HAS_EVENT|LOCATION_OBELISK:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * nObelisk++;
          break;
        case TILE_HAS_EVENT|LOCATION_FLOTSAM:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(0, 3);
          break;
        case TILE_HAS_EVENT|LOCATION_SKELETON:
          if ( game::HasObjectTilesetIndex(this, x, y, 55, 84) )
          {
            if ( Random(0, 9) <= 2 )
            {
              v3 = game::GetRandomArtifactId(this, 14, 1);
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v3 + 2);
            }
            else
            {
              v2 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v2) = v2 | 8;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v2;
            }
          }
          else
          {
            cell->objType &= 0x7Fu;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_WAGON:
          l = Random(0, 100);
          if ( l >= 40 )
          {
            if ( l >= 50 )
            {
              v5 = Random(0, 5);
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v5 + 16 * Random(2, 5) + 1);
            }
            else
            {
              v4 = game::GetRandomArtifactId(this, 12, 1);
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v4 | 0x80);
            }
          }
          else
          {
            cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_LEAN_TO:
          v6 = Random(0, 5);
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v6 + 16 * Random(1, 4) + 1);
          break;
        case TILE_HAS_EVENT|LOCATION_DAEMON_CAVE:
          switch ( Random(0, 99) % 10 )
          {
            case 0:
            case 1:
            case 2:
              v7 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v7) = v7 | 0x10;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v7;
              break;
            case 3:
              v8 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v8) = v8 | 0x18;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v8;
              break;
            case 4:
            case 5:
            case 6:
              v9 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v9) = v9 | 0x20;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v9;
              break;
            case 7:
            case 8:
            case 9:
              v10 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v10) = v10 | 0x28;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v10;
              break;
            default:
              continue;
          }
          continue;
        case TILE_HAS_EVENT|LOCATION_TREASURE_CHEST:
          if ( giGroundToTerrain[cell->groundIndex] )
          {
            l = Random(0, 100);
            if ( l >= 32 )
            {
              if ( l >= 64 )
              {
                if ( l >= 95 )
                {
                  v16 = game::GetRandomArtifactId(this, 8, 1);
                  cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v16 | 0x100);
                }
                else
                {
                  v15 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
                  LOBYTE(v15) = v15 | 0x20;
                  cell->field_4_1_1_isShadow_1_13_extraInfo = v15;
                }
              }
              else
              {
                v14 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
                LOBYTE(v14) = v14 | 0x18;
                cell->field_4_1_1_isShadow_1_13_extraInfo = v14;
              }
            }
            else
            {
              v13 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v13) = v13 | 0x10;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v13;
            }
          }
          else
          {
            cell->objType = -95;
            l = Random(0, 100);
            if ( l >= 20 )
            {
              if ( l >= 90 )
              {
                v12 = game::GetRandomArtifactId(this, 8, 1);
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v12 | 0x100);
              }
              else
              {
                v11 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
                LOBYTE(v11) = v11 | 8;
                cell->field_4_1_1_isShadow_1_13_extraInfo = v11;
              }
            }
            else
            {
              cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
            }
          }
          break;
        case TILE_HAS_EVENT|LOCATION_CAMPFIRE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | ((unsigned __int16)Random(4, 6) << 7);
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 5) | (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
          break;
        case TILE_HAS_EVENT|LOCATION_ANCIENT_LAMP:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 2) + 2);
          break;
        case TILE_HAS_EVENT|LOCATION_SHIPWRECK_SURVIVOR:
          l = Random(0, 100);
          if ( l >= 60 )
          {
            if ( l >= 80 )
            {
              v19 = game::GetRandomArtifactId(this, 2, 1);
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v19;
            }
            else
            {
              v18 = game::GetRandomArtifactId(this, 4, 1);
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v18;
            }
          }
          else
          {
            v17 = game::GetRandomArtifactId(this, 8, 1);
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v17;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_GRAVEYARD:
        case TILE_HAS_EVENT|LOCATION_SHIPWRECK:
        case TILE_HAS_EVENT|LOCATION_DERELICT_SHIP:
          switch ( Random(0, 99) % 10 )
          {
            case 0:
            case 1:
            case 2:
              v20 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v20) = v20 | 0x10;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v20;
              break;
            case 3:
            case 4:
            case 5:
              v21 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v21) = v21 | 0x18;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v21;
              break;
            case 6:
            case 7:
            case 8:
              v22 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v22) = v22 | 0x20;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v22;
              break;
            case 9:
              v23 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v23) = v23 | 0x28;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v23;
              break;
            default:
              continue;
          }
          continue;
        case TILE_HAS_EVENT|LOCATION_ARCHERS_HOUSE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(10, 25);
          break;
        case TILE_HAS_EVENT|LOCATION_GOBLIN_HUT:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(15, 40);
          break;
        case TILE_HAS_EVENT|LOCATION_DWARF_COTTAGE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 20) + 1);
          break;
        case TILE_HAS_EVENT|LOCATION_PEASANT_HUT:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 40) + 1);
          break;
        case TILE_HAS_EVENT|LOCATION_LOG_CABIN:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(20, 50);
          break;
        case TILE_HAS_EVENT|LOCATION_WATERWHEEL:
          v24 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          LOBYTE(v24) = v24 | 8;
          cell->field_4_1_1_isShadow_1_13_extraInfo = v24;
          break;
        case TILE_HAS_EVENT|LOCATION_ARTESIAN_SPRING:
          v25 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
          LOBYTE(v25) = v25 | 8;
          cell->field_4_1_1_isShadow_1_13_extraInfo = v25;
          break;
        case TILE_HAS_EVENT|LOCATION_MAGIC_GARDEN:
          if ( Random(0, 1) )
          {
            v26 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v26) = v26 | 0x38;
            cell->field_4_1_1_isShadow_1_13_extraInfo = v26;
          }
          else
          {
            v27 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v27) = v27 | 0x30;
            cell->field_4_1_1_isShadow_1_13_extraInfo = v27;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_TREE_OF_KNOWLEDGE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (v67++ | (unsigned __int16)((unsigned __int16)Random(1, 3) << 6));
          break;
        case TILE_HAS_EVENT|LOCATION_ARMY_CAMP:
          if ( !((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
          {
            v28 = game::GetRandomNumTroops(this, cell->objectIndex);
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v28;
            if ( cell->objectIndex != CREATURE_GHOST )
            {
              if ( cell->objectIndex != CREATURE_EARTH_ELEMENTAL
                && cell->objectIndex != CREATURE_AIR_ELEMENTAL
                && cell->objectIndex != CREATURE_FIRE_ELEMENTAL
                && cell->objectIndex != CREATURE_WATER_ELEMENTAL
                && Random(0, 100) < 20 )
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) | 0x1000);
            }
          }
          break;
        case TILE_HAS_EVENT|LOCATION_RESOURCE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (cell->objectIndex >> 1);
          v38 = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 && v38 != 2 )
          {
            if ( v38 == 6 )
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(5, 10);
            else
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(3, 6);
          }
          else
          {
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(5, 10);
          }
          break;
        case TILE_HAS_EVENT|LOCATION_SHRINE_FIRST:
          for ( cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1);
                gsSpellInfo[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                          - 1].level != 1;
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_SHRINE_SECOND_ORDER:
          for ( cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1);
                gsSpellInfo[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                          - 1].level != 2;
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_SHRINE_THIRD_ORDER:
          for ( cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1);
                gsSpellInfo[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                          - 1].level != 3;
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_PYRAMID:
          for ( cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1);
                gsSpellInfo[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                          - 1].level != 5;
                cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(0, 64) + 1) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_TREE_HOUSE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(15, 25);
          break;
        case TILE_HAS_EVENT|LOCATION_DWARF_CABIN:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(10, 20);
          break;
        case TILE_HAS_EVENT|LOCATION_WATCH_TOWER:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(7, 10);
          break;
        case TILE_HAS_EVENT|LOCATION_RUINS:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(3, 5);
          break;
        case TILE_HAS_EVENT|LOCATION_TREE_CITY:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(20, 40);
          break;
        case TILE_HAS_EVENT|LOCATION_HALFLING_HOLE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(20, 40);
          break;
        case TILE_HAS_EVENT|LOCATION_TROLL_BRIDGE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(4, 6) | 0x100);
          break;
        case TILE_HAS_EVENT|LOCATION_CITY_OF_DEAD:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (Random(4, 6) | 0x100);
          break;
        case TILE_HAS_EVENT|LOCATION_DRAGON_CITY:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 0x810;
          break;
        case TILE_HAS_EVENT|LOCATION_CAVE:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(10, 20);
          break;
        case TILE_HAS_EVENT|LOCATION_EXCAVATION:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(10, 25);
          break;
        case TILE_HAS_EVENT|LOCATION_DESRT_TENT:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(10, 20);
          break;
        case TILE_HAS_EVENT|LOCATION_WAGON_CAMP:
          if ( game::HasObjectTilesetIndex(this, x, y, 41, 129) )
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(30, 50);
          else
            cell->objType &= 0x7Fu;
          break;
        case TILE_HAS_EVENT|LOCATION_ARTIFACT:
          l = Random(0, 99);
          artId = cell->objectIndex >> 1;
          if ( artId != ARTIFACT_SPELL_SCROLL )
          {
            if ( l >= 60 )
            {
              if ( l >= 80 )
              {
                v48[0] = 9;
                v48[1] = 10;
                v48[2] = 19;
                v48[3] = 60;
                v48[4] = 35;
                v48[5] = 36;
                v48[6] = 37;
                v48[7] = 56;
                v48[8] = 45;
                v48[9] = 46;
                LOBYTE(v33) = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
                HIBYTE(v33) = 8;
                cell->field_4_1_1_isShadow_1_13_extraInfo = v33;
                if ( gArtifactLevel[artId] == 8 )
                {
                  cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) | 0x39);
                }
                else if ( gArtifactLevel[artId] == 4 )
                {
                  cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (LOWORD(v48[Random(0, 3)]) | (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
                }
                else
                {
                  cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (LOWORD(v48[Random(0, 5) + 4]) | (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
                }
              }
              else
              {
                switch ( gArtifactLevel[artId] )
                {
                  case 8:
                    v32 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
                    LOBYTE(v32) = v32 | 0x18;
                    cell->field_4_1_1_isShadow_1_13_extraInfo = v32;
                    break;
                  case 4:
                    cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int16)(16 * Random(0, 5)) | 6);
                    break;
                  case 2:
                    cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int16)(16 * Random(0, 5)) | 7);
                    break;
                }
              }
            }
            else if ( l % 10 == 1 )
            {
              v29 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v29) = v29 | 0x20;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v29;
            }
            else if ( l % 10 == 2 )
            {
              v30 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v30) = v30 | 0x28;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v30;
            }
            else
            {
              v31 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v31) = v31 | 8;
              cell->field_4_1_1_isShadow_1_13_extraInfo = v31;
            }
          }
          break;
        case TILE_HAS_EVENT|LOCATION_TOWN:
          v52 = game::GetTownId(this, x, y);
          for ( i = y - 3; y + 1 >= i; ++i )
          {
            for ( j = x - 2; x + 2 >= j; ++j )
            {
              if ( !((unsigned __int8)(*(&this->map.tiles[j].field_4_1_1_isShadow_1_13_extraInfo
                                       + 6 * i * this->map.width) >> 8) >> -5) )
              {
                v34 = &this->map.tiles[i * this->map.width] + j;
                v34->field_4_1_1_isShadow_1_13_extraInfo = v34->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v52;
              }
            }
          }
          v49 = &this->castles[v52];
          this->castles[v52].field_7 = -1;
          v49->buildDockRelated = v49->field_7;
          if ( MAP_HEIGHT - 3 >= y )
          {
            v47 = advManager::GetCell(gpAdvManager, x - 1, y + 2);
            if ( giGroundToTerrain[v47->groundIndex] )
            {
              v47 = advManager::GetCell(gpAdvManager, x + 1, y + 2);
              if ( !giGroundToTerrain[v47->groundIndex] )
              {
                v49->buildDockRelated = x + 1;
                v49->field_7 = y + 2;
              }
            }
            else
            {
              v49->buildDockRelated = x - 1;
              v49->field_7 = y + 2;
            }
          }
          break;
        case TILE_HAS_EVENT|LOCATION_LIGHTHOUSE:
          v35 = &this->map.tiles[y * this->map.width] + x;
          v35->field_4_1_1_isShadow_1_13_extraInfo = v35->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * game::GetMineId(this, x, y);
          break;
        case TILE_HAS_EVENT|LOCATION_ABANDONED_MINE:
          v52 = game::GetMineId(this, x, y);
          this->mines[v52].guardianType = 59;
          this->mines[v52].guadianQty = Random(30, 60);
          goto LABEL_178;
        case TILE_HAS_EVENT|LOCATION_ALCHEMIST_LAB:
        case TILE_HAS_EVENT|LOCATION_MINE:
        case TILE_HAS_EVENT|LOCATION_SAWMILL:
LABEL_178:
          v52 = game::GetMineId(this, x, y);
          for ( i = y - 1; y >= i; ++i )
          {
            for ( j = x - 2; x + 1 >= j; ++j )
            {
              if ( (x - 2 != j || cell->objType == 129)
                && (!((unsigned __int8)(*(&this->map.tiles[j].field_4_1_1_isShadow_1_13_extraInfo
                                        + 6 * i * this->map.width) >> 8) >> -5)
                 || !((cell->objType & 0x7F ^ *(&this->map.tiles[j].objType + 12 * i * this->map.width)) & 0x7F)) )
              {
                v36 = &this->map.tiles[i * this->map.width] + j;
                v36->field_4_1_1_isShadow_1_13_extraInfo = v36->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * v52;
              }
            }
          }
          break;
        case TILE_HAS_EVENT|LOCATION_WINDMILL:
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(1, 5);
          break;
        case TILE_HAS_EVENT|LOCATION_BARRIER:
          game::RandomizeBarrier(this, cell);
          break;
        case TILE_HAS_EVENT|LOCATION_TRAVELLER_TENT:
          game::RandomizePassword();
          break;
        case TILE_HAS_EVENT|LOCATION_ALCHEMIST_TOWER:
          game::WeeklyGenericSite(cell);
          break;
        case TILE_HAS_EVENT|LOCATION_EXPANSION_DWELLING:
          game::WeeklyRecruitSite((int)cell);
          break;
        default:
          continue;
      }
    }
  }
  for ( y = 0; y < MAP_HEIGHT; ++y )
  {
    for ( x = 0; MAP_WIDTH > x; ++x )
    {
      cell = &this->map.tiles[y * this->map.width] + x;
      if ( cell->objectIndex != 255 && (cell->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1 )
      {
        v68 = 1;
        for ( k = cell->extraIdx; k; k = extra->nextIdx )
        {
          extra = (mapCellExtra *)((char *)this->map.cellExtras + 8 * k - k);
          if ( extra->objectIndex != 255 && !(((unsigned __int8)extra->field_4_1_1_1_isShadow_5 >> 1) & 1) )
            v68 = 0;
        }
        if ( v68 )
          cell->displayFlags |= 0x80u;
      }
    }
  }
  for ( y = 0; ; ++y )
  {
    result = MAP_HEIGHT;
    if ( y >= MAP_HEIGHT )
      break;
    for ( x = 0; MAP_WIDTH > x; ++x )
    {
      cell = &this->map.tiles[y * this->map.width] + x;
      if ( (cell->objType & 0x7F) == LOCATION_ROCK
        && (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 62 )
        cell->displayFlags |= 8u;
      if ( cell->objectIndex != 255
        && !(cell->objType & 0x80)
        && !(cell->displayFlags & 0x80)
        && cell->overlayIndex != 255 )
        cell->displayFlags |= 8u;
      v45 = 0;
      v44 = 0;
      if ( !(cell->displayFlags & 8)
        && MAP_HEIGHT - 1 > y
        && cell->objectIndex != 255
        && !(cell->objType & 0x80)
        && !(cell->displayFlags & 0x80)
        && *(&this->map.tiles[x].objectIndex + 12 * (y + 1) * this->map.width) != 255
        && !(*(&this->map.tiles[x].objType + 12 * (y + 1) * this->map.width) & 0x80)
        && !(*(&this->map.tiles[x].displayFlags + 12 * (y + 1) * this->map.width) & 0x80) )
      {
        if ( !((cell->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1) )
        {
          v41[v45] = ((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F;
          v42[v45++] = cell->objectIndex;
        }
        if ( cell->extraIdx )
          extra = &this->map.cellExtras[cell->extraIdx];
        else
          extra = 0;
        while ( v45 < 5 && extra )
        {
          if ( extra->objectIndex != 255 && !(((unsigned __int8)extra->field_4_1_1_1_isShadow_5 >> 1) & 1) )
          {
            v41[v45] = (extra->_1_q_7_objTileset >> 1) & 0x7F;
            v42[v45++] = extra->objectIndex;
          }
          if ( extra->nextIdx )
            extra = &this->map.cellExtras[extra->nextIdx];
          else
            extra = 0;
        }
        v40 = &this->map.tiles[(y + 1) * this->map.width] + x;
        if ( !((v40->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1) )
        {
          v46[v44] = ((unsigned __int8)v40->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F;
          v43[v44++] = v40->objectIndex;
        }
        if ( v40->extraIdx )
          extra = &this->map.cellExtras[v40->extraIdx];
        else
          extra = 0;
        while ( v44 < 5 && extra )
        {
          if ( extra->objectIndex != 255 && !(((unsigned __int8)extra->field_4_1_1_1_isShadow_5 >> 1) & 1) )
          {
            v46[v44] = (extra->_1_q_7_objTileset >> 1) & 0x7F;
            v43[v44++] = extra->objectIndex;
          }
          if ( extra->nextIdx )
            extra = &this->map.cellExtras[extra->nextIdx];
          else
            extra = 0;
        }
        for ( l = 0; v45 > l; ++l )
        {
          for ( m = 0; v44 > m; ++m )
          {
            if ( v46[m] == v41[l] || v41[l] >= 35 && v41[l] <= 38 && v46[m] >= 35 && v46[m] <= 38 )
              cell->displayFlags |= 8u;
          }
        }
      }
      if ( MAP_HEIGHT - 1 > y
        && (*(&this->map.tiles[x].objType + 12 * (y + 1) * this->map.width) == 163
         || *(&this->map.tiles[x].objType + 12 * (y + 1) * this->map.width) == 176
         || *(&this->map.tiles[x].objType + 12 * (y + 1) * this->map.width) == 177) )
        cell->displayFlags |= 8u;
      if ( cell->objectIndex != 255
        && !(cell->objType & 0x80)
        && !(cell->displayFlags & 0x80)
        && (MAP_HEIGHT - 1 == y || *(&this->map.tiles[x].displayFlags + 12 * (y + 1) * this->map.width) & 4) )
        cell->displayFlags |= 8u;
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 41E350: using guessed type int var_E0[5];
// 41E350: using guessed type int var_CC[5];
// 41E350: using guessed type int var_9C[5];
// 41E350: using guessed type int var_B8[5];

//----- (00420960) --------------------------------------------------------
void __cdecl game::InitializePasswords()
{
  signed int j; // [sp+10h] [bp-Ch]@5
  signed int i; // [sp+14h] [bp-8h]@1
  char v2; // [sp+18h] [bp-4h]@3

  for ( i = 0; i < 8; ++i )
  {
    v2 = 0;
    while ( !v2 )
    {
      xPasswordStringsIndex[i] = Random(0, 210);
      v2 = 1;
      for ( j = 0; j < i; ++j )
      {
        if ( xPasswordStringsIndex[j] == xPasswordStringsIndex[i] )
          v2 = 0;
      }
    }
  }
}

//----- (00420A10) --------------------------------------------------------
void __thiscall game::RandomizeBarrier(game *this, mapCell *cell)
{
  int v2; // ST10_4@1

  v2 = ((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 7;
  cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                            * (v2 | (unsigned __int16)(8 * xPasswordStringsIndex[v2]));
}

//----- (00420A80) --------------------------------------------------------
unsigned int __cdecl game::RandomizePassword()
{
  game *v0; // ecx@0
  unsigned int result; // eax@1
  mapCell *cell; // [sp+18h] [bp+8h]@0

  game::RandomizeBarrier(v0, cell);
  return result;
}
// 420A80: inconsistent function type and number of purged bytes

//----- (00420AB0) --------------------------------------------------------
int __thiscall game::LoadMap(game *ecx0, char *nam)
{
  char buf; // [sp+10h] [bp-20h]@22
  int fd; // [sp+18h] [bp-18h]@1
  char y; // [sp+1Ch] [bp-14h]@5
  int i; // [sp+20h] [bp-10h]@3
  char x; // [sp+24h] [bp-Ch]@5
  char alignmentAndCastle; // [sp+28h] [bp-8h]@5

  sprintf(gText, "%s%s", ".\\MAPS\\", nam);
  fd = open(gText, O_BINARY);
  if ( fd == -1 )
    FileError(gText);
  _read(fd, &ecx0->mapHeader, 0x1A4u);
  fullMap::Read(&ecx0->map, fd, 1);
  game::SetMapSize(ecx0, ecx0->map.width, ecx0->map.height);
  for ( i = 0; i < MAX_CASTLES; ++i )
  {
    _read(fd, &x, 1u);
    _read(fd, &y, 1u);
    _read(fd, &alignmentAndCastle, 1u);
    if ( (unsigned __int8)x != 255 )
    {
      ecx0->castles[i].exists = 1;
      ecx0->castles[i].x = x;
      ecx0->castles[i].y = y;
      ecx0->castles[i].factionID = alignmentAndCastle & 0x7F;
      if ( alignmentAndCastle >= 0 )
        ecx0->castles[i].buildingsBuiltFlags |= BUILDING_SPECIAL_DEFENSE_BUILT;
      else
        ecx0->castles[i].buildingsBuiltFlags |= 0x40u;
    }
  }
  for ( i = 0; i < 144; ++i )
  {
    if ( ecx0->mapHeader.field_0 != 90 || i < 72 )
    {
      _read(fd, &x, 1u);
      _read(fd, &y, 1u);
      _read(fd, &alignmentAndCastle, 1u);
    }
    else
    {
      x = -1;
      y = -1;
      alignmentAndCastle = -1;
    }
    if ( (unsigned __int8)x != 255 )
    {
      ecx0->mines[i].guardianType = -1;
      ecx0->mines[i].x = x;
      ecx0->mines[i].y = y;
      ecx0->mines[i].type = alignmentAndCastle;
    }
  }
  ecx0->mapHeader.field_0 = 92;
  _read(fd, &ecx0->numObelisks, 1u);
  _read(fd, ecx0->rumorIndices, 2 * ecx0->mapHeader.numRumors);
  ecx0->numRumors = ecx0->mapHeader.numRumors;
  _read(fd, ecx0->eventIndices, 2 * ecx0->mapHeader.numEvents);
  ecx0->numEvents = ecx0->mapHeader.numEvents;
  _read(fd, &iMaxMapExtra, 4u);
  ppMapExtra = (void **)BaseAlloc(4 * iMaxMapExtra, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF3C0 + 89);
  pwSizeOfMapExtra = (__int16 *)BaseAlloc(2 * iMaxMapExtra, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF3C0 + 90);
  memset(ppMapExtra, 0, 4 * iMaxMapExtra);
  memset(pwSizeOfMapExtra, 0, 2 * iMaxMapExtra);
  for ( i = 1; i < iMaxMapExtra; ++i )
  {
    _read(fd, &pwSizeOfMapExtra[i], 2u);
    ppMapExtra[i] = BaseAlloc(pwSizeOfMapExtra[i], "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF3C0 + 98);
    _read(fd, ppMapExtra[i], pwSizeOfMapExtra[i]);
  }
  _read(fd, &buf, 2u);
  _close(fd);
  return 0;
}
// 4EF3C0: using guessed type __int16 word_4EF3C0;

//----- (00420F30) --------------------------------------------------------
void __thiscall game::ClaimTown(game *this, int castleIdx, int playerIdx, int a4)
{
  signed int i; // [sp+14h] [bp-8h]@6
  town *castle; // [sp+18h] [bp-4h]@3

  if ( !gbInNewGameSetup )
    SendMapChange(7, castleIdx, 0, 0, playerIdx, 0, 0);
  castle = &this->castles[castleIdx];
  if ( this->castles[castleIdx].ownerIdx != playerIdx )
  {
    this->castles[castleIdx].field_38 = 0;
    if ( this->field_2773[castleIdx] != -1 )
      town::Deallocate(&gpGame->castles[castleIdx]);
    for ( i = 0; i < 5; ++i )
    {
      castle->garrison.creatureTypes[i] = -1;
      castle->garrison.quantities[i] = 0;
    }
    if ( this->castles[castleIdx].ownerIdx == -1 )
      this->castles[castleIdx].field_55 = 2;
    else
      this->castles[castleIdx].field_55 = 0;
    this->castles[castleIdx].ownerIdx = playerIdx;
    this->field_2773[castleIdx] = playerIdx;
    *(&this->players[0].castlesOwned[284 * playerIdx] + this->players[playerIdx].numCastles++ - playerIdx) = castleIdx;
    fullMap::ChangeTilesetIndex(
      &this->map,
      (mapCell *)((char *)&this->map.tiles[this->map.width * this->castles[castleIdx].y]
                + 4 * (3 * this->castles[castleIdx].x - 3)),
      this->castles[castleIdx].x - 1,
      this->castles[castleIdx].y,
      14,
      2 * this->players[(char)playerIdx].color,
      1,
      -1);
    fullMap::ChangeTilesetIndex(
      &this->map,
      (mapCell *)((char *)&this->map.tiles[this->map.width * this->castles[castleIdx].y]
                + 4 * (3 * this->castles[castleIdx].x + 3)),
      this->castles[castleIdx].x + 1,
      this->castles[castleIdx].y,
      14,
      2 * this->players[(char)playerIdx].color + 1,
      1,
      -1);
    if ( !a4 )
    {
      game::SetVisibility(this, this->castles[castleIdx].x, this->castles[castleIdx].y, playerIdx, byte_4F21F4);
      CheckEndGame(0, 0);
    }
  }
}
// 4F21F4: using guessed type char byte_4F21F4;
// 523F1C: using guessed type int gbInNewGameSetup;

//----- (004212E0) --------------------------------------------------------
void __thiscall game::ClaimMine(game *this, int idx, int color)
{
  signed int v4; // [sp+18h] [bp-10h]@2
  mapCell *cell; // [sp+1Ch] [bp-Ch]@15
  int y; // [sp+20h] [bp-8h]@9
  int x; // [sp+24h] [bp-4h]@9

  SendMapChange(8, idx, 0, 0, color, 0, 0);
  this->mines[idx].owner = color;
  this->field_60A6[idx] = color;
  switch ( this->mines[idx].type )
  {
    case 0x65:
      v4 = 35;
      break;
    case 0x64:
      v4 = 42;
      break;
    case RESOURCE_WOOD:
      v4 = 28;
      break;
    case RESOURCE_MERCURY:
      v4 = 21;
      break;
    default:
      v4 = 14;
      break;
  }
  switch ( this )
  {
    case 1u:
      x = this->mines[idx].x;
      y = this->mines[idx].y - 1;
      break;
    case 0u:
      x = this->mines[idx].x + 1;
      y = this->mines[idx].y - 1;
      break;
    case 0x65u:
      x = this->mines[idx].x - 1;
      y = this->mines[idx].y - 3;
      break;
    case 0x64u:
      x = this->mines[idx].x;
      y = this->mines[idx].y;
      break;
    default:
      x = this->mines[idx].x;
      y = this->mines[idx].y;
      break;
  }
  cell = &this->map.tiles[y * this->map.width] + x;
  if ( color == -1 )
  {
    fullMap::ChangeTilesetIndex(&this->map, cell, x, y, 14, 255, 1, -1);
  }
  else
  {
    fullMap::ChangeTilesetIndex(&this->map, cell, x, y, 14, v4 + this->players[(char)color].color, 1, -1);
    if ( this->mines[idx].type == RESOURCE_MERCURY )
    {
      game::ConvertFlagToLateOverlay(this, x, y);
    }
    else if ( y > 0
  && (this->mines[idx].type == RESOURCE_ORE
   || this->mines[idx].type == RESOURCE_GOLD
   || this->mines[idx].type == RESOURCE_GEMS
   || this->mines[idx].type == RESOURCE_SULFUR
   || this->mines[idx].type == RESOURCE_CRYSTAL) )
    {
      if ( game::HasLateOverlay(this, x, y - 1) )
        game::ConvertFlagToLateOverlay(this, x, y);
    }
  }
}

//----- (004217B0) --------------------------------------------------------
int __thiscall game::ViewSpells(game *this, hero *hris, int a3, int (__fastcall *callback)(struct tag_message *), int a5)
{
  game *thisa; // [sp+Ch] [bp-2Ch]@1
  heroWindow *window; // [sp+18h] [bp-20h]@6
  tag_message evt; // [sp+1Ch] [bp-1Ch]@12

  thisa = this;
  viewSpellsHero = hris;
  *(_DWORD *)&this->mapEventIndices[68] = -1;
  if ( hero::GetNumSpells(hris, a3) )
  {
    thisa->callback = (int (__thiscall *)(tag_message *))callback;
    thisa->field_660D = a5;
    *(_DWORD *)&thisa->mapEventIndices[56] = hris;
    if ( a3 == 2 )
      *(_DWORD *)&thisa->mapEventIndices[58] = 1;
    else
      *(_DWORD *)&thisa->mapEventIndices[58] = a3;
    *(_DWORD *)&thisa->mapEventIndices[60] = 0;
    *(_DWORD *)&thisa->mapEventIndices[64] = hero::GetNumSpells(hris, 0);
    *(_DWORD *)&thisa->mapEventIndices[62] = 0;
    *(_DWORD *)&thisa->mapEventIndices[66] = hero::GetNumSpells(hris, 1);
    window = (heroWindow *)operator new(68);
    if ( window )
      *(_DWORD *)&thisa->mapEventIndices[54] = heroWindow::heroWindow(window, 86, 87, "spellwin.bin");
    else
      *(_DWORD *)&thisa->mapEventIndices[54] = 0;
    if ( !*(_DWORD *)&thisa->mapEventIndices[54] )
      MemError();
    if ( a3 != 2 )
    {
      evt.eventCode = INPUT_GUI_MESSAGE_CODE;
      evt.xCoordOrKeycode = 6;
      if ( a3 )
        evt.yCoordOrFieldID = 5;
      else
        evt.yCoordOrFieldID = 4;
      evt.payload = (void *)6;
      heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[54], &evt);
    }
    game::UpdateSpellWidgets((int)thisa);
    heroWindowManager::DoDialog(
      gpWindowManager,
      *(heroWindow **)&thisa->mapEventIndices[54],
      (int (__fastcall *)(tag_message *))ViewSpellsHandler,
      0);
    operator delete(*(void **)&thisa->mapEventIndices[54]);
  }
  else
  {
    NormalDialog("No spells to cast.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return *(_DWORD *)&thisa->mapEventIndices[68];
}

//----- (004219A0) --------------------------------------------------------
int __thiscall game::UpdateSpellWidgets(int this)
{
  int result; // eax@9
  int v2; // eax@17
  int v3; // eax@18
  int v4; // [sp+Ch] [bp-30h]@1
  int spell; // [sp+10h] [bp-2Ch]@13
  int evt; // [sp+18h] [bp-24h]@1
  int v7; // [sp+1Ch] [bp-20h]@4
  int v8; // [sp+20h] [bp-1Ch]@6
  int v9; // [sp+30h] [bp-Ch]@6
  int i; // [sp+34h] [bp-8h]@9
  int v11; // [sp+38h] [bp-4h]@1

  v4 = this;
  evt = 512;
  v11 = **(_WORD **)(this + 26093);
  if ( v11 > 999 )
    v11 = 999;
  memset(&evt, 0, 0x1Cu);
  evt = 512;
  if ( v11 <= 99 )
    v7 = 6;
  else
    v7 = 5;
  v8 = 7;
  v9 = 6;
  heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
  evt = 512;
  if ( v11 <= 9 )
    v7 = 6;
  else
    v7 = 5;
  v8 = 8;
  v9 = 6;
  heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
  sprintf(gText, "%d", v11 / 100 % 10);
  evt = 512;
  v7 = 3;
  v8 = 7;
  v9 = (int)gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
  sprintf(gText, "%d", v11 / 10 % 10);
  evt = 512;
  v7 = 3;
  v8 = 8;
  v9 = (int)gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
  sprintf(gText, "%d", v11 % 10);
  evt = 512;
  v7 = 3;
  v8 = 9;
  v9 = (int)gText;
  result = heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
  for ( i = 0; i < 12; ++i )
  {
    if ( i + *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 26097) + 26101) < *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 26097) + 26109) )
    {
      evt = 512;
      v7 = 5;
      v8 = i + 30;
      v9 = 2;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      spell = hero::GetNthSpell(
                *(hero **)(v4 + 26093),
                *(_DWORD *)(v4 + 26097),
                i + *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 26097) + 26101) + 1);
      evt = 512;
      v7 = 8;
      v8 = i + 30;
      if ( GetManaCost(spell, *(hero **)(v4 + 26093)) <= **(_WORD **)(v4 + 26093) )
        v9 = 1;
      else
        v9 = 3;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      if ( font::LineLength(smallFont, gSpellNames[spell], 78) == 1 )
      {
        v2 = GetManaCost(spell, *(hero **)(v4 + 26093));
        sprintf(gText, "%s\n[%d]", gSpellNames[spell], v2);
      }
      else
      {
        v3 = GetManaCost(spell, *(hero **)(v4 + 26093));
        sprintf(gText, "%s [%d]", gSpellNames[spell], v3);
      }
      evt = 512;
      v7 = 3;
      v8 = i + 30;
      v9 = (int)gText;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      evt = 512;
      v7 = 5;
      v8 = i + 30;
      v9 = 6;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      evt = 512;
      v7 = 5;
      v8 = i + 100;
      v9 = 2;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      evt = 512;
      v7 = 4;
      v8 = i + 100;
      v9 = gsSpellInfo[spell].spriteIdx;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      evt = 512;
      v7 = 5;
      v8 = i + 100;
      v9 = 6;
      result = heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
    }
    else
    {
      evt = 512;
      v7 = 6;
      v8 = i + 100;
      v9 = 6;
      heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
      evt = 512;
      v7 = 6;
      v8 = i + 30;
      v9 = 6;
      result = heroWindow::BroadcastMessage(*(heroWindow **)(v4 + 26089), (tag_message *)&evt);
    }
  }
  return result;
}

//----- (00421E70) --------------------------------------------------------
int __thiscall ViewSpellsHandler(tag_message *msg)
{
  int result; // eax@3
  int v2; // ST40_4@30
  int v3; // ST1C_4@42
  int v4; // eax@42
  int v5; // [sp+Ch] [bp-18h]@38
  int v6; // [sp+14h] [bp-10h]@10
  int v7; // [sp+18h] [bp-Ch]@6
  int spell; // [sp+20h] [bp-4h]@39

  if ( msg->eventCode == 4 )
  {
    heroWindowManager::ConvertToHover(gpWindowManager, msg);
    if ( gpWindowManager->hoveredFieldID == msg->yCoordOrFieldID )
      result = 1;
    else
      result = gpGame->callback(msg);
    return result;
  }
  if ( msg->eventCode != INPUT_GUI_MESSAGE_CODE )
    return 1;
  v7 = msg->xCoordOrKeycode;
  if ( v7 != 12 )
  {
    if ( v7 == 13 )
    {
      if ( msg->xCoordOrKeycode != 14 )
      {
        if ( !(BYTE1(msg->inputTypeBitmask) & 2) )
        {
          v6 = msg->yCoordOrFieldID;
          if ( v6 <= 30720 )
          {
            if ( v6 == 30720 )
            {
              msg->yCoordOrFieldID = 10;
            }
            else
            {
              switch ( v6 )
              {
                case 6:
                case 7:
                case 8:
                case 9:
                  sprintf(gText, off_4F64B0, viewSpellsHero->spellpoints);
                  NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
                  break;
                case 2:
                  if ( *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] )
                  {
                    *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] -= 12;
                    if ( *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] < 0 )
                      *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] = 0;
                    game::UpdateSpellWidgets((int)gpGame);
                    heroWindow::MoveWindow(*(heroWindow **)&gpGame->mapEventIndices[54], 0, 0);
                  }
                  else
                  {
                    game::UpdateSpellWidgets((int)gpGame);
                    heroWindow::MoveWindow(*(heroWindow **)&gpGame->mapEventIndices[54], 0, 0);
                  }
                  break;
                case 3:
                  if ( *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] + 12 < *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 64] )
                    *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60] += 12;
                  game::UpdateSpellWidgets((int)gpGame);
                  heroWindow::MoveWindow(*(heroWindow **)&gpGame->mapEventIndices[54], 0, 0);
                  break;
                case 4:
                  *(_DWORD *)&gpGame->mapEventIndices[58] = 1;
                  game::UpdateSpellWidgets((int)gpGame);
                  heroWindow::MoveWindow(*(heroWindow **)&gpGame->mapEventIndices[54], 0, 0);
                  break;
                case 5:
                  *(_DWORD *)&gpGame->mapEventIndices[58] = 0;
                  game::UpdateSpellWidgets((int)gpGame);
                  heroWindow::MoveWindow(*(heroWindow **)&gpGame->mapEventIndices[54], 0, 0);
                  break;
                default:
                  break;
              }
            }
          }
        }
      }
LABEL_50:
      if ( msg->yCoordOrFieldID == 10 )
      {
        msg->xCoordOrKeycode = msg->yCoordOrFieldID;
        return 2;
      }
      return 1;
    }
    if ( v7 != 14 )
      goto LABEL_50;
  }
  if ( msg->xCoordOrKeycode == 14 || BYTE1(msg->inputTypeBitmask) & 2 )
  {
    switch ( msg->yCoordOrFieldID )
    {
      case 0x64:
      case 0x65:
      case 0x66:
      case 0x67:
      case 0x68:
      case 0x69:
      case 0x6A:
      case 0x6B:
      case 0x6C:
      case 0x6D:
      case 0x6E:
      case 0x6F:
        v2 = hero::GetNthSpell(
               *(hero **)&gpGame->mapEventIndices[56],
               *(_DWORD *)&gpGame->mapEventIndices[58],
               msg->yCoordOrFieldID
             - 100
             + *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60]
             + 1);
        NormalDialog(gSpellDesc[v2], 4, -1, -1, 8, v2, -1, 0, -1, 0);
        break;
      case 2:
        NormalDialog(cSpellHelp, 4, -1, -1, -1, 0, -1, 0, -1, 0);
        break;
      case 3:
        NormalDialog(off_4F6494, 4, -1, -1, -1, 0, -1, 0, -1, 0);
        break;
      case 4:
        NormalDialog(off_4F6498, 4, -1, -1, -1, 0, -1, 0, -1, 0);
        break;
      case 5:
        NormalDialog(off_4F649C, 4, -1, -1, -1, 0, -1, 0, -1, 0);
        break;
      case 6:
      case 7:
      case 8:
      case 9:
        sprintf(gText, off_4F64B0, viewSpellsHero->spellpoints);
        NormalDialog(gText, 4, -1, -1, -1, 0, -1, 0, -1, 0);
        break;
      default:
        goto LABEL_50;
    }
    goto LABEL_50;
  }
  v5 = msg->yCoordOrFieldID;
  if ( v5 < 100 || v5 > 111 )
    goto LABEL_50;
  spell = hero::GetNthSpell(
            *(hero **)&gpGame->mapEventIndices[56],
            *(_DWORD *)&gpGame->mapEventIndices[58],
            msg->yCoordOrFieldID
          - 100
          + *(_DWORD *)&gpGame->mapEventIndices[2 * *(_DWORD *)&gpGame->mapEventIndices[58] + 60]
          + 1);
  if ( gpGame->field_660D )
  {
    NormalDialog(gSpellDesc[spell], 1, -1, -1, 8, spell, -1, 0, -1, 0);
    result = 1;
  }
  else if ( GetManaCost(spell, viewSpellsHero) <= viewSpellsHero->spellpoints )
  {
    *(_DWORD *)&gpGame->mapEventIndices[68] = spell;
    msg->xCoordOrKeycode = 10;
    result = 2;
  }
  else
  {
    v3 = viewSpellsHero->spellpoints;
    v4 = GetManaCost(spell, viewSpellsHero);
    sprintf(gText, "That spell costs %d mana.  You only have %d mana, so you can't cast the spell.", v4, v3);
    NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
    result = 0;
  }
  return result;
}

//----- (00422530) --------------------------------------------------------
signed int __thiscall ViewSpecialHandler(void *this)
{
  signed int result; // eax@3
  signed int v2; // [sp+Ch] [bp-8h]@4

  if ( *(_DWORD *)this == 4 )
  {
    if ( gpWindowManager->hoveredFieldID == *((_DWORD *)this + 2) )
    {
      result = 1;
    }
    else
    {
      gpWindowManager->hoveredFieldID = *((_DWORD *)this + 2);
      v2 = *((_DWORD *)this + 2);
      if ( v2 > 30720 )
      {
LABEL_11:
        strcpy(gText, off_4F64A4);
      }
      else if ( v2 == 30720 )
      {
        strcpy(gText, off_4F64A0);
      }
      else
      {
        switch ( v2 )
        {
          case 2:
            strcpy(gText, cSpellHelp);
            break;
          case 3:
            strcpy(gText, off_4F6494);
            break;
          case 4:
            strcpy(gText, off_4F6498);
            break;
          case 5:
            strcpy(gText, off_4F649C);
            break;
          case 6:
          case 7:
          case 8:
          case 9:
            sprintf(gText, off_4F64B0, viewSpellsHero->spellpoints);
            break;
          default:
            goto LABEL_11;
        }
      }
      HeroMessageUpdate(gText);
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (004226B0) --------------------------------------------------------
BOOL __thiscall game::ViewArmy(game *this, int a2, int a3, CREATURES creat, signed int a5, int a6, int a7, unsigned int a8, int a9, hero *hro, int a11, armyGroup *a12, int a13)
{
  int creatureFormBin; // eax@25
  char v14; // al@44
  char v15; // al@50
  signed int v16; // eax@78
  game *thisa; // [sp+Ch] [bp-D4h]@1
  char v19; // [sp+14h] [bp-CCh]@32
  iconWidget *v20; // [sp+1Ch] [bp-C4h]@85
  iconWidget *v21; // [sp+20h] [bp-C0h]@30
  heroWindow *thisb; // [sp+24h] [bp-BCh]@17
  int v23; // [sp+2Ch] [bp-B4h]@77
  int v24; // [sp+30h] [bp-B0h]@77
  signed int imgIdx; // [sp+34h] [bp-ACh]@77
  widget *v26; // [sp+38h] [bp-A8h]@86
  signed __int16 v27; // [sp+3Ch] [bp-A4h]@75
  char v28; // [sp+40h] [bp-A0h]@73
  int v29; // [sp+4Ch] [bp-94h]@56
  int evt; // [sp+50h] [bp-90h]@1
  int v31; // [sp+54h] [bp-8Ch]@38
  int v32; // [sp+58h] [bp-88h]@38
  char *v33; // [sp+68h] [bp-78h]@38
  __int16 v34; // [sp+6Ch] [bp-74h]@1
  int v35; // [sp+70h] [bp-70h]@15
  char filename; // [sp+74h] [bp-6Ch]@26
  __int16 v37; // [sp+84h] [bp-5Ch]@1
  int i; // [sp+88h] [bp-58h]@4
  int idx; // [sp+8Ch] [bp-54h]@28
  __int16 v40; // [sp+90h] [bp-50h]@1
  int v41; // [sp+94h] [bp-4Ch]@39
  int v42; // [sp+98h] [bp-48h]@65
  char a1; // [sp+9Ch] [bp-44h]@38
  icon *res; // [sp+BCh] [bp-24h]@28
  __int16 v45; // [sp+C0h] [bp-20h]@1
  char *buf; // [sp+C4h] [bp-1Ch]@38
  __int16 v47; // [sp+C8h] [bp-18h]@1
  int v48; // [sp+CCh] [bp-14h]@43
  tag_monsterInfo *creatureInfo; // [sp+D0h] [bp-10h]@14
  widget *guiObj; // [sp+D4h] [bp-Ch]@34
  __int16 v51; // [sp+D8h] [bp-8h]@1
  __int16 v52; // [sp+DCh] [bp-4h]@1
  int a12a; // [sp+110h] [bp+30h]@38

  thisa = this;
  v37 = 86;
  v45 = 164;
  v47 = 1;
  v40 = 2;
  v51 = 3;
  v52 = 4;
  v34 = 5;
  evt = 512;
  iViewArmyFrame = 0;
  iViewArmyType = creat;
  iViewArmyNumTroops = a5;
  gbAllowUpgrade = 0;
  if ( a6 && (gpAdvManager->ready == 1 || gpTownManager->ready == 1) )
  {
    for ( i = 20; i <= 24; ++i )
    {
      if ( LOBYTE((&gTownObjNames[3 * *(_BYTE *)(a6 + 3) + 27])[i + 1]) == creat )
      {
        if ( (1 << (i + 5)) & *(_DWORD *)(a6 + 24) )
        {
          gbAllowUpgrade = 1;
          iViewArmyUpgradeToType = creat + 1;
        }
      }
    }
    if ( (creat == CREATURE_GREEN_DRAGON || creat == CREATURE_RED_DRAGON) && *(_BYTE *)(a6 + 27) & 0x40 )
    {
      gbAllowUpgrade = 1;
      iViewArmyUpgradeToType = CREATURE_BLACK_DRAGON;
    }
  }
  creatureInfo = &gMonsterDatabase[creat];
  if ( a11 )
    v35 = a11 + 186;
  else
    v35 = (int)&gMonsterDatabase[creat];
  thisb = (heroWindow *)operator new(68);
  if ( thisb )
    *(_DWORD *)&thisa->mapEventIndices[50] = heroWindow::heroWindow(thisb, 19, 75, "armywin.bin");
  else
    *(_DWORD *)&thisa->mapEventIndices[50] = 0;
  if ( !*(_DWORD *)&thisa->mapEventIndices[50] )
    MemError();
  if ( a8 == 1 )
    viewArmyFacingWIPXMod = -1;
  else
    viewArmyFacingWIPXMod = 1;
  creatureFormBin = resourceManager::MakeId(gpResourceManager, cArmyFrameFileNames[creat], 1);
  resourceManager::PointToFile(gpResourceManager, creatureFormBin);
  resourceManager::ReadBlock(gpResourceManager, &sViewArmyMonFrameInfo, 821u);
  ModifyFrameInfo(&sViewArmyMonFrameInfo, creat);
  BuildTempWalkSeq(&sViewArmyMonFrameInfo, 0, 1);
  *(_DWORD *)&viewArmyBaseX = 167;
  if ( gbLowMemory )
    sprintf(&filename, "monh%04d.icn", creat);
  else
    strcpy(&filename, cMonFilename[creat]);
  res = resourceManager::GetIcon(gpResourceManager, &filename);
  idx = byte_522DB5[0];
  *(_DWORD *)&viewArmyBaseX += viewArmyFacingWIPXMod * (GetIconEntry(res, byte_522DB5[0])->width / 2);
  *(_DWORD *)&viewArmyBaseX += viewArmyFacingWIPXMod * byte_522CA5[0]
                             + viewArmyFacingWIPXMod * GetIconEntry(res, idx)->offsetX;
  *(_DWORD *)&viewArmyBaseY = 138;
  *(_DWORD *)&viewArmyBaseY = GetIconEntry(res, idx)->height / 2 + 138;
  if ( gbLowMemory )
  {
    *(_DWORD *)&viewArmyBaseX = 126;
    *(_DWORD *)&viewArmyBaseY = 93;
  }
  v21 = (iconWidget *)operator new(45);
  if ( v21 )
  {
    if ( gbLowMemory )
      v19 = 0;
    else
      v19 = byte_522DB5[0];
    guiObj = (widget *)iconWidget::iconWidget(
                         v21,
                         viewArmyBaseX,
                         viewArmyBaseY,
                         86,
                         149,
                         &filename,
                         v19,
                         a8 < 1,
                         5,
                         16,
                         1);
  }
  else
  {
    guiObj = 0;
  }
  if ( !guiObj )
    MemError();
  heroWindow::AddWidget(*(heroWindow **)&thisa->mapEventIndices[50], guiObj, -1);
  resourceManager::Dispose(gpResourceManager, (resource *)res);
  strcpy(&a1, gArmyNames[creat]);
  a1 -= 32;
  v31 = 3;
  v32 = 3;
  v33 = &a1;
  heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  buf = (char *)BaseAlloc(0x226u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF4B0 + 147);
  if ( a12a )
    v41 = armyGroup::GetMorale(a12, hro, (town *)a6, 0);
  else
    v41 = 0;
  if ( HIBYTE(creatureInfo->creature_flags) & 4 )
    v41 = 0;
  sprintf(buf, byte_4EF4EC);
  v48 = 0;
  sprintf(gText, "%s%d", cArmyDetail[0], creatureInfo->attack);
  strcat(buf, gText);
  if ( hro )
  {
    v14 = hero::Stats(hro, 0);
    v48 += v14;
  }
  if ( a11 )
    v48 = *(_BYTE *)(a11 + 198) - creatureInfo->attack;
  if ( v48 )
  {
    sprintf(gText, " (%d)", v48 + creatureInfo->attack);
    strcat(buf, gText);
  }
  v48 = 0;
  sprintf(gText, "\n%s%d", off_4F64E4[0], creatureInfo->defense);
  strcat(buf, gText);
  if ( hro )
  {
    v15 = hero::Stats(hro, PRIMARY_SKILL_DEFENSE);
    v48 += v15;
  }
  if ( a11 )
    v48 = *(_BYTE *)(a11 + 199) - creatureInfo->defense;
  if ( v48 )
  {
    sprintf(gText, " (%d)", v48 + creatureInfo->defense);
    strcat(buf, gText);
  }
  if ( creatureInfo->creature_flags & 4 )
  {
    v29 = *(_BYTE *)(v35 + 16);
    if ( v29 > 0 )
    {
      if ( gpCombatManager->ready == 1 )
        sprintf(gText, "\n%s%d", off_4F64E8[0], v29);
      else
        sprintf(gText, "\n%s%d", off_4F6500, v29);
      strcat(buf, gText);
    }
  }
  sprintf(gText, "\n%s%d", off_4F64EC[0], creatureInfo->min_damage);
  strcat(buf, gText);
  if ( creatureInfo->min_damage != creatureInfo->max_damage )
  {
    sprintf(gText, "-%d", creatureInfo->max_damage);
    strcat(buf, gText);
  }
  sprintf(gText, "\n%s%d", off_4F64F0[0], creatureInfo->hp);
  strcat(buf, gText);
  if ( gpCombatManager->ready == 1 )
  {
    sprintf(gText, "\n%s%d", "Hit Points Left: ", creatureInfo->hp - *(_DWORD *)(a11 + 162));
    strcat(buf, gText);
  }
  sprintf(gText, "\n%s%s", off_4F64F4[0], speedText[*(_BYTE *)(v35 + 11)]);
  strcat(buf, gText);
  sprintf(gText, "\n%s%s", off_4F64F8[0], off_4F629C[v41]);
  strcat(buf, gText);
  v42 = game::GetLuck(hro, (army *)a11, (town *)a6);
  sprintf(gText, "\n%s%s", off_4F64FC[0], off_4F627C[v42]);
  strcat(buf, gText);
  v32 = 4;
  v33 = buf;
  heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  if ( !gbAllowUpgrade )
  {
    v31 = 6;
    v33 = (char *)6;
    v32 = 500;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  }
  if ( a7 )
  {
    v31 = 6;
    v33 = (char *)6;
    v32 = 30723;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  }
  if ( a9 )
  {
    v31 = 6;
    v33 = (char *)6;
    v32 = 30720;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  }
  if ( a5 >= 1 )
  {
    sprintf(&v28, "%d", a5);
    v31 = 3;
    v32 = 2;
    v33 = &v28;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  }
  else
  {
    v31 = 6;
    v33 = (char *)6;
    v32 = 1;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
    v32 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)&thisa->mapEventIndices[50], (tag_message *)&evt);
  }
  if ( a11 )
  {
    v27 = 169;
    if ( a9 )
      v27 = 181;
    v23 = 44 - *(_DWORD *)(a11 + 262);
    v24 = 10 - *(_DWORD *)(a11 + 262) + 420 - v23 * *(_DWORD *)(a11 + 262) / 2;
    imgIdx = -1;
    for ( i = 0; ; ++i )
    {
      v16 = *(_DWORD *)(a11 + 262);
      if ( v16 >= 6 )
        v16 = 6;
      if ( v16 <= i )
        break;
      ++imgIdx;
      while ( imgIdx < 15 && !*(_BYTE *)(imgIdx + a11 + 266) )
        ++imgIdx;
      v20 = (iconWidget *)operator new(45);
      if ( v20 )
        v26 = (widget *)iconWidget::iconWidget(
                          v20,
                          v24 + v23 * (_WORD)i,
                          v27 + 14,
                          0,
                          0,
                          "spellinl.icn",
                          imgIdx,
                          0,
                          i + 200,
                          16,
                          1);
      else
        v26 = 0;
      if ( !v26 )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)&thisa->mapEventIndices[50], v26, -1);
    }
  }
  glTimers = KBTickCount() + 90;
  *(_DWORD *)&thisa->mapEventIndices[52] = 0;
  if ( a9 )
  {
    heroWindowManager::AddWindow(gpWindowManager, *(heroWindow **)&thisa->mapEventIndices[50], -1, 1);
    QuickViewWait();
    heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)&thisa->mapEventIndices[50]);
  }
  else
  {
    heroWindowManager::DoDialog(
      gpWindowManager,
      *(heroWindow **)&thisa->mapEventIndices[50],
      (int (__fastcall *)(tag_message *))ViewArmyHandler,
      0);
    if ( gbDismissArmy && a12 )
    {
      a12->creatureTypes[a13] = -1;
      a12->quantities[a13] = 0;
    }
    if ( gbUpgradeArmy && a12 )
      a12->creatureTypes[a13] = iViewArmyUpgradeToType;
  }
  BaseFree(buf, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF4B0 + 356);
  return operator delete(*(void **)&thisa->mapEventIndices[50]);
}
// 4EF4B0: using guessed type __int16 word_4EF4B0;
// 4F3D10: using guessed type char *gTownObjNames[32];
// 4F627C: using guessed type char *off_4F627C[4];
// 4F629C: using guessed type char *off_4F629C[4];
// 4F64E0: using guessed type char *cArmyDetail[9];
// 4F64E4: using guessed type char *off_4F64E4[8];
// 4F64E8: using guessed type char *off_4F64E8[7];
// 4F64EC: using guessed type char *off_4F64EC[6];
// 4F64F0: using guessed type char *off_4F64F0[5];
// 4F64F4: using guessed type char *off_4F64F4[4];
// 4F64F8: using guessed type char *off_4F64F8[3];
// 4F64FC: using guessed type char *off_4F64FC[2];
// 4F6500: using guessed type char *off_4F6500;
// 4F74A8: using guessed type int gbLowMemory;
// 522C38: using guessed type int iViewArmyNumTroops;
// 522C3C: using guessed type int gbUpgradeArmy;
// 522F78: using guessed type int viewArmyFacingWIPXMod;
// 522F7C: using guessed type int iViewArmyUpgradeToType;
// 522F80: using guessed type int gbAllowUpgrade;
// 522FC8: using guessed type int iViewArmyFrame;
// 522FCC: using guessed type int gbDismissArmy;
// 522FD8: using guessed type int iViewArmyType;

//----- (00423370) --------------------------------------------------------
signed int __thiscall ViewArmyHandler(void *this)
{
  signed int v2; // [sp+18h] [bp-20h]@3
  void *evt; // [sp+20h] [bp-18h]@1
  int img2Type; // [sp+24h] [bp-14h]@9
  int img1Arg; // [sp+28h] [bp-10h]@8
  int img2Arg; // [sp+2Ch] [bp-Ch]@9

  evt = this;
  gbDismissArmy = 0;
  gbUpgradeArmy = 0;
  if ( *(_DWORD *)this != 512 || *((_DWORD *)this + 1) != 13 )
    goto LABEL_30;
  v2 = *((_DWORD *)this + 2);
  if ( v2 > 30721 )
  {
    if ( v2 == 30723 )
    {
      NormalDialog("Are you sure you want to dismiss this army?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        gbDismissArmy = 1;
        *((_DWORD *)evt + 2) = 10;
        *((_DWORD *)evt + 1) = *((_DWORD *)evt + 2);
        return 2;
      }
    }
    goto LABEL_30;
  }
  if ( v2 >= 30720 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)this + 2);
    *((_DWORD *)this + 2) = 10;
    *((_DWORD *)this + 1) = *((_DWORD *)this + 2);
    return 2;
  }
  if ( v2 != 500 )
  {
LABEL_30:
    if ( !gbLowMemory )
    {
      if ( KBTickCount() > glTimers )
      {
        *(_DWORD *)evt = 512;
        *((_DWORD *)evt + 1) = 4;
        *((_DWORD *)evt + 2) = 5;
        iViewArmyFrame = (iViewArmyFrame + 1) % byte_522D39;
        *((_DWORD *)evt + 6) = byte_522DB5[iViewArmyFrame];
        heroWindow::BroadcastMessage(*(heroWindow **)&gpGame->mapEventIndices[50], (tag_message *)evt);
        *((_DWORD *)evt + 1) = 52;
        *((_DWORD *)evt + 6) = *(_DWORD *)&viewArmyBaseX + viewArmyFacingWIPXMod * byte_522CA5[iViewArmyFrame];
        heroWindow::BroadcastMessage(*(heroWindow **)&gpGame->mapEventIndices[50], (tag_message *)evt);
        heroWindow::DrawWindow(*(heroWindow **)&gpGame->mapEventIndices[50], 1, 0, 32767);
        glTimers = (signed __int64)((double)KBTickCount() + (double)dword_522CE2 * 1.35 / (double)byte_522D39);
      }
    }
    return 1;
  }
  img1Arg = 2
          * iViewArmyNumTroops
          * (gMonsterDatabase[iViewArmyUpgradeToType].cost - gMonsterDatabase[iViewArmyType].cost);
  if ( iViewArmyUpgradeToType == CREATURE_BLACK_DRAGON )
  {
    img2Type = 3;
    img2Arg = 2 * iViewArmyNumTroops;
  }
  else if ( iViewArmyUpgradeToType == CREATURE_TITAN )
  {
    img2Type = 5;
    img2Arg = 2 * iViewArmyNumTroops;
  }
  else
  {
    img2Type = -1;
    img2Arg = 0;
  }
  if ( gpCurPlayer->resources[6] < img1Arg || img2Type != -1 && gpCurPlayer->resources[img2Type] < img2Arg )
  {
    NormalDialog("You can't afford to upgrade your troops!", 1, -1, -1, 6, img1Arg, img2Type, img2Arg, -1, 0);
    goto LABEL_30;
  }
  NormalDialog(
    "Your troops can be upgraded, but it will cost you dearly.  Do you wish to upgrade them?",
    2,
    -1,
    -1,
    6,
    img1Arg,
    img2Type,
    img2Arg,
    -1,
    0);
  if ( gpWindowManager->buttonPressedCode != 30725 )
    goto LABEL_30;
  gpCurPlayer->resources[6] -= img1Arg;
  if ( img2Type != -1 )
    gpCurPlayer->resources[img2Type] -= img2Arg;
  gbUpgradeArmy = 1;
  *((_DWORD *)evt + 2) = 10;
  *((_DWORD *)evt + 1) = *((_DWORD *)evt + 2);
  return 2;
}
// 4F74A8: using guessed type int gbLowMemory;
// 522C38: using guessed type int iViewArmyNumTroops;
// 522C3C: using guessed type int gbUpgradeArmy;
// 522CE2: using guessed type int dword_522CE2;
// 522D39: using guessed type char byte_522D39;
// 522F78: using guessed type int viewArmyFacingWIPXMod;
// 522F7C: using guessed type int iViewArmyUpgradeToType;
// 522FC8: using guessed type int iViewArmyFrame;
// 522FCC: using guessed type int gbDismissArmy;
// 522FD8: using guessed type int iViewArmyType;

//----- (00423760) --------------------------------------------------------
int __thiscall game::GetRandomNumTroops(game *this, int creat)
{
  int result; // eax@2

  switch ( creat )
  {
    case CREATURE_PEASANT:
      result = Random(40, 80);
      break;
    case CREATURE_ARCHER:
      result = Random(20, 30);
      break;
    case CREATURE_RANGER:
      result = Random(20, 30);
      break;
    case CREATURE_PIKEMAN:
      result = Random(20, 30);
      break;
    case CREATURE_VETERAN_PIKEMAN:
      result = Random(20, 30);
      break;
    case CREATURE_SWORDSMAN:
      result = Random(12, 25);
      break;
    case CREATURE_MASTER_SWORDSMAN:
      result = Random(12, 25);
      break;
    case CREATURE_CAVALRY:
      result = Random(10, 18);
      break;
    case CREATURE_CHAMPION:
      result = Random(8, 16);
      break;
    case CREATURE_PALADIN:
      result = Random(6, 12);
      break;
    case CREATURE_CRUSADER:
      result = Random(6, 10);
      break;
    case CREATURE_GOBLIN:
      result = Random(25, 40);
      break;
    case CREATURE_ORC:
      result = Random(15, 30);
      break;
    case CREATURE_ORC_CHIEF:
      result = Random(15, 30);
      break;
    case CREATURE_WOLF:
      result = Random(20, 35);
      break;
    case CREATURE_OGRE:
      result = Random(12, 25);
      break;
    case CREATURE_OGRE_LORD:
      result = Random(10, 20);
      break;
    case CREATURE_TROLL:
      result = Random(7, 10);
      break;
    case CREATURE_WAR_TROLL:
      result = Random(7, 10);
      break;
    case CREATURE_CYCLOPS:
      result = Random(5, 7);
      break;
    case CREATURE_SPRITE:
      result = Random(25, 45);
      break;
    case CREATURE_DWARF:
      result = Random(12, 25);
      break;
    case CREATURE_BATTLE_DWARF:
      result = Random(10, 22);
      break;
    case CREATURE_ELF:
      result = Random(15, 30);
      break;
    case CREATURE_GRAND_ELF:
      result = Random(12, 28);
      break;
    case CREATURE_DRUID:
      result = Random(10, 25);
      break;
    case CREATURE_GREATER_DRUID:
      result = Random(10, 20);
      break;
    case CREATURE_UNICORN:
      result = Random(8, 15);
      break;
    case CREATURE_PHOENIX:
      result = Random(7, 12);
      break;
    case CREATURE_CENTAUR:
      result = Random(20, 50);
      break;
    case CREATURE_GARGOYLE:
      result = Random(15, 30);
      break;
    case CREATURE_GRIFFIN:
      result = Random(12, 25);
      break;
    case CREATURE_MINOTAUR:
      result = Random(10, 16);
      break;
    case CREATURE_MINOTAUR_KING:
      result = Random(9, 16);
      break;
    case CREATURE_HYDRA:
      result = Random(7, 10);
      break;
    case CREATURE_GREEN_DRAGON:
      result = Random(4, 7);
      break;
    case CREATURE_RED_DRAGON:
      result = Random(3, 7);
      break;
    case CREATURE_BLACK_DRAGON:
      result = Random(3, 7);
      break;
    case CREATURE_HALFLING:
      result = Random(20, 50);
      break;
    case CREATURE_BOAR:
      result = Random(15, 30);
      break;
    case CREATURE_IRON_GOLEM:
      result = Random(10, 25);
      break;
    case CREATURE_STEEL_GOLEM:
      result = Random(10, 22);
      break;
    case CREATURE_ROC:
      result = Random(10, 16);
      break;
    case CREATURE_MAGE:
      result = Random(8, 12);
      break;
    case CREATURE_ARCHMAGE:
      result = Random(7, 11);
      break;
    case CREATURE_GIANT:
      result = Random(5, 8);
      break;
    case CREATURE_TITAN:
      result = Random(3, 7);
      break;
    case CREATURE_SKELETON:
      result = Random(20, 50);
      break;
    case CREATURE_ZOMBIE:
      result = Random(15, 30);
      break;
    case CREATURE_MUTANT_ZOMBIE:
      result = Random(15, 30);
      break;
    case CREATURE_MUMMY:
      result = Random(10, 25);
      break;
    case CREATURE_ROYAL_MUMMY:
      result = Random(10, 25);
      break;
    case CREATURE_VAMPIRE:
      result = Random(8, 12);
      break;
    case CREATURE_VAMPIRE_LORD:
      result = Random(8, 12);
      break;
    case CREATURE_LICH:
      result = Random(6, 10);
      break;
    case CREATURE_POWER_LICH:
      result = Random(6, 10);
      break;
    case CREATURE_BONE_DRAGON:
      result = Random(4, 8);
      break;
    case CREATURE_ROGUE:
      result = Random(20, 40);
      break;
    case CREATURE_NOMAD:
      result = Random(12, 25);
      break;
    case CREATURE_GHOST:
      result = Random(10, 20);
      break;
    case CREATURE_GENIE:
      result = Random(5, 10);
      break;
    case CREATURE_MEDUSA:
      result = Random(12, 20);
      break;
    case CREATURE_EARTH_ELEMENTAL:
      result = Random(13, 25);
      break;
    case CREATURE_AIR_ELEMENTAL:
      result = Random(13, 25);
      break;
    case CREATURE_FIRE_ELEMENTAL:
      result = Random(13, 25);
      break;
    case CREATURE_WATER_ELEMENTAL:
      result = Random(13, 25);
      break;
    default:
      result = 3;
      break;
  }
  return result;
}

//----- (00423DE0) --------------------------------------------------------
void __cdecl game::TurnOnAIMusic()
{
  soundManager::StopAllSamples((soundManager *)gpSoundManager, 1);
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 28);
  *(_DWORD *)(gpSoundManager + 1672) = 0;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00423E20) --------------------------------------------------------
void __cdecl game::TurnOffAIMusic()
{
  *(_DWORD *)(gpSoundManager + 1672) = 1;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00423E50) --------------------------------------------------------
void __thiscall game::NextPlayer(game *this)
{
  hero *v1; // ST1C_4@18
  signed int i; // [sp+28h] [bp-Ch]@3
  signed int j; // [sp+28h] [bp-Ch]@16
  int v5; // [sp+2Ch] [bp-8h]@3

  this->heroes[gpCurPlayer->heroesForPurchase[0]].flags &= 0xFFFEFFFFu;
  this->heroes[gpCurPlayer->heroesForPurchase[1]].flags &= 0xFFFEFFFFu;
  LODWORD(iCurHourGlassPhase) = 0;
  if ( gbThisNetHumanPlayer[giCurPlayer] && *(_DWORD *)&shouldAutosave )
  {
    v5 = 0;
    for ( i = 0; i < 6; ++i )
    {
      if ( !this->playerDead[i] )
      {
        if ( gbHumanPlayer[i] )
          ++v5;
      }
    }
    game::SaveGame(this, "AUTOSAVE", 1, 0);
  }
  gpAdvManager->identifyCast = 0;
  if ( gpGame->players[giCurPlayer].field_43 > 0 )
    --gpGame->players[giCurPlayer].field_43;
  CheckEndGame(0, 0);
  advManager::DeactivateCurrTown();
  advManager::DeactivateCurrHero(gpAdvManager);
  do
  {
    ++giCurPlayer;
    if ( this->numPlayers <= giCurPlayer )
    {
      giCurPlayer = 0;
      game::PerDay(this);
    }
  }
  while ( gpGame->playerDead[giCurPlayer] );
  gpCurPlayer = &gpGame->players[giCurPlayer];
  giCurPlayerBit = 1 << giCurPlayer;
  for ( j = 0; this->players[giCurPlayer].numHeroes > j; ++j )
  {
    v1 = &this->heroes[*(&this->players[0].heroesOwned[284 * giCurPlayer] + j - giCurPlayer)];
    v1->mobility = hero::CalcMobility(v1);
    v1->remainingMobility = v1->mobility;
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    SetNoDialogMenus(1);
    inputManager::Flush(gpInputManager);
    gbAllBlack = 1;
    advManager::CheckSetEvilInterface(gpAdvManager, 1, giCurPlayer);
    gbAllBlack = 0;
    if ( gbBlackoutPlayer && iLastMsgNumHumanPlayers > 1 )
    {
      sprintf(gText, "%s's turn.", cPlayerNames[giCurPlayer]);
      game::WaitForPlayer(gText, giCurPlayer);
    }
    if ( gbThisNetHumanPlayer[giCurPlayer] )
      game::CancelComputerScreen();
    giCurWatchPlayerBit = giCurPlayerBit;
    giCurWatchPlayer = giCurPlayer;
  }
  else
  {
    mouseManager::SetPointer(gpMouseManager, 1);
    advManager::HideRoute(gpAdvManager, 1, 0, 1);
    advManager::CheckDimNextHeroBut();
    game::TurnOnAIMusic();
    SetNoDialogMenus(0);
    giBottomViewOverride = 6;
    game::ShowComputerScreen();
    bShowIt = 0;
    if ( gbRemoteOn )
    {
      if ( gbHumanPlayer[giCurPlayer] )
      {
        gbThisNetGotAdventureControl = 0;
        if ( !game::TransmitSaveGame(gpGame, gbGamePosToNetPos[giCurPlayer], 0, 0) )
          ShutDown(0);
      }
    }
    if ( giBottomViewOverride == 6 )
      giBottomViewOverride = 0;
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] && gbRemoteOn && this->day != 1 && giForceSwitchMusic == -1 )
  {
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 21);
    giForceSwitchMusic = KBTickCount();
    *(_DWORD *)(gpSoundManager + 1672) = 0;
  }
  if ( this->day == 1 && giCurTurn != 1 )
    *(_DWORD *)(gpSoundManager + 1672) = 0;
  game::DoNewTurn(this);
  CheckEndGame(0, 0);
  if ( gbThisNetHumanPlayer[giCurPlayer] && !*(_DWORD *)(gpSoundManager + 1672) && giForceSwitchMusic == -1 )
  {
    *(_DWORD *)(gpSoundManager + 1672) = 1;
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
    advManager::SetEnvironmentOrigin(gpAdvManager, gpAdvManager->viewX + 7, gpAdvManager->viewY + 7, 1);
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] )
    advManager::ForceNewHover(gpAdvManager);
}
// 4F7470: using guessed type int gbAllBlack;
// 4F747C: using guessed type int giForceSwitchMusic;
// 4F7494: using guessed type int gbRemoteOn;
// 50EAA8: using guessed type __int64 iCurHourGlassPhase;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 523EDC: using guessed type int giCurWatchPlayer;
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 52473C: using guessed type int gbBlackoutPlayer;
// 524C14: using guessed type int bShowIt;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532C54: using guessed type int giCurTurn;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (004243F0) --------------------------------------------------------
signed int __thiscall game::ComputeDailyGold(game *this, int playerIdx)
{
  signed int income; // [sp+28h] [bp-Ch]@1 MAPDST
  signed int i; // [sp+2Ch] [bp-8h]@1
  signed int j; // [sp+2Ch] [bp-8h]@9
  signed int k; // [sp+30h] [bp-4h]@21

  income = 0;
  for ( i = 0; i < 144; ++i )
  {
    if ( this->mines[i].owner == playerIdx )
    {
      if ( this->mines[i].type == 6 )
        income += 1000;
      if ( this->mines[i].type == 101 )
        income += 1000;
    }
  }
  for ( j = 0; j < 72; ++j )
  {
    if ( this->castles[j].ownerIdx == playerIdx )
    {
      if ( this->castles[j].buildingsBuiltFlags & 32 )
        income += 250;
      else
        income += 1000;
      if ( this->castles[j].buildingsBuiltFlags & 0x80u )
        income += 250;
      if ( this->castles[j].factionID == FACTION_WARLOCK && BYTE1(this->castles[j].buildingsBuiltFlags) & 32 )
        income += 500;
    }
  }
  income += 1000 * playerData::NumOfGivenArtifact(&this->players[playerIdx], ARTIFACT_ENDLESS_SACK_OF_GOLD);
  income += 750 * playerData::NumOfGivenArtifact(&this->players[playerIdx], ARTIFACT_ENDLESS_BAG_OF_GOLD);
  income += 500 * playerData::NumOfGivenArtifact(&this->players[playerIdx], ARTIFACT_ENDLESS_PURSE_OF_GOLD);
  income += 10000 * playerData::NumOfGivenArtifact(&this->players[playerIdx], ARTIFACT_GOLDEN_GOOSE);
  income += -250 * playerData::NumOfGivenArtifact(&this->players[playerIdx], ARTIFACT_TAX_LIEN);
  for ( k = 0; this->players[playerIdx].numHeroes > k; ++k )
    income += gEstatesGoldLevel[gpGame->heroes[this->players[playerIdx].heroesOwned[k]].secondarySkillLevel[13]];
  if ( !gbHumanPlayer[playerIdx] )
  {
    if ( !gpGame->difficulty )
      income = (signed __int64)((double)income * 0.75);
    if ( gpGame->difficulty == 2 )
      income = (signed __int64)((double)income * 1.29);
    if ( gpGame->difficulty == 3 )
      income = (signed __int64)((double)income * 1.45);
    if ( gpGame->difficulty == 4 )
      income = (signed __int64)((double)income * 1.6);
  }
  if ( this->playerHandicap[playerIdx] == 1 )
  {
    income = (signed __int64)((double)income * 0.85);
  }
  else if ( this->playerHandicap[playerIdx] == 2 )
  {
    income = (signed __int64)((double)income * 0.7);
  }
  return income;
}

//----- (00424830) --------------------------------------------------------
void __thiscall game::PerDay(game *this)
{
  int v1; // ecx@18
  int v2; // ST34_4@74
  double v4; // [sp+14h] [bp-30h]@61
  hero *v5; // [sp+1Ch] [bp-28h]@88
  hero *thisa; // [sp+24h] [bp-20h]@74
  int v7; // [sp+28h] [bp-1Ch]@74
  signed int v8; // [sp+2Ch] [bp-18h]@10
  signed int v9; // [sp+30h] [bp-14h]@10
  signed int i; // [sp+34h] [bp-10h]@3
  signed int j; // [sp+34h] [bp-10h]@57
  signed int k; // [sp+34h] [bp-10h]@68
  signed int playerIdx; // [sp+38h] [bp-Ch]@1
  signed int playerIdxa; // [sp+38h] [bp-Ch]@7
  signed int playerIdxb; // [sp+38h] [bp-Ch]@20
  int playerIdxc; // [sp+38h] [bp-Ch]@23
  signed int playerIdxd; // [sp+38h] [bp-Ch]@29
  signed int playerIdxe; // [sp+38h] [bp-Ch]@52
  signed int playerIdxf; // [sp+38h] [bp-Ch]@55
  signed int playerIdxg; // [sp+38h] [bp-Ch]@66
  signed int playerIdxh; // [sp+38h] [bp-Ch]@72
  signed int playerIdxi; // [sp+38h] [bp-Ch]@83
  int v23; // [sp+3Ch] [bp-8h]@74
  int v24; // [sp+3Ch] [bp-8h]@88

  for ( playerIdx = 0; gpGame->numPlayers > playerIdx; ++playerIdx )
  {
    for ( i = 0; i < 7; ++i )
      gpGame->players[playerIdx].field_E7[i] = -this->players[playerIdx].resources[i];
  }
  memset(this->field_27BB, 0, 9u);
  for ( playerIdxa = 0; playerIdxa < 144; ++playerIdxa )
  {
    if ( this->mines[playerIdxa].owner != -1 )
    {
      v8 = this->mines[playerIdxa].type;
      v9 = 0;
      if ( v8 == 2 )
      {
        v9 = 2;
      }
      else if ( this->mines[playerIdxa].type )
      {
        if ( v8 != 6 )
          v9 = 1;
      }
      else
      {
        v9 = 2;
      }
      if ( v8 != 6 && v8 <= 6 )
      {
        v1 = 283 * this->mines[playerIdxa].owner + 4 * v8;
        *(int *)((char *)this->players[0].resources + v1) += v9;
      }
    }
  }
  for ( playerIdxb = 0; playerIdxb < 72; ++playerIdxb )
    ++this->castles[playerIdxb].field_55;
  for ( playerIdxc = 0; this->numPlayers > playerIdxc; ++playerIdxc )
  {
    this->players[playerIdxc].resources[3] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_POUCH_OF_SULFUR);
    this->players[playerIdxc].resources[1] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_VIAL_OF_MERCURY);
    this->players[playerIdxc].resources[5] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_POUCH_OF_GEMS);
    this->players[playerIdxc].resources[0] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_CORD_OF_WOOD);
    this->players[playerIdxc].resources[2] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_CART_OF_ORE);
    this->players[playerIdxc].resources[4] += playerData::NumOfGivenArtifact(
                                                &this->players[playerIdxc],
                                                ARTIFACT_ENDLESS_POUCH_OF_CRYSTAL);
    this->players[playerIdxc].resources[6] += game::ComputeDailyGold(this, playerIdxc);
  }
  if ( xIsPlayingExpansionCampaign && ExpCampaign::HasAward(&xCampaign, 2) )
    this->players[0].resources[0] += 2;
  for ( playerIdxd = 0; this->numPlayers > playerIdxd; ++playerIdxd )
  {
    if ( !gbHumanPlayer[playerIdxd] )
    {
      if ( gpGame->difficulty >= 2 )
      {
        ++this->players[playerIdxd].resources[0];
        ++this->players[playerIdxd].resources[2];
      }
      if ( gpGame->difficulty >= 3 && this->day >= 1 && this->day <= 6 )
        ++*(_DWORD *)&this->players[playerIdxd].castlesOwned[4 * this->day + 68];
      if ( gpGame->difficulty >= 4 && this->day >= 1 && this->day <= 6 )
        ++*(_DWORD *)&this->players[playerIdxd].castlesOwned[4 * this->day + 68];
      if ( gpGame->players[playerIdxd].personality == 1 && this->day >= 1 && this->day <= 6 )
        ++*(_DWORD *)&this->players[playerIdxd].castlesOwned[4 * this->day + 68];
    }
  }
  ++this->day;
  giCurTurn = this->day + 7 * (this->week - 1) + 28 * (this->month - 1);
  if ( !gbGameOver )
  {
    if ( this->day > 7 )
    {
      this->day = 1;
      game::PerWeek(this);
    }
    if ( this->week > 4 )
    {
      this->week = 1;
      game::PerMonth(this);
    }
  }
  for ( playerIdxe = 0; playerIdxe < 54; ++playerIdxe )
    this->heroes[playerIdxe].flags &= 0xFFFEFFFFu;
  for ( playerIdxf = 0; gpGame->numPlayers > playerIdxf; ++playerIdxf )
  {
    for ( j = 0; j < 6; ++j )
    {
      if ( this->playerHandicap[playerIdxf] )
      {
        if ( this->playerHandicap[playerIdxf] == 1 )
          v4 = 0.15;
        else
          v4 = 0.3;
        this->players[playerIdxf].resources[j] -= (signed __int64)((double)(this->players[playerIdxf].resources[j]
                                                                          + gpGame->players[playerIdxf].field_E7[j])
                                                                 * v4);
      }
    }
  }
  for ( playerIdxg = 0; gpGame->numPlayers > playerIdxg; ++playerIdxg )
  {
    for ( k = 0; k < 7; ++k )
      gpGame->players[playerIdxg].field_E7[k] += this->players[playerIdxg].resources[k];
  }
  for ( playerIdxh = 0; playerIdxh < 54; ++playerIdxh )
  {
    thisa = &this->heroes[playerIdxh];
    v2 = thisa->spellpoints;
    v23 = 10 * hero::Stats(thisa, PRIMARY_SKILL_KNOWLEDGE);
    v7 = this->heroes[playerIdxh].secondarySkillLevel[8] + 1 + v2;
    if ( hero::HasArtifact(thisa, 67) )
      v7 += 2;
    if ( v7 > v23 )
      v7 = v23;
    if ( thisa->spellpoints < v7 )
      thisa->spellpoints = v7;
    if ( BYTE1(this->heroes[playerIdxh].flags) & HERO_VISITED_WELL )
      this->heroes[playerIdxh].flags -= 0x1000;
  }
  for ( playerIdxi = 0; playerIdxi < 72; ++playerIdxi )
  {
    if ( this->castles[playerIdxi].buildingsBuiltFlags & 1 )
    {
      if ( this->castles[playerIdxi].visitingHeroIdx != -1 )
      {
        v5 = &this->heroes[this->castles[playerIdxi].visitingHeroIdx];
        v24 = 10 * hero::Stats(v5, PRIMARY_SKILL_KNOWLEDGE);
        if ( v5->spellpoints < v24 )
          v5->spellpoints = v24;
      }
    }
  }
}
// 4EF268: using guessed type int gbGameOver;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 532C54: using guessed type int giCurTurn;

//----- (004251E0) --------------------------------------------------------
void __thiscall game::PerWeek(game *this)
{
  char v1; // al@52
  mapCell *v2; // ecx@64
  mapCell *v3; // STC8_4@65
  unsigned __int16 v4; // ax@65
  mapCell *v5; // STC4_4@67
  unsigned __int16 v6; // ax@67
  unsigned __int16 v7; // ax@70
  unsigned __int16 v8; // ax@71
  mapCell *v9; // STBC_4@73
  mapCell *v10; // STB4_4@75
  mapCell *v11; // STAC_4@78
  mapCell *v12; // STA4_4@81
  mapCell *v13; // ST9C_4@84
  mapCell *v14; // ST94_4@87
  mapCell *v15; // ST8C_4@90
  mapCell *v16; // ST84_4@93
  mapCell *v17; // ST7C_4@96
  mapCell *v18; // ST74_4@99
  mapCell *v19; // ST6C_4@102
  mapCell *v20; // ST64_4@105
  mapCell *v21; // ST5C_4@108
  mapCell *v22; // ST54_4@111
  mapCell *v23; // ST4C_4@114
  mapCell *v24; // ST44_4@117
  mapCell *v25; // ST3C_4@121
  mapCell *v26; // ST34_4@125
  mapCell *v27; // ecx@129
  mapCell *v29; // [sp+B4h] [bp-44h]@69
  int getPowerfulHero; // [sp+C8h] [bp-30h]@50
  int v31; // [sp+D0h] [bp-28h]@60
  signed int v32; // [sp+D4h] [bp-24h]@60
  int v33; // [sp+D4h] [bp-24h]@62
  signed int growth; // [sp+D8h] [bp-20h]@9
  town *cstl; // [sp+DCh] [bp-1Ch]@6
  signed int i; // [sp+E0h] [bp-18h]@6
  signed int j; // [sp+E0h] [bp-18h]@33
  signed int playerIdx; // [sp+E4h] [bp-14h]@4
  int playerIdxa; // [sp+E4h] [bp-14h]@31
  signed int playerIdxb; // [sp+E4h] [bp-14h]@136
  int k; // [sp+E8h] [bp-10h]@54
  int l; // [sp+ECh] [bp-Ch]@56
  signed int faction; // [sp+F0h] [bp-8h]@38
  int v44; // [sp+F4h] [bp-4h]@1

  v44 = 0;
  giWeekType = 0;
  giWeekTypeExtra = Random(0, 14);
  if ( this->week != 4 && Random(1, 4) == 1 )
  {
    giWeekType = 1;
    giWeekTypeExtra = Random(0, 56);
  }
  for ( playerIdx = 0; playerIdx < 72; ++playerIdx )
  {
    cstl = &this->castles[playerIdx];
    for ( i = 19; i <= 30; ++i )
    {
      if ( (1 << i) & this->castles[playerIdx].buildingsBuiltFlags )
      {
        growth = gMonsterDatabase[LOBYTE((&gTownObjNames[3 * this->castles[playerIdx].factionID + 27])[i + 1])].growth;
        if ( this->castles[playerIdx].buildingsBuiltFlags & BUILDING_EXT_0 )
          growth += 2;
        if ( i == 19 && BYTE1(this->castles[playerIdx].buildingsBuiltFlags) & 8 )
          growth += 8;
        if ( this->castles[playerIdx].ownerIdx == -1 )
          growth /= 2;
        if ( this->castles[playerIdx].ownerIdx >= 0
          && !*(_WORD *)&cstl[-1].name[2 * i + 5]
          && !gbHumanPlayer[this->castles[playerIdx].ownerIdx] )
        {
          if ( gpGame->difficulty == 2 )
            growth = (signed __int64)((double)growth * 1.2);
          if ( gpGame->difficulty == 3 )
            growth = (signed __int64)((double)growth * 1.32);
          if ( gpGame->difficulty == 4 )
            growth = (signed __int64)((double)growth * 1.44);
        }
        if ( giWeekType == 1 )
        {
          if ( LOBYTE((&gTownObjNames[3 * this->castles[playerIdx].factionID + 27])[i + 1]) == giWeekTypeExtra )
            LOWORD(growth) = growth + 5;
        }
        *(_WORD *)&cstl[-1].name[2 * i + 5] += growth;
      }
    }
  }
  for ( playerIdxa = 0; playerIdxa < 6; ++playerIdxa )
  {
    for ( j = 0; j < 2; ++j )
    {
      if ( j == 1 )
        v44 = this->heroes[gpGame->players[playerIdxa].heroesForPurchase[0]].factionID;
      v44 = (v44 + Random(1, 5)) % 6;
      faction = v44;
      if ( !j && this->field_459[gcColorToSetupPos[this->players[playerIdxa].color]] < 6 )
        faction = this->field_459[gcColorToSetupPos[this->players[playerIdxa].color]];
      if ( gpGame->relatedToHeroForHireStatus[*(&gpGame->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] != 64
        || !(BYTE2(gpGame->heroes[*(&gpGame->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)].flags) & 1) )
      {
        if ( gpGame->relatedToHeroForHireStatus[*(&gpGame->players[0].heroesForPurchase[284 * playerIdxa]
                                                + j
                                                - playerIdxa)] == 64 )
          gpGame->relatedToHeroForHireStatus[*(&gpGame->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] = -1;
        if ( j == 1 && !gbHumanPlayer[playerIdxa] )
          faction = -1;
        getPowerfulHero = !gbHumanPlayer[playerIdxa] && gpGame->difficulty > 0;
        v1 = game::GetNewHeroId(gpGame, playerIdxa, faction, getPowerfulHero);
        *(&gpGame->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa) = v1;
        this->relatedToHeroForHireStatus[*(&gpGame->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] = 64;
      }
    }
  }
  for ( k = 0; MAP_HEIGHT > k; ++k )
  {
    for ( l = 0; l < MAP_WIDTH; ++l )
    {
      switch ( *(&this->map.tiles[l].objType + 12 * k * this->map.width) )
      {
        case TILE_HAS_EVENT|LOCATION_ARMY_CAMP:
          v32 = (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                    + 6 * k * this->map.width) >> 8) >> -5);
          v31 = v32 / 7;
          if ( Random(1, 7) <= v32 % 7 )
            ++v31;
          v33 = v31 + v32;
          if ( v33 > 4000 )
            LOWORD(v33) = 4000;
          v2 = &this->map.tiles[k * this->map.width] + l;
          v2->field_4_1_1_isShadow_1_13_extraInfo = v2->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                                * (v33 | ((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo + 6 * k * this->map.width) >> 8) >> -5) & 0);
          break;
        case TILE_HAS_EVENT|LOCATION_ARTESIAN_SPRING:
          v3 = &this->map.tiles[k * this->map.width] + l;
          v4 = v3->field_4_1_1_isShadow_1_13_extraInfo & 7;
          LOBYTE(v4) = v4 | 8;
          v3->field_4_1_1_isShadow_1_13_extraInfo = v4;
          break;
        case TILE_HAS_EVENT|LOCATION_WATERWHEEL:
          if ( (unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                   + 6 * k * this->map.width) >> 8) >> -5) != 255 )
          {
            v5 = &this->map.tiles[k * this->map.width] + l;
            v6 = v5->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v6) = v6 | 0x10;
            v5->field_4_1_1_isShadow_1_13_extraInfo = v6;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_MAGIC_GARDEN:
          v29 = &this->map.tiles[k * this->map.width] + l;
          if ( Random(0, 1) )
          {
            v7 = v29->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v7) = v7 | 0x38;
            v29->field_4_1_1_isShadow_1_13_extraInfo = v7;
          }
          else
          {
            v8 = v29->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v8) = v8 | 0x30;
            v29->field_4_1_1_isShadow_1_13_extraInfo = v8;
          }
          break;
        case TILE_HAS_EVENT|LOCATION_WINDMILL:
          v9 = &this->map.tiles[k * this->map.width] + l;
          v9->field_4_1_1_isShadow_1_13_extraInfo = v9->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(1, 5);
          break;
        case TILE_HAS_EVENT|LOCATION_ARCHERS_HOUSE:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v10 = &this->map.tiles[k * this->map.width] + l;
            v10->field_4_1_1_isShadow_1_13_extraInfo = v10->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v10->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(2, 4));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_GOBLIN_HUT:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v11 = &this->map.tiles[k * this->map.width] + l;
            v11->field_4_1_1_isShadow_1_13_extraInfo = v11->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v11->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(3, 6));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_DWARF_COTTAGE:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v12 = &this->map.tiles[k * this->map.width] + l;
            v12->field_4_1_1_isShadow_1_13_extraInfo = v12->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v12->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(2, 4));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_PEASANT_HUT:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v13 = &this->map.tiles[k * this->map.width] + l;
            v13->field_4_1_1_isShadow_1_13_extraInfo = v13->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v13->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(5, 10));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_LOG_CABIN:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v14 = &this->map.tiles[k * this->map.width] + l;
            v14->field_4_1_1_isShadow_1_13_extraInfo = v14->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v14->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(5, 10));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_DESRT_TENT:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v15 = &this->map.tiles[k * this->map.width] + l;
            v15->field_4_1_1_isShadow_1_13_extraInfo = v15->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v15->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(1, 3));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_WAGON_CAMP:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v16 = &this->map.tiles[k * this->map.width] + l;
            v16->field_4_1_1_isShadow_1_13_extraInfo = v16->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(3, 6));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_TREE_HOUSE:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v17 = &this->map.tiles[k * this->map.width] + l;
            v17->field_4_1_1_isShadow_1_13_extraInfo = v17->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v17->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(4, 8));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_DWARF_CABIN:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v18 = &this->map.tiles[k * this->map.width] + l;
            v18->field_4_1_1_isShadow_1_13_extraInfo = v18->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(3, 6));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_WATCH_TOWER:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v19 = &this->map.tiles[k * this->map.width] + l;
            v19->field_4_1_1_isShadow_1_13_extraInfo = v19->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v19->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(1, 4));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_RUINS:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v20 = &this->map.tiles[k * this->map.width] + l;
            v20->field_4_1_1_isShadow_1_13_extraInfo = v20->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v20->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(1, 3));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_TREE_CITY:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8161 )
          {
            v21 = &this->map.tiles[k * this->map.width] + l;
            v21->field_4_1_1_isShadow_1_13_extraInfo = v21->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v21->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(10, 20));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_CAVE:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v22 = &this->map.tiles[k * this->map.width] + l;
            v22->field_4_1_1_isShadow_1_13_extraInfo = v22->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(3, 6));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_EXCAVATION:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v23 = &this->map.tiles[k * this->map.width] + l;
            v23->field_4_1_1_isShadow_1_13_extraInfo = v23->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v23->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(4, 8));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_HALFLING_HOLE:
          if ( (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 8171 )
          {
            v24 = &this->map.tiles[k * this->map.width] + l;
            v24->field_4_1_1_isShadow_1_13_extraInfo = v24->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v24->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(5, 10));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_TROLL_BRIDGE:
          if ( !((*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo + 6 * k * this->map.width) >> 3) & 0x80)
            && (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 220 )
          {
            v25 = &this->map.tiles[k * this->map.width] + l;
            v25->field_4_1_1_isShadow_1_13_extraInfo = v25->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v25->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(1, 3));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_CITY_OF_DEAD:
          if ( !((*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo + 6 * k * this->map.width) >> 3) & 0x80)
            && (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 220 )
          {
            v26 = &this->map.tiles[k * this->map.width] + l;
            v26->field_4_1_1_isShadow_1_13_extraInfo = v26->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v26->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + (unsigned __int16)Random(1, 3));
          }
          break;
        case TILE_HAS_EVENT|LOCATION_DRAGON_CITY:
          if ( !((*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo + 6 * k * this->map.width) >> 3) & 0x80)
            && (signed int)(unsigned __int8)((unsigned __int8)(*(&this->map.tiles[l].field_4_1_1_isShadow_1_13_extraInfo
                                                               + 6 * k * this->map.width) >> 8) >> -5) < 220 )
          {
            v27 = &this->map.tiles[k * this->map.width] + l;
            v27->field_4_1_1_isShadow_1_13_extraInfo = v27->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v27->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + 1);
          }
          break;
        case TILE_HAS_EVENT|LOCATION_EXPANSION_DWELLING:
          game::WeeklyRecruitSite((int)(&this->map.tiles[k * this->map.width].groundIndex + 6 * l));
          break;
        case TILE_HAS_EVENT|LOCATION_ALCHEMIST_TOWER:
          game::WeeklyGenericSite(&this->map.tiles[k * this->map.width] + l);
          break;
        case TILE_HAS_EVENT|LOCATION_ROAD:
        case TILE_HAS_EVENT|LOCATION_EVENT:
        case TILE_HAS_EVENT|LOCATION_LIGHTHOUSE:
        case TILE_HAS_EVENT|LOCATION_MINE:
        case TILE_HAS_EVENT|LOCATION_OBELISK:
        case TILE_HAS_EVENT|LOCATION_OASIS:
        case TILE_HAS_EVENT|LOCATION_RESOURCE:
        case TILE_HAS_EVENT|LOCATION_ARMY_CAMP|LOCATION_SKELETON:
        case TILE_HAS_EVENT|LOCATION_SAWMILL:
        case TILE_HAS_EVENT|LOCATION_ORACLE:
        case TILE_HAS_EVENT|LOCATION_SHRINE_FIRST:
        case TILE_HAS_EVENT|LOCATION_SHIPWRECK:
        case TILE_HAS_EVENT|LOCATION_SEA_CHEST:
        case TILE_HAS_EVENT|LOCATION_TOWN:
        case TILE_HAS_EVENT|LOCATION_STONE_LITHS:
        case TILE_HAS_EVENT|LOCATION_WELL:
        case TILE_HAS_EVENT|LOCATION_WHIRLPOOL:
        case TILE_HAS_EVENT|LOCATION_ARTIFACT:
        case TILE_HAS_EVENT|LOCATION_HERO:
        case TILE_HAS_EVENT|LOCATION_BOAT:
        case TILE_HAS_EVENT|LOCATION_WINDMILL|LOCATION_SKELETON:
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT:
        case TILE_HAS_EVENT|LOCATION_RANDOM_RESOURCE:
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER:
        case TILE_HAS_EVENT|LOCATION_RANDOM_TOWN:
        case TILE_HAS_EVENT|LOCATION_RANDOM_CASTLE:
        case TILE_HAS_EVENT|LOCATION_RANDOM_TOWN|LOCATION_SIGN:
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_WEAK:
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_MEDIUM:
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_STRONG:
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_VERY_STRONG:
        case TILE_HAS_EVENT|LOCATION_RANDOM_HERO:
        case TILE_HAS_EVENT|LOCATION_NOTHING_SPECIAL:
        case TILE_HAS_EVENT|LOCATION_NOTHING_SPECIAL|LOCATION_ALCHEMIST_LAB:
        case TILE_HAS_EVENT|LOCATION_FORT:
        case TILE_HAS_EVENT|LOCATION_TRADING_POST:
        case TILE_HAS_EVENT|LOCATION_ABANDONED_MINE:
        case TILE_HAS_EVENT|LOCATION_STANDING_STONES:
        case TILE_HAS_EVENT|LOCATION_IDOL:
        case TILE_HAS_EVENT|LOCATION_TREE_OF_KNOWLEDGE:
        case TILE_HAS_EVENT|LOCATION_WITCH_DOCTORS_HUT:
        case TILE_HAS_EVENT|LOCATION_TEMPLE:
        case TILE_HAS_EVENT|LOCATION_HILL_FORT:
        case TILE_HAS_EVENT|LOCATION_MERCENARY_CAMP:
        case TILE_HAS_EVENT|LOCATION_SHRINE_SECOND_ORDER:
        case TILE_HAS_EVENT|LOCATION_SHRINE_THIRD_ORDER:
        case TILE_HAS_EVENT|LOCATION_PYRAMID:
        case TILE_HAS_EVENT|LOCATION_SPHINX:
        case TILE_HAS_EVENT|LOCATION_WAGON:
        case TILE_HAS_EVENT|LOCATION_TAR_PIT:
        case TILE_HAS_EVENT|LOCATION_WATERING_HOLE:
        case TILE_HAS_EVENT|LOCATION_WITCH_HUT:
        case TILE_HAS_EVENT|LOCATION_XANADU:
        case TILE_HAS_EVENT|LOCATION_LEAN_TO:
        case TILE_HAS_EVENT|LOCATION_MAGELLANS_MAPS:
        case TILE_HAS_EVENT|LOCATION_FLOTSAM:
        case TILE_HAS_EVENT|LOCATION_DERELICT_SHIP:
        case TILE_HAS_EVENT|LOCATION_SHIPWRECK_SURVIVOR:
        case TILE_HAS_EVENT|LOCATION_BOTTLE:
        case TILE_HAS_EVENT|LOCATION_MAGIC_WELL:
        case TILE_HAS_EVENT|LOCATION_OBSERVATION_TOWER:
        case TILE_HAS_EVENT|LOCATION_FREEMANS_FOUNDRY:
        case TILE_HAS_EVENT|LOCATION_STREAM:
        case TILE_HAS_EVENT|LOCATION_TREES:
        case TILE_HAS_EVENT|LOCATION_MOUNTAINS:
        case TILE_HAS_EVENT|LOCATION_VOLCANO:
        case TILE_HAS_EVENT|LOCATION_FLOWERS:
        case TILE_HAS_EVENT|LOCATION_ROCK:
        case TILE_HAS_EVENT|LOCATION_LAKE:
        case TILE_HAS_EVENT|LOCATION_MANDRAKE:
        case TILE_HAS_EVENT|LOCATION_DEAD_TREE:
        case TILE_HAS_EVENT|LOCATION_STUMP:
        case TILE_HAS_EVENT|LOCATION_CRATER:
        case TILE_HAS_EVENT|LOCATION_CACTUS:
        case TILE_HAS_EVENT|LOCATION_MOUND:
        case TILE_HAS_EVENT|LOCATION_DUNE:
        case TILE_HAS_EVENT|LOCATION_LAVA_POOL:
        case TILE_HAS_EVENT|LOCATION_SHRUB:
        case TILE_HAS_EVENT|LOCATION_HOLE:
        case TILE_HAS_EVENT|LOCATION_OUTCROPPING:
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_TREASURE:
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_MINOR:
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_MAJOR:
        case TILE_HAS_EVENT|LOCATION_BARRIER:
        case TILE_HAS_EVENT|LOCATION_TRAVELLER_TENT:
          continue;
      }
    }
  }
  for ( playerIdxb = 0; playerIdxb < 54; ++playerIdxb )
  {
    if ( BYTE2(this->heroes[playerIdxb].flags) & 0x80 )
      this->heroes[playerIdxb].flags -= 0x800000;
  }
  ++this->week;
  game::SetupNewRumour(this);
  game::GiveTroopsToNeutralTowns(this);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (00426B80) --------------------------------------------------------
__int16 __stdcall game::WeeklyRecruitSite(int a1)
{
  __int16 result; // ax@10
  signed int v2; // [sp+14h] [bp-Ch]@1
  __int16 v3; // [sp+18h] [bp-8h]@1

  v3 = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7;
  v2 = (signed int)(unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) >> 3;
  switch ( ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7 )
  {
    case 0:
      v2 += Random(2, 5);
      break;
    case 1:
      v2 += Random(2, 5);
      break;
    case 2:
      v2 += Random(2, 5);
      break;
    case 3:
      v2 += Random(2, 5);
      break;
    case 4:
      v2 += Random(2, 5);
      break;
    default:
      break;
  }
  if ( v2 > 1000 )
    LOWORD(v2) = 1000;
  result = *(_WORD *)(a1 + 4) & 7 | 8 * (v3 | 8 * v2);
  *(_WORD *)(a1 + 4) = result;
  return result;
}

//----- (00426CB0) --------------------------------------------------------
unsigned __int16 __stdcall game::WeeklyGenericSite(mapCell *a1)
{
  unsigned __int16 result; // ax@1

  result = ((unsigned __int8)(a1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x3F;
  if ( (((unsigned __int8)(a1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x3F) == 4 )
  {
    result = 8 * (((unsigned __int8)(a1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x3F) | a1->field_4_1_1_isShadow_1_13_extraInfo & 7;
    a1->field_4_1_1_isShadow_1_13_extraInfo = result;
  }
  return result;
}

//----- (00426D20) --------------------------------------------------------
void __thiscall game::PerMonth(game *this)
{
  __int16 v1; // ST1C_2@35
  char *v3; // [sp+18h] [bp-1Ch]@10
  signed int j; // [sp+1Ch] [bp-18h]@8
  mapCell *v5; // [sp+20h] [bp-14h]@30
  int v6; // [sp+24h] [bp-10h]@1
  signed int i; // [sp+24h] [bp-10h]@6
  int row; // [sp+28h] [bp-Ch]@28
  int col; // [sp+2Ch] [bp-8h]@26
  __int16 v10; // [sp+30h] [bp-4h]@11

  ++this->month;
  v6 = Random(1, 10);
  if ( v6 > 5 )
  {
    if ( v6 > 9 )
    {
      giMonthType = 2;
    }
    else
    {
      giMonthType = 1;
      giMonthTypeExtra = byte_4EF660[Random(0, 11)];
    }
  }
  else
  {
    giMonthType = 0;
    giMonthTypeExtra = Random(0, 9);
  }
  for ( i = 0; i < 72; ++i )
  {
    for ( j = 19; j <= 30; ++j )
    {
      v3 = (char *)&this->castles[i];
      if ( (1 << j) & this->castles[i].buildingsBuiltFlags )
      {
        v10 = gMonsterDatabase[LOBYTE((&gTownObjNames[3 * this->castles[i].factionID + 27])[j + 1])].growth;
        if ( this->castles[i].buildingsBuiltFlags & 0x10 )
          v10 += 2;
        if ( j == 19 && BYTE1(this->castles[i].buildingsBuiltFlags) & 8 )
          v10 += 8;
        if ( giMonthType == 1
          && LOBYTE((&gTownObjNames[3 * this->castles[i].factionID + 27])[j + 1]) == giMonthTypeExtra )
          *(_WORD *)&v3[2 * j - 8] *= 2;
        if ( giMonthType == 2 )
        {
          *(_WORD *)&v3[2 * j - 8] -= v10;
          if ( (signed int)*(_WORD *)&v3[2 * j - 8] < 0 )
            *(_WORD *)&v3[2 * j - 8] = 0;
          *(_WORD *)&v3[2 * j - 8] >>= 1;
        }
      }
    }
  }
  if ( giMonthType == 1 )
  {
    for ( col = 0; col < MAP_WIDTH; ++col )
    {
      for ( row = 0; row < MAP_HEIGHT; ++row )
      {
        v5 = advManager::GetCell(gpAdvManager, col, row);
        if ( !v5->objType )
        {
          if ( !((v5->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1) )
          {
            if ( !(v5->field_4_1_1_isShadow_1_13_extraInfo & 1) )
            {
              if ( giGroundToTerrain[v5->groundIndex] )
              {
                if ( Random(0, 360) == 10 )
                {
                  v5->objType = -104;
                  v5->bitfield_1_hasObject_1_isRoad_6_objTileset = v5->bitfield_1_hasObject_1_isRoad_6_objTileset & 3 | 0x30;
                  v5->objectIndex = giMonthTypeExtra;
                  v1 = game::GetRandomNumTroops(this, giMonthTypeExtra);
                  v5->field_4_1_1_isShadow_1_13_extraInfo = v5->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * (game::GetRandomNumTroops(this, giMonthTypeExtra) + v1);
                  if ( Random(0, 100) < 20 )
                    v5->field_4_1_1_isShadow_1_13_extraInfo = v5->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(v5->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) | 0x1000);
                }
              }
            }
          }
        }
      }
    }
  }
  advManager::CompleteDraw(gpAdvManager, 0);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (004270A0) --------------------------------------------------------
void __thiscall game::ConvertObject(game *this, int x1, int y1, int x2, int y2, int fromObjTileset, signed int fromObjIndexLow, signed int fromObjIndexHigh, char toObjTileset, char toObjectIndexLow, int fromObjType, char toObjType)
{
  mapCell *tile; // [sp+10h] [bp-10h]@11
  mapCellExtra *cellExtra; // [sp+14h] [bp-Ch]@20 MAPDST
  int j; // [sp+18h] [bp-8h]@3
  int i; // [sp+1Ch] [bp-4h]@1

  for ( i = x1; x2 >= i; ++i )
  {
    for ( j = y1; y2 >= j; ++j )
    {
      if ( i >= 0 && MAP_WIDTH > i && j >= 0 && j < MAP_HEIGHT )
      {
        tile = &this->map.tiles[j * this->map.width] + i;
        if ( tile->objectIndex != 255
          && (((unsigned __int8)tile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == fromObjTileset
          && tile->objectIndex >= fromObjIndexLow
          && tile->objectIndex <= fromObjIndexHigh )
        {
          tile->bitfield_1_hasObject_1_isRoad_6_objTileset = 4 * toObjTileset | tile->bitfield_1_hasObject_1_isRoad_6_objTileset & 3;
          tile->objectIndex = toObjectIndexLow + tile->objectIndex - fromObjIndexLow;
        }
        if ( (tile->objType & 0x7F) == fromObjType )
          tile->objType = toObjType | tile->objType & 0x80;
        if ( tile->extraIdx && this->map.cellExtras[tile->extraIdx].objectIndex != 255 )
          cellExtra = &this->map.cellExtras[tile->extraIdx];
        else
          cellExtra = 0;
        while ( cellExtra )
        {
          if ( ((cellExtra->_1_q_7_objTileset >> 1) & 0x7F) == fromObjTileset
            && cellExtra->objectIndex >= fromObjIndexLow
            && cellExtra->objectIndex <= fromObjIndexHigh )
          {
            cellExtra->_1_q_7_objTileset = 2 * toObjTileset | cellExtra->_1_q_7_objTileset & 1;
            cellExtra->objectIndex = toObjectIndexLow + cellExtra->objectIndex - fromObjIndexLow;
          }
          if ( cellExtra->nextIdx && this->map.cellExtras[cellExtra->nextIdx].objectIndex != 255 )
            cellExtra = &this->map.cellExtras[cellExtra->nextIdx];
          else
            cellExtra = 0;
        }
        if ( tile->overlayIndex != 255
          && (((unsigned __int8)tile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F) == fromObjTileset
          && tile->overlayIndex >= fromObjIndexLow
          && tile->overlayIndex <= fromObjIndexHigh )
        {
          tile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset = 4 * toObjTileset | tile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset & 3;
          tile->overlayIndex = toObjectIndexLow + tile->overlayIndex - fromObjIndexLow;
        }
        if ( tile->extraIdx && this->map.cellExtras[tile->extraIdx].field_6 != 255 )
          cellExtra = &this->map.cellExtras[tile->extraIdx];
        else
          cellExtra = 0;
        while ( cellExtra )
        {
          if ( (((unsigned __int8)cellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F) == fromObjTileset
            && cellExtra->field_6 >= fromObjIndexLow
            && cellExtra->field_6 <= fromObjIndexHigh )
          {
            cellExtra->_1_q_1_hasLateOverlay_6_q = 4 * toObjTileset | cellExtra->_1_q_1_hasLateOverlay_6_q & 3;
            cellExtra->field_6 = toObjectIndexLow + cellExtra->field_6 - fromObjIndexLow;
          }
          if ( cellExtra->nextIdx && this->map.cellExtras[cellExtra->nextIdx].field_6 != 255 )
            cellExtra = &this->map.cellExtras[cellExtra->nextIdx];
          else
            cellExtra = 0;
        }
      }
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00427520) --------------------------------------------------------
int __thiscall game::RandomizeTown(void *this, int a2, int a3, int a4)
{
  int result; // eax@4
  void *thisa; // [sp+Ch] [bp-1Ch]@1
  signed int v6; // [sp+10h] [bp-18h]@1
  void *v7; // [sp+14h] [bp-14h]@1
  char v8; // [sp+24h] [bp-4h]@2

  thisa = this;
  v6 = game::GetTownId((game *)this, a2, a3);
  v7 = ppMapExtra[(unsigned __int8)((unsigned __int8)(*(_WORD *)(*(_DWORD *)((char *)thisa + 2878)
                                                               + 12 * a3 * *(_DWORD *)((char *)thisa + 2886)
                                                               + 12 * a2
                                                               + 4) >> 8) >> -5)];
  if ( *(_BYTE *)v7 == -1 )
    v8 = Random(0, 5);
  else
    v8 = *((_BYTE *)thisa + gcColorToSetupPos[*(_BYTE *)v7] + 1113);
  *((_WORD *)thisa + 50 * v6 + 1492) = 10;
  game::ConvertObject((game *)thisa, a2 - 5, a3 - 3, a2 + 2, a3 + 1, 38, 0, 31, 35, 32 * v8, 48, 35);
  game::ConvertObject((game *)thisa, a2 - 5, a3 - 3, a2 + 2, a3 + 1, 38, 32, 255, 37, 32 * v8, 48, 35);
  game::ConvertObject((game *)thisa, a2 - 5, a3 - 3, a2 + 2, a3 + 1, 38, 0, 31, 35, 32 * v8, 49, 35);
  game::ConvertObject((game *)thisa, a2 - 5, a3 - 3, a2 + 2, a3 + 1, 38, 32, 255, 37, 32 * v8, 49, 35);
  LOBYTE(result) = v8;
  *((_BYTE *)thisa + 100 * v6 + 2902) = v8;
  return result;
}

//----- (004276F0) --------------------------------------------------------
int __thiscall game::RandomizeMine(int this, int a2, int a3)
{
  int v3; // ecx@47
  int v4; // ST4C_4@57
  int result; // eax@60
  int thisa; // [sp+24h] [bp-48h]@1
  char v7; // [sp+48h] [bp-24h]@28
  signed int v8; // [sp+4Ch] [bp-20h]@51
  signed int j; // [sp+50h] [bp-1Ch]@51
  signed int i; // [sp+54h] [bp-18h]@1
  signed int k; // [sp+58h] [bp-14h]@53
  char v12; // [sp+5Ch] [bp-10h]@47
  int v13; // [sp+60h] [bp-Ch]@0
  int v14; // [sp+64h] [bp-8h]@1
  char v15; // [sp+68h] [bp-4h]@16

  thisa = this;
  v14 = (unsigned __int8)giGroundToTerrain[*(_WORD *)(*(_DWORD *)(thisa + 2878)
                                                    + 12 * a3 * *(_DWORD *)(thisa + 2886)
                                                    + 12 * a2)];
  for ( i = 0; i < 30; ++i )
  {
    switch ( v14 )
    {
      case 1:
      case 6:
        v13 = Random(1, 6);
        if ( v13 == 1 )
          v13 = 0;
        break;
      case 2:
        v13 = Random(2, 6);
        break;
      case 3:
        v13 = Random(0, 6);
        break;
      case 4:
        v13 = 1;
        break;
      default:
        v13 = Random(1, 6);
        break;
    }
    if ( !word_522FA0[v13] )
      i = 30;
  }
  ++word_522FA0[v13];
  if ( v13 )
  {
    if ( v13 == 1 )
    {
      v15 = 25;
    }
    else if ( v14 == 1 )
    {
      v15 = 15;
    }
    else if ( v14 == 2 )
    {
      v15 = 19;
    }
    else
    {
      v15 = 9;
    }
  }
  else
  {
    v15 = 5;
  }
  if ( v13 )
  {
    if ( v13 == 1 )
    {
      if ( v14 == 3 )
      {
        v7 = 43;
      }
      else if ( v14 == 4 )
      {
        v7 = 35;
      }
      else
      {
        v7 = 27;
      }
    }
    else
    {
      switch ( v14 )
      {
        case 1:
          v7 = 17;
          break;
        case 2:
          v7 = 21;
          break;
        case 3:
          v7 = 23;
          break;
        case 5:
          v7 = 13;
          break;
        default:
          v7 = 11;
          break;
      }
    }
  }
  else
  {
    v7 = 7;
  }
  *(_BYTE *)(*(_DWORD *)(thisa + 2878) + 12 * a3 * *(_DWORD *)(thisa + 2886) + 12 * a2 + 3) = v7;
  *(_BYTE *)(*(_DWORD *)(thisa + 2878) + 12 * a3 * *(_DWORD *)(thisa + 2886) + 4 * (3 * a2 + 3) + 3) = v7 + 1;
  *(_BYTE *)(*(_DWORD *)(thisa + 2878) + 12 * (a3 - 1) * *(_DWORD *)(thisa + 2886) + 12 * a2 + 7) = v15;
  *(_BYTE *)(*(_DWORD *)(thisa + 2878) + 12 * (a3 - 1) * *(_DWORD *)(thisa + 2886) + 4 * (3 * a2 + 3) + 7) = v15 + 1;
  if ( v13 == 1 )
  {
    v3 = *(_DWORD *)(thisa + 2878) + 12 * a3 * *(_DWORD *)(thisa + 2886) + 4 * (3 * a2 + 3);
    *(_BYTE *)(v3 + 2) |= 1u;
    v12 = 1;
  }
  else if ( v13 )
  {
    fullMap::ChangeTilesetIndex(
      (fullMap *)(thisa + 2878),
      (mapCell *)(*(_DWORD *)(thisa + 2878) + 12 * a3 * *(_DWORD *)(thisa + 2886) + 4 * (3 * a2 + 3)),
      a2 + 1,
      a3,
      29,
      v13 - 2,
      0,
      -1);
    v12 = 23;
  }
  else
  {
    v12 = 29;
  }
  v8 = game::GetMineId((game *)thisa, a2, a3);
  for ( j = 0; j < 2; ++j )
  {
    for ( k = 0; k < 2; ++k )
    {
      if ( (*(_BYTE *)(12 * (a2 + k) + 12 * (a3 - j) * *(_DWORD *)(thisa + 2886) + *(_DWORD *)(thisa + 2878) + 9) & 0x7F) <= 0
        || (*(_BYTE *)(12 * (a2 + k) + 12 * (a3 - j) * *(_DWORD *)(thisa + 2886) + *(_DWORD *)(thisa + 2878) + 9) & 0x7Fu) > 0x30 )
      {
        v4 = *(_DWORD *)(thisa + 2878) + 12 * (a2 + k) + 12 * (a3 - j) * *(_DWORD *)(thisa + 2886);
        *(_WORD *)(v4 + 4) = *(_WORD *)(v4 + 4) & 7 | 8 * v8;
        *(_BYTE *)(*(_DWORD *)(thisa + 2878) + 12 * (a2 + k) + 12 * (a3 - j) * *(_DWORD *)(thisa + 2886) + 9) = v12;
      }
    }
  }
  result = *(_DWORD *)(thisa + 2878) + 12 * a3 * *(_DWORD *)(thisa + 2886) + 12 * a2;
  *(_BYTE *)(result + 9) |= 0x80u;
  LOBYTE(result) = v13;
  *(_BYTE *)(7 * v8 + thisa + 23736) = v13;
  return result;
}
// 522FA0: using guessed type __int16 word_522FA0[];

//----- (00427D10) --------------------------------------------------------
int __thiscall game::InitRandomArtifacts(game *this)
{
  int result; // eax@2
  mapCell *v3; // [sp+10h] [bp-10h]@5
  int j; // [sp+18h] [bp-8h]@3
  int i; // [sp+1Ch] [bp-4h]@1

  memset(this->artifactGeneratedRandomly, 0, 0x67u);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( MAP_WIDTH <= i )
      break;
    for ( j = 0; j < MAP_HEIGHT; ++j )
    {
      v3 = &this->map.tiles[j * this->map.width] + i;
      if ( v3->objType == 169 )
        this->artifactGeneratedRandomly[v3->objectIndex >> 1] = 1;
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00427DE0) --------------------------------------------------------
int __thiscall game::GetRandomArtifactId(game *this, char allowedLevels, int allowNegatives)
{
  signed int v3; // ST10_4@19
  int tries; // [sp+14h] [bp-8h]@1
  int randArtifact; // [sp+18h] [bp-4h]@3

  tries = 0;
  while ( 1 )
  {
    if ( xIsExpansionMap )
      randArtifact = Random(0, NUM_EXPANSION_ARTIFACTS);
    else
      randArtifact = Random(0, NUM_BASE_ARTIFACTS);
    if ( (unsigned __int8)(gArtifactLevel[randArtifact] & allowedLevels)
      && randArtifact != ARTIFACT_NONE1
      && randArtifact != ARTIFACT_NONE2
      && randArtifact != ARTIFACT_NONE3
      && randArtifact != ARTIFACT_NONE4
      && randArtifact != ARTIFACT_SPELL_SCROLL
      && (!xIsPlayingExpansionCampaign
       || randArtifact != ARTIFACT_BREASTPLATE_OF_ANDURAN
       && randArtifact != ARTIFACT_BATTLE_GARB_OF_ANDURAN
       && randArtifact != ARTIFACT_HELMET_OF_ANDURAN
       && randArtifact != ARTIFACT_SWORD_OF_ANDURAN
       && randArtifact != ARTIFACT_SPHERE_OF_NEGATION) )
    {
      v3 = tries++;
      if ( v3 >= 100 || !this->artifactGeneratedRandomly[randArtifact] )
      {
        if ( (!IsCursedItem(randArtifact) || allowNegatives && Random(0, 100) >= 30)
          && (this->mapHeader.winConditionType != WIN_CONDITION_FIND_ARTIFACT
           || this->mapHeader.winConditionArgument - 1 != randArtifact) )
          break;
      }
    }
  }
  this->artifactGeneratedRandomly[randArtifact] = 1;
  return randArtifact;
}
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (00427F80) --------------------------------------------------------
bool __fastcall IsCursedItem(int art)
{
  return art == ARTIFACT_FIZBIN_OF_MISFOURTUNE
      || art == ARTIFACT_HIDEOUS_MASK
      || art == ARTIFACT_TAX_LIEN
      || art == ARTIFACT_ARM_OF_THE_MARTYR
      || art == ARTIFACT_BROACH_OF_SHIELDING
      || art == ARTIFACT_HEART_OF_FIRE
      || art == ARTIFACT_HEART_OF_ICE;
}

//----- (00427FF0) --------------------------------------------------------
void __thiscall game::RandomizeHeroPool(game *this)
{
  signed int idx; // [sp+10h] [bp-4h]@1

  for ( idx = 0; idx < 54; ++idx )
  {
    this->heroes[idx].experience = Random(0, 50) + 40;
    game::SetRandomHeroArmies(this, idx, 0);
    this->heroes[idx].remainingMobility = hero::CalcMobility(&this->heroes[idx]);
    this->heroes[idx].mobility = this->heroes[idx].remainingMobility;
    this->heroes[idx].randomSeed = Random(1, 255);
    this->heroes[idx].wisdomLastOffered = 1;
    switch ( this->heroes[idx].factionID )
    {
      case FACTION_SORCERESS:
        this->heroes[idx].spellsLearned[14] = 1;
        break;
      case FACTION_WARLOCK:
        this->heroes[idx].spellsLearned[18] = 1;
        break;
      case FACTION_NECROMANCER:
        this->heroes[idx].spellsLearned[9] = 1;
        break;
      case FACTION_WIZARD:
        this->heroes[idx].spellsLearned[16] = 1;
        break;
    }
  }
}

//----- (004281E0) --------------------------------------------------------
int __thiscall game::SetRandomHeroArmies(void *this, _DWORD a2, unsigned int a3)
{
  int result; // eax@1
  void *v4; // [sp+Ch] [bp-90h]@1
  _DWORD v5; // [sp+10h] [bp-8Ch]@1
  int v6; // [sp+14h] [bp-88h]@9
  signed int i; // [sp+18h] [bp-84h]@3
  signed int j; // [sp+18h] [bp-84h]@6
  int v9; // [sp+1Ch] [bp-80h]@9
  __int16 v10; // [sp+20h] [bp-7Ch]@1
  __int16 v11; // [sp+22h] [bp-7Ah]@1
  __int16 v12; // [sp+24h] [bp-78h]@1
  __int16 v13; // [sp+26h] [bp-76h]@1
  __int16 v14; // [sp+28h] [bp-74h]@1
  __int16 v15; // [sp+2Ah] [bp-72h]@1
  __int16 v16; // [sp+2Ch] [bp-70h]@1
  __int16 v17; // [sp+2Eh] [bp-6Eh]@1
  __int16 v18; // [sp+30h] [bp-6Ch]@1
  __int16 v19; // [sp+32h] [bp-6Ah]@1
  __int16 v20; // [sp+34h] [bp-68h]@1
  __int16 v21; // [sp+36h] [bp-66h]@1
  __int16 v22; // [sp+38h] [bp-64h]@1
  __int16 v23; // [sp+3Ah] [bp-62h]@1
  __int16 v24; // [sp+3Ch] [bp-60h]@1
  __int16 v25; // [sp+3Eh] [bp-5Eh]@1
  __int16 v26; // [sp+40h] [bp-5Ch]@1
  __int16 v27; // [sp+42h] [bp-5Ah]@1
  __int16 v28; // [sp+44h] [bp-58h]@1
  __int16 v29; // [sp+46h] [bp-56h]@1
  __int16 v30; // [sp+48h] [bp-54h]@1
  __int16 v31; // [sp+4Ah] [bp-52h]@1
  __int16 v32; // [sp+4Ch] [bp-50h]@1
  __int16 v33; // [sp+4Eh] [bp-4Eh]@1
  __int16 v34; // [sp+50h] [bp-4Ch]@1
  __int16 v35; // [sp+52h] [bp-4Ah]@1
  __int16 v36; // [sp+54h] [bp-48h]@1
  __int16 v37; // [sp+56h] [bp-46h]@1
  __int16 v38; // [sp+58h] [bp-44h]@1
  __int16 v39; // [sp+5Ah] [bp-42h]@1
  __int16 v40; // [sp+5Ch] [bp-40h]@1
  __int16 v41; // [sp+5Eh] [bp-3Eh]@1
  __int16 v42; // [sp+60h] [bp-3Ch]@1
  __int16 v43; // [sp+62h] [bp-3Ah]@1
  __int16 v44; // [sp+64h] [bp-38h]@1
  __int16 v45; // [sp+66h] [bp-36h]@1
  __int16 v46; // [sp+68h] [bp-34h]@1
  __int16 v47; // [sp+6Ah] [bp-32h]@1
  __int16 v48; // [sp+6Ch] [bp-30h]@1
  __int16 v49; // [sp+6Eh] [bp-2Eh]@1
  __int16 v50; // [sp+70h] [bp-2Ch]@1
  __int16 v51; // [sp+72h] [bp-2Ah]@1
  __int16 v52; // [sp+74h] [bp-28h]@1
  __int16 v53; // [sp+76h] [bp-26h]@1
  __int16 v54; // [sp+78h] [bp-24h]@1
  __int16 v55; // [sp+7Ah] [bp-22h]@1
  __int16 v56; // [sp+7Ch] [bp-20h]@1
  __int16 v57; // [sp+7Eh] [bp-1Eh]@1
  __int16 v58; // [sp+80h] [bp-1Ch]@1
  __int16 v59; // [sp+82h] [bp-1Ah]@1
  __int16 v60; // [sp+84h] [bp-18h]@1
  __int16 v61; // [sp+86h] [bp-16h]@1
  __int16 v62; // [sp+88h] [bp-14h]@1
  __int16 v63; // [sp+8Ah] [bp-12h]@1
  char *v64; // [sp+8Ch] [bp-10h]@1
  int v65; // [sp+90h] [bp-Ch]@1
  bool v66; // [sp+94h] [bp-8h]@1
  bool v67; // [sp+98h] [bp-4h]@1

  v4 = this;
  v64 = (char *)this + 250 * a2 + 10281;
  v5 = 0;
  v10 = 0;
  v11 = 30;
  v12 = 50;
  v13 = 1;
  v14 = 3;
  v15 = 5;
  v16 = 3;
  v17 = 2;
  v18 = 4;
  v19 = 11;
  v20 = 15;
  v21 = 25;
  v22 = 12;
  v23 = 3;
  v24 = 5;
  v25 = 14;
  v26 = 2;
  v27 = 3;
  v28 = 20;
  v29 = 10;
  v30 = 20;
  v31 = 21;
  v32 = 2;
  v33 = 4;
  v34 = 23;
  v35 = 1;
  v36 = 2;
  v37 = 29;
  v38 = 6;
  v39 = 10;
  v40 = 30;
  v41 = 2;
  v42 = 4;
  v43 = 31;
  v44 = 1;
  v45 = 2;
  v46 = 38;
  v47 = 6;
  v48 = 10;
  v49 = 39;
  v50 = 2;
  v51 = 4;
  v52 = 40;
  v53 = 1;
  v54 = 2;
  v55 = 47;
  v56 = 6;
  v57 = 10;
  v58 = 48;
  v59 = 2;
  v60 = 4;
  v61 = 50;
  v62 = 1;
  v63 = 2;
  v65 = 1;
  v66 = Random(0, 99) < (a3 < 1 ? 50 : 80);
  result = Random(0, 99);
  v67 = (a3 < 1 ? 25 : 65) > result;
  if ( (a3 < 1 ? 25 : 65) <= result )
    v66 = 1;
  for ( i = 0; i < 5; ++i )
  {
    v64[i] = -1;
    result = i;
    *(_WORD *)&v64[2 * i + 5] = -1;
  }
  for ( j = 0; j < 2; ++j )
  {
    result = j;
    if ( *(&v65 + j) )
    {
      v64[v5] = *((_BYTE *)&v10 + 18 * *((_BYTE *)v4 + 250 * a2 + 10203) + 6 * j);
      v9 = 10 * *(&v11 + 9 * *((_BYTE *)v4 + 250 * a2 + 10203) + 3 * j);
      v6 = 10 * *(&v12 + 9 * *((_BYTE *)v4 + 250 * a2 + 10203) + 3 * j) + 9;
      if ( a3 )
        v9 = (v6 + v9) / 2;
      result = Random(v9, v6) / 10;
      *(_WORD *)&v64[2 * v5++ + 5] = result;
    }
  }
  return result;
}
// 4281E0: too many cbuild loops

//----- (00428580) --------------------------------------------------------
int __thiscall game::ProcessRandomObjects(game *this)
{
  int result; // eax@5
  char v2; // ST70_1@40
  char v3; // ST70_1@41
  char v4; // ST70_1@42
  char v5; // ST70_1@43
  int v7; // [sp+2Ch] [bp-20h]@32
  mapCell *cell; // [sp+30h] [bp-1Ch]@9
  int v9; // [sp+34h] [bp-18h]@13
  int y2; // [sp+38h] [bp-14h]@4
  signed int i; // [sp+3Ch] [bp-10h]@1
  int x2; // [sp+40h] [bp-Ch]@6
  int v13; // [sp+48h] [bp-4h]@13

  giUABaseX = -1;
  giUABaseY = -1;
  giUARadius = 0;
  for ( i = 0; i < 7; ++i )
    word_522FA0[i] = 0;
  for ( y2 = 0; ; ++y2 )
  {
    result = MAP_HEIGHT;
    if ( y2 >= MAP_HEIGHT )
      break;
    for ( x2 = 0; x2 < MAP_WIDTH; ++x2 )
    {
      cell = &this->map.tiles[y2 * this->map.width] + x2;
      switch ( cell->objType )
      {
        case TILE_HAS_EVENT|LOCATION_WINDMILL|LOCATION_SKELETON:
          giUABaseX = x2;
          giUABaseY = y2;
          giUARadius = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          cell->objType = 0;
          cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 3u;
          cell->objectIndex = -1;
          continue;
        case TILE_HAS_EVENT|LOCATION_RANDOM_TOWN:
          game::RandomizeTown(this, x2, y2, 0);
          continue;
        case TILE_HAS_EVENT|LOCATION_RANDOM_CASTLE:
          game::RandomizeTown(this, x2, y2, 1);
          continue;
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER:
          v13 = 80;
          v9 = 2000;
          goto LABEL_18;
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_WEAK:
          v13 = 0;
          v9 = 400;
          goto LABEL_18;
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_MEDIUM:
          v13 = 400;
          v9 = 1000;
          goto LABEL_18;
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_STRONG:
          v13 = 1000;
          v9 = 2500;
          goto LABEL_18;
        case TILE_HAS_EVENT|LOCATION_RANDOM_MONSTER_VERY_STRONG:
          v13 = 2500;
          v9 = 100000;
LABEL_18:
          if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 12
            && cell->objectIndex >= 67
            && cell->objectIndex <= 70 )
          {
            switch ( cell->objectIndex )
            {
              case 0x43:
                v13 = 0;
                v9 = 400;
                break;
              case 0x44:
                v13 = 400;
                v9 = 1000;
                break;
              case 0x45:
                v13 = 1000;
                v9 = 2500;
                break;
              case 0x46:
                v13 = 2500;
                v9 = 100000;
                break;
              default:
                break;
            }
          }
          cell->objType = -104;
          for ( cell->objectIndex = Random(0, 65);
                gMonsterDatabase[cell->objectIndex].fight_value <= v13
             || gMonsterDatabase[cell->objectIndex].fight_value >= v9;
                cell->objectIndex = Random(0, 65) )
            ;
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_RESOURCE:
          cell->objType = -101;
          v7 = Random(0, 6);
          game::ConvertObject(this, x2 - 1, y2, x2 - 1, y2, 46, 16, 16, 46, 2 * v7, -1, -1);
          game::ConvertObject(this, x2, y2, x2, y2, 46, 17, 17, 46, 2 * v7 + 1, -1, -1);
          if ( v7 && v7 != 2 )
          {
            if ( v7 == 6 )
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(5, 10);
            else
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(3, 7);
          }
          else
          {
            cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * Random(8, 16);
          }
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT:
          v2 = game::GetRandomArtifactId(this, 14, 0);
          cell->objType = -87;
          game::ConvertObject(this, x2 - 1, y2, x2 - 1, y2, 11, 162, 162, 11, 2 * v2, -1, -1);
          game::ConvertObject(this, x2, y2, x2, y2, 11, 163, 163, 11, 2 * v2 + 1, -1, -1);
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_TREASURE:
          v3 = game::GetRandomArtifactId(this, 8, 0);
          cell->objType = -87;
          game::ConvertObject(this, x2 - 1, y2, x2 - 1, y2, 11, 166, 166, 11, 2 * v3, -1, -1);
          game::ConvertObject(this, x2, y2, x2, y2, 11, 167, 167, 11, 2 * v3 + 1, -1, -1);
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_MINOR:
          v4 = game::GetRandomArtifactId(this, 4, 0);
          cell->objType = -87;
          game::ConvertObject(this, x2 - 1, y2, x2 - 1, y2, 11, 168, 168, 11, 2 * v4, -1, -1);
          game::ConvertObject(this, x2, y2, x2, y2, 11, 169, 169, 11, 2 * v4 + 1, -1, -1);
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_ARTIFACT_MAJOR:
          v5 = game::GetRandomArtifactId(this, 2, 0);
          cell->objType = -87;
          game::ConvertObject(this, x2 - 1, y2, x2 - 1, y2, 11, 170, 170, 11, 2 * v5, -1, -1);
          game::ConvertObject(this, x2, y2, x2, y2, 11, 171, 171, 11, 2 * v5 + 1, -1, -1);
          break;
        case TILE_HAS_EVENT|LOCATION_RANDOM_TOWN|LOCATION_SIGN:
          game::RandomizeMine((int)this, x2, y2);
          break;
        default:
          continue;
      }
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 522F90: using guessed type __int16 giUARadius;
// 522FA0: using guessed type __int16 word_522FA0[];
// 522FB4: using guessed type __int16 giUABaseX;
// 522FB8: using guessed type __int16 giUABaseY;

//----- (00428CD0) --------------------------------------------------------
int __thiscall game::SetVisibility(game *this, int x, int y, int playerIdx, signed int radius)
{
  int result; // eax@12
  int v6; // ebx@24
  char playerBit; // [sp+1Ch] [bp-18h]@1
  int i; // [sp+20h] [bp-14h]@11
  int point[2]; // [sp+20h] [bp-14h]@20
  int j; // [sp+24h] [bp-10h]@13
  int v11; // [sp+30h] [bp-4h]@8

  playerBit = 1 << playerIdx;
  if ( !gbHumanPlayer[playerIdx] )
  {
    if ( giCurTurn <= 40 )
    {
      if ( giCurTurn <= 20 )
        ++radius;
      else
        radius += 2;
    }
    else
    {
      radius += 3;
    }
  }
  if ( radius < 5 )
    v11 = 2;
  else
    v11 = 3;
  if ( radius < 10 )
  {
    for ( point[0] = y - radius; ; ++point[0] )
    {
      result = y + radius;
      if ( y + radius < point[0] )
        break;
      for ( point[1] = x - radius; radius + x >= point[1]; ++point[1] )
      {
        v6 = radius + radius - abs(y - point[0]);
        if ( v11 <= v6 - abs(x - point[1]) && *(_QWORD *)point >= 0i64 && MAP_WIDTH > point[1] && point[0] < MAP_HEIGHT )
          *(&mapRevealed[point[1]] + point[0] * MAP_WIDTH) |= playerBit;
      }
    }
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      result = MAP_HEIGHT;
      if ( i >= MAP_HEIGHT )
        break;
      for ( j = 0; MAP_WIDTH > j; ++j )
      {
        if ( (signed int)(signed __int64)sqrt((double)((y - i) * (y - i) + (x - j) * (x - j))) < radius )
          *(&mapRevealed[j] + i * MAP_WIDTH) |= playerBit;
      }
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 532C54: using guessed type int giCurTurn;

//----- (00428F00) --------------------------------------------------------
void __thiscall game::MakeAllWaterVisible(game *this, char playerIdx)
{
  int row; // [sp+14h] [bp-8h]@3
  int col; // [sp+18h] [bp-4h]@1

  for ( col = 0; MAP_WIDTH > col; ++col )
  {
    for ( row = 0; row < MAP_HEIGHT; ++row )
    {
      if ( !giGroundToTerrain[*(&this->map.tiles[row * this->map.width].groundIndex + 6 * col)] )
        *(&mapRevealed[col] + MAP_WIDTH * row) |= 1 << playerIdx;
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00428FE0) --------------------------------------------------------
void __stdcall game::GiveArmy(armyGroup *arm, int creatureType, int amt, signed int slot)
{
  signed int i; // [sp+14h] [bp-4h]@2

  if ( slot >= 0 )
  {
    i = slot;
    arm->creatureTypes[slot] = creatureType;
    arm->quantities[slot] = 0;
LABEL_14:
    arm->creatureTypes[i] = creatureType;
    arm->quantities[i] += amt;
    return;
  }
  for ( i = 0; i < 5 && arm->creatureTypes[i] != creatureType; ++i )
    ;
  if ( i >= 5 )
  {
    for ( i = 0; i < 5; ++i )
    {
      if ( arm->creatureTypes[i] < 0 )
      {
        arm->quantities[i] = 0;
        break;
      }
    }
  }
  if ( i < 5 )
    goto LABEL_14;
}

//----- (004290E0) --------------------------------------------------------
int __stdcall game::ExperienceValueOfStack(int a1, int a2)
{
  int v3; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v3 = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( (signed int)*(_WORD *)(a1 + 2 * i + 5) > 0 )
      v3 += *(_WORD *)(a1 + 2 * i + 5) * gMonsterDatabase[*(_BYTE *)(i + a1)].hp;
  }
  if ( a2 )
    v3 += 500;
  return v3;
}

//----- (00429180) --------------------------------------------------------
int __stdcall game::GetLuck(hero *hro, army *stack, town *castle)
{
  int result; // eax@2
  signed int artifactLuck; // [sp+10h] [bp-4h]@3
  int totLuck; // [sp+10h] [bp-4h]@14

  if ( hro )
  {
    artifactLuck = 0;
    if ( hero::HasArtifact(hro, ARTIFACT_LUCKY_RABBITS_FOOT) )
      artifactLuck = 1;
    if ( hero::HasArtifact(hro, ARTIFACT_GOLDEN_HORSESHOE) )
      ++artifactLuck;
    if ( hero::HasArtifact(hro, ARTIFACT_GAMBLERS_LUCKY_COIN) )
      ++artifactLuck;
    if ( hero::HasArtifact(hro, ARTIFACT_FOUR_LEAF_CLOVER) )
      ++artifactLuck;
    if ( hero::HasArtifact(hro, ARTIFACT_MASTHEAD) && hro->flags & HERO_AT_SEA )
      ++artifactLuck;
    totLuck = hro->secondarySkillLevel[9] + hro->tempLuckBonuses + artifactLuck;
    if ( castle
      && castle->factionID == FACTION_SORCERESS
      && BYTE1(castle->buildingsBuiltFlags) & BUILDING_SPECIAL_DEFENSE_BUILT )
      totLuck += 2;
    if ( totLuck < -3 )
      totLuck = -3;
    if ( totLuck > 3 )
      totLuck = 3;
    if ( hero::HasArtifact(hro, ARTIFACT_BATTLE_GARB_OF_ANDURAN) )
      totLuck = 3;
    result = totLuck;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004292B0) --------------------------------------------------------
void __thiscall game::SetupAdjacentMons(game *this)
{
  int a4; // [sp+10h] [bp-14h]@5
  int a3; // [sp+14h] [bp-10h]@5
  unsigned __int8 v3; // [sp+18h] [bp-Ch]@1
  int j; // [sp+1Ch] [bp-8h]@3
  int i; // [sp+20h] [bp-4h]@1

  v3 = 0x7Fu;
  for ( i = 0; MAP_WIDTH > i; ++i )
  {
    for ( j = 0; j < MAP_HEIGHT; ++j )
    {
      if ( advManager::FindAdjacentMonster(gpAdvManager, i, j, (int)&a3, (int)&a4, -1, -1) )
        *(&mapRevealed[i] + MAP_WIDTH * j) |= 0x80u;
      else
        *(&mapRevealed[i] + MAP_WIDTH * j) &= v3;
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (004293B0) --------------------------------------------------------
void __cdecl game::CancelComputerScreen()
{
  int fieldID; // [sp+10h] [bp-4h]@1

  game::TurnOffAIMusic();
  bShowIt = 1;
  for ( fieldID = 1; fieldID <= 6; ++fieldID )
    heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 6, fieldID, 16392);
}
// 524C14: using guessed type int bShowIt;

//----- (00429420) --------------------------------------------------------
void __cdecl game::ShowComputerScreen()
{
  signed __int8 v0; // [sp+10h] [bp-8h]@2
  int fieldID; // [sp+14h] [bp-4h]@2

  if ( *(_DWORD *)&blackoutComputer )
  {
    v0 = gbThisNetHumanPlayer[giCurPlayer];
    gbThisNetHumanPlayer[giCurPlayer] = 1;
    for ( fieldID = 1; fieldID <= 6; ++fieldID )
      heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, fieldID, 16392);
    gbAllBlack = 1;
    advManager::CompleteDraw(gpAdvManager, 1);
    advManager::UpdateHeroLocators(gpAdvManager, 1, 1);
    advManager::UpdateTownLocators(gpAdvManager, 1, 1);
    advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
    advManager::UpdateScreen(gpAdvManager, 0, 1);
    gbAllBlack = 0;
    gbThisNetHumanPlayer[giCurPlayer] = v0;
  }
  game::ShowHeroesLogo();
}
// 4F7470: using guessed type int gbAllBlack;

//----- (00429510) --------------------------------------------------------
void __cdecl game::ShowHeroesLogo()
{
  icon *v0; // ST34_4@2

  if ( !gpAdvManager->field_37A )
  {
    gpAdvManager->field_37A = 1;
    v0 = resourceManager::GetIcon(gpResourceManager, "herologo.icn");
    IconToBitmap(v0, gpWindowManager->screenBuffer, 480, 16, 0, 0, 0, 0, 0x280u, 480, 0);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 480, 16, 0x90u, 144);
    resourceManager::Dispose(gpResourceManager, (resource *)v0);
  }
}

//----- (004295B0) --------------------------------------------------------
void __stdcall game::WaitForPlayer(char *a1, int a2)
{
  if ( gbBlackoutPlayer && iLastMsgNumHumanPlayers > 1 )
  {
    if ( !gbRemoteOn )
    {
      mouseManager::SetPointer(gpMouseManager, 0);
      gbAllBlack = 1;
      giBottomViewOverrideEndTime = KBTickCount() + 9999999;
      giBottomViewOverride = gbThisNetHumanPlayer[giCurPlayer] != 0;
      *(_DWORD *)(gpSoundManager + 1672) = 1;
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 21);
      advManager::CompleteDraw(gpAdvManager, 1);
      advManager::UpdateHeroLocators(gpAdvManager, 1, 1);
      advManager::UpdateTownLocators(gpAdvManager, 1, 1);
      advManager::UpdateScreen(gpAdvManager, 0, 1);
      game::ShowHeroesLogo();
      gbAllBlack = 0;
      NormalDialog(a1, 1, -1, -1, 9, gpGame->players[a2].color, -1, 0, -1, 0);
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
    }
  }
}
// 4F7470: using guessed type int gbAllBlack;
// 4F7494: using guessed type int gbRemoteOn;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 52473C: using guessed type int gbBlackoutPlayer;
// 524798: using guessed type int giBottomViewOverrideEndTime;

//----- (00429700) --------------------------------------------------------
signed int __thiscall game::HasLateOverlay(game *this, int x, int y)
{
  signed int result; // eax@2
  mapCell *cell; // [sp+10h] [bp-8h]@1
  mapCellExtra *cellExtra; // [sp+14h] [bp-4h]@4

  cell = &this->map.tiles[y * this->map.width] + x;
  if ( ((unsigned __int8)cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 1) & 1 )
  {
    result = 1;
  }
  else
  {
    if ( cell->extraIdx )
      cellExtra = &this->map.cellExtras[cell->extraIdx];
    else
      cellExtra = 0;
    while ( cellExtra )
    {
      if ( ((unsigned __int8)cellExtra->_1_q_1_hasLateOverlay_6_q >> 1) & 1 )
        return 1;
      if ( cellExtra->nextIdx )
        cellExtra = &this->map.cellExtras[cellExtra->nextIdx];
      else
        cellExtra = 0;
    }
    result = 0;
  }
  return result;
}

//----- (00429810) --------------------------------------------------------
void __thiscall game::ConvertFlagToLateOverlay(game *this, int x, int y)
{
  mapCell *cell; // [sp+10h] [bp-8h]@1
  mapCellExtra *cellExtra; // [sp+14h] [bp-4h]@4

  cell = &this->map.tiles[y * this->map.width] + x;
  if ( (((unsigned __int8)cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F) == 14 )
    cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset |= 2u;
  if ( cell->extraIdx )
    cellExtra = &this->map.cellExtras[cell->extraIdx];
  else
    cellExtra = 0;
  while ( cellExtra )
  {
    if ( (((unsigned __int8)cellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F) == 14 )
      cellExtra->_1_q_1_hasLateOverlay_6_q |= 2u;
    if ( cellExtra->nextIdx )
      cellExtra = &this->map.cellExtras[cellExtra->nextIdx];
    else
      cellExtra = 0;
  }
}

//----- (00429930) --------------------------------------------------------
signed int __thiscall game::HasObjectTilesetIndex(game *this, int x, int y, int tset, int index)
{
  signed int result; // eax@3
  mapCell *cell; // [sp+10h] [bp-8h]@1
  mapCellExtra *cellExtra; // [sp+14h] [bp-4h]@5

  cell = &this->map.tiles[y * this->map.width] + x;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != tset
    || cell->objectIndex != index )
  {
    if ( cell->extraIdx )
      cellExtra = &this->map.cellExtras[cell->extraIdx];
    else
      cellExtra = 0;
    while ( cellExtra )
    {
      if ( ((cellExtra->_1_q_7_objTileset >> 1) & 0x7F) == tset && cellExtra->objectIndex == index )
        return 1;
      if ( cellExtra->nextIdx )
        cellExtra = &this->map.cellExtras[cellExtra->nextIdx];
      else
        cellExtra = 0;
    }
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00429A70) --------------------------------------------------------
void __thiscall game::ConvertAllToLateOverlay(game *this, int x, int y)
{
  mapCell *cell; // [sp+10h] [bp-8h]@1
  mapCellExtra *v5; // [sp+14h] [bp-4h]@4

  cell = &this->map.tiles[y * this->map.width] + x;
  if ( cell->overlayIndex != 255 )
    cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset |= 2u;
  if ( cell->extraIdx )
    v5 = &this->map.cellExtras[cell->extraIdx];
  else
    v5 = 0;
  while ( v5 )
  {
    if ( v5->field_6 != 255 )
      v5->_1_q_1_hasLateOverlay_6_q |= 2u;
    if ( v5->nextIdx )
      v5 = &this->map.cellExtras[v5->nextIdx];
    else
      v5 = 0;
  }
}

//----- (00429B90) --------------------------------------------------------
int __thiscall game::ProcessMapExtra(game *this)
{
  signed int v1; // ST20_4@6
  int result; // eax@28
  signed int v3; // [sp+Ch] [bp-20h]@5
  mapCell *cell; // [sp+14h] [bp-18h]@5
  mapCell *cella; // [sp+14h] [bp-18h]@16
  int y; // [sp+1Ch] [bp-10h]@1
  int ya; // [sp+1Ch] [bp-10h]@12
  int yb; // [sp+1Ch] [bp-10h]@27
  int x; // [sp+20h] [bp-Ch]@3
  int xa; // [sp+20h] [bp-Ch]@14
  int xb; // [sp+20h] [bp-Ch]@29

  for ( y = 0; MAP_HEIGHT > y; ++y )
  {
    for ( x = 0; x < MAP_WIDTH; ++x )
    {
      cell = &this->map.tiles[y * this->map.width] + x;
      v3 = cell->objType;
      if ( v3 == 163 || v3 >= 176 && v3 <= 177 )
      {
        v1 = game::GetTownId(this, x, y);
        this->castles[v1].extraIdx = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
        cell->field_4_1_1_isShadow_1_13_extraInfo = 8 * v1 | cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
      }
    }
  }
  for ( ya = 0; MAP_HEIGHT > ya; ++ya )
  {
    for ( xa = 0; xa < MAP_WIDTH; ++xa )
    {
      cella = &this->map.tiles[ya * this->map.width] + xa;
      if ( cella->objType == 151 && ya > 0 && game::HasLateOverlay(this, xa, ya - 1) )
        game::ConvertFlagToLateOverlay(this, xa, ya);
      if ( cella->objType == 129 )
      {
        if ( ya > 0 )
          game::ConvertFlagToLateOverlay(this, xa, ya - 1);
        if ( ya > 1 )
          game::ConvertFlagToLateOverlay(this, xa, ya - 2);
      }
    }
  }
  for ( yb = 0; ; ++yb )
  {
    result = yb;
    if ( MAP_HEIGHT <= yb )
      break;
    for ( xb = 0; xb < MAP_WIDTH; ++xb )
    {
      if ( game::HasLateOverlay(this, xb, yb) )
        game::ConvertAllToLateOverlay(this, xb, yb);
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00429E30) --------------------------------------------------------
void __thiscall game::SetupTowns(game *this)
{
  char v3[10]; // [sp+14h] [bp-A0h]@22
  int v4; // [sp+20h] [bp-94h]@22
  int v5; // [sp+24h] [bp-90h]@92
  int numSpellsOfLevel[5]; // [sp+28h] [bp-8Ch]@52
  int k; // [sp+3Ch] [bp-78h]@52
  int j; // [sp+40h] [bp-74h]@50
  int spell; // [sp+44h] [bp-70h]@87
  int randNum; // [sp+48h] [bp-6Ch]@63
  bool hasAdventureSpellAtLevel; // [sp+4Ch] [bp-68h]@81
  int playerPos; // [sp+50h] [bp-64h]@6
  char spellPresent[68]; // [sp+54h] [bp-60h]@50
  int tries; // [sp+98h] [bp-1Ch]@86 MAPDST
  TownExtra *twn; // [sp+9Ch] [bp-18h]@5
  int i; // [sp+A4h] [bp-10h]@9
  int castleIdx; // [sp+A8h] [bp-Ch]@1
  town *castle; // [sp+ACh] [bp-8h]@5
  int v19; // [sp+B0h] [bp-4h]@5

  for ( castleIdx = 0; castleIdx < 72; ++castleIdx )
  {
    if ( this->castles[castleIdx].exists )
    {
      castle = &this->castles[castleIdx];
      v19 = this->castles[castleIdx].extraIdx;
      twn = (TownExtra *)ppMapExtra[v19];
      if ( twn->color == -1 )
        playerPos = -1;
      else
        playerPos = gcColorToPlayerPos[twn->color];
      game::ClaimTown(this, castleIdx, playerPos, 0);
      castle->playerPos = playerPos;
      if ( twn->customGarrison )
      {
        for ( i = 0; i < 5; ++i )
        {
          castle->garrison.quantities[i] = twn->garrison.quantities[i];
          if ( castle->garrison.quantities[i] <= 0 )
            castle->garrison.creatureTypes[i] = -1;
          else
            castle->garrison.creatureTypes[i] = twn->garrison.creatureTypes[i];
        }
      }
      else
      {
        for ( i = 0; i < 5; ++i )
        {
          castle->garrison.quantities[i] = 0;
          castle->garrison.creatureTypes[i] = -1;
        }
        game::GiveTroopsToNeutralTown(this, castleIdx);
        game::GiveTroopsToNeutralTown(this, castleIdx);
        game::GiveTroopsToNeutralTown(this, castleIdx);
        game::GiveTroopsToNeutralTown(this, castleIdx);
      }
      if ( twn->customBuildings )
      {
        castle->buildingsBuiltFlags = castle->buildingsBuiltFlags & 0x60 | twn->buildingsBuilt & gTownEligibleBuildMask[castle->factionID];
        castle->mageGuildLevel = twn->mageGuildLevel;
      }
      else
      {
        v3[0] = 1;
        v3[1] = 1;
        v3[2] = 1;
        v3[3] = 2;
        v3[4] = 1;
        v3[5] = 1;
        v3[6] = 1;
        v3[7] = 2;
        v3[8] = 1;
        v3[9] = 2;
        v4 = v3[Random(0, 99) / 10];
        castle->buildingsBuiltFlags |= 0x80000u;// Dwelling 1
        if ( !gbHumanPlayer[castle->ownerIdx] && v4 == 1 && Random(1, 10) < 4 )
          ++v4;
        --v4;
        if ( v4 )
        {
          castle->buildingsBuiltFlags |= 0x100000u;// Dwelling 2
          --v4;
        }
        castle->mageGuildLevel = 0;
      }
      for ( i = 25; i <= 30; ++i )
      {                                         // If upgrade built, non-upg not built
        if ( (1 << i) & castle->buildingsBuiltFlags )
        {
          if ( i == 30 )
            castle->buildingsBuiltFlags &= 0xDEFFFFFFu;
          else
            castle->buildingsBuiltFlags &= -1 - (1 << (i - 5));
        }
      }
      for ( i = 19; i <= 30; ++i )
      {
        if ( (1 << i) & castle->buildingsBuiltFlags )
          *(_WORD *)&castle[-1].name[2 * i + 5] = gMonsterDatabase[LOBYTE((&gTownObjNames[3 * castle->factionID + 27])[i + 1])].growth;
      }
      if ( castle->buildingsBuiltFlags & 1 )
      {
        for ( i = 1; castle->mageGuildLevel >= i; ++i )
        {
          castle->mageGuildSpells[4][i + 3] = byte_4F29FF[i];
          if ( castle->factionID == 4 && BYTE1(castle->buildingsBuiltFlags) & 0x20 )
            ++castle->mageGuildSpells[4][i + 3];
        }
      }
      if ( twn->hasCaptain )
        castle->buildingsBuiltFlags |= 0x8000u; // Captain
      castle->mayNotBeUpgradedToCastle = twn->mayNotBeUpgraded;
      strcpy(castle->name, twn->name);
      memset(spellPresent, 0, 0x41u);
      for ( j = 0; j < 5; ++j )
      {
        numSpellsOfLevel[j] = 0;
        for ( k = 0; k < 4; ++k )
          castle->mageGuildSpells[j][k] = -1;
      }
      if ( castle->factionID == FACTION_NECROMANCER && castle->ownerIdx != -1 && !gbHumanPlayer[castle->ownerIdx] )
      {
        if ( Random(0, 100) >= 50 )
          k = SPELL_DEATH_WAVE;
        else
          k = SPELL_DEATH_RIPPLE;
        j = gsSpellInfo[k].level - 1;
        castle->mageGuildSpells[j][numSpellsOfLevel[j]++] = k;
      }
      randNum = Random(0, 100);
      if ( randNum >= 25 )
      {
        if ( randNum >= 50 )
        {
          if ( randNum >= 75 )
            k = SPELL_CURE;
          else
            k = SPELL_ANTI_MAGIC;
        }
        else
        {
          k = SPELL_MASS_DISPEL;
        }
      }
      else
      {
        k = SPELL_DISPEL_MAGIC;
      }
      j = gsSpellInfo[k].level - 1;
      castle->mageGuildSpells[j][numSpellsOfLevel[j]++] = k;
      randNum = Random(0, 100);
      if ( randNum >= 20 )
      {
        if ( randNum >= 40 )
        {
          if ( randNum >= 60 )
          {
            if ( randNum >= 80 )
              k = SPELL_COLD_RING;
            else
              k = SPELL_COLD_RAY;
          }
          else
          {
            k = SPELL_FIREBALL;
          }
        }
        else
        {
          k = SPELL_LIGHTNING_BOLT;
        }
      }
      else
      {
        k = SPELL_MAGIC_ARROW;
      }
      j = gsSpellInfo[k].level - 1;
      castle->mageGuildSpells[j][numSpellsOfLevel[j]++] = k;
      for ( j = 0; j < 5; ++j )
      {
        hasAdventureSpellAtLevel = 0;
        for ( k = 0; k < 4; ++k )
        {
          if ( castle->mageGuildSpells[j][k] == -1 )
          {
            tries = 0;
            while ( 1 )
            {
              for ( spell = Random(0, 64); gsSpellInfo[spell].level - 1 != j; spell = Random(0, 64) )
                ;
              if ( castle->ownerIdx == -1 || gbHumanPlayer[castle->ownerIdx] )
                v5 = 1500;
              else
                v5 = gsSpellInfo[spell].appearingChance
                   * ((unsigned __int8)(gsSpellInfo[spell].attributes & ATTR_COMMON_SPELL) < 1u ? 1 : 4)
                   + 50;
              if ( spell == SPELL_DIMENSION_DOOR )
                v5 = 1500;
              if ( hasAdventureSpellAtLevel != 1 || !(gsSpellInfo[spell].attributes & ATTR_ADVENTURE_SPELL) )
              {
                if ( *(&gsSpellInfo[spell].nonMagicFactionAppearanceChance + castle->factionID) >= Random(0, 10) )
                {
                  ++tries;
                  if ( tries <= 500 )
                  {
                    if ( !spellPresent[spell] && Random(1, 1500) <= v5 )
                      break;
                  }
                }
              }
            }
            if ( gsSpellInfo[spell].attributes & ATTR_ADVENTURE_SPELL )
              ++hasAdventureSpellAtLevel;
            castle->mageGuildSpells[j][k] = spell;
            spellPresent[spell] = 1;
          }
          else
          {
            spellPresent[castle->mageGuildSpells[j][k]] = 1;
          }
        }
      }
      BaseFree(ppMapExtra[v19], (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF67C + 238);
      ppMapExtra[v19] = 0;
    }
  }
}
// 4EF67C: using guessed type __int16 word_4EF67C;
// 4F3D10: using guessed type char *gTownObjNames[32];
// 429E30: using guessed type char spellPresent[68];
// 429E30: using guessed type int numSpellsOfLevel[5];

//----- (0042A730) --------------------------------------------------------
void *__thiscall game::ProcessOnMapHeroes(game *this)
{
  void *result; // eax@1
  int v3; // [sp+18h] [bp-70h]@20
  signed int v4; // [sp+24h] [bp-64h]@25
  signed int k; // [sp+28h] [bp-60h]@36
  mapCell *cell; // [sp+2Ch] [bp-5Ch]@7
  int j; // [sp+30h] [bp-58h]@3
  signed int l; // [sp+34h] [bp-54h]@42
  signed int m; // [sp+34h] [bp-54h]@60
  signed int n; // [sp+34h] [bp-54h]@63
  int x; // [sp+38h] [bp-50h]@5
  char *thisa; // [sp+3Ch] [bp-4Ch]@32
  char v13[56]; // [sp+40h] [bp-48h]@1
  int v14; // [sp+78h] [bp-10h]@9
  heroMapExtra *mapExtra; // [sp+7Ch] [bp-Ch]@9
  char v16; // [sp+80h] [bp-8h]@9
  int i; // [sp+84h] [bp-4h]@1

  result = memset(v13, 0, 0x36u);
  for ( i = 0; i < 3; ++i )
  {
    for ( j = 0; ; ++j )
    {
      result = (void *)MAP_HEIGHT;
      if ( j >= MAP_HEIGHT )
        break;
      for ( x = 0; x < MAP_WIDTH; ++x )
      {
        cell = &this->map.tiles[j * this->map.width] + x;
        if ( (cell->objType & 0x7F) == 55 || cell->objType == 251 )
        {
          v16 = (cell->objType & 0x7F) == LOCATION_JAIL;
          v14 = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          mapExtra = (heroMapExtra *)ppMapExtra[v14];
          if ( !i )
          {
            if ( !mapExtra->field_11 || mapExtra->field_12 >= 54 || v13[mapExtra->field_12] )
            {
              mapExtra->field_3D = 0;
            }
            else
            {
              v13[mapExtra->field_12] = 1;
              mapExtra->field_3D = 1;
            }
            if ( v16 )
            {
              mapExtra->owner = -1;
            }
            else
            {
              mapExtra->owner = cell->objectIndex / 7;
              mapExtra->owner = gcColorToPlayerPos[mapExtra->owner];
            }
          }
          if ( i == 1 )
          {
            if ( v16 )
            {
              v3 = mapExtra->field_3C;
            }
            else
            {
              v3 = cell->objectIndex % 7;
              if ( v3 == 6 )
                v3 = this->field_459[gcColorToSetupPos[gpGame->players[mapExtra->owner].color]];
            }
            if ( mapExtra->field_3D )
            {
              this->heroes[mapExtra->field_12].factionID = v3;
            }
            else
            {
              v4 = game::RandomScan((int)v13, 9 * v3, 9, 1000, 0);
              if ( v4 == -1 )
              {
                v4 = game::RandomScan((int)v13, 0, 54, 10000, 0);
                v3 = v4 / 9;
              }
              v13[v4] = 1;
              this->heroes[v4].factionID = v3;
              if ( mapExtra->field_11 && mapExtra->field_12 >= 54 )
                this->heroes[v4].heroID = mapExtra->field_12;
              mapExtra->field_12 = v4;
            }
          }
          if ( i == 2 )
          {
            thisa = (char *)&this->heroes[mapExtra->field_12];
            if ( !v16 && mapExtra->field_28[19] )
            {
              LOBYTE(this->heroes[mapExtra->field_12].field_29) = x;
              thisa[42] = j;
              thisa[43] = mapExtra->field_3C;
            }
            if ( mapExtra->field_1 )
            {
              for ( k = 0; k < 5; ++k )
              {
                *(_WORD *)&thisa[2 * k + 106] = mapExtra->army.quantities[k];
                if ( (signed int)*(_WORD *)&thisa[2 * k + 106] <= 0 )
                  thisa[k + 101] = -1;
                else
                  thisa[k + 101] = mapExtra->army.creatureTypes[k];
              }
            }
            for ( l = 0; l < 3; ++l )
            {
              if ( mapExtra->artifacts[l] >= 0 )
                GiveArtifact((hero *)thisa, (ARTIFACT)mapExtra->artifacts[l], 1, -1);
            }
            if ( mapExtra->field_28[5] )
              strcpy(thisa + 10, &mapExtra->field_28[6]);
            *(_DWORD *)(thisa + 57) = 0;
            advManager::GiveExperience((hero *)thisa, *(_DWORD *)&mapExtra->field_17, 1);
            hero::CheckLevel((hero *)thisa);
            *(_DWORD *)(thisa + 25) = x;
            *(_DWORD *)(thisa + 29) = j;
            if ( v16 )
            {
              thisa[3] = -1;
              this->relatedToHeroForHireStatus[mapExtra->field_12] = 65;
            }
            else
            {
              thisa[3] = mapExtra->owner;
              this->relatedToHeroForHireStatus[mapExtra->field_12] = thisa[3];
              *(&this->players[0].heroesOwned[284 * thisa[3]] + this->players[thisa[3]].numHeroes++ - thisa[3]) = thisa[2];
            }
            if ( !v16 && j > 0 && *(&this->map.tiles[x].objType + 12 * (j - 1) * this->map.width) == 163 )
            {
              --thisa[42];
              --*(_DWORD *)(thisa + 29);
              this->castles[game::GetTownId(this, x, j - 1)].visitingHeroIdx = thisa[2];
            }
            if ( v16 )
            {
              cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * mapExtra->field_12;
            }
            else
            {
              cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 3u;
              cell->objectIndex = -1;
              cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
              cell->objType = 0;
            }
            if ( mapExtra->field_1B )
            {
              *((_DWORD *)thisa + 36) = 0;
              for ( m = 0; m < 14; ++m )
              {
                thisa[m + 116] = 0;
                thisa[m + 130] = 0;
              }
              for ( n = 0; n < 8; ++n )
              {
                if ( mapExtra->secondarySkills[n] != -1 )
                  hero::GiveSS((hero *)thisa, mapExtra->secondarySkills[n], *(&mapExtra->firstSecondarySkillLevel + n));
              }
            }
            if ( !v16 )
              game::SetVisibility(
                this,
                *(_DWORD *)(thisa + 25),
                *(_DWORD *)(thisa + 29),
                thisa[3],
                giVisRange[thisa[119]]);
            BaseFree(ppMapExtra[v14], (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF69C + 221);
            ppMapExtra[v14] = 0;
          }
        }
      }
    }
  }
  return result;
}
// 4EF69C: using guessed type __int16 word_4EF69C;
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 42A730: using guessed type char var_48[56];

//----- (0042AEB0) --------------------------------------------------------
void __thiscall game::CheckHeroConsistency(game *this)
{
  game *thisa; // [sp+Ch] [bp-28h]@1
  mapCell *v2; // [sp+18h] [bp-1Ch]@25
  signed int i; // [sp+1Ch] [bp-18h]@5
  signed int j; // [sp+1Ch] [bp-18h]@12
  signed int k; // [sp+1Ch] [bp-18h]@44
  signed int l; // [sp+1Ch] [bp-18h]@53
  signed int playerIdx; // [sp+20h] [bp-14h]@1
  int playerIdxa; // [sp+20h] [bp-14h]@9
  signed int playerIdxb; // [sp+20h] [bp-14h]@42
  signed int playerIdxc; // [sp+20h] [bp-14h]@51
  signed int sumSomething; // [sp+24h] [bp-10h]@1
  int row; // [sp+28h] [bp-Ch]@23
  int col; // [sp+2Ch] [bp-8h]@21
  hero *v14; // [sp+30h] [bp-4h]@27

  thisa = this;
  sumSomething = 0;
  for ( playerIdx = 0; this->numPlayers > playerIdx; ++playerIdx )
  {
    if ( !this->playerDead[playerIdx] )
    {
      sumSomething += this->players[playerIdx].numHeroes;
      for ( i = 0; this->players[playerIdx].numHeroes > i; ++i )
        ;
    }
  }
  for ( playerIdxa = 0; thisa->numPlayers > playerIdxa; ++playerIdxa )
  {
    if ( !thisa->playerDead[playerIdxa] )
    {
      for ( j = 0; j < 2; ++j )
      {
        if ( thisa->relatedToHeroForHireStatus[*(&thisa->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] >= 0
          && thisa->relatedToHeroForHireStatus[*(&thisa->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] <= 5
          || sumSomething < 40
          && thisa->relatedToHeroForHireStatus[*(&thisa->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] == -1 )
        {
          *(&thisa->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa) = game::GetNewHeroId(
                                                                                         thisa,
                                                                                         playerIdxa,
                                                                                         -1,
                                                                                         0);
          thisa->relatedToHeroForHireStatus[*(&thisa->players[0].heroesForPurchase[284 * playerIdxa] + j - playerIdxa)] = 64;
        }
      }
    }
  }
  for ( col = 0; col < MAP_WIDTH; ++col )
  {
    for ( row = 0; row < MAP_HEIGHT; ++row )
    {
      v2 = advManager::GetCell(gpAdvManager, col, row);
      if ( v2->objType == 170 )
      {
        if ( (signed int)(unsigned __int8)((unsigned __int8)(v2->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >= 54 )
        {
          v2->objType = 0;
        }
        else
        {
          v14 = &thisa->heroes[(unsigned __int8)((unsigned __int8)(v2->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
          if ( thisa->heroes[(unsigned __int8)((unsigned __int8)(v2->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].x != col
            || thisa->heroes[(unsigned __int8)((unsigned __int8)(v2->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].y != row )
          {
            v2->objType = 0;
            v2->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          }
          if ( v14->ownerIdx < 0 || v14->ownerIdx >= 6 )
          {
            if ( v14->occupiedObjType == 163 )
              gpGame->castles[v14->occupiedObjVal].visitingHeroIdx = -1;
            if ( v14->x != col || v14->y != row )
            {
              v2->objType = 0;
              v2->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
            }
            else
            {
              game::RestoreCell(v14->x, v14->y, v14->occupiedObjType, v14->occupiedObjVal, 0, 1);
            }
          }
        }
      }
    }
  }
  for ( playerIdxb = 0; playerIdxb < 54; ++playerIdxb )
  {
    for ( k = 0; k < 5; ++k )
    {
      if ( thisa->heroes[playerIdxb].army.creatureTypes[k] == -1 || thisa->heroes[playerIdxb].army.quantities[k] < 0 )
        thisa->heroes[playerIdxb].army.quantities[k] = 0;
    }
  }
  for ( playerIdxc = 0; playerIdxc < 72; ++playerIdxc )
  {
    for ( l = 0; l < 5; ++l )
    {
      if ( thisa->castles[playerIdxc].garrison.creatureTypes[l] == -1
        || thisa->castles[playerIdxc].garrison.quantities[l] < 0 )
        thisa->castles[playerIdxc].garrison.quantities[l] = 0;
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (0042B410) --------------------------------------------------------
signed int __thiscall game::TransmitSaveGame(void *this, int a2, int a3, int a4)
{
  int v4; // ST38_4@1
  int v5; // ST38_4@63
  void *thisa; // [sp+Ch] [bp-22Ch]@1
  int i; // [sp+10h] [bp-228h]@18
  void *buf; // [sp+24h] [bp-214h]@7
  void *v10; // [sp+28h] [bp-210h]@3
  LPVOID a1; // [sp+2Ch] [bp-20Ch]@5
  signed int v12; // [sp+34h] [bp-204h]@23
  UINT fd; // [sp+38h] [bp-200h]@7
  void *v14; // [sp+3Ch] [bp-1FCh]@1
  int j; // [sp+40h] [bp-1F8h]@25
  int k; // [sp+40h] [bp-1F8h]@36
  int l; // [sp+40h] [bp-1F8h]@41
  int nbytes; // [sp+44h] [bp-1F4h]@5
  signed int v19; // [sp+48h] [bp-1F0h]@1
  int v20; // [sp+4Ch] [bp-1ECh]@1
  int v21; // [sp+50h] [bp-1E8h]@18
  int v22; // [sp+54h] [bp-1E4h]@18
  size_t v23; // [sp+58h] [bp-1E0h]@29
  int v24; // [sp+5Ch] [bp-1DCh]@1
  int track; // [sp+60h] [bp-1D8h]@1
  int v26; // [sp+64h] [bp-1D4h]@10
  char v27; // [sp+6Ch] [bp-1CCh]@5
  int v28; // [sp+230h] [bp-8h]@14
  int v29; // [sp+234h] [bp-4h]@21

  thisa = this;
  advManager::TrimLoopingSounds(gpAdvManager, 4);
  v20 = 0;
  v14 = 0;
  v19 = 0;
  v24 = 0;
  track = -1;
  v4 = *(_DWORD *)(gpSoundManager + 1672);
  *(_DWORD *)(gpSoundManager + 1672) = 1;
  track = *(_BYTE *)(gpSoundManager + 1404);
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
  *(_DWORD *)(gpSoundManager + 1672) = v4;
  LogStr("Transmit Game Start");
  if ( gpAdvManager->ready == 1 )
    BVResMsg("Sending Data", -1, 0);
  AiPrint("Transmit Start - Compressing");
  v10 = BaseAlloc(0x1388u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 43);
  memset(v10, 0, 0x1388u);
  game::SaveGame((game *)thisa, (const char *)&gConfig + 366, 0, 0);
  if ( !gbUseDiffCompression )
    a4 = 1;
  CreateDiffFile((int)byte_5249A1, (int)byte_5249AE, (int)(&gConfig + 379), a2, a4);
  sprintf(&v27, "%s%s", ".\\DATA\\", &gConfig + 379);
  nbytes = FileSize(&v27);
  LogInt((int)"PostDiffFileSize", nbytes, -999, -999, -999, -999, -999, -999);
  a1 = BaseAlloc(0x100u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 63);
  if ( gbUseRegularCompression )
    v14 = BaseAlloc(nbytes + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 65);
  buf = BaseAlloc(nbytes + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 66);
  fd = open(&v27, 32768);
  if ( fd == -1 )
    FileError(&v27);
  if ( fd != -1 )
  {
    _read(fd, buf, nbytes);
    _close(fd);
    v26 = calc_crc_long((int)buf, nbytes);
    if ( gbUseRegularCompression )
      nbytes = EncodeData(v14, buf, nbytes);
    else
      v14 = buf;
    AiPrint("Transmit Start - Sending");
    if ( gbUseRegularCompression )
      v28 = calc_crc_long((int)v14, nbytes);
    else
      v28 = v26;
    LogInt((int)"Send", nbytes, v28, -999, -999, -999, -999, -999);
    *(_DWORD *)a1 = nbytes;
    *((_DWORD *)a1 + 1) = v26;
    *((_DWORD *)a1 + 2) = v28;
    *((_DWORD *)a1 + 3) = a3;
    v24 = TransmitAndWait(a1, a2, 0x10u, 1, 2, (int)&v20);
    if ( !v24 )
      ShutDown(0);
    v21 = (nbytes - 1) / 200 + 1;
    v22 = (nbytes - 1) / 200 / 100 + 1;
    for ( i = 0; i < v22; ++i )
    {
      if ( i + 1 == v22 )
        v29 = v21 - 100 * i;
      else
        v29 = 100;
      v12 = 0;
      while ( !v12 )
      {
        for ( j = 100 * i; v29 + 100 * i > j; ++j )
        {
          PollSound();
          CheckDoMain(0, 1);
          if ( !*((_BYTE *)v10 + j) )
          {
            if ( j + 1 == v21 )
              v23 = nbytes - 200 * j;
            else
              v23 = 200;
            *(_WORD *)a1 = j;
            memcpy((char *)a1 + 2, (char *)v14 + 200 * j, v23);
            v24 = TransmitRemoteData(a1, a2, v23 + 2, 3, 0, 1, -1);
            if ( !v24 )
              ShutDown(0);
          }
        }
        LogStr("PreWait");
        *(_WORD *)a1 = 100 * i;
        v24 = TransmitAndWait(a1, a2, 2u, 4, 5, (int)&v20);
        LogStr("PostWait");
        if ( !v24 )
          ShutDown(0);
        for ( k = 0; k < v29; ++k )
        {
          if ( (signed int)*(_BYTE *)(k + v20 + 9) > 0 )
            *((_BYTE *)v10 + 100 * i + k) = 1;
        }
        v12 = 1;
        for ( l = 100 * i; v29 + 100 * i > l; ++l )
        {
          if ( !*((_BYTE *)v10 + l) )
            v12 = 0;
        }
      }
    }
    v24 = TransmitRemoteData(0, a2, 0, 6, 1, 1, -1);
    if ( !v24 )
      ShutDown(0);
    v19 = 1;
  }
  if ( a1 )
    BaseFree(a1, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 199);
  if ( v14 )
    BaseFree(v14, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 200);
  if ( buf && v14 != buf )
    BaseFree(buf, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 201);
  if ( v10 )
    BaseFree(v10, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF6BC + 202);
  AiPrint("Transmit End");
  if ( gpAdvManager->ready == 1 )
  {
    giBottomViewOverride = 0;
    advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
  }
  if ( track != -1 )
  {
    v5 = *(_DWORD *)(gpSoundManager + 1672);
    *(_DWORD *)(gpSoundManager + 1672) = 1;
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, track);
    *(_DWORD *)(gpSoundManager + 1672) = v5;
  }
  return v19;
}
// 4EF6BC: using guessed type __int16 word_4EF6BC;
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 526DAC: using guessed type char gbUseDiffCompression;
// 526ED8: using guessed type char gbUseRegularCompression;

//----- (0042BCA0) --------------------------------------------------------
signed int __stdcall game::ReceiveSaveGame(size_t a1, int a2, int a3, int a4)
{
  int v4; // ST3C_4@3
  int v5; // ST64_4@3
  int v6; // edx@9
  int v7; // ST48_4@17
  int v8; // ST3C_4@46
  int v10; // [sp+Ch] [bp-210h]@16
  int v11; // [sp+18h] [bp-204h]@7
  void *v12; // [sp+20h] [bp-1FCh]@1
  const void *v13; // [sp+24h] [bp-1F8h]@7
  int v14; // [sp+28h] [bp-1F4h]@18
  int v15; // [sp+2Ch] [bp-1F0h]@32
  const void *v16; // [sp+30h] [bp-1ECh]@7
  int i; // [sp+34h] [bp-1E8h]@18
  int v18; // [sp+3Ch] [bp-1E0h]@30
  void *v19; // [sp+40h] [bp-1DCh]@13
  void *a1a; // [sp+48h] [bp-1D4h]@5
  int track; // [sp+4Ch] [bp-1D0h]@3
  signed int v22; // [sp+50h] [bp-1CCh]@1
  int v23; // [sp+54h] [bp-1C8h]@29
  char this; // [sp+58h] [bp-1C4h]@32

  LogInt((int)"FW1", a4, -999, -999, -999, -999, -999, -999);
  LogStr("RSG1");
  AiPrint("Receive Start - Getting Data");
  advManager::TrimLoopingSounds(gpAdvManager, 4);
  v12 = 0;
  v22 = 0;
  advManager::UnwindMapChangeQueue(gpAdvManager, 999, 0);
  if ( gpAdvManager->ready == 1 )
    BVResMsg("Receiving Data", -1, 0);
  v4 = *(_DWORD *)(gpSoundManager + 1672);
  track = *(_BYTE *)(gpSoundManager + 1404);
  *(_DWORD *)(gpSoundManager + 1672) = 1;
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
  *(_DWORD *)(gpSoundManager + 1672) = v4;
  LogStr("Begin Transmit Init Confirm");
  v5 = TransmitRemoteData(0, a4, 0, 2, 1, 1, -1);
  LogStr("End Transmit Init Confirm");
  if ( !v5 )
    ShutDown(0);
  a1a = BaseAlloc(0x1388u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 51);
  memset(a1a, 0, 0x1388u);
  if ( gbUseRegularCompression )
    v12 = BaseAlloc(0xAAE60u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 55);
  v13 = BaseAlloc(0x100u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 57);
  v16 = BaseAlloc(a1 + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 58);
  v11 = KBTickCount();
  LogInt((int)"FW2", a4, -999, -999, -999, -999, -999, -999);
  while ( !v22 )
  {
    PollSound();
    CheckDoMain(0, 1);
    if ( KBTickCount() > v11 + 90000 )
    {
      NormalDialog("Error receiving data.  Keep trying?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode == 30725 )
        v11 = KBTickCount();
      else
        ShutDown(0);
    }
    v19 = GetRemoteData(1, v6);
    if ( v19 && (*((_BYTE *)v19 + 5) == 2 || *((_BYTE *)v19 + 5) == 3) )
    {
      v11 = KBTickCount();
      v10 = *((_BYTE *)v19 + 6);
      switch ( v10 )
      {
        case 3:
          v7 = *(_WORD *)((char *)v19 + 9);
          *((_BYTE *)a1a + v7) = 1;
          memcpy((char *)v16 + 200 * v7, (char *)v19 + 11, *(_WORD *)((char *)v19 + 7) - 2);
          break;
        case 4:
          v14 = *(_WORD *)((char *)v19 + 9);
          for ( i = *(_WORD *)((char *)v19 + 9); v14 + 100 > i; ++i )
            *((_BYTE *)v13 + i - v14) = *((_BYTE *)a1a + i);
          LogInt((int)"FW3", a4, -999, -999, -999, -999, -999, -999);
          if ( !TransmitRemoteData(v13, a4, 0xC8u, 5, 1, 1, -1) )
            ShutDown(0);
          break;
        case 6:
          v22 = 1;
          break;
      }
    }
  }
  AiPrint("Receive Start - Decompressing Data");
  v23 = calc_crc_long((int)v16, a1);
  LogInt((int)"Receive", a1, v23, a3, -999, -999, -999, -999);
  if ( gbUseRegularCompression )
  {
    a1 = DecodeData(v12, v16, a1);
    v18 = calc_crc_long((int)v12, a1);
  }
  else
  {
    v12 = (void *)v16;
    v18 = v23;
  }
  LogInt((int)"Receive", a1, v18, a2, -999, -999, -999, -999);
  sprintf(&this, "%s%s", ".\\DATA\\", &gConfig + 340);
  v15 = open(&this, 33537, 128);
  if ( v15 == -1 )
    FileError(&this);
  _write(v15, v12, a1);
  _close(v15);
  if ( a1a )
    BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 161);
  if ( v13 )
    BaseFree((void *)v13, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 162);
  if ( v16 )
    BaseFree((void *)v16, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 163);
  if ( v12 && v16 != v12 )
    BaseFree(v12, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EF850 + 164);
  CreateJoinFile((int)byte_52497A, (int)byte_524994, (int)(&gConfig + 327));
  AiPrint("Receive End");
  if ( gpAdvManager->ready == 1 )
  {
    giBottomViewOverride = 0;
    advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
  }
  if ( track != -1 )
  {
    v8 = *(_DWORD *)(gpSoundManager + 1672);
    *(_DWORD *)(gpSoundManager + 1672) = 1;
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, track);
    *(_DWORD *)(gpSoundManager + 1672) = v8;
  }
  return 1;
}
// 4EF850: using guessed type __int16 word_4EF850;
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 526ED8: using guessed type char gbUseRegularCompression;

//----- (0042C420) --------------------------------------------------------
void __thiscall game::DoNewTurn(game *this)
{
  int v1; // eax@9
  game *thisa; // [sp+Ch] [bp-4Ch]@1
  int track; // [sp+10h] [bp-48h]@20
  char v4; // [sp+14h] [bp-44h]@23
  char a1; // [sp+48h] [bp-10h]@20

  thisa = this;
  game::CheckForTimeEvent(this);
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    giBottomViewOverrideEndTime = KBTickCount() + 3000;
    giBottomViewOverride = 1;
    advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
    advManager::SetInitialMapOrigin(gpAdvManager);
    advManager::CompleteDraw(gpAdvManager, 0);
    advManager::UpdateScreen(gpAdvManager, 0, 0);
    CheckEndGame(0, 0);
    if ( gpCurPlayer->field_43 >= 0 )
    {
      if ( gpCurPlayer->field_43 == 1 )
        sprintf(gText, off_4F6544, cPlayerNames[giCurPlayer]);
      else
        sprintf(gText, cNewTurn, cPlayerNames[giCurPlayer], gpCurPlayer->field_43);
      NormalDialog(gText, 1, -1, -1, 9, gpGame->players[(char)giCurPlayer].color, -1, 0, -1, 0);
    }
    if ( gpCurPlayer->numHeroes <= 0 )
    {
      if ( gpCurPlayer->numCastles > 0 )
        advManager::SetTownContext(gpAdvManager, gpCurPlayer->castlesOwned[0]);
    }
    else
    {
      v1 = playerData::NextHero(gpCurPlayer, 0);
      advManager::SetHeroContext(gpAdvManager, v1, 0);
    }
    advManager::CheckDimNextHeroBut();
    if ( thisa->day == 1 && (thisa->month != 1 || thisa->week != 1 || thisa->day != 1) )
    {
      if ( gbThisNetHumanPlayer[giCurPlayer] )
        *(_DWORD *)(gpSoundManager + 1672) = 1;
      if ( giWeekType != -1 )
      {
        if ( thisa->week == 1 )
        {
          track = 21;
          strcpy(&a1, "newmonth.82m");
          if ( giMonthType )
          {
            if ( giMonthType == 1 )
            {
              strcpy(&v4, gArmyNames[giMonthTypeExtra]);
              v4 -= 32;
              sprintf(gText, off_4F654C, gArmyNames[giMonthTypeExtra], &v4);
            }
            else
            {
              sprintf(gText, off_4F6550);
            }
          }
          else
          {
            sprintf(gText, off_4F6548, gMonthNames[giMonthTypeExtra]);
          }
        }
        else
        {
          track = 20;
          strcpy(&a1, "newweek.82m");
          if ( giWeekType )
          {
            strcpy(&v4, gArmyNames[giWeekTypeExtra]);
            v4 -= 32;
            sprintf(gText, off_4F6558, gArmyNames[giWeekTypeExtra], &v4);
          }
          else
          {
            sprintf(gText, off_4F6554, gWeekNames[giWeekTypeExtra]);
          }
        }
        soundManager::PlayAmbientMusic(gpSoundManager, track, 0, -1);
        mouseManager::SetPointer(gpMouseManager, 0);
        NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        soundManager::SwitchAmbientMusic(
          (soundManager *)gpSoundManager,
          (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
      }
    }
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
    advManager::SetEnvironmentOrigin(gpAdvManager, gpAdvManager->viewX + 7, gpAdvManager->viewY + 7, 1);
  }
  else
  {
    CheckEndGame(0, 0);
  }
}
// 4F6310: using guessed type char *gMonthNames[25];
// 4F6338: using guessed type char *gWeekNames[15];
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 524798: using guessed type int giBottomViewOverrideEndTime;

//----- (0042C880) --------------------------------------------------------
int __thiscall game::GetBoatsBuilt(game *this)
{
  signed int i; // [sp+10h] [bp-8h]@1
  int n; // [sp+14h] [bp-4h]@1

  n = 0;
  for ( i = 0; i < 48; ++i )
  {
    if ( this->boatBuilt[i] != -1 )
      ++n;
  }
  return n;
}

//----- (0042C8E0) --------------------------------------------------------
int __thiscall game::getNumberOfThievesGuilds(game *this, int playerIdx)
{
  int v3; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v3 = 0;
  for ( i = 0; this->players[playerIdx].numCastles > i; ++i )
  {
    if ( gpGame->castles[*(&this->players[0].castlesOwned[284 * playerIdx] + i - playerIdx)].buildingsBuiltFlags & 2 )
      ++v3;
  }
  return v3;
}

//----- (0042C980) --------------------------------------------------------
signed int __thiscall game::CalcDifficultyRating(game *this)
{
  signed int v2; // [sp+14h] [bp-4h]@1

  v2 = 0;
  if ( this->difficulty )
  {
    switch ( this->difficulty )
    {
      case 1:
        v2 = 80;
        break;
      case 2:
        v2 = 100;
        break;
      case 3:
        v2 = 120;
        break;
      case 4:
        v2 = 140;
        break;
    }
  }
  else
  {
    v2 = 50;
  }
  if ( LOBYTE(this->mapHeader.field_4) )
  {
    switch ( LOBYTE(this->mapHeader.field_4) )
    {
      case 1:
        v2 += 20;
        break;
      case 2:
        v2 += 40;
        break;
      case 3:
        v2 += 80;
        break;
    }
  }
  return v2;
}

//----- (0042CAA0) --------------------------------------------------------
int __fastcall CalcBaseScore(signed int a1)
{
  signed int v2; // [sp+38h] [bp-8h]@1
  int v3; // [sp+3Ch] [bp-4h]@9
  signed int v4; // [sp+3Ch] [bp-4h]@12

  v2 = a1;
  if ( gpGame->mapHeader.width == 144 )
  {
    v2 = (signed __int64)((double)a1 * 0.6);
  }
  else if ( gpGame->mapHeader.width == 108 )
  {
    v2 = (signed __int64)((double)a1 * 0.8);
  }
  else if ( gpGame->mapHeader.width != 72 && gpGame->mapHeader.width == 36 )
  {
    v2 = (signed __int64)((double)a1 * 1.4);
  }
  if ( v2 > 60 )
  {
    if ( v2 > 120 )
    {
      v4 = (signed __int64)((double)140 - 30.0);
      if ( v2 > 360 )
        v3 = (signed __int64)((double)(signed int)(signed __int64)((double)v4 - 60.0) - (double)(v2 - 360) * 0.125);
      else
        v3 = (signed __int64)((double)v4 - (double)(v2 - 120) * 0.25);
    }
    else
    {
      v3 = (signed __int64)((double)140 - (double)(v2 - 60) * 0.5);
    }
  }
  else
  {
    v3 = 200 - v2;
  }
  if ( v3 < 20 )
    v3 = 20;
  return v3;
}

//----- (0042CC90) --------------------------------------------------------
__int16 __stdcall game::RestoreCell(int a1, int a, int a2, __int16 a3, int a4, int a5)
{
  unsigned int v6; // eax@7
  mapCell *v8; // [sp+10h] [bp-4h]@2

  if ( a4 )
    v8 = (mapCell *)a4;
  else
    v8 = advManager::GetCell(gpAdvManager, a1, a);
  if ( a <= 0 || a2 != 163 || advManager::GetCell(gpAdvManager, a1, a - 1)->objType == 35 )
  {
    v8->objType = a2;
    LOWORD(v6) = 8 * a3 | v8->field_4_1_1_isShadow_1_13_extraInfo & 7;
    v8->field_4_1_1_isShadow_1_13_extraInfo = v6;
  }
  else
  {
    v8->objType = 0;
    v6 = (unsigned int)v8;
    *(_WORD *)(v6 + 4) &= 7u;
  }
  return v6;
}

//----- (0042CD50) --------------------------------------------------------
void *__thiscall game::SetMapSize(game *this, int w, int h)
{
  if ( MAP_HEIGHT != h || MAP_WIDTH != w || !bMapInitialized )
  {
    bMapInitialized = 1;
    MAP_WIDTH = w;
    MAP_HEIGHT = h;
    searchArray::Init(gpSearchArray);
  }
  if ( mapRevealed )
    BaseFree(mapRevealed, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA44 + 12);
  mapRevealed = (char *)BaseAlloc(MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA44 + 13);
  return memset(mapRevealed, 0, MAP_HEIGHT * MAP_WIDTH);
}
// 4EFA40: using guessed type char bMapInitialized;
// 4EFA44: using guessed type __int16 word_4EFA44;
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (0042CE40) --------------------------------------------------------
int __fastcall WriteDiffHeaderInfo(char a1, signed int a2, int a3, int a4)
{
  signed int v4; // ecx@2
  int result; // eax@2
  char v6; // [sp+1Ch] [bp-4h]@1

  v6 = a1 << 7;
  if ( a2 <= 8191 )
  {
    if ( a2 <= 31 )
    {
      *(_BYTE *)(*(_DWORD *)a4 + a3) = a2 | v6;
      result = a4;
      ++*(_DWORD *)result;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)a4 + a3) = BYTE1(a2) & 0x1F | v6 | 0x20;
      *(_BYTE *)(*(_DWORD *)a4 + a3 + 1) = a2;
      result = a4;
      *(_DWORD *)result += 2;
    }
  }
  else
  {
    v4 = a2;
    *(_BYTE *)(*(_DWORD *)a4 + a3) = ((v4 & 0x2F0000u) >> 16) | v6 | 0x40;
    *(_WORD *)(*(_DWORD *)a4 + a3 + 1) = a2;
    result = a4;
    *(_DWORD *)result += 3;
  }
  return result;
}

//----- (0042CF40) --------------------------------------------------------
int __fastcall GetSkipCopyLen(int a1, int a2)
{
  int v3; // [sp+14h] [bp-8h]@2
  char v4; // [sp+18h] [bp-4h]@1

  v4 = *(_BYTE *)(*(_DWORD *)a2 + a1);
  if ( v4 & 0x40 )
  {
    v3 = *(_WORD *)(*(_DWORD *)a2 + a1 + 1) | ((v4 & 0x3F) << 16);
    *(_DWORD *)a2 += 3;
  }
  else if ( v4 & 0x20 )
  {
    v3 = *(_BYTE *)(*(_DWORD *)a2 + a1 + 1) | ((v4 & 0x1F) << 8);
    *(_DWORD *)a2 += 2;
  }
  else
  {
    v3 = v4 & 0x1F;
    ++*(_DWORD *)a2;
  }
  return v3;
}

//----- (0042CFF0) --------------------------------------------------------
void __fastcall CreateDiffFile(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@7
  int v6; // ecx@11
  int v7; // [sp+Ch] [bp-44h]@1
  int v8; // [sp+10h] [bp-40h]@1
  signed int nbytes; // [sp+14h] [bp-3Ch]@5
  void *buf; // [sp+18h] [bp-38h]@5
  UINT v11; // [sp+20h] [bp-30h]@8
  signed int i; // [sp+28h] [bp-28h]@20
  void *buf2; // [sp+2Ch] [bp-24h]@1
  unsigned int v14; // [sp+30h] [bp-20h]@1
  int fd; // [sp+34h] [bp-1Ch]@5
  size_t v16; // [sp+38h] [bp-18h]@15
  void *v17; // [sp+3Ch] [bp-14h]@1
  int a1a; // [sp+40h] [bp-10h]@1
  int v19; // [sp+44h] [bp-Ch]@1
  int v20; // [sp+48h] [bp-8h]@36
  int v21; // [sp+4Ch] [bp-4h]@15

  v7 = a2;
  v8 = a1;
  KBTickCount();
  buf2 = 0;
  v17 = 0;
  a1a = 0;
  v14 = 0;
  v19 = 0;
  if ( a5 || iLastDiffSendTo != -1 && iLastDiffSendTo != a4 )
    v19 = 1;
  iLastDiffSendTo = a4;
  sprintf(gText, "%s%s", ".\\DATA\\", v7);
  nbytes = FileSize(gText);
  buf = BaseAlloc(nbytes, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 24);
  sprintf(gText, "%s%s", ".\\DATA\\", v7);
  fd = open(gText, 32768);
  if ( fd == -1 )
    FileError(gText);
  _read(fd, buf, nbytes);
  _close(fd);
  v5 = calc_crc_long((int)buf, nbytes);
  LogInt((int)"Orig Join CRC", v5, nbytes, -999, -999, -999, -999, -999);
  if ( !a5 )
  {
    sprintf(gText, "%s%s", ".\\DATA\\", v8);
    a1a = FileSize(gText);
    buf2 = BaseAlloc(a1a, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 45);
    sprintf(gText, "%s%s", ".\\DATA\\", v8);
    v11 = open(gText, 32768);
    if ( v11 == -1 )
      FileError(gText);
    _read(v11, buf2, a1a);
    _close(v11);
  }
  v6 = a1a;
  if ( a1a <= nbytes )
    v6 = nbytes;
  v17 = BaseAlloc(v6 + 5000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 55);
  if ( v19 )
  {
    *(_BYTE *)v17 = 0;
    *((_BYTE *)v17 + 1) = 0;
    memcpy((char *)v17 + 2, buf, nbytes);
    v14 = nbytes + 2;
  }
  else
  {
    *(_BYTE *)v17 = 1;
    *((_BYTE *)v17 + 1) = 0;
    v14 = 2;
    v21 = 0;
    v16 = 0;
    while ( (signed int)(v16 + v21) < a1a && (signed int)(v16 + v21) < nbytes )
    {
      if ( *((_BYTE *)buf2 + v16 + v21) == *((_BYTE *)buf + v16 + v21) )
      {
        for ( i = 1;
              (signed int)(v16 + i + v21) < a1a
           && (signed int)(v16 + i + v21) < nbytes
           && *((_BYTE *)buf2 + v16 + i + v21) == *((_BYTE *)buf + v16 + i + v21);
              ++i )
          ;
        if ( i > 3 )
        {
          if ( v16 )
          {
            WriteDiffHeaderInfo(1, v16, (int)v17, (int)&v14);
            memcpy((char *)v17 + v14, (char *)buf + v21, v16);
            v14 += v16;
            v21 += v16;
            v16 = 0;
          }
          WriteDiffHeaderInfo(0, i, (int)v17, (int)&v14);
          v21 += i;
        }
        else
        {
          v16 += i;
        }
      }
      else
      {
        while ( (signed int)(v16 + v21) < a1a
             && (signed int)(v16 + v21) < nbytes
             && *((_BYTE *)buf2 + v16 + v21) != *((_BYTE *)buf + v16 + v21) )
          ++v16;
      }
    }
    v16 = a1a - v21;
    WriteDiffHeaderInfo(1, a1a - v21, (int)v17, (int)&v14);
    memcpy((char *)v17 + v14, (char *)buf + v21, v16);
    v14 += v16;
    v21 += v16;
    v16 = 0;
  }
  sprintf(gText, "%s%s", ".\\DATA\\", a3);
  v20 = open(gText, 33537, 128);
  if ( v20 == -1 )
    FileError(gText);
  _write(v20, v17, v14);
  _close(v20);
  sprintf(gText, "%s%s", ".\\DATA\\", v8);
  v20 = open(gText, 33537, 128);
  if ( v20 == -1 )
    FileError(gText);
  _write(v20, buf, nbytes);
  _close(v20);
  if ( buf2 )
    BaseFree(buf2, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 161);
  if ( buf )
    BaseFree(buf, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 163);
  if ( v17 )
    BaseFree(v17, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFA80 + 165);
}
// 4EFA80: using guessed type __int16 word_4EFA80;
// 4F31B8: using guessed type int iLastDiffSendTo;

//----- (0042D5B0) --------------------------------------------------------
void __fastcall CreateJoinFile(int a1, int a2, int a3)
{
  int v3; // ST24_4@1
  char v4; // ST40_1@9
  int v5; // eax@15
  int v6; // [sp+10h] [bp-30h]@1
  int v7; // [sp+14h] [bp-2Ch]@1
  void *v8; // [sp+18h] [bp-28h]@3
  int nbytes; // [sp+1Ch] [bp-24h]@1
  UINT fd; // [sp+20h] [bp-20h]@1
  UINT fda; // [sp+20h] [bp-20h]@5
  void *buf2; // [sp+24h] [bp-1Ch]@1
  int buf; // [sp+2Ch] [bp-14h]@1
  int v14; // [sp+30h] [bp-10h]@9
  int a1a; // [sp+34h] [bp-Ch]@5
  int v16; // [sp+38h] [bp-8h]@7
  int v17; // [sp+3Ch] [bp-4h]@13

  v3 = a2;
  v6 = a1;
  buf2 = 0;
  v7 = 0;
  sprintf(gText, "%s%s", ".\\DATA\\", a2);
  nbytes = FileSize(gText);
  buf = (int)BaseAlloc(nbytes, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 13);
  sprintf(gText, "%s%s", ".\\DATA\\", v3);
  fd = open(gText, 32768);
  if ( fd == -1 )
    FileError(gText);
  _read(fd, (void *)buf, nbytes);
  _close(fd);
  v8 = BaseAlloc(0xAAE60u, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 22);
  if ( *(_BYTE *)buf )
  {
    sprintf(gText, "%s%s", ".\\DATA\\", v6);
    a1a = FileSize(gText);
    buf2 = BaseAlloc(a1a, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 33);
    sprintf(gText, "%s%s", ".\\DATA\\", v6);
    fda = open(gText, 32768);
    if ( fda == -1 )
      FileError(gText);
    _read(fda, buf2, a1a);
    _close(fda);
    memcpy(v8, buf2, a1a);
    v16 = 2;
    while ( nbytes > v16 )
    {
      v4 = (signed int)*(_BYTE *)(v16 + buf) >> 7;
      v14 = GetSkipCopyLen(buf, (int)&v16);
      if ( v4 )
      {
        memcpy((char *)v8 + v7, (const void *)(buf + v16), v14);
        v7 += v14;
        v16 += v14;
      }
      else
      {
        v7 += v14;
      }
    }
  }
  else
  {
    memcpy(v8, (const void *)(buf + 2), nbytes - 2);
    v7 = nbytes - 2;
  }
  sprintf(gText, "%s%s", ".\\DATA\\", a3);
  v17 = open(gText, 33537, 128);
  if ( v17 == -1 )
    FileError(gText);
  _write(v17, v8, v7);
  _close(v17);
  v5 = calc_crc_long((int)v8, v7);
  LogInt((int)"New Join CRC", v5, v7, -999, -999, -999, -999, -999);
  sprintf(gText, "%s%s", ".\\DATA\\", v6);
  v17 = open(gText, 33537, 128);
  if ( v17 == -1 )
    FileError(gText);
  _write(v17, v8, v7);
  _close(v17);
  if ( buf2 )
    BaseFree(buf2, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 83);
  if ( buf )
    BaseFree((void *)buf, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 85);
  if ( v8 )
    BaseFree(v8, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFB9C + 87);
}
// 4EFB9C: using guessed type __int16 word_4EFB9C;

//----- (0042D980) --------------------------------------------------------
signed int __stdcall game::HeroIDToHeroPos(int a1, int a2)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; *(_BYTE *)(a1 + 1) > i; ++i )
  {
    if ( *(_BYTE *)(i + a1 + 4) == a2 )
      return i;
  }
  return -1;
}

//----- (0042D9E0) --------------------------------------------------------
signed int __stdcall getCastleOwnedIdx(playerData *player, int castleIdx)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; player->numCastles > i; ++i )
  {
    if ( player->castlesOwned[i] == castleIdx )
      return i;
  }
  return -1;
}

//----- (0042DA40) --------------------------------------------------------
void __thiscall game::SetupNewRumour(game *this)
{
  int v1; // ST80_4@4
  int v2; // ST7C_4@17
  int v3; // ecx@52
  signed int v5; // [sp+78h] [bp-9Ch]@31
  char playerIndices; // [sp+7Ch] [bp-98h]@18
  int playerStats; // [sp+84h] [bp-90h]@18
  int v8; // [sp+88h] [bp-8Ch]@18
  void *v9; // [sp+9Ch] [bp-78h]@8
  int idx; // [sp+A0h] [bp-74h]@6
  int row; // [sp+108h] [bp-Ch]@18
  int v12; // [sp+10Ch] [bp-8h]@14
  int v13; // [sp+110h] [bp-4h]@3

  if ( this->numRumors && Random(0, 9) < this->numRumors )
  {
    v13 = 0;
    while ( 1 )
    {
      v1 = v13++;
      if ( v1 >= 200 )
        break;
      if ( this->numRumors <= 1 )
        idx = 0;
      else
        idx = Random(0, this->numRumors - 1);
      v9 = ppMapExtra[this->rumorIndices[idx]];
      if ( strlen((char *)v9 + 8) > 2 && *((_BYTE *)v9 + 8) != 64 )
      {
        strcpy(this->currentRumor, (char *)v9 + 8);
        *((_BYTE *)v9 + 8) = 64;
        return;
      }
    }
  }
  if ( Random(0, 100) >= 30 )
  {
    v12 = Random(0, 100);
    if ( v12 < 80 && giCurTurn > 1 )
    {
      v13 = 0;
      while ( 1 )
      {
        v2 = v13++;
        if ( v2 >= 200 )
          break;
        row = Random(6, 9);
        GetCategoryStats(row, &playerStats, &playerIndices);
        SortStats(&playerStats, &playerIndices);
        if ( v8 != playerStats )
        {
          switch ( row )
          {
            case 6:
              sprintf(this->currentRumor, "%s has found the most obelisks.", cPlayerNames[playerIndices]);
              break;
            case 7:
              sprintf(this->currentRumor, "%s has found the most artifacts.", cPlayerNames[playerIndices]);
              break;
            case 8:
              sprintf(this->currentRumor, "%s has the most powerful forces.", cPlayerNames[playerIndices]);
              break;
            default:
              sprintf(this->currentRumor, "%s earns the most gold.", cPlayerNames[playerIndices]);
              break;
          }
          return;
        }
      }
    }
    row = Random(0, 100);
    if ( row >= 33 )
    {
      if ( row >= 66 )
      {
        if ( this->field_6397 == -1 )
          strcpy(
            this->currentRumor,
            cRandomTavernText[((unsigned int)((unsigned __int64)(giCurTurn / 7) >> 32) ^ abs(giCurTurn / 7) & 7)
                            - ((unsigned __int64)(giCurTurn / 7) >> 32)]);
        else
          sprintf(this->currentRumor, "The ultimate artifact is really the %s.", gArtifactNames[this->field_6397]);
      }
      else
      {
        v3 = advManager::GetCell(gpAdvManager, this->field_6395, this->field_6396)->groundIndex;
        sprintf(
          this->currentRumor,
          "The ultimate artifact may be found %s.",
          cRumourTerrainDescriptions[(unsigned __int8)giGroundToTerrain[v3]]);
      }
    }
    else
    {
      if ( (double)this->field_6395 >= (double)this->mapHeader.width * 0.33
        || (double)this->field_6395 >= (double)this->mapHeader.height * 0.33 )
      {
        if ( (double)this->field_6395 >= (double)this->mapHeader.width * 0.33
          || (double)this->field_6395 <= (double)this->mapHeader.height * 0.66 )
        {
          if ( (double)this->field_6395 >= (double)this->mapHeader.width * 0.33 )
          {
            if ( (double)this->field_6395 <= (double)this->mapHeader.width * 0.66
              || (double)this->field_6395 >= (double)this->mapHeader.height * 0.33 )
            {
              if ( (double)this->field_6395 <= (double)this->mapHeader.width * 0.66
                || (double)this->field_6395 <= (double)this->mapHeader.height * 0.66 )
              {
                if ( (double)this->field_6395 <= (double)this->mapHeader.width * 0.66 )
                {
                  if ( (double)this->field_6395 >= (double)this->mapHeader.height * 0.33 )
                  {
                    if ( (double)this->field_6395 <= (double)this->mapHeader.height * 0.66 )
                      v5 = 8;
                    else
                      v5 = 4;
                  }
                  else
                  {
                    v5 = 0;
                  }
                }
                else
                {
                  v5 = 2;
                }
              }
              else
              {
                v5 = 3;
              }
            }
            else
            {
              v5 = 1;
            }
          }
          else
          {
            v5 = 6;
          }
        }
        else
        {
          v5 = 5;
        }
      }
      else
      {
        v5 = 7;
      }
      sprintf(this->currentRumor, "The ultimate artifact may be found in the %s regions of the world.", cDirections[v5]);
    }
  }
  else
  {
    strcpy(
      this->currentRumor,
      cRandomTavernText[((unsigned int)((unsigned __int64)(giCurTurn / 7) >> 32) ^ abs(giCurTurn / 7) & 7)
                      - ((unsigned __int64)(giCurTurn / 7) >> 32)]);
  }
}
// 4F6ED0: using guessed type char *cDirections[9];
// 4F6EF8: using guessed type char *cRumourTerrainDescriptions[9];
// 532C54: using guessed type int giCurTurn;

//----- (0042E250) --------------------------------------------------------
void *__fastcall GetMapEvent(int x, int y)
{
  int v2; // edx@3
  signed int i; // [sp+14h] [bp-8h]@1
  void *v6; // [sp+18h] [bp-4h]@3

  for ( i = 0; gpGame->numMapEvents > i; ++i )
  {
    v2 = gpGame->mapEventIndices[i];
    v6 = ppMapExtra[v2];
    if ( *((_WORD *)v6 + 19) == x
      && *((_WORD *)v6 + 20) == y
      && *((_BYTE *)v6 + 37)
      && *((_BYTE *)v6 + gpGame->players[(char)giCurPlayer].color + 43) )
      return ppMapExtra[v2];
  }
  return 0;
}

//----- (0042E330) --------------------------------------------------------
game *__thiscall game::CheckForTimeEvent(game *this)
{
  game *result; // eax@2
  game *thisa; // [sp+Ch] [bp-28h]@1
  int v3; // [sp+10h] [bp-24h]@14
  int img2Arg; // [sp+14h] [bp-20h]@12
  int img2Type; // [sp+18h] [bp-1Ch]@12
  int img1Type; // [sp+1Ch] [bp-18h]@12
  int img1Arg; // [sp+20h] [bp-14h]@12
  signed int j; // [sp+24h] [bp-10h]@12
  signed int i; // [sp+28h] [bp-Ch]@1
  int v10; // [sp+2Ch] [bp-8h]@1
  void *v11; // [sp+30h] [bp-4h]@3

  thisa = this;
  v10 = this->day + 7 * (this->week - 1) + 28 * (this->month - 1);
  for ( i = 0; ; ++i )
  {
    result = thisa;
    if ( thisa->numEvents <= i )
      break;
    v11 = ppMapExtra[*(_WORD *)&thisa->eventIndices[2 * i]];
    if ( (gbHumanPlayer[giCurPlayer] && *((_BYTE *)v11 + 42) || !gbHumanPlayer[giCurPlayer] && *((_BYTE *)v11 + 31))
      && *((_BYTE *)v11 + thisa->players[(char)giCurPlayer].color + 43)
      && (*(_WORD *)((char *)v11 + 33) == v10
       || *(_WORD *)((char *)v11 + 35)
       && *(_WORD *)((char *)v11 + 33) < v10
       && !((v10 - *(_WORD *)((char *)v11 + 33)) % *(_WORD *)((char *)v11 + 35))) )
    {
      img1Type = -1;
      img1Arg = 0;
      img2Type = -1;
      img2Arg = 0;
      for ( j = 0; j < 7; ++j )
      {
        v3 = *(_DWORD *)((char *)v11 + 4 * j + 1);
        if ( gpGame->players[giCurPlayer].resources[j] < -v3 )
          v3 = -gpGame->players[giCurPlayer].resources[j];
        gpGame->players[giCurPlayer].resources[j] += *(_DWORD *)((char *)v11 + 4 * j + 1);
        if ( gpGame->players[giCurPlayer].resources[j] < 0 )
          gpGame->players[giCurPlayer].resources[j] = 0;
        if ( v3 )
        {
          if ( img1Type != -1 )
          {
            img2Type = img1Type;
            img2Arg = img1Arg;
          }
          img1Type = j;
          img1Arg = v3;
        }
      }
      if ( img1Type >= 0 && img1Type <= 6 && img1Arg < 0 )
        img1Arg -= 100000;
      if ( img2Type >= 0 && img2Type <= 6 && img2Arg < 0 )
        img2Arg -= 100000;
      if ( gbThisNetHumanPlayer[giCurPlayer] )
        NormalDialog((char *)v11 + 49, 1, -1, -1, img1Type, img1Arg, img2Type, img2Arg, -1, 0);
    }
  }
  return result;
}

//----- (0042E680) --------------------------------------------------------
int __cdecl CheckValidAvailableHeroes()
{
  int result; // eax@2
  int playerIdx; // [sp+Ch] [bp-10h]@1
  signed int k; // [sp+10h] [bp-Ch]@7
  signed int i; // [sp+14h] [bp-8h]@3
  signed int j; // [sp+18h] [bp-4h]@5

  for ( playerIdx = 0; ; ++playerIdx )
  {
    result = gpGame->numPlayers;
    if ( result <= playerIdx )
      break;
    for ( i = 0; gpGame->players[playerIdx].numHeroes > i; ++i )
    {
      for ( j = 0; gpGame->numPlayers > j; ++j )
      {
        for ( k = 0; k < 2; ++k )
        {
          if ( gpGame->players[j].heroesForPurchase[k] == *(&gpGame->players[0].heroesOwned[284 * playerIdx]
                                                          + i
                                                          - playerIdx) )
            gpGame->players[j].heroesForPurchase[k] = game::GetNewHeroId(gpGame, playerIdx, -1, 0);
        }
      }
    }
  }
  return result;
}

//----- (0042E7D0) --------------------------------------------------------
int __thiscall CalcFileCRC(const char *this)
{
  int v1; // ST28_4@3
  const char *thisa; // [sp+Ch] [bp-14h]@1
  UINT fd; // [sp+10h] [bp-10h]@1
  int nbytes; // [sp+14h] [bp-Ch]@1
  void *a1; // [sp+18h] [bp-8h]@1

  thisa = this;
  nbytes = FileSize(this);
  a1 = BaseAlloc(nbytes, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFDCC + 3);
  fd = open(thisa, 32768);
  if ( fd == -1 )
    FileError((void *)thisa);
  _read(fd, a1, nbytes);
  v1 = calc_crc_long((int)a1, nbytes);
  _close(fd);
  BaseFree(a1, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFDCC + 14);
  return v1;
}
// 4EFDCC: using guessed type __int16 word_4EFDCC;

//----- (0042E880) --------------------------------------------------------
void __cdecl CompressTest2()
{
  int v0; // ST30_4@4
  const void *a1; // [sp+Ch] [bp-28h]@1
  void *v2; // [sp+10h] [bp-24h]@1
  int v3; // [sp+1Ch] [bp-18h]@1
  int i; // [sp+20h] [bp-14h]@1
  void *v5; // [sp+28h] [bp-Ch]@1

  v3 = Random(20000, 100000);
  a1 = BaseAlloc(v3 + 5000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 7);
  v2 = BaseAlloc(v3 + 5000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 8);
  v5 = BaseAlloc(v3 + 5000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 9);
  for ( i = 0; i < v3; ++i )
    *((_BYTE *)a1 + i) = Random(0, 255);
  calc_crc_long((int)a1, v3);
  v0 = EncodeData(v2, a1, v3);
  DecodeData(v5, v2, v0);
  calc_crc_long((int)v5, v3);
  calc_crc_long((int)a1, v3);
  BaseFree((void *)a1, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 26);
  BaseFree(v2, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 27);
  BaseFree(v5, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFE08 + 28);
}
// 4EFE08: using guessed type __int16 word_4EFE08;

//----- (0042E9E0) --------------------------------------------------------
void __cdecl CompressTest()
{
  void *a1; // [sp+Ch] [bp-48h]@1
  void *v1; // [sp+10h] [bp-44h]@1
  UINT fd; // [sp+1Ch] [bp-38h]@1
  int nbytes; // [sp+20h] [bp-34h]@1
  char this; // [sp+24h] [bp-30h]@1
  int v5; // [sp+44h] [bp-10h]@3
  void *v6; // [sp+48h] [bp-Ch]@1
  int v7; // [sp+4Ch] [bp-8h]@3
  int v8; // [sp+50h] [bp-4h]@3

  LogStr("C1");
  strcpy(&this, "c:\\TEMP\\Z.DIF");
  nbytes = FileSize(&this);
  a1 = BaseAlloc(nbytes + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 9);
  v1 = BaseAlloc(nbytes + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 10);
  v6 = BaseAlloc(nbytes + 2000, "F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 11);
  LogStr("C2");
  fd = open(&this, 32768);
  if ( fd == -1 )
    FileError(&this);
  _read(fd, a1, nbytes);
  LogStr("C3");
  v5 = calc_crc_long((int)a1, nbytes);
  LogStr("C4");
  _close(fd);
  LogStr("C5");
  v7 = EncodeData(v1, a1, nbytes);
  LogStr("C6");
  v8 = DecodeData(v6, v1, v7);
  LogStr("C7");
  calc_crc_long((int)v6, nbytes);
  calc_crc_long((int)a1, nbytes);
  BaseFree(a1, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 36);
  BaseFree(v1, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 37);
  BaseFree(v6, (int)"F:\\h2xsrc\\Source\\GAME.CPP", word_4EFEB4 + 38);
  LogStr("C8");
}
// 4EFEB4: using guessed type __int16 word_4EFEB4;

//----- (0042EBA0) --------------------------------------------------------
void __cdecl CompressTest3()
{
  char v0; // [sp+Ch] [bp-2Ch]@3
  int i; // [sp+34h] [bp-4h]@1

  for ( i = 0; i < 100; ++i )
  {
    sprintf(&v0, "Test # %d", i);
    AiPrint(&v0);
    CompressTest2();
  }
}

//----- (0042EC00) --------------------------------------------------------
int __thiscall game::CountShrines(game *this, int a2)
{
  int result; // eax@2
  mapCell *cell; // [sp+10h] [bp-18h]@7
  int row; // [sp+14h] [bp-14h]@3
  int col; // [sp+18h] [bp-10h]@5
  int v6; // [sp+20h] [bp-8h]@3
  town *v7; // [sp+24h] [bp-4h]@7

  if ( xIsExpansionMap )
  {
    v6 = 0;
    for ( row = 0; row < MAP_HEIGHT; ++row )
    {
      for ( col = 0; col < MAP_WIDTH; ++col )
      {
        cell = &this->map.tiles[row * this->map.width] + col;
        v7 = 0;
        if ( cell->objType == 163 )
        {
          v7 = &gpGame->castles[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
        }
        else if ( cell->objType == 170
  && gpGame->heroes[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjType == 163 )
        {
          v7 = &gpGame->castles[gpGame->heroes[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjVal];
        }
        if ( v7 && v7->ownerIdx == a2 && v7->buildingsBuiltFlags & 4 )
        {
          if ( v7->factionID == FACTION_NECROMANCER )
            ++v6;
        }
      }
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (0042EDB0) --------------------------------------------------------
void __cdecl PollSound()
{
  if ( !gbInPollSound )
  {
    gbInPollSound = 1;
    if ( KBTickCount() > timer2 && !gbPutzingWithMouseCtr )
    {
      timer2 = KBTickCount() + 13;
      mouseManager::NewUpdate(gpMouseManager, 0);
    }
    if ( KBTickCount() > timer1 )
    {
      if ( giCycleType != 1 && giCycleType != 3 )
        timer1 = KBTickCount() + 200;
      else
        timer1 = KBTickCount() + 110;
      bDoColorCycle = 1;
      if ( giGraphicsType == 1 )
      {
        if ( giMainVideoModeColorDepth != 8 )
        {
          timer1 += 300;
          if ( gbHeroMoving )
            bDoColorCycle = 0;
        }
      }
      if ( bDoColorCycle )
        CycleColors(0);
    }
    if ( KBTickCount() > globalSoundUpdateTimer )
    {
      globalSoundUpdateTimer = KBTickCount() + 30;
      if ( gbForegroundApp )
        soundManager::PollSound((soundManager *)gpSoundManager);
      PollRemote();
    }
    gbInPollSound = 0;
  }
}
// 4F0A10: using guessed type int gbForegroundApp;
// 4F0A14: using guessed type int giMainVideoModeColorDepth;
// 4F19A0: using guessed type int giCycleType;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;
// 4F3084: using guessed type int gbHeroMoving;
// 4F74BC: using guessed type int gbInPollSound;
// 5192F0: using guessed type int giGraphicsType;
// 5240A8: using guessed type int gpSoundManager;
// 524A60: using guessed type int bDoColorCycle;
// 524BFC: using guessed type int globalSoundUpdateTimer;
// 524C00: using guessed type int timer2;
// 524C04: using guessed type int timer1;

//----- (0042EF00) --------------------------------------------------------
void __cdecl ForcePollSound()
{
  globalSoundUpdateTimer = KBTickCount() - 1;
  PollSound();
}
// 524BFC: using guessed type int globalSoundUpdateTimer;

//----- (0042EF20) --------------------------------------------------------
void __fastcall InitMainClasses()
{
  hero *j; // [sp+Ch] [bp-4Ch]@26
  signed int v1; // [sp+10h] [bp-48h]@26
  town *i; // [sp+14h] [bp-44h]@23
  signed int v3; // [sp+18h] [bp-40h]@23
  palette *v4; // [sp+1Ch] [bp-3Ch]@49
  armyGroup *v5; // [sp+20h] [bp-38h]@46
  void *v6; // [sp+24h] [bp-34h]@43
  searchArray *v7; // [sp+28h] [bp-30h]@40
  townManager *v8; // [sp+2Ch] [bp-2Ch]@37
  combatManager *ecx0; // [sp+30h] [bp-28h]@34
  advManager *v10; // [sp+34h] [bp-24h]@31
  game *v11; // [sp+38h] [bp-20h]@22
  baseManager *v12; // [sp+3Ch] [bp-1Ch]@19
  soundManager *v13; // [sp+40h] [bp-18h]@16
  resourceManager *this; // [sp+44h] [bp-14h]@13
  heroWindowManager *v2; // [sp+48h] [bp-10h]@10
  mouseManager *v16; // [sp+4Ch] [bp-Ch]@7
  int v17; // [sp+50h] [bp-8h]@4
  executive *v18; // [sp+54h] [bp-4h]@1

  v18 = (executive *)operator new(16);
  if ( v18 )
    gpExec = executive::executive(v18);
  else
    gpExec = 0;
  v17 = (int)operator new(2154);
  if ( v17 )
    gpInputManager = inputManager::inputManager(v17);
  else
    gpInputManager = 0;
  v16 = (mouseManager *)operator new(138);
  if ( v16 )
    gpMouseManager = mouseManager::mouseManager(v16);
  else
    gpMouseManager = 0;
  v2 = (heroWindowManager *)operator new(98);
  if ( v2 )
    gpWindowManager = heroWindowManager::heroWindowManager(v2);
  else
    gpWindowManager = 0;
  this = (resourceManager *)operator new(162);
  if ( this )
    gpResourceManager = resourceManager::resourceManager(this);
  else
    gpResourceManager = 0;
  v13 = (soundManager *)operator new(1714);
  if ( v13 )
    gpSoundManager = (int)soundManager::soundManager(v13);
  else
    gpSoundManager = 0;
  v12 = (baseManager *)operator new(99);
  if ( v12 )
    gpHighScoreManager = highScoreManager::highScoreManager(v12);
  else
    gpHighScoreManager = 0;
  v11 = (game *)operator new(26127);
  if ( v11 )
  {
    fullMap::fullMap(&v11->map);
    v3 = 72;
    for ( i = v11->castles; ; ++i )
    {
      --v3;
      if ( v3 < 0 )
        break;
      town::town(i);
    }
    v1 = 54;
    for ( j = v11->heroes; ; ++j )
    {
      --v1;
      if ( v1 < 0 )
        break;
      hero::hero(j);
    }
    gpGame = v11;
  }
  else
  {
    gpGame = 0;
  }
  v10 = (advManager *)operator new(894);
  if ( v10 )
    gpAdvManager = advManager::advManager(v10);
  else
    gpAdvManager = 0;
  ecx0 = (combatManager *)operator new(63607);
  if ( ecx0 )
    gpCombatManager = combatManager::combatManager(ecx0);
  else
    gpCombatManager = 0;
  v8 = (townManager *)operator new(378);
  if ( v8 )
    gpTownManager = townManager::townManager(v8);
  else
    gpTownManager = 0;
  v7 = (searchArray *)operator new(9496);
  if ( v7 )
    gpSearchArray = searchArray::searchArray(v7);
  else
    gpSearchArray = 0;
  v6 = operator new(1);
  if ( v6 )
    gpPhilAI = (int)philAI::philAI(v6);
  else
    gpPhilAI = 0;
  v5 = (armyGroup *)operator new(15);
  if ( v5 )
    gpMonGroup = armyGroup::armyGroup(v5);
  else
    gpMonGroup = 0;
  v4 = (palette *)operator new(20);
  if ( v4 )
    gpBufferPalette = palette::palette(v4);
  else
    gpBufferPalette = 0;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (0042F2C0) --------------------------------------------------------
void *__cdecl DeleteMainClasses()
{
  void *result; // eax@2
  void *v1; // [sp+5Ch] [bp-28h]@18
  void *this; // [sp+70h] [bp-14h]@9

  if ( gpBufferPalette )
  {
    result = gpBufferPalette;
    if ( gpBufferPalette )
      result = (void *)((int (__thiscall *)(_DWORD))gpBufferPalette->vtable->scalarDeletingDestructor)(gpBufferPalette);
  }
  gpBufferPalette = 0;
  if ( gpMonGroup )
    result = (void *)operator delete(gpMonGroup);
  gpMonGroup = 0;
  if ( gpPhilAI )
    result = (void *)operator delete((void *)gpPhilAI);
  gpPhilAI = 0;
  if ( gpSearchArray )
  {
    result = gpSearchArray;
    this = gpSearchArray;
    if ( gpSearchArray )
    {
      searchArray::_searchArray(gpSearchArray);
      result = (void *)operator delete(this);
    }
  }
  gpSearchArray = 0;
  if ( gpTownManager )
    result = (void *)operator delete(gpTownManager);
  gpTownManager = 0;
  if ( gpCombatManager )
    result = (void *)operator delete(gpCombatManager);
  gpCombatManager = 0;
  if ( gpAdvManager )
    result = (void *)operator delete(gpAdvManager);
  gpAdvManager = 0;
  if ( gpGame )
  {
    result = gpGame;
    v1 = gpGame;
    if ( gpGame )
    {
      fullMap::_fullMap(&gpGame->map.tiles);
      result = (void *)operator delete(v1);
    }
  }
  gpGame = 0;
  if ( gpHighScoreManager )
    result = (void *)operator delete(gpHighScoreManager);
  gpHighScoreManager = 0;
  if ( gpSoundManager )
    result = (void *)operator delete((void *)gpSoundManager);
  gpSoundManager = 0;
  if ( gpWindowManager )
    result = (void *)operator delete(gpWindowManager);
  gpWindowManager = 0;
  if ( gpMouseManager )
    result = (void *)operator delete(gpMouseManager);
  gpMouseManager = 0;
  if ( gpInputManager )
    result = (void *)operator delete(gpInputManager);
  gpInputManager = 0;
  if ( gpExec )
    result = (void *)operator delete(gpExec);
  gpExec = 0;
  if ( gpResourceManager )
    result = (void *)operator delete(gpResourceManager);
  gpResourceManager = 0;
  return result;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (0042F610) --------------------------------------------------------
void __fastcall EarlyShutdown(const CHAR *a1, const CHAR *a2)
{
  MessageBoxA(hwndApp, a2, a1, 0x10u);
  exit(0);
}

//----- (0042F650) --------------------------------------------------------
void __fastcall SetupCDRom()
{
  int v0; // [sp+Ch] [bp-4h]@1

  v0 = gbNoSound;
  if ( iCDRomErr == 1 )
  {
    SetPalette(gPalette->contents, 1);
    mouseManager::ShowColorPointer(gpMouseManager);
    gbNoSound = 1;
    if ( giTCPHostStatus )
      NormalDialog(
        "Unable to access CD-ROM Drive.  Without a CD-ROM drive and a Heroes 2 Expansion CD-ROM you will only be able to play as the guest in a multi-player game.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
    gbNoCDRom = 1;
  }
  else if ( iCDRomErr == 2 )
  {
    SetPalette(gPalette->contents, 1);
    mouseManager::ShowColorPointer(gpMouseManager);
    gbNoSound = 1;
    if ( giTCPHostStatus )
      NormalDialog(
        "The Heroes 2 Expansion CD-ROM is not in the drive.  Without a Heroes 2 Expansion CD-ROM you will only be able to play as the guest in a multi-player game.  If you have the CD, then exit the program, put the CD in, and try again.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
    gbNoCDRom = 1;
  }
  if ( iCDRomErr == 3 )
  {
    EarlyShutdown("Startup Error", "Unable to change to the Heroes II directory.  Please run the installation program.");
    exit(0);
  }
  if ( iCDRomErr == 4 )
  {
    EarlyShutdown("Startup Error", "Unable to find the Heroes II data files.  Please run the installation program.");
    exit(0);
  }
  gbNoSound = v0;
}
// 4F1CBC: using guessed type int gbNoCDRom;
// 50CAF0: using guessed type int iCDRomErr;
// 52340C: using guessed type int giTCPHostStatus;
// 523F24: using guessed type int gbNoSound;

//----- (0042F7A0) --------------------------------------------------------
signed int __cdecl EarlySetup()
{
  signed int result; // eax@2

  if ( bEarlySetupDone )
  {
    result = 0;
  }
  else
  {
    InitMainClasses();
    GetGraphicsInfo();
    ReadPrefs();
    if ( InterpretCommandLine() )
    {
      LogTruncate();
      LogStr("ES1");
      iCDRomErr = SetupCDDrive();
      InitVars();
      LogStr("ES2");
      result = 1;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 50CAF0: using guessed type int iCDRomErr;
// 50CAF4: using guessed type int bEarlySetupDone;

//----- (0042F820) --------------------------------------------------------
int __cdecl oldmain()
{
  char *v1; // ST1C_4@153
  signed int v2; // eax@153
  int v3; // eax@172
  const char *v4; // ST1C_4@198
  int v5; // ebx@198
  __int16 v6; // ax@198
  heroWindow *this; // [sp+24h] [bp-14Ch]@52
  signed int v8; // [sp+28h] [bp-148h]@184
  bool v9; // [sp+28h] [bp-148h]@197
  char v10; // [sp+2Ch] [bp-144h]@122
  char v11; // [sp+32h] [bp-13Eh]@131
  char v12; // [sp+33h] [bp-13Dh]@131
  char v13; // [sp+34h] [bp-13Ch]@122
  char v14[8]; // [sp+12Ch] [bp-44h]@92
  int j; // [sp+134h] [bp-3Ch]@92
  int k; // [sp+138h] [bp-38h]@96
  char v17[8]; // [sp+13Ch] [bp-34h]@92
  int v18; // [sp+144h] [bp-2Ch]@68
  int v19; // [sp+148h] [bp-28h]@11
  int v20; // [sp+154h] [bp-1Ch]@14
  int i; // [sp+158h] [bp-18h]@62
  int v22; // [sp+15Ch] [bp-14h]@133
  int mainMenuButton; // [sp+164h] [bp-Ch]@3
  int v24; // [sp+168h] [bp-8h]@14
  int v25; // [sp+16Ch] [bp-4h]@14

  if ( bKBDone )
    return 0;
  bKBDone = 1;
  LogStr("OM1");
  LogStr("OM2");
  mainMenuButton = -1;
  if ( executive::InitSystem(gpExec) )
    ShutDown("Initialization failed!");
  LogStr("OM3");
  KBChangeMenu(hmnuDflt);
  gPalette = (palette *)resourceManager::GetPalette(gpResourceManager, "kb.pal");
  gpWindowManager->cycleColors = 1;
  smallFont = resourceManager::GetFont(gpResourceManager, "smalfont.fnt");
  bigFont = resourceManager::GetFont(gpResourceManager, "bigfont.fnt");
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  mouseManager::SetColorMice(gpMouseManager, *(&bMenu + 7 * giCurExe + 6));
  LogStr("OM4");
  SetupCDRom();
  LogStr("OM5");
  if ( (**(int (__thiscall ***)(_DWORD))gpSoundManager)(gpSoundManager) )
    ShutDown("Unable to initialize sound.");
  if ( giDebugLevel < 9 )
    CheckMem();
  LogStr("OM6");
  if ( giShowIntro )
  {
    FillBitmapArea(gpWindowManager->screenBuffer, 0, 0, 640u, 480, 0);
    BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0, 0);
    if ( !gbSkipIntro )
    {
      v19 = gpWindowManager->cycleColors;
      gpWindowManager->cycleColors = 0;
      if ( PlaySmacker(66) )
        PlaySmacker(1);
      PlaySmacker(65);
      gpWindowManager->cycleColors = v19;
    }
  }
  LoadSystemwideIcons();
  memset(gbThisNetHumanPlayer, 0, 6u);
  mouseManager::ShowColorPointer(gpMouseManager);
  v25 = 0;
  v20 = 0;
  v24 = 1;
LABEL_15:
  if ( !v25 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
LABEL_16:
          if ( !gShingleAnim )
            gShingleAnim = resourceManager::GetIcon(gpResourceManager, "shnganim.icn");
          if ( gGameCommand != 105 )
            soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 42);
          if ( !v20 )
          {
            if ( gGameCommand != 105 )
            {
              resourceManager::GetBackdrop(gpResourceManager, "heroes.icn", gpWindowManager->screenBuffer, 1);
              heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
              if ( v24 )
                SetPalette(gPalette->contents, 1);
              else
                heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
              v24 = 0;
            }
            mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
          }
          v20 = 1;
          if ( gGameCommand != 105 )
            gpWindowManager->cycleColors = 1;
          if ( giTCPHostStatus == -1 || !gbTCPFirstTime )
          {
            if ( giMenuCommand != -1 )
              goto LABEL_48;
            if ( gGameCommand == -1 )
            {
              this = (heroWindow *)operator new(68);
              if ( this )
                gpInitWin = heroWindow::heroWindow(this, 0, 0, "stpmain.bin");
              else
                gpInitWin = 0;
              if ( !gpInitWin )
                MemError();
              gbInSetupDialog = 1;
              heroWindowManager::DoDialog(
                gpWindowManager,
                gpInitWin,
                (int (__fastcall *)(tag_message *))InitMenuHandler,
                0);
              operator delete(gpInitWin);
              gpInitWin = 0;
              mainMenuButton = gpWindowManager->buttonPressedCode;
              gbInSetupDialog = 0;
            }
            else
            {
              mainMenuButton = gGameCommand;
              gGameCommand = -1;
            }
            goto LABEL_58;
          }
          gbTCPFirstTime = 0;
          iLastMsgNumHumanPlayers = 1;
          iMPBaseType = 1;
          iMPNetProtocol = 2;
          iMPExtendedType = giTCPHostStatus ? 1 : 2;
          giSetupGameType = giTCPType;
          RemoteMain((void *)iMPExtendedType);
          gbWaitForRemoteReceive = iMPExtendedType == 2;
          giTCPHostStatus = -1;
          if ( !giSetupGameType )
            break;
          if ( (unsigned __int8)giSetupGameType != 1 || game::PickLoadGame() )
            goto LABEL_58;
        }
      }
      while ( !game::NewGame(gpGame) );
LABEL_58:
      if ( giMenuCommand != -1 )
        goto LABEL_48;
      switch ( mainMenuButton )
      {
        case 102:
          giSetupGameType = 1;
          goto LABEL_62;
        case 101:
          giSetupGameType = 0;
LABEL_62:
          for ( i = 0; i < 6; ++i )
            sprintf(cPlayerNames[i], byte_50CE04);
          if ( !game::SetupGame(gpGame) )
            goto LABEL_16;
          if ( !giSetupGameType )
          {
            if ( gbInCampaign )
            {
              game::InitEntireCampaign(gpGame, gbCampaignSideChoice[0]);
              v18 = game::HandleCampaignWin(gpGame);
              if ( v18 )
              {
                game::InitCampaignMap(gpGame);
                goto LABEL_147;
              }
              heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
              v20 = 0;
            }
            else if ( xIsPlayingExpansionCampaign )
            {
              if ( ExpCampaign::HandleVictory((int)&xCampaign) )
              {
                ExpCampaign::InitMap((int)&xCampaign);
                goto LABEL_147;
              }
              heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
              v20 = 0;
            }
            else
            {
              LogStr("New Game 1");
              if ( game::NewGame(gpGame) )
              {
                LogStr("New Game 2");
                goto LABEL_88;
              }
            }
            goto LABEL_16;
          }
          if ( (unsigned __int8)giSetupGameType != 1 )
          {
LABEL_88:
            while ( giMenuCommand != -1 )
            {
LABEL_48:
              switch ( giMenuCommand )
              {
                case 40123:
                case 40124:
                case 40127:
                case 40128:
                case 40129:
                case 40131:
                case 40132:
                case 40134:
                case 40135:
                case 40137:
                case 40138:
                  if ( game::PickLoadGame() )
                    goto LABEL_88;
                  goto LABEL_16;
                case 40102:
                case 40104:
                case 40105:
                case 40106:
                case 40107:
                case 40110:
                case 40111:
                case 40112:
                case 40114:
                case 40115:
                case 40117:
                case 40118:
                case 40120:
                case 40121:
                  if ( game::NewGame(gpGame) )
                    goto LABEL_88;
                  goto LABEL_16;
                default:
                  goto LABEL_88;
              }
            }
            LogStr("DWM 1");
            if ( !v25 )
            {
              LogStr("DWM 2");
              if ( gbRemoteOn && !giThisNetPos )
              {
                LogStr("DWM 3");
                memset(v17, 0, 6u);
                memset(v14, 0, 6u);
                for ( j = 0; j < 6; ++j )
                {
                  if ( gbHumanPlayer[j] )
                  {
                    for ( k = 0; k < 6; ++k )
                    {
                      if ( strlen(&gpGame->field_637D[4 * k]) == 3
                        && !strcmp((int)&gpGame->field_637D[4 * k], (int)((char *)&gsNetPlayerInfo + 34 * j))
                        && !gpGame->playerDead[k]
                        && !v17[k] )
                      {
                        if ( !v14[j] )
                        {
                          v17[k] = 1;
                          v14[j] = 1;
                          gbGamePosToNetPos[k] = j;
                        }
                      }
                    }
                  }
                }
                for ( k = 0; k < 6 && v17[k]; ++k )
                  ;
                for ( j = 0; j < 6; ++j )
                {
                  if ( !v14[j] )
                  {
                    if ( gbHumanPlayer[j] )
                    {
                      gbGamePosToNetPos[j] = k;
                      strcpy(&gpGame->field_637D[4 * k++], (char *)&gsNetPlayerInfo + 34 * j);
                      while ( k < 6 && v17[k] )
                        ++k;
                    }
                    else
                    {
                      gbGamePosToNetPos[j] = -1;
                    }
                  }
                }
                memcpy(&v10, gbGamePosToNetPos, 6u);
                memcpy(&v13, &gsNetPlayerInfo, 0xCCu);
                giThisGamePos = NetPosToGamePos(0);
                gbUseDiffCompression = 1;
                gbUseRegularCompression = 1;
                if ( giHighMemBuffer < 6000 )
                  gbUseRegularCompression = 0;
                for ( i = 0; i < iLastMsgNumHumanPlayers; ++i )
                {
                  if ( !byte_526CFA[34 * i] )
                    gbUseRegularCompression = 0;
                  if ( !byte_526CFB[34 * i] )
                    gbUseDiffCompression = 0;
                }
                v11 = gbUseRegularCompression;
                v12 = gbUseDiffCompression;
                for ( i = 1; i < iLastMsgNumHumanPlayers; ++i )
                {
                  v22 = TransmitRemoteData(&v10, i, 0xD4u, 32, 1, 1, -1);
                  if ( !v22 )
                    ShutDown(0);
                }
                for ( i = 1; i < iLastMsgNumHumanPlayers; ++i )
                {
                  if ( !game::TransmitSaveGame(gpGame, i, 0, 1) )
                    ShutDown(0);
                }
                memset(gbThisNetHumanPlayer, 0, 6u);
                gbThisNetHumanPlayer[giThisGamePos] = 1;
                iLastDiffSendTo = -1;
                game::SaveGame(gpGame, (const char *)&gConfig + 314, 0, 0);
              }
              LogStr("DWM 4");
              if ( gbRemoteOn && gbWaitForRemoteReceive )
              {
                LogStr("DWM 5");
                giWaitType = 0;
                NormalDialog("Waiting to receive game data.", 6, -1, -1, -1, 0, -1, 0, -1, 0);
                if ( !gbFunctionComplete )
                  ShutDown(0);
                game::LoadGame(gpGame, (char *)&gConfig + 327, 0, 1);
                sprintf(gpGame->lastSaveFile, "NEWGAME");
                iLastDiffSendTo = -1;
                game::SaveGame(gpGame, (const char *)&gConfig + 353, 0, 0);
              }
              goto LABEL_147;
            }
LABEL_177:
            if ( gbGameOver )
            {
              while ( 1 )
              {
                RemoteCleanup();
                bShowIt = 1;
                mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
                sprintf(
                  gcWinText,
                  "My heroes, our foes have been scattered, their castles broken and laid bare.  The great campaign is now complete, and I stand before you as the undisputed High King!\n\nOur victory was achieved in %d days!",
                  giCurTurn);
                if ( giEndSequence != 1 )
                  break;
                if ( gbInCampaign )
                {
                  v8 = game::HandleCampaignWin(gpGame);
                  if ( gpGame->field_4 == 10 && gpGame->_1[12 * gpGame->field_2 + 10]
                    || gpGame->field_4 == 9 && !gpGame->field_2 && gpGame->_1[12 * gpGame->field_2 + 9] )
                  {
                    gbShowHighScore = 1;
                    ShowCongrats(0);
                    AddScoreToHighScore(
                      *(_WORD *)&gpGame->_11[49],
                      *(_WORD *)&gpGame->_11[49],
                      0,
                      0,
                      &aArchibald[("Roland" - "Archibald") & ((gpGame->field_2 == 1) - 1)]);
                  }
                  if ( !v8 )
                    goto LABEL_208;
                  for ( i = 0; i < 6; ++i )
                    sprintf(cPlayerNames[i], byte_50CFB4);
                  game::InitCampaignMap(gpGame);
                  gbGameOver = 0;
                  bForceCheckTimeEvent = 1;
                }
                else
                {
                  if ( !xIsPlayingExpansionCampaign )
                  {
                    ShowCongrats((void *)1);
                    if ( gbShowHighScore )
                    {
                      soundManager::PlayAmbientMusic(gpSoundManager, 43, 0, -1);
                    }
                    else
                    {
                      heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
                      resourceManager::GetBackdrop(gpResourceManager, "heroes.icn", gpWindowManager->screenBuffer, 1);
                      heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
                      heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
                      gpWindowManager->cycleColors = 1;
                      v20 = 1;
                      soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
                    }
                    goto LABEL_208;
                  }
                  v9 = ExpCampaign::HandleVictory((int)&xCampaign);
                  if ( ExpCampaign::IsCompleted((int)&xCampaign) )
                  {
                    gbShowHighScore = 1;
                    ShowCongrats((void *)2);
                    v4 = (&xHSCampaignNames)[4 * ExpCampaign::CampaignID(&xCampaign)];
                    v5 = (signed __int16)ExpCampaign::Days((int)&xCampaign);
                    v6 = ExpCampaign::Days((int)&xCampaign);
                    AddScoreToHighScore(v6, v5, 0, 2, v4);
                  }
                  if ( !v9 )
                    goto LABEL_208;
                  for ( i = 0; i < 6; ++i )
                    sprintf(cPlayerNames[i], byte_50CFB8);
                  ExpCampaign::InitMap((int)&xCampaign);
                  gbGameOver = 0;
                  bForceCheckTimeEvent = 1;
                }
LABEL_147:
                gpWindowManager->cycleColors = 1;
                if ( gShingleAnim )
                  resourceManager::Dispose(gpResourceManager, (resource *)gShingleAnim);
                gShingleAnim = 0;
                if ( iLastMsgNumHumanPlayers > 1 )
                {
                  for ( i = 0; i < iLastMsgNumHumanPlayers; ++i )
                  {
                    if ( iMPBaseType != 2 )
                    {
                      v1 = (char *)&gsNetPlayerInfo + 34 * i + 4;
                      v2 = NetPosToGamePos((void *)i);
                      strcpy(cPlayerNames[v2], v1);
                    }
                  }
                }
                for ( i = 0; gpGame->numPlayers > i; ++i )
                {
                  if ( !strlen(cPlayerNames[i]) )
                  {
                    sprintf(cPlayerNames[i], "%s player", (&gColors)[4 * gpGame->players[i].color]);
                    cPlayerNames[i][0] -= 32;
                  }
                }
                ComputeAdvNetControl();
                gbGameInitialized = 1;
                v20 = 0;
                soundManager::StopAllSamples((soundManager *)gpSoundManager, 1);
                heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
                gMapX = 0;
                gMapY = 0;
                for ( giCurWatchPlayer = giCurPlayer;
                      !gbThisNetHumanPlayer[giCurWatchPlayer];
                      giCurWatchPlayer = (giCurWatchPlayer + 1) % gpGame->numPlayers )
                  ;
                giCurWatchPlayerBit = 1 << giCurWatchPlayer;
                if ( gbInCampaign && gpGame->_11[71] )
                {
                  giEndSequence = 1;
                }
                else
                {
                  if ( !xIsPlayingExpansionCampaign || !ExpCampaign::IsThisMapCompleted((int)&xCampaign) )
                  {
                    if ( executive::AddManager(gpExec, (baseManager *)gpAdvManager, -1) )
                      ShutDown("Can't add manager!");
                    if ( mainMenuButton == 101 )
                    {
                      v3 = playerData::NextHero(gpGame->players, 0);
                      advManager::SetHeroContext(gpAdvManager, v3, 0);
                    }
                    if ( mainMenuButton == 101 || bForceCheckTimeEvent )
                    {
                      bForceCheckTimeEvent = 0;
                      game::CheckForTimeEvent(gpGame);
                    }
                    executive::MainLoop(gpExec);
                    gMapX = gpAdvManager->viewX;
                    gMapY = gpAdvManager->viewY;
                    executive::RemoveManager(gpExec, (baseManager *)gpAdvManager);
                    heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
                    goto LABEL_177;
                  }
                  giEndSequence = 1;
                }
              }
              gpWindowManager->cycleColors = 0;
              if ( xIsExpansionMap )
                PlaySmacker(64);
              else
                PlaySmacker(3);
              heroWindowManager::FadeScreen(gpWindowManager, 1, 128, gPalette);
              resourceManager::GetBackdrop(gpResourceManager, "heroes.icn", gpWindowManager->screenBuffer, 1);
              heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
              heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
              gpWindowManager->cycleColors = 1;
              v20 = 1;
              soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
LABEL_208:
              gbGameOver = 0;
              if ( gbShowHighScore )
              {
                gbShowHighScore = 0;
                if ( executive::AddManager(gpExec, gpHighScoreManager, -1) )
                  ShutDown("Can't add manager!");
                executive::MainLoop(gpExec);
                executive::RemoveManager(gpExec, gpHighScoreManager);
                giHighScoreRank = -1;
                soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 42);
                resourceManager::GetBackdrop(gpResourceManager, "heroes.icn", gpWindowManager->screenBuffer, 1);
                heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
                heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
                v20 = 1;
              }
            }
            if ( gbRemoteOn )
              v25 = 1;
            goto LABEL_15;
          }
          LogStr("Load Game 1");
          if ( game::PickLoadGame() )
          {
            LogStr("Load Game 2");
            goto LABEL_88;
          }
          break;
        case 103:
          if ( executive::AddManager(gpExec, gpHighScoreManager, -1) )
            ShutDown("Can't add manager!");
          executive::MainLoop(gpExec);
          executive::RemoveManager(gpExec, gpHighScoreManager);
          v20 = 0;
          goto LABEL_16;
        case 104:
          heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
          PlaySmacker(72);
          PlaySmacker(36);
          v20 = 0;
          heroWindowManager::FadeScreen(gpWindowManager, 1, 128, gPalette);
          goto LABEL_16;
        case 105:
          v25 = 1;
          goto LABEL_88;
        default:
          goto LABEL_88;
      }
    }
  }
  ShutDown(0);
  return 0;
}
// 4EF268: using guessed type int gbGameOver;
// 4F19A8: using guessed type int giMenuCommand;
// 4F21F0: using guessed type int giDebugLevel;
// 4F2E88: using guessed type int giCurExe;
// 4F307C: using guessed type int gbInSetupDialog;
// 4F31B4: using guessed type int iMPNetProtocol;
// 4F31B8: using guessed type int iLastDiffSendTo;
// 4F7468: using guessed type int gbSkipIntro;
// 4F7494: using guessed type int gbRemoteOn;
// 4F7498: using guessed type int gbGameInitialized;
// 4F749C: using guessed type int giHighScoreRank;
// 4F74A4: using guessed type int gbShowHighScore;
// 4F74AC: using guessed type int giHighMemBuffer;
// 50CD40: using guessed type int bKBDone;
// 50CD48: using guessed type int bForceCheckTimeEvent;
// 522FF8: using guessed type int giEndSequence;
// 523004: using guessed type char giSetupGameType;
// 523018: using guessed type int gbFunctionComplete;
// 523408: using guessed type int gGameCommand;
// 52340C: using guessed type int giTCPHostStatus;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523ED8: using guessed type int iMPExtendedType;
// 523EDC: using guessed type int giCurWatchPlayer;
// 523EE0: using guessed type int giTCPType;
// 523F08: using guessed type int gbWaitForRemoteReceive;
// 52409C: using guessed type int giShowIntro;
// 5240A8: using guessed type int gpSoundManager;
// 524214: using guessed type int gMapX;
// 524218: using guessed type int gMapY;
// 524730: using guessed type int giThisGamePos;
// 524750: using guessed type int giWaitType;
// 524778: using guessed type int iMPBaseType;
// 524BE0: using guessed type int gbTCPFirstTime;
// 524C14: using guessed type int bShowIt;
// 526DAC: using guessed type char gbUseDiffCompression;
// 526ED8: using guessed type char gbUseRegularCompression;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532C54: using guessed type int giCurTurn;
// 42F820: using guessed type char var_34[8];
// 42F820: using guessed type char var_44[8];

//----- (00430E60) --------------------------------------------------------
char __fastcall toupper(char a1)
{
  char result; // al@3

  if ( a1 < 'a' || a1 > 'z' )
    result = a1;
  else
    result = a1 - 32;
  return result;
}

//----- (00430EB0) --------------------------------------------------------
signed int __cdecl InterpretCommandLine()
{
  int v1; // [sp+Ch] [bp-28h]@43
  int v2; // [sp+10h] [bp-24h]@12
  signed int v3; // [sp+14h] [bp-20h]@69
  int k; // [sp+18h] [bp-1Ch]@69
  signed int v5; // [sp+1Ch] [bp-18h]@61
  int j; // [sp+20h] [bp-14h]@61
  int v7; // [sp+24h] [bp-10h]@54
  signed int i; // [sp+28h] [bp-Ch]@1
  signed int l; // [sp+28h] [bp-Ch]@81
  signed int m; // [sp+28h] [bp-Ch]@85
  signed int v11; // [sp+2Ch] [bp-8h]@1
  unsigned int v12; // [sp+30h] [bp-4h]@1

  gbTCPFirstTime = 1;
  giTCPType = -1;
  giTCPHostStatus = -1;
  giTCPNumPlayers = -1;
  strcpy(gcTCPAddress, byte_50D014);
  strcpy(gcTCPName, byte_50D018);
  gbUseWaveout = 0;
  giDebugLevel = 0;
  giShowIntro = 1;
  gbNoSound = 0;
  gbCheatMenus = 0;
  giScreenScroll = 1;
  giLimitPlayer = 0;
  gbBlackoutPlayer = 1;
  v11 = 0;
  strcpy(gMapName, "Chaos.mp2");
  strcpy(gFullMapName, "Chaos");
  v12 = strlen(gcCommandLine);
  for ( i = 0; (signed int)v12 > i; ++i )
  {
    if ( gcCommandLine[i] == ' '
      && i + 1 < (signed int)v12
      && (gcCommandLine[i + 1] == '?' || gcCommandLine[i + 1] == 'h' || gcCommandLine[i + 1] == 'H') )
      v11 = 1;
    if ( gcCommandLine[i] == '/' && i + 1 < (signed int)v12 )
    {
      v2 = toupper(gcCommandLine[i + 1]) - 68;
      switch ( v2 )
      {
        case 22:
          dword_4F746C = 0;
          break;
        case 19:
          gbUseWaveout = 1;
          if ( i + 2 < (signed int)v12 )
            gbUseWaveout = gcCommandLine[i + 2] - 48;
          break;
        case 18:
          *(_DWORD *)&slowVideo = 1;
          WritePrefs();
          break;
        case 10:
          if ( i + 3 < (signed int)v12 && toupper(gcCommandLine[i + 2]) == 'W' && toupper(gcCommandLine[i + 3]) == 'C' )
            gbCheatMenus = 1;
          break;
        case 9:
          if ( i + 2 < (signed int)v12 )
            gbDontTryMIDI = 1 - (gcCommandLine[i + 2] - 48);
          break;
        case 14:
          if ( i + 2 < (signed int)v12 )
            gbDontTryRedbook = 1 - (gcCommandLine[i + 2] - 48);
          break;
        case 0:
          if ( i + 2 < (signed int)v12 )
            gbDontTryDigital = 1 - (gcCommandLine[i + 2] - 48);
          break;
        case 15:
          if ( i + 2 < (signed int)v12 )
            gbNoSound = 1 - (gcCommandLine[i + 2] - 48);
          break;
        case 5:
          if ( i + 2 < (signed int)v12 )
            giShowIntro = gcCommandLine[i + 2] - 48;
          break;
        case 12:
          if ( i + 2 < (signed int)v12 )
            giDebugLevel = gcCommandLine[i + 2] - 48;
          break;
        case 20:
          byte_4F74B8 = 1;
          break;
        case 16:
          if ( i + 2 < (signed int)v12 )
          {
            v1 = toupper(gcCommandLine[i + 2]) - 65;
            switch ( v1 )
            {
              case 19:
                giTCPType = i + 3 < (signed int)v12 && toupper(gcCommandLine[i + 3]) == 76;
                break;
              case 18:
                giTCPHostStatus = i + 3 < (signed int)v12 && toupper(gcCommandLine[i + 3]) == 72;
                break;
              case 15:
                v7 = 0;
                if ( i + 3 < (signed int)v12 )
                  v7 = gcCommandLine[i + 3] - 48;
                if ( v7 >= 2 && v7 <= 6 )
                  giTCPNumPlayers = v7;
                break;
              case 0:
                if ( i + 3 < (signed int)v12 )
                {
                  v5 = 0;
                  for ( j = i + 3;
                        v5 < 20 && gcCommandLine[j] && gcCommandLine[j] != 32;
                        gcTCPAddress[v5++] = gcCommandLine[j++] )
                    ;
                  gcTCPAddress[v5] = 0;
                }
                break;
              case 13:
                if ( i + 3 < (signed int)v12 )
                {
                  v3 = 0;
                  for ( k = i + 3;
                        v3 < 20 && gcCommandLine[k] && gcCommandLine[k] != 32;
                        gcTCPName[v3++] = gcCommandLine[k++] )
                    ;
                  gcTCPName[v3] = 0;
                }
                break;
              default:
                continue;
            }
          }
          continue;
        default:
          continue;
      }
    }
  }
  if ( v11 )
  {
    sprintf(gText, byte_50D030);
    for ( l = 0; l < 14; ++l )
      strcat(gText, (&gcCommandLineHelp)[4 * l]);
    ShutDown(gText);
  }
  sprintf(cAggPathName, "%s%s", ".\\DATA\\", "heroes2.agg");
  DEFAULT_AGGREGATE_NAME = cAggPathName;
  sprintf(cExpAggPathName, "%s%s", ".\\DATA\\", "heroes2x.agg");
  EXPANSION_AGGREGATE_NAME = cExpAggPathName;
  giFrameStep = 6;
  for ( m = 0; m < 4; ++m )
    gbHumanPlayer[m] = iLastMsgNumHumanPlayers > m;
  if ( iLastMsgNumHumanPlayers == 1 )
    gbBlackoutPlayer = 0;
  if ( giTCPHostStatus != -1 )
  {
    if ( giTCPType == -1 || giTCPNumPlayers == -1 || !giTCPHostStatus && strlen(gcTCPAddress) < 1 )
      ShutDown("Incomplete TCP/IP command line information");
    giShowIntro = 0;
  }
  return 1;
}
// 4F19A4: using guessed type int giScreenScroll;
// 4F1C90: using guessed type int gbDontTryRedbook;
// 4F1C94: using guessed type int gbDontTryMIDI;
// 4F1C98: using guessed type int gbDontTryDigital;
// 4F1CC8: using guessed type int gbCheatMenus;
// 4F1CCC: using guessed type int gbUseWaveout;
// 4F21F0: using guessed type int giDebugLevel;
// 4F746C: using guessed type int dword_4F746C;
// 4F74B8: using guessed type char byte_4F74B8;
// 52340C: using guessed type int giTCPHostStatus;
// 523410: using guessed type int giTCPNumPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523EE0: using guessed type int giTCPType;
// 523F24: using guessed type int gbNoSound;
// 52409C: using guessed type int giShowIntro;
// 52473C: using guessed type int gbBlackoutPlayer;
// 524794: using guessed type int giLimitPlayer;
// 524BE0: using guessed type int gbTCPFirstTime;
// 524CB4: using guessed type int giFrameStep;

//----- (00431650) --------------------------------------------------------
signed int __thiscall InitMenuHandler(tag_message *msg)
{
  signed int result; // eax@26
  int v2; // ST48_4@29
  int v3; // [sp+Ch] [bp-24h]@27
  signed int v5; // [sp+1Ch] [bp-14h]@40
  signed int v6; // [sp+20h] [bp-10h]@4
  signed int v7; // [sp+24h] [bp-Ch]@1
  int highID; // [sp+2Ch] [bp-4h]@32
  signed int highIDa; // [sp+2Ch] [bp-4h]@40

  v7 = 0;
  PollSound();
  if ( BYTE1(msg->inputTypeBitmask) & 2 )
  {
    if ( msg->xCoordOrKeycode == 12 || msg->xCoordOrKeycode == 14 )
    {
      v6 = -1;
      switch ( msg->yCoordOrFieldID )
      {
        case 101:
          v6 = 0;                               // new game
          break;
        case 102:
          v6 = 1;                               // load game
          break;
        case 103:                               // high scores
          v6 = 2;
          break;
        case 104:                               // credits
          v6 = 3;
          break;
        case 105:                               // quit
          v6 = 4;
          break;
        default:
          break;
      }
      if ( v6 >= 0 )
        NormalDialog(gEventText[v6 + 116], 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
  else
  {
    switch ( msg->eventCode )
    {
      case INPUT_KEYDOWN_EVENT_CODE:
        switch ( msg->xCoordOrKeycode )
        {
          case '1':
            gpWindowManager->buttonPressedCode = 101;
            v7 = 1;
            break;
          case '&':
            gpWindowManager->buttonPressedCode = 102;
            v7 = 1;
            break;
          case '.':
            gpWindowManager->buttonPressedCode = 104;
            v7 = 1;
            break;
          case '#':
            gpWindowManager->buttonPressedCode = 103;
            v7 = 1;
            break;
          case '\x10':
            gpWindowManager->buttonPressedCode = 105;
            v7 = 1;
            break;
          default:
            goto LABEL_54;
        }
        break;
      case INPUT_GUI_MESSAGE_CODE:
        if ( msg->yCoordOrFieldID < 101 || msg->yCoordOrFieldID > 107 )
          return 0;
        v3 = msg->xCoordOrKeycode;
        if ( v3 == 12 )
        {
          if ( msg->yCoordOrFieldID != 107 )
          {
            v2 = msg->yCoordOrFieldID - 101;
            msg->eventCode = 512;
            msg->yCoordOrFieldID = v2 + 11;
            msg->xCoordOrKeycode = 4;
            msg->payload = (void *)(4 * v2 + 3);
            heroWindow::BroadcastMessage(gpInitWin, msg);
            heroWindow::DrawWindow(gpInitWin, 0, v2 + 11, v2 + 11);
            heroWindowManager::UpdateScreenRegion(
              gpWindowManager,
              (unsigned __int16)IMHotSpots[4 * v2],
              (unsigned __int16)word_50CFEA[4 * v2],
              (unsigned __int16)word_50CFEC[4 * v2],
              (unsigned __int16)word_50CFEE[4 * v2]);
          }
        }
        else if ( v3 == 13 )
        {
          if ( msg->yCoordOrFieldID == 107 )
          {
            PlaySmacker(38);
            resourceManager::GetBackdrop(gpResourceManager, "heroes.icn", gpWindowManager->screenBuffer, 1);
            heroWindow::DrawWindow(gpInitWin, 0);
            heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
            soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
          }
          else
          {
            gpWindowManager->buttonPressedCode = msg->yCoordOrFieldID;
            for ( highID = 11; highID <= 15; ++highID )
            {
              msg->eventCode = 512;
              msg->yCoordOrFieldID = highID;
              msg->xCoordOrKeycode = 4;
              msg->payload = (void *)(4 * highID - 44);
              heroWindow::BroadcastMessage(gpInitWin, msg);
            }
            heroWindow::DrawWindow(gpInitWin, 0, 11, 15);
            heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 105, 0x235u, 375);
            v7 = 1;
          }
        }
        break;
      case INPUT_MOUSEMOVE_EVENT_CODE:
        v5 = -1;
        for ( highIDa = 0; highIDa < 5; ++highIDa )
        {
          if ( (unsigned __int16)IMHotSpots[4 * highIDa] <= msg->altXCoord
            && (unsigned __int16)word_50CFEA[4 * highIDa] <= msg->altYCoord
            && (unsigned __int16)IMHotSpots[4 * highIDa] + (unsigned __int16)word_50CFEC[4 * highIDa] > msg->altXCoord
            && (unsigned __int16)word_50CFEE[4 * highIDa] + (unsigned __int16)word_50CFEA[4 * highIDa] > msg->altYCoord )
            v5 = highIDa;
        }
        if ( v5 != lastIMHoverID )
        {
          if ( lastIMHoverID != -1 )
          {
            msg->eventCode = 512;
            msg->yCoordOrFieldID = lastIMHoverID + 11;
            msg->xCoordOrKeycode = 4;
            msg->payload = (void *)(4 * lastIMHoverID + 1);
            heroWindow::BroadcastMessage(gpInitWin, msg);
            heroWindow::DrawWindow(gpInitWin, 0, lastIMHoverID + 11, lastIMHoverID + 11);
            heroWindowManager::UpdateScreenRegion(
              gpWindowManager,
              (unsigned __int16)IMHotSpots[4 * lastIMHoverID],
              (unsigned __int16)word_50CFEA[4 * lastIMHoverID],
              (unsigned __int16)word_50CFEC[4 * lastIMHoverID],
              (unsigned __int16)word_50CFEE[4 * lastIMHoverID]);
          }
          if ( v5 != -1 )
          {
            msg->eventCode = 512;
            msg->yCoordOrFieldID = v5 + 11;
            msg->xCoordOrKeycode = 4;
            msg->payload = (void *)(4 * v5 + 2);
            heroWindow::BroadcastMessage(gpInitWin, msg);
            heroWindow::DrawWindow(gpInitWin, 0, v5 + 11, v5 + 11);
            heroWindowManager::UpdateScreenRegion(
              gpWindowManager,
              (unsigned __int16)IMHotSpots[4 * v5],
              (unsigned __int16)word_50CFEA[4 * v5],
              (unsigned __int16)word_50CFEC[4 * v5],
              (unsigned __int16)word_50CFEE[4 * v5]);
          }
          lastIMHoverID = v5;
        }
        break;
    }
  }
LABEL_54:
  if ( v7 || giMenuCommand != -1 )
  {
    msg->eventCode = 512;
    msg->yCoordOrFieldID = 10;
    msg->xCoordOrKeycode = msg->yCoordOrFieldID;
    result = 2;
  }
  else
  {
    CheckShingleUpdate();
    result = 1;
  }
  return result;
}
// 4F19A8: using guessed type int giMenuCommand;
// 50CFE8: using guessed type __int16 IMHotSpots[];
// 50CFEA: using guessed type __int16 word_50CFEA[];
// 50CFEC: using guessed type __int16 word_50CFEC[];
// 50CFEE: using guessed type __int16 word_50CFEE[];
// 50D010: using guessed type int lastIMHoverID;
// 5240A8: using guessed type int gpSoundManager;

//----- (00431D10) --------------------------------------------------------
signed int __fastcall RecruitHeroHandler(tag_message *msg)
{
  signed int result; // eax@16
  int v2; // [sp+Ch] [bp-28h]@7
  int v3; // [sp+14h] [bp-20h]@2
  signed int v5; // [sp+30h] [bp-4h]@1

  v5 = 0;
  if ( msg->eventCode == INPUT_GUI_MESSAGE_CODE )
  {
    v3 = msg->xCoordOrKeycode;
    if ( v3 == 12 )
    {
      if ( msg->yCoordOrFieldID == 2 )
      {
        HeroView(gpTownManager->heroBeingRecruited->idx, 1, 0);
        townManager::RedrawTownScreen(gpTownManager);
        heroWindow::DrawWindow(gpTownManager->curScreen);
        heroWindow::DrawWindow(gpTownManager->dialog);
        heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
      }
    }
    else if ( v3 == 13 )
    {
      v2 = msg->yCoordOrFieldID;
      if ( v2 == BUTTON_CANCEL )
      {
        gpTownManager->recruitHeroConfirmed = -1;
        v5 = 1;
      }
      else if ( v2 == BUTTON_OK )
      {
        gpTownManager->recruitHeroConfirmed = 0;
        gpWindowManager->buttonPressedCode = msg->yCoordOrFieldID;
        v5 = 1;
      }
    }
  }
  if ( v5 == 1 )
  {
    msg->yCoordOrFieldID = 10;
    msg->xCoordOrKeycode = msg->yCoordOrFieldID;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00431EC0) --------------------------------------------------------
char *__fastcall GetBuildingInfo(int faction, signed int building, int withTitle)
{
  char *v3; // ST0C_4@5
  char *hordeDesc; // eax@5
  char *v5; // ST0C_4@10
  char *v6; // eax@10
  char *v8; // eax@12
  signed int fieldIDa; // [sp+Ch] [bp-198h]@1
  int factiona; // [sp+10h] [bp-194h]@1
  char buf[1]; // [sp+14h] [bp-190h]@3

  fieldIDa = building;
  factiona = faction;
  if ( faction != FACTION_NECROMANCER || building != 2 )
  {
    if ( building == BUILDING_SPECIAL_GROWTH )
    {
      v3 = gArmyNamesPlural[gDwellingType[faction][0]];
      hordeDesc = GetBuildingName(faction, BUILDING_SPECIAL_GROWTH);
      sprintf(buf, "The %s increases production of %s by 8 per week.", hordeDesc, v3);
    }
    else if ( building == BUILDING_SPECIAL )
    {
      sprintf(buf, gBuildingInfoSpecial[faction]);
    }
    else
    {
      if ( building >= BUILDING_DWELLING_1 )
      {
        v5 = gArmyNamesPlural[LOBYTE((&gTownObjNames[3 * faction + 27])[building + 1])];
        v6 = GetBuildingName(faction, building);
        sprintf(gText, "The %s produces %s.", v6, v5);
        return gText;
      }
      sprintf(buf, (&cBuildingInfoNeutral)[4 * building]);
    }
  }
  else
  {
    sprintf(buf, xNecromancerShrineDesc);
  }
  if ( withTitle )
  {
    v8 = GetBuildingName(factiona, fieldIDa);
    sprintf(gText, "{%s}\n\n%s", v8, buf);
  }
  else
  {
    sprintf(gText, buf);
  }
  return gText;
}
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (00432070) --------------------------------------------------------
char *__fastcall GetBuildingName(int faction, signed int building)
{
  char *result; // eax@3

  if ( faction != FACTION_NECROMANCER || building != BUILDING_TAVERN )
  {
    if ( building == BUILDING_SPECIAL_GROWTH )
    {
      result = gWellExtraNames[faction];
    }
    else if ( building == BUILDING_SPECIAL )
    {
      result = gSpecialBuildingNames[faction];
    }
    else if ( building >= BUILDING_DWELLING_1 )
    {
      result = (char *)*(&(&off_4F6C54)[faction] + building);
    }
    else
    {
      result = gNeutralBuildingNames[building];
    }
  }
  else
  {
    result = xNecromancerShrine;
  }
  return result;
}
// 4F6C10: using guessed type char *gNeutralBuildingNames[11];

//----- (00432120) --------------------------------------------------------
void *__fastcall GetBuildingCost(int a1, signed int a2, void *a3, int a4)
{
  void *result; // eax@3

  if ( a2 != 2 || a1 != 5 )
  {
    if ( a2 < 19 || a2 > 30 )
    {
      if ( a2 )
      {
        if ( a2 == 13 )
        {
          result = memcpy(a3, (char *)&gSpecialBuildingCosts + 28 * a1, 0x1Cu);
        }
        else if ( a2 < 16 )
        {
          result = memcpy(a3, (char *)&gNeutralBuildingCosts + 28 * a2, 0x1Cu);
        }
      }
      else
      {
        result = memcpy(a3, &gMageBuildingCosts[7 * (a4 + 1)], 0x1Cu);
      }
    }
    else
    {
      result = memcpy(a3, &gDwellingCosts[12 * a1] + a2 - 19, 0x1Cu);
    }
  }
  else
  {
    result = memcpy(a3, &xShrineBuildingCost, 0x1Cu);
  }
  return result;
}
// 4F4288: using guessed type building_cost gDwellingCosts[];

//----- (00432260) --------------------------------------------------------
char *__fastcall GetMonsterName(int creature)
{
  return gArmyNames[creature];
}

//----- (00432280) --------------------------------------------------------
void __fastcall GetMonsterCost(int mon, int *const costs)
{
  RESOURCE_CONSTANTS i; // [sp+18h] [bp-4h]@1

  for ( i = 0; i < NUM_RESOURCES; ++i )
    costs[i] = 0;
  costs[6] = gMonsterDatabase[mon].cost;
  switch ( mon )
  {
    case CREATURE_GENIE:
      costs[5] = 1;
      break;
    case CREATURE_PHOENIX:
      costs[1] = 1;
      break;
    case CREATURE_CYCLOPS:
      costs[4] = 1;
      break;
    case CREATURE_GREEN_DRAGON:
    case CREATURE_RED_DRAGON:
      costs[3] = 1;
      break;
    case CREATURE_BLACK_DRAGON:
      costs[3] = 2;
      break;
    case CREATURE_GIANT:
      costs[5] = 1;
      break;
    case CREATURE_TITAN:
      costs[5] = 2;
      break;
    default:
      return;
  }
}

//----- (004323C0) --------------------------------------------------------
bool __fastcall CanBuild(unsigned int *a1, signed int a2)
{
  bool result; // eax@2
  int v3; // ST20_4@51
  signed int v4; // [sp+Ch] [bp-10h]@1
  unsigned int *this; // [sp+10h] [bp-Ch]@1
  unsigned int v6; // [sp+14h] [bp-8h]@39

  v4 = a2;
  this = a1;
  if ( BitTest(gpGame->field_27BB, *(_BYTE *)a1) )
  {
    result = 0;
  }
  else if ( v4 == 6 || *((_BYTE *)this + 24) & 0x40 )
  {
    if ( xIsExpansionMap || v4 != 2 || *((_BYTE *)this + 3) != 5 )
    {
      if ( v4 == 3 )
      {
        result = town::CanBuildDock((town *)this) != 0;
      }
      else if ( v4 || (signed int)*((_BYTE *)this + 28) < 5 )
      {
        if ( v4 != 5 && v4 != 14 && v4 != 16 && v4 != 17 && v4 != 18 && v4 != 31 )
        {
          if ( v4 >= 19 && v4 <= 30 )
          {
            if ( v4 == 20 && *((_BYTE *)this + 27) & 2
              || v4 == 21 && *((_BYTE *)this + 27) & 4
              || v4 == 22 && *((_BYTE *)this + 27) & 8
              || v4 == 23 && *((_BYTE *)this + 27) & 0x10
              || v4 == 24 && (*((_BYTE *)this + 27) & 0x20 || *((_BYTE *)this + 27) & 0x40)
              || v4 == 29 && *((_BYTE *)this + 27) & 0x40 )
            {
              result = 0;
            }
            else
            {
              v6 = this[6];
              if ( BYTE3(v6) & 2 )
                v6 |= 0x100000u;
              if ( BYTE3(v6) & 4 )
                v6 |= 0x200000u;
              if ( BYTE3(v6) & 8 )
                v6 |= 0x400000u;
              if ( BYTE3(v6) & 0x10 )
                v6 |= 0x800000u;
              if ( BYTE3(v6) & 0x40 )
                v6 |= 0x20000000u;
              if ( BYTE3(v6) & 0x20 )
                v6 |= 0x1000000u;
              v3 = *(&stru_4F4A14.ore + 12 * *((_BYTE *)this + 3) + v4);
              if ( (v6 & v3) == v3 )
                result = *((_BYTE *)this + 3) != 5 || v4 != 28 || (signed int)*((_BYTE *)this + 28) > 1;
              else
                result = 0;
            }
          }
          else
          {
            result = 1;
          }
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F4A14: using guessed type building_cost stru_4F4A14;

//----- (00432680) --------------------------------------------------------
signed int __fastcall CanBuy(int a1, signed int a2)
{
  int v3[7]; // [sp+14h] [bp-24h]@1
  int i; // [sp+30h] [bp-8h]@1
  playerData *v5; // [sp+34h] [bp-4h]@1

  GetBuildingCost(*(_BYTE *)(a1 + 3), a2, v3, *(_BYTE *)(a1 + 28));
  v5 = &gpGame->players[giCurPlayer];
  for ( i = 0; i < 7; ++i )
  {
    if ( v5->resources[i] < v3[i] )
      return 0;
  }
  return 1;
}
// 432680: using guessed type int var_24[7];

//----- (00432720) --------------------------------------------------------
int __fastcall GetBuildingBaseResourceValue(int a1, signed int a2, int a3)
{
  int result; // eax@3

  if ( a1 != 5 || a2 != 5 )
  {
    if ( a2 >= 19 && a2 <= 30 )
    {
      result = *(&dword_4F411C[12 * a1] + a2);
    }
    else if ( a2 <= 15 )
    {
      if ( a2 )
      {
        if ( a2 == 13 )
          result = dword_4F4150[a1];
        else
          result = dword_4F4100[a2];
      }
      else
      {
        result = gMageBaseResourceValues[a3];
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 1000;
  }
  return result;
}
// 4F40E8: using guessed type int gMageBaseResourceValues[];
// 4F4100: using guessed type int dword_4F4100[];
// 4F411C: using guessed type int dword_4F411C[];
// 4F4150: using guessed type int dword_4F4150[];

//----- (004327F0) --------------------------------------------------------
signed int __thiscall WaitHandler(tag_message *this)
{
  signed int result; // eax@27
  int v2; // [sp+10h] [bp-10h]@3
  tag_message *thisa; // [sp+18h] [bp-8h]@1
  signed int v4; // [sp+1Ch] [bp-4h]@1

  thisa = this;
  v4 = 0;
  gbFunctionComplete = 1;
  PollSound();
  if ( thisa->eventCode == 512 )
  {
    if ( thisa->xCoordOrKeycode == 13 )
    {
      v2 = thisa->yCoordOrFieldID;
      if ( v2 >= 30720 && v2 <= 30722 )
      {
        gbFunctionComplete = 0;
        v4 = 1;
      }
    }
  }
  if ( !v4 )
  {
    switch ( giWaitType )
    {
      case 0:
        v4 = WaitForOtherPlayer();
        break;
      case 2:
        v4 = WaitForHost();
        break;
      case 1:
        v4 = WaitForGuest();
        break;
      case 3:
        v4 = InitNetGuest();
        break;
      case 4:
        v4 = InitNetHost();
        break;
      case 5:
        v4 = GUIModemCommandExec();
        break;
      case 6:
        v4 = GUIModemResponseExec();
        break;
      case 7:
        v4 = WaitForDirectConnect();
        break;
      case 8:
        v4 = dpWaitForFirstGuest();
        break;
      case 9:
        v4 = dpWaitForExtraGuests();
        break;
      case 10:
        v4 = dpWaitForHost();
        break;
      case 11:
        v4 = wsWaitForFirstGuest();
        break;
      case 12:
        v4 = wsWaitForExtraGuests();
        break;
      case 13:
        v4 = wsWaitForHost();
        break;
      default:
        break;
    }
  }
  CheckShingleUpdate();
  if ( v4 )
  {
    gpWindowManager->buttonPressedCode = 30721;
    thisa->eventCode = 512;
    thisa->yCoordOrFieldID = 10;
    thisa->xCoordOrKeycode = thisa->yCoordOrFieldID;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 523018: using guessed type int gbFunctionComplete;
// 524750: using guessed type int giWaitType;

//----- (00432A10) --------------------------------------------------------
signed int __fastcall EventWindowHandler(tag_message *this)
{
  signed int result; // eax@6
  int v2; // [sp+14h] [bp-14h]@10
  int v3; // [sp+18h] [bp-10h]@8
  tag_message *thisa; // [sp+1Ch] [bp-Ch]@1
  signed int v5; // [sp+20h] [bp-8h]@9
  signed int v6; // [sp+24h] [bp-4h]@9

  thisa = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) && gpAdvManager->ready == 1 )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( giDialogTimeout && KBTickCount() > giDialogTimeout )
  {
    thisa->eventCode = 512;
    gpWindowManager->buttonPressedCode = thisa->yCoordOrFieldID;
    thisa->yCoordOrFieldID = 10;
    thisa->xCoordOrKeycode = thisa->yCoordOrFieldID;
    giDialogTimeout = 0;
    return 2;
  }
  if ( thisa->eventCode != INPUT_GUI_MESSAGE_CODE )
    return 1;
  v3 = thisa->xCoordOrKeycode;
  if ( v3 == 12 )
    goto LABEL_9;
  if ( v3 != 13 )
  {
    if ( v3 != 14 )
      return 1;
LABEL_9:
    v6 = -1;
    v5 = -1;
    if ( BYTE1(thisa->inputTypeBitmask) & 2 )
    {
      v2 = thisa->yCoordOrFieldID;
      if ( v2 == 7700 )
      {
        v6 = giResType1;
        v5 = giResExtra1;
      }
      else if ( v2 == 7701 )
      {
        v6 = giResType2;
        v5 = giResExtra2;
      }
      switch ( v6 )
      {
        case 10:
          NormalDialog(cLuckInfo, 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 11:
          NormalDialog(off_4F6428, 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 12:
          NormalDialog(cMoraleInfo, 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 13:
          NormalDialog(off_4F68A0, 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 14:
          NormalDialog(
            "{Experience}\n\nExperience allows your heroes to go up levels, increasing their primary and secondary skills.",
            4,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          break;
        case 7:
          if ( v5 == 86 )
          {
            sprintf(gText, gArtifactDesc[86], gSpellNames[xTheSpell]);
            NormalDialog(gText, 4, -1, -1, -1, 0, -1, 0, -1, 0);
          }
          else
          {
            NormalDialog(gArtifactDesc[v5], 4, -1, -1, -1, 0, -1, 0, -1, 0);
          }
          break;
        case 8:
          NormalDialog(gSpellDesc[v5], 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 17:
          NormalDialog((&cSecSkillDesc[3 * (v5 / 3)])[4 * (v5 % 3)], 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 25:
          NormalDialog(gStatDesc[v5], 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
          NormalDialog(
            "{Resources}\n\nThere are seven resources in Heroes 2, used to build and improves castles, purchase troops and recruit heroes.  Gold is the most common, required for virtually everything.  Wood and ore are used for most buildings.  Gems, Mercury, Sulfur and Crystal are rare magical resources used for the most powerful creatures and buildings.",
            4,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          break;
        default:
          return 1;
      }
    }
    return 1;
  }
  switch ( thisa->yCoordOrFieldID )
  {
    case 0x7800:
    case 0x7801:
    case 0x7802:
    case 0x7803:
    case 0x7805:
    case 0x7806:
    case 0x7807:
    case 0x7808:
      gpWindowManager->buttonPressedCode = thisa->yCoordOrFieldID;
      thisa->yCoordOrFieldID = 10;
      thisa->xCoordOrKeycode = thisa->yCoordOrFieldID;
      giDialogTimeout = 0;
      result = 2;
      break;
    case 0x7804:
      return 1;
  }
  return result;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F6DC0: using guessed type char *cSecSkillDesc[42];
// 5240A8: using guessed type int gpSoundManager;
// 524228: using guessed type int giResType1;
// 524230: using guessed type int giResType2;
// 524788: using guessed type int giResExtra1;
// 524790: using guessed type int giResExtra2;
// 5304CC: using guessed type int xTheSpell;

//----- (00432E90) --------------------------------------------------------
signed int __fastcall TrueFalseDialogHandler(tag_message *this)
{
  return EventWindowHandler(this);
}

//----- (00432EB0) --------------------------------------------------------
void __fastcall PlayerDead(int playerNo)
{
  int idx; // [sp+10h] [bp-8h]@1
  int idxa; // [sp+10h] [bp-8h]@6
  signed int idxb; // [sp+10h] [bp-8h]@9
  playerData *player; // [sp+14h] [bp-4h]@1

  gbRetreatWin = 0;
  player = &gpGame->players[playerNo];
  gpGame->playerDead[playerNo] = 1;
  ++gpGame->couldBeNumDefeatedPlayers;
  for ( idx = 0; idx < 144; ++idx )
  {
    if ( gpGame->field_60A6[idx] == playerNo )
      game::ClaimMine(gpGame, idx, -1);
  }
  for ( idxa = player->numHeroes - 1; idxa >= 0; --idxa )
    hero::Deallocate(&gpGame->heroes[player->heroesOwned[idxa]], 1);
  for ( idxb = 0; idxb < 2; ++idxb )
  {
    if ( gpGame->relatedToHeroForHireStatus[player->heroesForPurchase[idxb]] == 64 )
      gpGame->relatedToHeroForHireStatus[player->heroesForPurchase[idxb]] = -1;
  }
  if ( gbRemoteOn )
  {
    if ( gbHumanPlayer[playerNo] )
      HandleRemoteDeadPlayerExit(playerNo);
    else
      SendMapChange(10, playerNo, 0, 0, -999, 0, 0);
  }
}
// 4F7494: using guessed type int gbRemoteOn;
// 524210: using guessed type char gbRetreatWin;

//----- (00433050) --------------------------------------------------------
void __fastcall CheckEndGame(int a1, int a2)
{
  signed int v2; // ST38_4@84
  signed int v3; // ST34_4@96
  int v4; // ecx@119
  int v5; // ecx@125
  int a2a; // [sp+Ch] [bp-1C4h]@1
  int a1a; // [sp+10h] [bp-1C0h]@1
  char saveFile; // [sp+1Ch] [bp-1B4h]@264
  int j; // [sp+30h] [bp-1A0h]@250
  int v10; // [sp+34h] [bp-19Ch]@240
  int v11; // [sp+38h] [bp-198h]@240
  int v12; // [sp+3Ch] [bp-194h]@200
  int v13; // [sp+40h] [bp-190h]@187
  int hasDwarfTown; // [sp+44h] [bp-18Ch]@170
  char v15; // [sp+48h] [bp-188h]@161
  int v16; // [sp+ACh] [bp-124h]@135
  hero *this; // [sp+B0h] [bp-120h]@140
  hero *v18; // [sp+B4h] [bp-11Ch]@125
  hero *v19; // [sp+B8h] [bp-118h]@119
  int v20; // [sp+BCh] [bp-114h]@101
  int goldAmt; // [sp+C0h] [bp-110h]@101
  town *v22; // [sp+C4h] [bp-10Ch]@96
  town *v23; // [sp+C8h] [bp-108h]@84
  int v24; // [sp+CCh] [bp-104h]@52
  int v25; // [sp+D0h] [bp-100h]@52
  int v26; // [sp+D4h] [bp-FCh]@33
  int v27; // [sp+D8h] [bp-F8h]@5
  int i; // [sp+DCh] [bp-F4h]@138
  int v29; // [sp+E0h] [bp-F0h]@33
  int v30; // [sp+E4h] [bp-ECh]@41
  int playerNo; // [sp+1B0h] [bp-20h]@5
  int v32; // [sp+1B4h] [bp-1Ch]@33
  int v33; // [sp+1B8h] [bp-18h]@5
  int v34; // [sp+1BCh] [bp-14h]@41
  int v35; // [sp+1C0h] [bp-10h]@33
  playerData *player; // [sp+1C4h] [bp-Ch]@8
  int v37; // [sp+1C8h] [bp-8h]@33
  int v38; // [sp+1CCh] [bp-4h]@41

  a2a = a2;
  a1a = a1;
  if ( gbThisNetGotAdventureControl && !gbInNewGameSetup && !gbGameOver && !dword_50D2C0 )
  {
    dword_50D2C0 = 1;
    v33 = gbRemoteOn;
    v27 = 0;
    for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
    {
      if ( !gpGame->playerDead[playerNo] )
      {
        player = &gpGame->players[playerNo];
        if ( (gpGame->players[playerNo].numHeroes || player->numCastles)
          && (!xIsPlayingExpansionCampaign || !ExpCampaign::IsSpecialLossCondition((int)&xCampaign, playerNo)) )
        {
          if ( player->numCastles )
          {
            player->field_43 = -1;
          }
          else if ( player->field_43 == -1 )
          {
            if ( gbThisNetHumanPlayer[playerNo] && playerNo == giCurPlayer )
            {
              sprintf(
                gText,
                "%s, you have lost your last town.  If you do not conquer another town in the next week, you will be eliminated.",
                cPlayerNames[playerNo]);
              NormalDialog(gText, 1, -1, -1, 9, gpGame->players[(char)playerNo].color, -1, 0, -1, 0);
            }
            player->field_43 = 7;
          }
          else if ( !player->field_43 )
          {
            PlayerDead(playerNo);
            if ( gbThisNetHumanPlayer[playerNo] && playerNo == giCurPlayer )
            {
              if ( !v27 )
              {
                v27 = 1;
                sprintf(
                  gText,
                  "%s, your heroes abandon you, and you are banished from this land.",
                  cPlayerNames[playerNo]);
              }
            }
            else
            {
              sprintf(
                gText,
                "%s's heroes have abandoned him, and he is banished from this land.",
                cPlayerNames[playerNo]);
            }
            NormalDialog(gText, 1, -1, -1, 9, gpGame->players[(char)playerNo].color, -1, 0, -1, 0);
          }
        }
        else
        {
          PlayerDead(playerNo);
          if ( playerNo == giThisGamePos )
          {
            v27 = 1;
            sprintf(gText, "You have been eliminated from the game!!!");
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
          else
          {
            sprintf(gText, "%s has been vanquished!", cPlayerNames[playerNo]);
            NormalDialog(gText, 1, -1, -1, 9, gpGame->players[(char)playerNo].color, -1, -1, -1, 5000);
          }
        }
      }
    }
    v29 = 0;
    v32 = 0;
    v35 = 0;
    v26 = 0;
    v37 = 0;
    for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
    {
      if ( !gpGame->playerDead[playerNo] )
      {
        ++v29;
        v32 = playerNo;
        if ( gbThisNetHumanPlayer[playerNo] )
          ++v37;
        if ( gbHumanPlayer[playerNo] )
        {
          ++v35;
          v26 = playerNo;
        }
      }
    }
    v30 = 0;
    v38 = 0;
    v34 = 1;
    if ( gpGame->mapHeader.winConditionType && !gpGame->mapHeader.allowDefeatAllVictory
      || gbInCampaign && gpGame->field_2 == 1 && gpGame->field_4 == 6 )
      v34 = 0;
    if ( gpGame->mapHeader.winConditionType == WIN_CONDITION_DEFEAT_COLOR
      && gpGame->mapHeader.winConditionArgument != 99
      && (!gbInCampaign || gpGame->field_2 != 1 || gpGame->field_4 != 6) )
    {
      v24 = 0;
      v25 = 0;
      for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
      {
        if ( !gpGame->playerDead[playerNo] )
        {
          if ( gpGame->players[playerNo].color >= (signed int)HIWORD(gpGame->mapHeader.field_2E) )
            ++v25;
          else
            ++v24;
        }
      }
      if ( v24 )
      {
        if ( !v25 )
        {
          for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
          {
            if ( gbThisNetHumanPlayer[playerNo]
              && !gpGame->playerDead[playerNo]
              && gpGame->players[playerNo].color < (signed int)HIWORD(gpGame->mapHeader.field_2E) )
              v30 = 1;
          }
        }
      }
      else
      {
        for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
        {
          if ( gbThisNetHumanPlayer[playerNo]
            && !gpGame->playerDead[playerNo]
            && gpGame->players[playerNo].color >= (signed int)HIWORD(gpGame->mapHeader.field_2E) )
            v30 = 1;
        }
      }
      if ( !v24 || !v25 )
      {
        if ( !v30 )
          v38 = 1;
        if ( !v27 && v30 )
        {
          v27 = 1;
          sprintf(gText, "The enemy is beaten.  Your side has triumphed!");
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gpGame->mapHeader.winConditionType == WIN_CONDITION_CAPTURE_CASTLE )
    {
      v2 = game::GetTownId(gpGame, gpGame->mapHeader.winConditionArgument, gpGame->mapHeader.field_2C);
      v23 = &gpGame->castles[v2];
      if ( gpGame->castles[v2].ownerIdx != -1 )
      {
        if ( gbHumanPlayer[v23->ownerIdx] || gpGame->mapHeader.field_1E )
        {
          if ( gbThisNetHumanPlayer[v23->ownerIdx] )
            v30 = 1;
          else
            v38 = 1;
          if ( !v27 )
          {
            v27 = 1;
            if ( v30 )
              sprintf(gText, "You captured %s!  You are victorious.", v23->name);
            else
              sprintf(gText, "The enemy has captured %s!  They are triumphant.", v23->name);
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
        }
      }
    }
    if ( gpGame->mapHeader.field_22 == 1 )
    {
      v3 = game::GetTownId(gpGame, *(_WORD *)&gpGame->mapHeader.field_23, LOWORD(gpGame->mapHeader.field_2E));
      v22 = &gpGame->castles[v3];
      if ( gpGame->castles[v3].ownerIdx == -1 || !gbHumanPlayer[v22->ownerIdx] )
      {
        v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "%s has fallen!  All is lost.", v22->name);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gpGame->mapHeader.winConditionType == 5 )
    {
      goldAmt = 0;
      v20 = -1;
      for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
      {
        if ( (gbHumanPlayer[playerNo] || gpGame->mapHeader.field_1E)
          && gpGame->players[playerNo].resources[6] >= 1000 * gpGame->mapHeader.winConditionArgument
          && gpGame->players[playerNo].resources[6] >= goldAmt )
        {
          goldAmt = gpGame->players[playerNo].resources[6];
          v20 = playerNo;
        }
        if ( v20 != -1 )
        {
          if ( gbThisNetHumanPlayer[v20] )
            v30 = 1;
          else
            v38 = 1;
          if ( !v27 )
          {
            v27 = 1;
            if ( v30 )
              sprintf(
                gText,
                "You have built up over %d gold in your treasury.  All enemies bow before your wealth and power.",
                goldAmt);
            else
              sprintf(
                gText,
                "The enemy has built up over %d gold in his treasury.  You must bow done in defeat before his wealth and power.",
                goldAmt);
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
        }
      }
    }
    if ( gpGame->mapHeader.winConditionType == 2 )
    {
      v4 = gpGame->mapHeader.winConditionArgument;
      v19 = &gpGame->heroes[v4];
      if ( gpGame->heroes[v4].ownerIdx < 0 || v19->ownerIdx >= 6 || gbHumanPlayer[v19->ownerIdx] )
      {
        v30 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "You have captured the enemy hero %s!  Your quest is complete.", v19->name);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gpGame->mapHeader.field_22 == 2 )
    {
      v5 = *(_WORD *)&gpGame->mapHeader.field_23;
      v18 = &gpGame->heroes[v5];
      if ( gpGame->heroes[v5].ownerIdx < 0 || v18->ownerIdx >= 6 || !gbHumanPlayer[v18->ownerIdx] )
      {
        v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "You have lost the hero %s.  Your quest is over.", v18->name);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gpGame->mapHeader.field_22 == 3 )
    {
      if ( gpGame->day + 7 * (gpGame->week - 1) + 28 * (gpGame->month - 1) > *(_WORD *)&gpGame->mapHeader.field_23 )
      {
        v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "You have failed to complete your quest in time.  All is lost.");
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gpGame->mapHeader.winConditionType == 3 )
    {
      v16 = -1;
      for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
      {
        if ( !gpGame->playerDead[playerNo] )
        {
          for ( i = 0; gpGame->players[playerNo].numHeroes > i; ++i )
          {
            this = &gpGame->heroes[gpGame->players[playerNo].heroesOwned[i]];
            if ( gpGame->mapHeader.winConditionArgument <= 0 )
            {
              if ( hero::HasArtifact(this, 0)
                || hero::HasArtifact(this, 1)
                || hero::HasArtifact(this, 2)
                || hero::HasArtifact(this, 3)
                || hero::HasArtifact(this, 4)
                || hero::HasArtifact(this, 5)
                || hero::HasArtifact(this, 6)
                || hero::HasArtifact(this, 7) )
                v16 = playerNo;
            }
            else if ( hero::HasArtifact(this, gpGame->mapHeader.winConditionArgument - 1) )
            {
              v16 = playerNo;
            }
          }
        }
      }
      if ( v16 != -1 )
      {
        if ( gbThisNetHumanPlayer[v16] )
          v30 = 1;
        else
          v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          if ( gpGame->mapHeader.winConditionArgument )
            sprintf(&v15, dword_4F55F4[gpGame->mapHeader.winConditionArgument]);
          else
            sprintf(&v15, "Ultimate Artifact");
          if ( v30 )
            sprintf(gText, "You have found the %s.  Your quest is complete.", &v15);
          else
            sprintf(gText, "The enemy has found the %s.  Your quest is a failure.", &v15);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gbInCampaign && !gpGame->field_2 && gpGame->field_4 == 2 )
    {
      hasDwarfTown = 0;
      for ( playerNo = 0; gpGame->players[0].numCastles > playerNo; ++playerNo )
      {
        if ( gpGame->castles[gpGame->players[0].castlesOwned[playerNo]].factionID == FACTION_SORCERESS )
          hasDwarfTown = 1;
      }
      if ( !hasDwarfTown )
      {
        v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "All the dwarf towns have fallen.  This is a disastrous defeat!  You have lost.");
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gbInCampaign )
    {
      if ( gpGame->field_2 == 1 )
      {
        if ( gpGame->field_4 == 6 )
        {
          if ( a2a )
          {
            v30 = 1;
            if ( !v27 )
            {
              v27 = 1;
              sprintf(gText, "Dragon city has fallen!  You are now the Master of the Dragons.");
              NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
          }
        }
      }
    }
    if ( gbInCampaign && !gpGame->field_2 && gpGame->field_4 == 8 )
    {
      v13 = 0;
      for ( playerNo = 0; playerNo < 54; ++playerNo )
      {
        if ( gpGame->heroes[playerNo].heroID == 54
          && gpGame->heroes[playerNo].ownerIdx >= 0
          && gpGame->heroes[playerNo].ownerIdx <= 5 )
          v13 = 1;
      }
      if ( !v13 )
      {
        v38 = 1;
        if ( !v27 )
        {
          v27 = 1;
          sprintf(gText, "Roland has been captured!  All is lost.");
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
    }
    if ( gbInCampaign && !gpGame->field_2 && gpGame->field_4 == 8 )
    {
      v12 = 0;
      for ( playerNo = 0; gpGame->numPlayers > playerNo; ++playerNo )
      {
        if ( !gpGame->playerDead[playerNo] && gpGame->players[playerNo].color && gpGame->players[playerNo].color != 3 )
          v12 = 1;
      }
      if ( !v12 )
      {
        v30 = 1;
        if ( !v27 )
        {
          if ( v30 )
          {
            v27 = 1;
            sprintf(gText, "The enemy is beaten.  Your side has triumphed!");
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
        }
      }
    }
    if ( v38 )
    {
      gbGameOver = 1;
      giEndSequence = 0;
    }
    if ( v30 )
    {
      gbGameOver = 1;
      giEndSequence = 1;
    }
    if ( v29 == 1 || !v35 || v35 == 1 && !gbThisNetHumanPlayer[v26] )
    {
      if ( v35 == 1 && gbThisNetHumanPlayer[v26] )
      {
        if ( v34 )
        {
          gbGameOver = 1;
          giEndSequence = 1;
        }
      }
      else
      {
        gbGameOver = 1;
        giEndSequence = 0;
      }
    }
    if ( v33 && !v37 )
    {
      gbGameOver = 1;
      giEndSequence = 0;
    }
    if ( a1a == 1 )
    {
      v30 = 1;
      gbGameOver = 1;
      giEndSequence = 1;
    }
    if ( a1a == 2 )
    {
      v38 = 1;
      gbGameOver = 1;
      giEndSequence = 0;
    }
    if ( giEndSequence == 1 && gbGameOver )
      v30 = 1;
    if ( !giEndSequence && gbGameOver )
      v38 = 1;
    if ( gbInCampaign && v30 )
    {
      v11 = gpGame->day + 7 * (gpGame->week - 1) + 28 * (gpGame->month - 1);
      gpGame->_11[71] = 1;
      *(&gpGame->_1[12 * gpGame->field_2] + gpGame->field_4) = 1;
      *((_WORD *)&gpGame->_1[24 * gpGame->field_2 + 72] + gpGame->field_4) = v11;
      *(_WORD *)&gpGame->_11[49] = *((_WORD *)&gpGame->_1[24 * gpGame->field_2 + 24] + gpGame->field_4)
                                 + *((_WORD *)&gpGame->_1[24 * gpGame->field_2 + 72] + gpGame->field_4);
      v10 = -1;
      if ( !gpGame->field_2 && gpGame->field_4 == 6 )
        v10 = 99;
      if ( gpGame->field_2 == 1 && gpGame->field_4 == 9 )
        v10 = 99;
      if ( v10 != -1 )
      {
        for ( playerNo = 0; playerNo < 5; ++playerNo )
        {
          *(_WORD *)&gpGame->_11[2 * playerNo + 51] = -1;
          *(_WORD *)&gpGame->_11[2 * playerNo + 61] = 0;
        }
        for ( j = 0;
              gpGame->players[0].numHeroes > j
           && v10 != 99
           && gpGame->heroes[gpGame->players[0].heroesOwned[j]].heroID != v10;
              ++j )
          ;
        if ( gpGame->players[0].numHeroes == j )
        {
          *(_WORD *)&gpGame->_11[51] = 0;
          *(_WORD *)&gpGame->_11[61] = 1;
        }
        else
        {
          for ( playerNo = 0; playerNo < 5; ++playerNo )
          {
            *(_WORD *)&gpGame->_11[2 * playerNo + 51] = gpGame->heroes[gpGame->players[0].heroesOwned[j]].army.creatureTypes[playerNo];
            *(_WORD *)&gpGame->_11[2 * playerNo + 61] = gpGame->heroes[gpGame->players[0].heroesOwned[j]].army.quantities[playerNo];
          }
        }
      }
      if ( gpGame->field_4 != 10 && (gpGame->field_4 != 9 || gpGame->field_2) )
      {
        sprintf(&saveFile, "%s%c_%02d", "WIN_", (unsigned int)gpGame->field_2 < 1 ? 71 : 69, gpGame->field_4 + 1);
        game::SaveGame(gpGame, &saveFile, 1, 0);
      }
    }
    else if ( xIsPlayingExpansionCampaign && v30 )
    {
      ExpCampaign::Autosave((signed int)&xCampaign);
    }
    dword_50D2C0 = 0;
  }
}
// 4EF268: using guessed type int gbGameOver;
// 4F7494: using guessed type int gbRemoteOn;
// 50D2C0: using guessed type int dword_50D2C0;
// 522FF8: using guessed type int giEndSequence;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 523F1C: using guessed type int gbInNewGameSetup;
// 524730: using guessed type int giThisGamePos;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (00434AC0) --------------------------------------------------------
void __cdecl QuickViewWait()
{
  tag_message a2; // [sp+Ch] [bp-3Ch]@3
  tag_message evt; // [sp+28h] [bp-20h]@3
  bool i; // [sp+44h] [bp-4h]@1

  mouseManager::ReallyHidePointer(gpMouseManager);
  for ( i = 0;
        !i;
        i = evt.eventCode == INPUT_RIGHT_UP_EVENT_CODE
         || evt.eventCode == INPUT_LEFT_CLICK_EVENT_CODE
         || evt.eventCode == INPUT_LEFT_UP_EVENT_CODE )
  {
    PollSound();
    Process1WindowsMessage();
    memcpy(&evt, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), sizeof(evt));
  }
  mouseManager::ReallyShowPointer(gpMouseManager);
}

//----- (00434B60) --------------------------------------------------------
void __cdecl InitVars()
{
  signed int i; // [sp+10h] [bp-4h]@1

  NULL_SAMPLE2.file = 0;
  NULL_SAMPLE2.sample = 0;
  gGameCommand = -1;
  gPalette = 0;
  gbCombatSurrender = 0;
  *(_DWORD *)&gpGame->mapEventIndices[52] = 0;
  strcpy(gpGame->mapFilename, "brokena.mp2");
  gpGame->mapFilename[20] = 0;
  gbInNewGameSetup = 0;
  strcpy(cNetBoxLine, byte_50D7B0);
  strcpy(&cNetBoxLine[140], byte_50D7B4);
  strcpy(&cNetBoxLine[280], byte_50D7B8);
  strcpy(&cNetBoxLine[420], byte_50D7BC);
  cNetBoxColor = 6;
  byte_524C41 = 6;
  byte_524C42 = 6;
  byte_524C43 = 6;
  ppMapExtra = 0;
  pwSizeOfMapExtra = 0;
  iMaxMapExtra = 0;
  for ( i = 0; i < 10; ++i )
    *(&glTimers + i) = 0;
  if ( gbCheatMenus )
  {
    hmnuDflt = LoadMenuA(hInstApp, "mnuDflt");
    hmnuCmbt = LoadMenuA(hInstApp, "mnuCmbt");
    hmnuAdv = LoadMenuA(hInstApp, "mnuAdvD");
    hmnuTown = LoadMenuA(hInstApp, "mnuTownD");
  }
  else
  {
    hmnuDflt = LoadMenuA(hInstApp, "mnuDflt");
    hmnuCmbt = LoadMenuA(hInstApp, "mnuCmbt");
    hmnuAdv = LoadMenuA(hInstApp, "mnuAdv");
    hmnuTown = LoadMenuA(hInstApp, "mnuTown");
  }
}
// 4F1CC8: using guessed type int gbCheatMenus;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 523408: using guessed type int gGameCommand;
// 523450: using guessed type char gbCombatSurrender;
// 523F1C: using guessed type int gbInNewGameSetup;
// 524C40: using guessed type char cNetBoxColor;
// 524C41: using guessed type char byte_524C41;
// 524C42: using guessed type char byte_524C42;
// 524C43: using guessed type char byte_524C43;

//----- (00434D70) --------------------------------------------------------
heroWindow *__stdcall game::ShowMoraleInfo(int a1, int a2)
{
  town *v2; // eax@1
  town *v3; // eax@3
  unsigned int v4; // eax@69
  int v6; // [sp+10h] [bp-DCh]@15
  signed int v7; // [sp+14h] [bp-D8h]@1
  char v8; // [sp+18h] [bp-D4h]@2
  int i; // [sp+E0h] [bp-Ch]@15
  unsigned int v10; // [sp+E4h] [bp-8h]@6
  int v11; // [sp+E8h] [bp-4h]@11

  v7 = 0;
  v2 = hero::GetOccupiedTown((hero *)a1);
  if ( armyGroup::GetMorale((armyGroup *)(a1 + 101), (hero *)a1, v2, 0) <= 0 )
  {
    v3 = hero::GetOccupiedTown((hero *)a1);
    if ( armyGroup::GetMorale((armyGroup *)(a1 + 101), (hero *)a1, v3, 0) )
      sprintf(&v8, off_4F68A0);
    else
      sprintf(&v8, off_4F689C);
  }
  else
  {
    sprintf(&v8, cMoraleInfo);
  }
  sprintf(gText, off_4F68A4, &v8);
  v10 = strlen(gText);
  if ( armyGroup::HasAllUndead((armyGroup *)(a1 + 101)) )
  {
    strcat(gText, off_4F68EC);
  }
  else
  {
    if ( armyGroup::HasSomeUndead((armyGroup *)(a1 + 101)) || hero::HasArtifact((hero *)a1, 87) )
    {
      strcat(gText, off_4F68F0);
      v7 = 1;
    }
    v11 = armyGroup::IsHomogeneous((armyGroup *)(a1 + 101), -1);
    if ( v7 && v11 > 0 )
      v11 = 0;
    if ( v11 > 0 )
    {
      v6 = 0;
      for ( i = 0; i < 5; ++i )
      {
        if ( *(_BYTE *)(i + a1 + 101) != -1 )
          v6 = gMonsterDatabase[*(_BYTE *)(i + a1 + 101)].faction;
      }
      sprintf(&v8, off_4F68AC, gAlignmentNames[v6]);
      strcat(gText, &v8);
    }
    if ( v11 == -1 )
    {
      sprintf(&v8, off_4F68B0);
      strcat(gText, &v8);
    }
    if ( v11 == -2 )
    {
      sprintf(&v8, off_4F68B4);
      strcat(gText, &v8);
    }
    if ( v11 == -3 )
    {
      sprintf(&v8, off_4F68E8);
      strcat(gText, &v8);
    }
    if ( hero::GetOccupiedTown((hero *)a1)
      && hero::GetOccupiedTown((hero *)a1)->factionID == 1
      && BYTE1(hero::GetOccupiedTown((hero *)a1)->buildingsBuiltFlags) & 0x20 )
      strcat(gText, off_4F68FC);
    if ( hero::GetOccupiedTown((hero *)a1) && hero::GetOccupiedTown((hero *)a1)->buildingsBuiltFlags & 4 )
      strcat(gText, off_4F6900);
    if ( hero::HasArtifact((hero *)a1, 12) )
      strcat(gText, off_4F68B8);
    if ( hero::HasArtifact((hero *)a1, 13) )
      strcat(gText, off_4F68BC);
    if ( hero::HasArtifact((hero *)a1, 14) )
      strcat(gText, off_4F68C0);
    if ( hero::HasArtifact((hero *)a1, 15) )
      strcat(gText, off_4F68C4);
    if ( hero::HasArtifact((hero *)a1, 16) )
      strcat(gText, off_4F68C8);
    if ( *(_BYTE *)(a1 + 227) & 2 )
      strcat(gText, off_4F68CC);
    if ( *(_BYTE *)(a1 + 227) & 8 )
      strcat(gText, off_4F68D0);
    if ( *(_BYTE *)(a1 + 228) & 1 )
      strcat(gText, off_4F68D4);
    if ( *(_BYTE *)(a1 + 227) & 0x20 )
      strcat(gText, off_4F68D8);
    if ( *(_BYTE *)(a1 + 227) & 0x40 )
      strcat(gText, off_4F68DC);
    if ( *(_BYTE *)(a1 + 228) & 2 )
      strcat(gText, off_4F68F4);
    if ( *(_BYTE *)(a1 + 228) & 4 )
      strcat(gText, off_4F68F8);
    if ( *(_BYTE *)(a1 + 122) == 1 )
      strcat(gText, off_4F6904);
    if ( *(_BYTE *)(a1 + 122) == 2 )
      strcat(gText, off_4F6908);
    if ( *(_BYTE *)(a1 + 122) == 3 )
      strcat(gText, off_4F690C);
    if ( hero::HasArtifact((hero *)a1, 97) && *(_BYTE *)(a1 + 227) & 0x80 )
      strcat(gText, off_4F6910);
    if ( hero::HasArtifact((hero *)a1, 90) )
      strcat(gText, off_4F6914);
    v4 = strlen(gText);
    if ( v4 == v10 )
      strcat(gText, off_4F68E4);
  }
  return NormalDialog(gText, a2, -1, -1, -1, 0, -1, 0, -1, 0);
}

//----- (00435370) --------------------------------------------------------
heroWindow *__stdcall game::ShowLuckInfo(int a1, int a2)
{
  town *v2; // eax@1
  town *v3; // eax@3
  unsigned int v4; // eax@39
  char v6; // [sp+10h] [bp-D0h]@2
  unsigned int v7; // [sp+DCh] [bp-4h]@6

  v2 = hero::GetOccupiedTown((hero *)a1);
  if ( game::GetLuck((hero *)a1, 0, v2) <= 0 )
  {
    v3 = hero::GetOccupiedTown((hero *)a1);
    if ( game::GetLuck((hero *)a1, 0, v3) )
      sprintf(&v6, off_4F6428);
    else
      sprintf(&v6, off_4F6424);
  }
  else
  {
    sprintf(&v6, cLuckInfo);
  }
  sprintf(gText, off_4F642C, &v6);
  v7 = strlen(gText);
  if ( hero::GetOccupiedTown((hero *)a1)
    && hero::GetOccupiedTown((hero *)a1)->factionID == 2
    && BYTE1(hero::GetOccupiedTown((hero *)a1)->buildingsBuiltFlags) & 0x20 )
    strcat(gText, off_4F6450);
  if ( hero::HasArtifact((hero *)a1, 35) )
    strcat(gText, off_4F6430);
  if ( hero::HasArtifact((hero *)a1, 36) )
    strcat(gText, off_4F6434);
  if ( hero::HasArtifact((hero *)a1, 37) )
    strcat(gText, off_4F6438);
  if ( hero::HasArtifact((hero *)a1, 38) )
    strcat(gText, off_4F643C);
  if ( *(_BYTE *)(a1 + 227) & 0x10 )
    strcat(gText, off_4F6440);
  if ( *(_BYTE *)(a1 + 228) & 0x20 )
    strcat(gText, off_4F6454);
  if ( *(_BYTE *)(a1 + 227) & 4 )
    strcat(gText, off_4F6444);
  if ( *(_BYTE *)(a1 + 228) & 0x40 )
    strcat(gText, off_4F6458);
  if ( *(_BYTE *)(a1 + 125) == 1 )
    strcat(gText, off_4F645C);
  if ( *(_BYTE *)(a1 + 125) == 2 )
    strcat(gText, off_4F6460);
  if ( *(_BYTE *)(a1 + 125) == 3 )
    strcat(gText, off_4F6464);
  if ( hero::HasArtifact((hero *)a1, 97) && *(_BYTE *)(a1 + 227) & 0x80 )
    strcat(gText, off_4F6468);
  if ( *(_BYTE *)(a1 + 229) & 0x10 )
    strcat(gText, off_4F646C);
  if ( hero::HasArtifact((hero *)a1, 90) )
    strcat(gText, off_4F6470);
  v4 = strlen(gText);
  if ( v4 == v7 )
    strcat(gText, off_4F6448);
  return NormalDialog(gText, a2, -1, -1, -1, 0, -1, 0, -1, 0);
}

//----- (004356E0) --------------------------------------------------------
void __cdecl ClearMapExtra()
{
  int i; // [sp+Ch] [bp-4h]@1

  for ( i = 0; i < iMaxMapExtra; ++i )
  {
    if ( ppMapExtra[i] )
      BaseFree(ppMapExtra[i], (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D804 + 6);
  }
  if ( ppMapExtra )
    BaseFree(ppMapExtra, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D804 + 9);
  ppMapExtra = 0;
  if ( pwSizeOfMapExtra )
    BaseFree(pwSizeOfMapExtra, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D804 + 13);
  pwSizeOfMapExtra = 0;
  iMaxMapExtra = 0;
}
// 50D804: using guessed type __int16 word_50D804;

//----- (004357C0) --------------------------------------------------------
_DWORD __fastcall GetMonType(signed int a1, _DWORD a2)
{
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 65; i >= 0; --i )
  {
    if ( a2 && a2 != 2 )
    {
      if ( giScoreMon[2 * i] <= a1 )
        return word_4F2C2A[2 * i];
    }
    else if ( giScoreCampaignMon[2 * i] >= a1 )
    {
      return word_4F2D32[2 * i];
    }
  }
  return word_4F2C2A[0];
}
// 4357C0: too many cbuild loops
// 4F2C28: using guessed type __int16 giScoreMon[];
// 4F2D30: using guessed type __int16 giScoreCampaignMon[];
// 4F2D32: using guessed type __int16 word_4F2D32[];

//----- (00435860) --------------------------------------------------------
int __fastcall AddScoreToHighScore(int a1, int a2, int a3, int a4, const char *a5)
{
  int v6; // [sp+Ch] [bp-574h]@1
  int v7; // [sp+10h] [bp-570h]@1
  char this; // [sp+14h] [bp-56Ch]@2
  int v9; // [sp+174h] [bp-40Ch]@1
  int j; // [sp+178h] [bp-408h]@27
  int fd; // [sp+17Ch] [bp-404h]@4
  int i; // [sp+180h] [bp-400h]@7
  char buf[58]; // [sp+184h] [bp-3FCh]@9
  int v14; // [sp+1BEh] [bp-3C2h]@9
  int v15; // [sp+1C2h] [bp-3BEh]@30
  int v16; // [sp+1C6h] [bp-3BAh]@30
  char v17[930]; // [sp+1CAh] [bp-3B6h]@30
  char a2a; // [sp+56Ch] [bp-14h]@30

  v6 = a2;
  v7 = a1;
  v9 = 0;
  if ( a4 == 1 )
    sprintf(&this, "%sSTANDARD.HS", ".\\DATA\\");
  else
    sprintf(&this, "%sCAMPAIGN.HS", ".\\DATA\\");
  fd = open(&this, 32768);
  if ( fd == -1 )
    v9 = 1;
  if ( v9 )
  {
    for ( i = 0; i < 10; ++i )
    {
      memset(&buf[100 * i], 0, 0x64u);
      *(&v14 + 25 * i) = -1;
    }
  }
  else
  {
    for ( i = 0; i < 10; ++i )
      _read(fd, &buf[100 * i], 0x3E8u);
    _close(fd);
  }
  gbShowHighScore = 1;
  giHighScoreType = a4;
  giHighScoreRank = -1;
  giScore = v7;
  for ( i = 0; i < 10; ++i )
  {
    if ( *(&v14 + 25 * i) <= v7 && a4 == 1
      || *(&v14 + 25 * i) >= v7 && !a4
      || *(&v14 + 25 * i) >= v7 && a4 == 2
      || *(&v14 + 25 * i) == -1 )
    {
      giHighScoreRank = i;
      break;
    }
  }
  if ( i >= 10 )
  {
    gbShowHighScore = 0;
  }
  else
  {
    for ( j = 8; i <= j; --j )
      memcpy(&buf[25 * (4 * j + 4)], &buf[100 * j], 0x64u);
    GetDataEntry("Please enter your name for the high score list.", (int)&a2a, 16, 0, 0, 1);
    memset(&buf[100 * i], 0, 0x64u);
    strcpy(&buf[100 * i], &a2a);
    strcpy(&buf[100 * i + 17], (char *)a5);
    *(&v14 + 25 * i) = v7;
    *(&v15 + 25 * i) = v6;
    *(&v16 + 25 * i) = a3;
    v17[100 * i] = gpGame->_B[1];
    if ( !a4 && gpGame->_11[72] )
      v17[100 * i] = 1;
    fd = open(&this, 33537, 128);
    if ( fd == -1 )
      FileError(&this);
    for ( i = 0; i < 10; ++i )
      _write(fd, &buf[100 * i], 100);
    _close(fd);
  }
  return 0;
}
// 4F749C: using guessed type int giHighScoreRank;
// 4F74A0: using guessed type int giHighScoreType;
// 4F74A4: using guessed type int gbShowHighScore;
// 5247B0: using guessed type int giScore;
// 435860: using guessed type char buf[58];
// 435860: using guessed type char var_3B6[930];

//----- (00435D20) --------------------------------------------------------
int __fastcall BVResMsg(const char *a1, int a2, int a3)
{
  int v3; // ST18_4@1
  char *v4; // ST1C_4@1

  v3 = a2;
  v4 = (char *)a1;
  giBottomViewOverride = 5;
  giBottomViewOverrideEndTime = KBTickCount() + 5000;
  *(_DWORD *)&giBottomViewResource = v3;
  giBottomViewResourceQty = a3;
  strcpy(gcBottomViewText, v4);
  return advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
}
// 52405C: using guessed type int giBottomViewOverride;
// 524798: using guessed type int giBottomViewOverrideEndTime;
// 5249E4: using guessed type int giBottomViewResourceQty;

//----- (00435D90) --------------------------------------------------------
void __thiscall GOut(void *this)
{
  if ( gpAdvManager->ready == 1 )
    AiPrint(this);
}

//----- (00435DC0) --------------------------------------------------------
signed int __thiscall NetPosToGamePos(void *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 6; ++i )
  {
    if ( (void *)gbGamePosToNetPos[i] == this )
      return i;
  }
  return -1;
}

//----- (00435E20) --------------------------------------------------------
signed int __cdecl WaitForOtherPlayer()
{
  int v0; // edx@1
  int v2; // [sp+Ch] [bp-Ch]@3
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@1

  v4 = 0;
  PollSound();
  v3 = GetRemoteData(1, v0);
  if ( v3 && *((_BYTE *)v3 + 5) == 2 )
  {
    v2 = *((_BYTE *)v3 + 6);
    if ( v2 == 1 )
    {
      v4 = game::ReceiveSaveGame(
             *(_DWORD *)((char *)v3 + 9),
             *(_DWORD *)((char *)v3 + 13),
             *(_DWORD *)((char *)v3 + 17),
             *(_BYTE *)v3);
    }
    else if ( v2 == 32 )
    {
      memcpy(gbGamePosToNetPos, (char *)v3 + 9, 6u);
      gbUseRegularCompression = *((_BYTE *)v3 + 15);
      gbUseDiffCompression = *((_BYTE *)v3 + 16);
      memcpy(&gsNetPlayerInfo, (char *)v3 + 17, 0xCCu);
      giThisGamePos = NetPosToGamePos((void *)giThisNetPos);
    }
  }
  return v4;
}
// 524730: using guessed type int giThisGamePos;
// 526DAC: using guessed type char gbUseDiffCompression;
// 526ED8: using guessed type char gbUseRegularCompression;

//----- (00435F20) --------------------------------------------------------
void __fastcall PopNetBox(const char *a1, void *a2)
{
  signed int v2; // eax@4
  int v3; // edx@14
  int v4; // edx@14
  signed int v5; // eax@25
  signed int v6; // eax@58
  unsigned int v7; // eax@58
  void *v8; // [sp+1Ch] [bp-148h]@1
  tag_message a2a; // [sp+24h] [bp-140h]@30
  int this; // [sp+40h] [bp-124h]@7
  int v11; // [sp+44h] [bp-120h]@79
  void *v12; // [sp+48h] [bp-11Ch]@14
  int v13; // [sp+4Ch] [bp-118h]@2
  int v14; // [sp+50h] [bp-114h]@7
  int v15; // [sp+54h] [bp-110h]@2
  tag_message v16; // [sp+58h] [bp-10Ch]@30
  int v17; // [sp+74h] [bp-F0h]@2
  int v18; // [sp+78h] [bp-ECh]@7
  int v19; // [sp+7Ch] [bp-E8h]@12
  tag_message evt; // [sp+80h] [bp-E4h]@12
  int v21; // [sp+9Ch] [bp-C8h]@12
  int i; // [sp+A0h] [bp-C4h]@72
  int v23; // [sp+A4h] [bp-C0h]@58
  int v24; // [sp+A8h] [bp-BCh]@12
  int v25; // [sp+ACh] [bp-B8h]@2
  heroWindow *window; // [sp+B0h] [bp-B4h]@8
  int v27; // [sp+B4h] [bp-B0h]@42
  char a1a; // [sp+B8h] [bp-ACh]@12
  char v29[151]; // [sp+B9h] [bp-ABh]@67
  int v30; // [sp+150h] [bp-14h]@12
  int v31; // [sp+154h] [bp-10h]@12
  int v32; // [sp+158h] [bp-Ch]@12
  int v33; // [sp+15Ch] [bp-8h]@12
  int v34; // [sp+160h] [bp-4h]@2

  v8 = a2;
  if ( !gbRemoteOn )
    return;
  v34 = 120;
  v13 = 1;
  v17 = 20;
  v15 = 54;
  v25 = 0;
  if ( a1 )
  {
    if ( (signed int)a2 < 0 )
    {
      sprintf(gText, a1);
      gText[120] = 0;
      AddNetBoxLine(gText, 6);
    }
    else
    {
      sprintf(gText, "%s:  %s", (char *)&gsNetPlayerInfo + 34 * (_DWORD)a2 + 4, a1);
      gText[120] = 0;
      v2 = NetPosToGamePos(v8);
      AddNetBoxLine(gText, gpGame->players[v2].color);
    }
    v25 = KBTickCount();
  }
  v18 = 0;
  v14 = bShowIt;
  bShowIt = 1;
  gbMoveShown = 0;
  this = (int)operator new(68);
  if ( this )
    window = heroWindow::heroWindow((heroWindow *)this, 0, 411, "netbox.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  evt.eventCode = 512;
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 1;
  evt.payload = cNetBoxLine;
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 2;
  evt.payload = &cNetBoxLine[140];
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 3;
  evt.payload = &cNetBoxLine[280];
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 4;
  evt.payload = &cNetBoxLine[420];
  heroWindow::BroadcastMessage(window, &evt);
  evt.xCoordOrKeycode = 4;
  evt.yCoordOrFieldID = 20;
  evt.payload = (void *)(cNetBoxColor + 1);
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 21;
  evt.payload = (void *)(byte_524C41 + 1);
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 22;
  evt.payload = (void *)(byte_524C42 + 1);
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 23;
  evt.payload = (void *)(byte_524C43 + 1);
  heroWindow::BroadcastMessage(window, &evt);
  evt.yCoordOrFieldID = 24;
  evt.payload = (void *)(gpGame->players[NetPosToGamePos((void *)giThisNetPos)].color + 1);
  heroWindow::BroadcastMessage(window, &evt);
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  v30 = 0;
  v31 = 0;
  v32 = 1;
  v33 = 0;
  v19 = 0;
  v24 = 1;
  v21 = 0;
  strcpy(&a1a, byte_50D8C4);
  inputManager::SetKeyCodeType(gpInputManager, 0);
  while ( !v31 )
  {
    PollSound();
    v12 = GetRemoteData(0, v3);
    if ( v12 )
    {
      if ( *((_BYTE *)v12 + 5) == 3 )
      {
        v12 = GetRemoteData(1, v4);
        if ( *((_BYTE *)v12 + 6) == 41 )
        {
          dword_4F1CC0 = 1;
          if ( gpAdvManager->ready == 1 )
          {
            bShowIt = v14;
            advManager::ProcessIncomingGroupMapChange(gpAdvManager, (char *)v12 + 9);
            bShowIt = 1;
            v21 = 1;
          }
          dword_4F1CC0 = 0;
          v32 = 1;
        }
      }
      else if ( *((_BYTE *)v12 + 5) == 2 )
      {
        if ( *((_BYTE *)v12 + 6) == 11 )
        {
          v12 = GetRemoteData(1, v4);
          sprintf(gText, "%s:  %s", (char *)&gsNetPlayerInfo + 34 * *(_BYTE *)v12 + 4, (char *)v12 + 9);
          v5 = NetPosToGamePos((void *)*(_BYTE *)v12);
          AddNetBoxLine(gText, gpGame->players[v5].color);
          v24 = 1;
          if ( v25 )
            v25 = KBTickCount();
        }
        else
        {
          AddNetBoxLine("[ Incoming data, must exit... ]", 6);
          v24 = 1;
          v30 = 1;
        }
      }
      else
      {
        v12 = GetRemoteData(1, v4);
      }
    }
    Process1WindowsMessage();
    memcpy(&v16, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2a), sizeof(v16));
    if ( v16.eventCode == 1 )
    {
      v25 = 0;
      if ( v16.xCoordOrKeycode <= 27 )
      {
        if ( v16.xCoordOrKeycode == 27 )
          goto LABEL_32;
        if ( v16.xCoordOrKeycode == 10 )
        {
          v19 = 1;
          goto LABEL_54;
        }
LABEL_37:
        if ( LOBYTE(v16.xCoordOrKeycode) >= 0x20u )
        {
          if ( LOBYTE(v16.xCoordOrKeycode) <= 0x7Fu )
          {
            if ( v18 < 93 )
            {
              if ( v16.xCoordOrKeycode )
              {
                *(&a1a + v18) = 0;
                v27 = font::LineWidth(smallFont, &a1a);
                if ( v27 + 50 < 602 )
                {
                  *(&a1a + v18++) = LOBYTE(v16.xCoordOrKeycode);
                  v32 = 1;
                  v33 = 0;
                }
              }
            }
          }
        }
        goto LABEL_54;
      }
      if ( v16.xCoordOrKeycode != 127 )
      {
        if ( v16.xCoordOrKeycode == 0x3B00 )
        {
LABEL_32:
          v31 = 1;
          goto LABEL_54;
        }
        goto LABEL_37;
      }
      if ( v18 > 0 )
        --v18;
      v32 = 1;
      v33 = 1;
    }
LABEL_54:
    if ( !v32 && KBTickCount() > glTimers )
    {
      v33 = 1 - v33;
      v32 = 1;
    }
    if ( v19 )
    {
      v19 = 0;
      *(&a1a + v18) = 0;
      v6 = NetPosToGamePos((void *)giThisNetPos);
      AddNetBoxLine(&a1a, gpGame->players[v6].color);
      v7 = strlen(&a1a);
      v23 = TransmitRemoteData(&a1a, 127, v7 + 1, 11, 1, 1, -1);
      if ( !v23 )
        ShutDown(0);
      v18 = 0;
      strcpy(&a1a, byte_50D8F0);
      v32 = 1;
      v24 = 1;
    }
    if ( v24 )
    {
      v24 = 0;
      evt.eventCode = 512;
      evt.xCoordOrKeycode = 3;
      evt.yCoordOrFieldID = 1;
      evt.payload = cNetBoxLine;
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 2;
      evt.payload = &cNetBoxLine[140];
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 3;
      evt.payload = &cNetBoxLine[280];
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 4;
      evt.payload = &cNetBoxLine[420];
      heroWindow::BroadcastMessage(window, &evt);
      evt.xCoordOrKeycode = 4;
      evt.yCoordOrFieldID = 20;
      evt.payload = (void *)(cNetBoxColor + 1);
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 21;
      evt.payload = (void *)(byte_524C41 + 1);
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 22;
      evt.payload = (void *)(byte_524C42 + 1);
      heroWindow::BroadcastMessage(window, &evt);
      evt.yCoordOrFieldID = 23;
      evt.payload = (void *)(byte_524C43 + 1);
      heroWindow::BroadcastMessage(window, &evt);
      heroWindow::DrawWindow(window);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 411, 0x27Fu, 68);
    }
    if ( v32 )
    {
      v32 = 0;
      glTimers = KBTickCount() + 360;
      if ( v33 )
        *(&a1a + v18) = 95;
      else
        *(&a1a + v18) = 31;
      v29[v18] = 0;
      evt.eventCode = 512;
      evt.xCoordOrKeycode = 3;
      evt.yCoordOrFieldID = 5;
      evt.payload = &a1a;
      heroWindow::BroadcastMessage(window, &evt);
      heroWindow::DrawWindow(window);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 465, 0x27Fu, 12);
    }
    if ( v25 && KBTickCount() > v25 + 6000 )
      v31 = 1;
    if ( v30 )
    {
      for ( i = 0; i < 20; ++i )
      {
        PollSound();
        DelayMilli(75);
      }
      v31 = 1;
    }
  }
  inputManager::SetKeyCodeType(gpInputManager, 1);
  if ( v21 && gbMoveShown )
  {
    gbDrawWindowBackground = 0;
    heroWindowManager::RemoveWindow(gpWindowManager, window);
    gbDrawWindowBackground = 1;
    v11 = bShowIt;
    bShowIt = 1;
    advManager::RedrawAdvScreen(gpAdvManager, 1, 0);
    bShowIt = v11;
  }
  else
  {
    heroWindowManager::RemoveWindow(gpWindowManager, window);
  }
  bShowIt = v14;
}
// 4F1CC0: using guessed type int dword_4F1CC0;
// 4F1CC4: using guessed type int gbDrawWindowBackground;
// 4F7494: using guessed type int gbRemoteOn;
// 5247A8: using guessed type int gbMoveShown;
// 524C14: using guessed type int bShowIt;
// 524C40: using guessed type char cNetBoxColor;
// 524C41: using guessed type char byte_524C41;
// 524C42: using guessed type char byte_524C42;
// 524C43: using guessed type char byte_524C43;
// 435F20: using guessed type char var_AB[151];

//----- (00436B00) --------------------------------------------------------
char __fastcall AddNetBoxLine(const char *a1, char a2)
{
  char result; // al@4
  char v3; // [sp+Ch] [bp-8h]@1
  char *a2a; // [sp+10h] [bp-4h]@1

  v3 = a2;
  a2a = (char *)a1;
  if ( a2 < 0 || a2 > 6 )
    v3 = 6;
  strcpy(cNetBoxLine, &cNetBoxLine[140]);
  strcpy(&cNetBoxLine[140], &cNetBoxLine[280]);
  strcpy(&cNetBoxLine[280], &cNetBoxLine[420]);
  strcpy(&cNetBoxLine[420], a2a);
  cNetBoxColor = byte_524C41;
  byte_524C41 = byte_524C42;
  byte_524C42 = byte_524C43;
  result = v3;
  byte_524C43 = v3;
  return result;
}
// 524C40: using guessed type char cNetBoxColor;
// 524C41: using guessed type char byte_524C41;
// 524C42: using guessed type char byte_524C42;
// 524C43: using guessed type char byte_524C43;

//----- (00436BD0) --------------------------------------------------------
void __thiscall ShutDown(char *this)
{
  char *a2; // [sp+Ch] [bp-304h]@1
  char Text; // [sp+10h] [bp-300h]@2

  a2 = this;
  if ( !bInShutDown )
  {
    LogStr("Shutdown");
    bInShutDown = 1;
    gbClosingApp = 1;
    Text = 0;
    mouseManager::SetColorMice(gpMouseManager, 0);
    if ( a2 )
    {
      strcpy(&Text, a2);
      SetFullScreenStatus(0);
      LogStr(&Text);
      MessageBoxA(hwndApp, &Text, "Unexpected Program Termination", 0x10u);
    }
    else
    {
      sprintf(&Text, "Bye!");
    }
    ShutDownSmacker();
    soundManager::CDStop((soundManager *)gpSoundManager);
    ClearMapExtra();
    UnloadSystemwideIcons();
    if ( gbRemoteOn )
      HandleRemoteSuddenExit();
    if ( gPalette )
    {
      resourceManager::Dispose(gpResourceManager, (resource *)gPalette);
      gPalette = 0;
    }
    if ( bigFont )
    {
      resourceManager::Dispose(gpResourceManager, (resource *)bigFont);
      bigFont = 0;
    }
    if ( smallFont )
    {
      resourceManager::Dispose(gpResourceManager, (resource *)smallFont);
      smallFont = 0;
    }
    RemoteCleanup();
    executive::ShutDownSystem(gpExec);
    if ( gEventHandle )
    {
      CloseHandle(gEventHandle);
      gEventHandle = 0;
    }
    if ( mapRevealed )
      BaseFree(mapRevealed, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D8F8 + 71);
    mapRevealed = 0;
    CloseAIMapVars();
    DeleteMainClasses();
    AppExit();
    PrintMemoryLeaks();
    if ( gpMemEntry )
      free((BOOL)gpMemEntry);
    gpMemEntry = 0;
    exit(0);
  }
}
// 4F0A0C: using guessed type int gbClosingApp;
// 4F7494: using guessed type int gbRemoteOn;
// 50D8F4: using guessed type int bInShutDown;
// 50D8F8: using guessed type __int16 word_50D8F8;
// 5240A8: using guessed type int gpSoundManager;

//----- (00436DF0) --------------------------------------------------------
void __fastcall FileError(void *this)
{
  void *v1; // ST24_4@1
  char *v2; // eax@1
  char thisa; // [sp+10h] [bp-3ECh]@1
  int v4; // [sp+204h] [bp-1F8h]@1
  char prefix; // [sp+208h] [bp-1F4h]@1

  v1 = this;
  v4 = *_errno();
  v2 = strerror(v4);
  sprintf(&prefix, "File Error %s", v2);
  LogInt((int)&prefix, v4, -999, -999, -999, -999, -999, -999);
  sprintf(&thisa, "Error opening file %s!", v1);
  ShutDown(&thisa);
}

//----- (00436EA0) --------------------------------------------------------
void __fastcall SmackFade(const void *a1, void *a2)
{
  void *this; // [sp+Ch] [bp-38h]@1
  const void *v3; // [sp+10h] [bp-34h]@1
  void *a1a; // [sp+14h] [bp-30h]@1
  signed int v5; // [sp+18h] [bp-2Ch]@3
  int v6; // [sp+1Ch] [bp-28h]@5
  signed __int8 *v7; // [sp+20h] [bp-24h]@9
  signed int j; // [sp+24h] [bp-20h]@3
  void *v9; // [sp+28h] [bp-1Ch]@1
  signed int i; // [sp+2Ch] [bp-18h]@1
  signed int l; // [sp+30h] [bp-14h]@11
  signed int k; // [sp+34h] [bp-10h]@9
  int v13; // [sp+3Ch] [bp-8h]@3
  signed int v14; // [sp+40h] [bp-4h]@1

  this = a2;
  v3 = a1;
  v14 = -1;
  a1a = BaseAlloc(0x300u, "F:\\h2xsrc\\Source\\KB.CPP", word_50D970 + 13);
  v9 = BaseAlloc(0x100u, "F:\\h2xsrc\\Source\\KB.CPP", word_50D970 + 14);
  memset(a1a, 0, 0x300u);
  memset(v9, 0, 0x100u);
  for ( i = 10; i < 246; ++i )
  {
    v13 = (*((_BYTE *)v3 + 3 * i) + *((_BYTE *)v3 + 3 * i + 2) + *((_BYTE *)v3 + 3 * i + 1)) / 3;
    v5 = 999;
    for ( j = 10; j < 36; ++j )
    {
      v6 = abs(v13 - (*((_BYTE *)this + 3 * j) + *((_BYTE *)this + 3 * j + 2) + *((_BYTE *)this + 3 * j + 1)) / 3);
      if ( v5 > v6 )
      {
        v5 = v6;
        v14 = j;
      }
    }
    memcpy((char *)a1a + 3 * i, (char *)this + 3 * v14, 3u);
    *((_BYTE *)v9 + i) = v14;
  }
  FadeTo(v3, a1a, 8);
  v7 = gpWindowManager->screenBuffer->contents;
  for ( k = 0; k < 640; ++k )
  {
    for ( l = 0; l < 480; ++l )
    {
      *v7 = *((_BYTE *)v9 + (unsigned __int8)*v7);
      ++v7;
    }
  }
  heroWindowManager::UpdateScreen(gpWindowManager);
  UpdatePalette((#72 *)this);
  BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D970 + 49);
  BaseFree(v9, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D970 + 50);
}
// 50D970: using guessed type __int16 word_50D970;

//----- (00437100) --------------------------------------------------------
void *__thiscall ShowCongrats(void *this)
{
  int v1; // eax@2
  __int16 v2; // ax@4
  int v3; // eax@4
  int v4; // eax@5
  __int16 v5; // ax@11
  char rating[2]; // [sp+10h] [bp-32Ch]@2
  int score; // [sp+30h] [bp-30Ch]@1
  int baseScore; // [sp+34h] [bp-308h]@1
  char v11; // [sp+3Ch] [bp-300h]@1

  mouseManager::HideColorPointer(gpMouseManager);
  memcpy(&v11, gpBufferPalette->contents, 0x300u);
  gpWindowManager->cycleColors = 0;
  congratsText = (char *)BaseAlloc(0x1F4u, "F:\\h2xsrc\\Source\\KB.CPP", word_50D9D4 + 9);
  baseScore = CalcBaseScore(giCurTurn);
  score = baseScore * gpGame->gameDifficulty / 100;
  soundManager::PlayAmbientMusic(gpSoundManager, -1, 0, -1);
  if ( this == (void *)1 )
  {
    v1 = GetMonType(score, 1);
    sprintf(rating, gArmyNames[v1]);
  }
  else if ( this == (void *)2 )
  {
    v2 = ExpCampaign::Days((int)&xCampaign);
    v3 = GetMonType(v2, 2);
    sprintf(rating, gArmyNames[v3]);
  }
  else
  {
    v4 = GetMonType(*(_WORD *)&gpGame->_11[49], this);
    sprintf(rating, gArmyNames[v4]);
  }
  rating[0] -= 32;
  if ( gpGame->_B[1] )
    sprintf(rating, "Cheater!!!");
  if ( this == (void *)1 )
  {
    sprintf(
      congratsText,
      "Congratulations!\n\nDays: %d\nBase Score: %d\nDifficulty: %d\n\nScore: %d\n\nRating:\n%s\n",
      giCurTurn,
      baseScore,
      gpGame->gameDifficulty,
      score,
      rating);
  }
  else if ( this == (void *)2 )
  {
    v5 = ExpCampaign::Days((int)&xCampaign);
    sprintf(congratsText, "Congratulations!\n\nDays: %d\n\nRating:\n%s\n", v5, rating);
  }
  else
  {
    sprintf(congratsText, "Congratulations!\n\nDays: %d\n\nRating:\n%s\n", *(_WORD *)&gpGame->_11[49], rating);
  }
  PlaySmacker(2);
  memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
  SmackFade(gpBufferPalette->contents, &v11);
  memcpy(gPalette->contents, &v11, 0x300u);
  memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
  mouseManager::ShowColorPointer(gpMouseManager);
  AddScoreToHighScore(score, giCurTurn, gpGame->gameDifficulty, 1, gpGame->mapHeader.name);
  BaseFree(congratsText, (int)"F:\\h2xsrc\\Source\\KB.CPP", word_50D9D4 + 78);
  congratsText = 0;
  gpWindowManager->cycleColors = 1;
  return memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
}
// 50D9D4: using guessed type __int16 word_50D9D4;
// 5240A8: using guessed type int gpSoundManager;
// 532C54: using guessed type int giCurTurn;

//----- (00437440) --------------------------------------------------------
const void *__cdecl CongratsWait()
{
  const void *result; // eax@1
  char a2[28]; // [sp+Ch] [bp-40h]@3
  int v2; // [sp+28h] [bp-24h]@3
  int v3; // [sp+44h] [bp-8h]@1
  int v4; // [sp+48h] [bp-4h]@1

  v4 = 0;
  v3 = 0;
  result = (const void *)inputManager::Flush(gpInputManager);
  while ( !v3 )
  {
    PollSound();
    Process1WindowsMessage();
    result = inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)a2);
    memcpy(&v2, result, 28u);
    if ( v2 == 1 || v2 == 8 || v2 == 16 || v2 == 32 || v2 == 64 )
      v3 = 1;
  }
  return result;
}

//----- (004374E0) --------------------------------------------------------
__int64 __thiscall LoadPlaySample(const char *this)
{
  __int64 res; // [sp+10h] [bp-8h]@0

  LODWORD(res) = resourceManager::GetSample(gpResourceManager, this);
  if ( (_DWORD)res )
  {
    *(_DWORD *)(res + 28) = 2;
    HIDWORD(res) = soundManager::MemorySample((soundManager *)gpSoundManager, (sample *)res);
  }
  return res;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00437540) --------------------------------------------------------
void __thiscall WaitEndSample(void *this, resource *res, HSAMPLE samp)
{
  void *delaya; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@3

  delaya = this;
  if ( (signed int)this < 0 )
    delaya = (void *)4000;
  v4 = (int)((char *)delaya + KBTickCount());
  if ( samp )
  {
    while ( soundManager::DigitalReport((soundManager *)gpSoundManager, samp, 4) && KBTickCount() < v4 )
    {
      Process1WindowsMessage();
      PollSound();
    }
  }
  if ( res )
    resourceManager::Dispose(gpResourceManager, res);
}
// 5240A8: using guessed type int gpSoundManager;

//----- (004375D0) --------------------------------------------------------
void __cdecl MemError()
{
  if ( !gbInMemError )
  {
    gbInMemError = 1;
    LogStr("Out of Memory");
    sprintf(gText, cOutOfMemory, "Out of memory.", 6400);
    ShutDown(gText);
  }
}
// 50DAB8: using guessed type int gbInMemError;

//----- (00437630) --------------------------------------------------------
char *__fastcall GetTownName(int idx)
{
  return gpGame->castles[idx].name;
}

//----- (00437670) --------------------------------------------------------
icon *__cdecl LoadSystemwideIcons()
{
  icon *result; // eax@1

  gBuyBuildIcons = resourceManager::GetIcon(gpResourceManager, "buybuild.icn");
  result = resourceManager::GetIcon(gpResourceManager, "system.icn");
  gSystemIcons = result;
  return result;
}

//----- (004376B0) --------------------------------------------------------
void __cdecl UnloadSystemwideIcons()
{
  resourceManager::Dispose(gpResourceManager, (resource *)gBuyBuildIcons);
  resourceManager::Dispose(gpResourceManager, (resource *)gSystemIcons);
}

//----- (00437700) --------------------------------------------------------
bool __cdecl GameUnsaved()
{
  return gpAdvManager && gpAdvManager->ready == 1
      || gpCombatManager && gpCombatManager->ready == 1
      || gpTownManager && gpTownManager->ready == 1;
}

//----- (00437780) --------------------------------------------------------
signed int __fastcall HandleAppSpecificMenuCommands(signed int a1, int a2)
{
  signed int v3; // [sp+10h] [bp-1Ch]@1
  int v4; // [sp+14h] [bp-18h]@94
  int level; // [sp+1Ch] [bp-10h]@85
  signed int v6; // [sp+20h] [bp-Ch]@1
  int spell; // [sp+24h] [bp-8h]@55
  signed int spella; // [sp+24h] [bp-8h]@62
  signed int spellb; // [sp+24h] [bp-8h]@89
  signed int spellc; // [sp+24h] [bp-8h]@92
  char *this; // [sp+28h] [bp-4h]@1

  v3 = a1;
  v6 = 0;
  this = 0;
  if ( gpCurPlayer && gpCurPlayer->curHeroIdx != -1 )
    this = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  switch ( a1 )
  {
    case 40102:
    case 40104:
    case 40105:
    case 40106:
    case 40107:
    case 40110:
    case 40111:
    case 40112:
    case 40114:
    case 40115:
    case 40117:
    case 40118:
    case 40120:
    case 40121:
      strcpy(gText, "Are you sure you want to restart?  (Your current game will be lost)");
      goto LABEL_7;
    case 40123:
    case 40124:
    case 40127:
    case 40128:
    case 40129:
    case 40131:
    case 40132:
    case 40134:
    case 40135:
    case 40137:
    case 40138:
      strcpy(gText, "Are you sure you want to load a new game?  (Your current game will be lost)");
LABEL_7:
      if ( gpAdvManager->ready != 1
        || (NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0), gpWindowManager->buttonPressedCode == 30725) )
        giMenuCommand = v3;
      goto LABEL_100;
    case 40139:
      SaveGame();
      goto LABEL_100;
    case 40140:
      PostMessageA(hwndApp, 0x10u, 0, 0);
      goto LABEL_100;
    case 40016:
      *(_DWORD *)&Data = 0;
      goto LABEL_23;
    case 40017:
      *(_DWORD *)&Data = 1;
      goto LABEL_23;
    case 40018:
      *(_DWORD *)&Data = 2;
      goto LABEL_23;
    case 40019:
      *(_DWORD *)&Data = 3;
      goto LABEL_23;
    case 40020:
      *(_DWORD *)&Data = 4;
      goto LABEL_23;
    case 40021:
      *(_DWORD *)&Data = 5;
      goto LABEL_23;
    case 40022:
      *(_DWORD *)&Data = 6;
      goto LABEL_23;
    case 40023:
      *(_DWORD *)&Data = 7;
      goto LABEL_23;
    case 40024:
      *(_DWORD *)&Data = 8;
      goto LABEL_23;
    case 40025:
      *(_DWORD *)&Data = 9;
      goto LABEL_23;
    case 40026:
      *(_DWORD *)&Data = 10;
LABEL_23:
      soundManager::AdjustMusicVolumes(gpSoundManager);
      v6 = 1;
      goto LABEL_100;
    case 40028:
      *(_DWORD *)&soundVolume = 0;
      goto LABEL_35;
    case 40029:
      *(_DWORD *)&soundVolume = 1;
      goto LABEL_35;
    case 40030:
      *(_DWORD *)&soundVolume = 2;
      goto LABEL_35;
    case 40031:
      *(_DWORD *)&soundVolume = 3;
      goto LABEL_35;
    case 40032:
      *(_DWORD *)&soundVolume = 4;
      goto LABEL_35;
    case 40033:
      *(_DWORD *)&soundVolume = 5;
      goto LABEL_35;
    case 40034:
      *(_DWORD *)&soundVolume = 6;
      goto LABEL_35;
    case 40035:
      *(_DWORD *)&soundVolume = 7;
      goto LABEL_35;
    case 40036:
      *(_DWORD *)&soundVolume = 8;
      goto LABEL_35;
    case 40037:
      *(_DWORD *)&soundVolume = 9;
      goto LABEL_35;
    case 40038:
      *(_DWORD *)&soundVolume = 10;
LABEL_35:
      soundManager::AdjustSoundVolumes((soundManager *)gpSoundManager);
      v6 = 1;
      goto LABEL_100;
    case 40046:
      *(_DWORD *)&showRoute = 1 - *(_DWORD *)&showRoute;
      v6 = 1;
      goto LABEL_100;
    case 40047:
      *(_DWORD *)&blackoutComputer = 1 - *(_DWORD *)&blackoutComputer;
      v6 = 1;
      goto LABEL_100;
    case 40012:
      advManager::ViewWorld(gpAdvManager, a2, 53, 0, 0);
      goto LABEL_100;
    case 40013:
      advManager::ViewPuzzle(gpAdvManager);
      goto LABEL_100;
    case 40014:
      advManager::CheckCastSpell(gpAdvManager);
      goto LABEL_100;
    case 40015:
      advManager::ProcessSearch(gpAdvManager, -1i64);
      goto LABEL_100;
    case 40141:
      gpGame->_B[1] = 1;
      if ( gbInCampaign )
        gpGame->_11[72] = 1;
      game::SetVisibility(gpGame, 30, 30, giCurPlayer, 180);
      if ( this )
        advManager::Reseed(0, 0);
      advManager::UpdateRadar(gpAdvManager, 1, 0);
      advManager::CompleteDraw(gpAdvManager, 0);
      advManager::UpdateScreen(gpAdvManager, 0, 0);
      goto LABEL_100;
    case 40142:
      gpGame->_B[1] = 1;
      if ( gbInCampaign )
        gpGame->_11[72] = 1;
      if ( this )
        *(_DWORD *)(this + 53) = 299999;
      goto LABEL_100;
    case 40143:
      gpGame->_B[1] = 1;
      if ( gbInCampaign )
        gpGame->_11[72] = 1;
      if ( this )
      {
        for ( spell = 0; spell < 65; ++spell )
          hero::AddSpell((hero *)this, spell, 10);
        *(_WORD *)this = 999;
      }
      goto LABEL_100;
    case 40144:
      gpGame->_B[1] = 1;
      if ( gbInCampaign )
        gpGame->_11[72] = 1;
      for ( spella = 0; spella < 7; ++spella )
      {
        if ( spella == 6 )
          gpCurPlayer->resources[6] += 1000;
        else
          gpCurPlayer->resources[spella] += 10;
      }
      advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
      goto LABEL_100;
    default:
      if ( a1 >= 43000 && a1 < 43101 )
      {
        gpGame->_B[1] = 1;
        if ( gbInCampaign )
          gpGame->_11[72] = 1;
        giDebugBuildingToBuild = a1 - 43000;
LABEL_100:
        if ( v6 )
          WritePrefs();
        return 0;
      }
      if ( a1 >= 41000 && a1 < 41066 )
      {
        gpGame->_B[1] = 1;
        if ( gbInCampaign )
          gpGame->_11[72] = 1;
        if ( gpCurPlayer->curHeroIdx != -1 )
        {
          game::GiveArmy(&gpGame->heroes[gpCurPlayer->curHeroIdx].army, a1 - 41000, 5, -1);
          advManager::UpdBottomView(gpAdvManager, 1, 1, 1);
        }
        goto LABEL_100;
      }
      if ( a1 >= 42000 && a1 < 42056 )
      {
        gpGame->_B[1] = 1;
        if ( gbInCampaign )
          gpGame->_11[72] = 1;
        level = (((unsigned __int64)(a1 - 42000) >> 32) ^ abs(a1 - 16) & 3) - ((unsigned __int64)(a1 - 42000) >> 32);
        if ( this )
          hero::SetSS((hero *)this, (a1 - 42000) / 4, level);
      }
      if ( v3 >= 44000 && v3 < 44200 )
      {
        gpCombatManager->combatFieldCoverID = v3 - 44000;
        gpCombatManager->zeroedAfterAnimatingDeathAndHolySpells = 0;
        for ( spellb = 0; spellb < 117; ++spellb )
        {
          gpCombatManager->combatGrid[spellb].isBlocked = 0;
          gpCombatManager->combatGrid[spellb].combatObjIdx = -1;
        }
        for ( spellc = 0; spellc < 15; ++spellc )
        {
          v4 = sElevationOverlay[gpCombatManager->combatFieldCoverID].coveredHexes[spellc];
          if ( v4 != -1 )
            gpCombatManager->combatGrid[v4].isBlocked = 1;
        }
        combatManager::SetupGridForArmy(
          gpCombatManager,
          &gpCombatManager->creatures[gpCombatManager->activeStackOwner][gpCombatManager->activeStack]);
        combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 0, 1, 1);
      }
      return 1;
  }
}
// 4F19A8: using guessed type int giMenuCommand;
// 4F4B88: using guessed type int giDebugBuildingToBuild;
// 5240A8: using guessed type int gpSoundManager;

//----- (004381A0) --------------------------------------------------------
void __cdecl UpdateSystemOptionsMenu()
{
  UINT uIDCheckItem; // [sp+14h] [bp-8h]@4
  UINT uIDCheckItema; // [sp+14h] [bp-8h]@20
  UINT uIDCheckItemb; // [sp+14h] [bp-8h]@36
  UINT v3; // [sp+18h] [bp-4h]@8
  UINT v4; // [sp+18h] [bp-4h]@24

  if ( *(&bMenu + 7 * giCurExe) && hmnuApp && hmnuApp == hmnuAdv )
  {
    for ( uIDCheckItem = 40016; (signed int)uIDCheckItem <= 40026; ++uIDCheckItem )
      CheckMenuItem(hmnuApp, uIDCheckItem, 0);
    switch ( *(_DWORD *)&Data )
    {
      case 1:
        v3 = 40017;
        break;
      case 2:
        v3 = 40018;
        break;
      case 3:
        v3 = 40019;
        break;
      case 4:
        v3 = 40020;
        break;
      case 5:
        v3 = 40021;
        break;
      case 6:
        v3 = 40022;
        break;
      case 7:
        v3 = 40023;
        break;
      case 8:
        v3 = 40024;
        break;
      case 9:
        v3 = 40025;
        break;
      case 0xA:
        v3 = 40026;
        break;
      default:
        v3 = 40016;
        break;
    }
    CheckMenuItem(hmnuApp, v3, 8u);
    for ( uIDCheckItema = 40028; (signed int)uIDCheckItema <= 40038; ++uIDCheckItema )
      CheckMenuItem(hmnuApp, uIDCheckItema, 0);
    switch ( *(_DWORD *)&soundVolume )
    {
      case 1:
        v4 = 40029;
        break;
      case 2:
        v4 = 40030;
        break;
      case 3:
        v4 = 40031;
        break;
      case 4:
        v4 = 40032;
        break;
      case 5:
        v4 = 40033;
        break;
      case 6:
        v4 = 40034;
        break;
      case 7:
        v4 = 40035;
        break;
      case 8:
        v4 = 40036;
        break;
      case 9:
        v4 = 40037;
        break;
      case 0xA:
        v4 = 40038;
        break;
      default:
        v4 = 40028;
        break;
    }
    CheckMenuItem(hmnuApp, v4, 8u);
    for ( uIDCheckItemb = 40040; (signed int)uIDCheckItemb <= 40044; ++uIDCheckItemb )
      CheckMenuItem(hmnuApp, uIDCheckItemb, 0);
    CheckMenuItem(hmnuApp, 40046u, *(_DWORD *)&showRoute < 1u ? 0 : 8);
    CheckMenuItem(hmnuApp, 40047u, (unsigned int)(1 - *(_DWORD *)&blackoutComputer) < 1 ? 0 : 8);
  }
}
// 4F2E88: using guessed type int giCurExe;

//----- (004384B0) --------------------------------------------------------
BOOL __cdecl CleanUpMenus()
{
  BOOL result; // eax@2

  if ( hmnuApp )
  {
    result = SetMenu(hwndApp, 0);
    if ( hmnuAdv )
      result = DestroyMenu(hmnuAdv);
    if ( hmnuDflt )
      result = DestroyMenu(hmnuDflt);
    if ( hmnuCmbt )
      result = DestroyMenu(hmnuCmbt);
    if ( hmnuTown )
      result = DestroyMenu(hmnuTown);
  }
  hmnuApp = 0;
  return result;
}

//----- (00438550) --------------------------------------------------------
void __thiscall UpdateAppSpecificMenus(HMENU menu)
{
  if ( menu == hmnuAdv )
    UpdateSystemOptionsMenu();
}

//----- (00438580) --------------------------------------------------------
void __stdcall EarlyResizeWindow(int a1, int a2)
{
  ;
}

//----- (004385B0) --------------------------------------------------------
bool __fastcall InMapArea(signed int a1, signed int a2)
{
  return a1 >= 16 && a1 < 448 && a2 >= 16 && a2 < 448;
}

//----- (00438610) --------------------------------------------------------
int __fastcall SetupDynamicWindow(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int *a8, int *a9, int a10, int a11, int a12, int a13, int *a14, int a15)
{
  int result; // eax@3
  __int16 v16; // ax@41
  __int16 v17; // ax@46
  __int16 v18; // ax@54
  __int16 v19; // ax@59
  int y; // [sp+Ch] [bp-90h]@1
  int x; // [sp+10h] [bp-8Ch]@1
  iconWidget *v22; // [sp+14h] [bp-88h]@58
  iconWidget *v23; // [sp+18h] [bp-84h]@53
  iconWidget *v24; // [sp+1Ch] [bp-80h]@45
  iconWidget *v25; // [sp+20h] [bp-7Ch]@40
  iconWidget *v26; // [sp+24h] [bp-78h]@33
  iconWidget *v27; // [sp+28h] [bp-74h]@28
  iconWidget *v28; // [sp+2Ch] [bp-70h]@23
  iconWidget *v29; // [sp+30h] [bp-6Ch]@18
  iconWidget *this; // [sp+34h] [bp-68h]@11
  heroWindow *v31; // [sp+38h] [bp-64h]@4
  widget *guiObj; // [sp+3Ch] [bp-60h]@12
  widget *guiObja; // [sp+3Ch] [bp-60h]@19
  widget *guiObjb; // [sp+3Ch] [bp-60h]@24
  widget *guiObjc; // [sp+3Ch] [bp-60h]@29
  widget *guiObjd; // [sp+3Ch] [bp-60h]@34
  widget *guiObje; // [sp+3Ch] [bp-60h]@41
  widget *guiObjf; // [sp+3Ch] [bp-60h]@46
  widget *guiObjg; // [sp+3Ch] [bp-60h]@54
  widget *guiObjh; // [sp+3Ch] [bp-60h]@59
  int k; // [sp+4Ch] [bp-50h]@38
  int l; // [sp+4Ch] [bp-50h]@51
  int i; // [sp+50h] [bp-4Ch]@7
  int j; // [sp+5Ch] [bp-40h]@9
  int v45; // [sp+68h] [bp-34h]@1
  int v46; // [sp+74h] [bp-28h]@7
  int v47; // [sp+78h] [bp-24h]@7
  int v48; // [sp+84h] [bp-18h]@7
  int v49; // [sp+88h] [bp-14h]@7
  int v50; // [sp+94h] [bp-8h]@1

  y = a2;
  x = a1;
  v45 = (a6 - 1) / 48 + 1;
  v50 = (a7 - 1) / 48 + 1;
  *a8 = 48 * ((a6 - 1) / 48 + 1) + 48;
  *a9 = 48 * v50 + 48;
  if ( a3 )
  {
    x = ((a4 - (48 * v45 + 32)) >> 1) - 16 + a1;
    y = ((a5 - (48 * v50 + 32)) >> 1) + a2;
  }
  *(_DWORD *)a10 = x + 32;
  *(_DWORD *)a11 = y + 16;
  *(_DWORD *)a12 = *(_DWORD *)a10 + 48 * v45 - 1;
  result = *(_DWORD *)a11 + 48 * v50 - 1;
  *(_DWORD *)a13 = result;
  if ( !a15 )
  {
    v31 = (heroWindow *)operator new(68);
    if ( v31 )
      *a14 = (int)heroWindow::heroWindow(v31, x, y, *a8, *a9, 16386);
    else
      *a14 = 0;
    v46 = *(_DWORD *)a10 - x;
    v48 = *(_DWORD *)a11 - y;
    v47 = *(_DWORD *)a12 - x;
    v49 = *(_DWORD *)a13 - y;
    for ( i = 0; i < v50; ++i )
    {
      for ( j = 0; j < v45; ++j )
      {
        this = (iconWidget *)operator new(45);
        if ( this )
          guiObj = (widget *)iconWidget::iconWidget(
                               this,
                               v46 + 48 * j,
                               v48 + 48 * i,
                               48,
                               48,
                               "stonebk2.icn",
                               12,
                               0,
                               -1,
                               16,
                               1);
        else
          guiObj = 0;
        if ( !guiObj )
          MemError();
        heroWindow::AddWidget((heroWindow *)*a14, guiObj, -1);
      }
    }
    v29 = (iconWidget *)operator new(45);
    if ( v29 )
      guiObja = (widget *)iconWidget::iconWidget(v29, v46 - 40, v48 - 40, 72, 72, "stonebk2.icn", 0, 0, -1, 16, 1);
    else
      guiObja = 0;
    if ( !guiObja )
      MemError();
    heroWindow::AddWidget((heroWindow *)*a14, guiObja, -1);
    v28 = (iconWidget *)operator new(45);
    if ( v28 )
      guiObjb = (widget *)iconWidget::iconWidget(v28, v47 - 23, v48 - 40, 72, 72, "stonebk2.icn", 1, 0, -1, 16, 1);
    else
      guiObjb = 0;
    if ( !guiObjb )
      MemError();
    heroWindow::AddWidget((heroWindow *)*a14, guiObjb, -1);
    v27 = (iconWidget *)operator new(45);
    if ( v27 )
      guiObjc = (widget *)iconWidget::iconWidget(v27, v47 - 23, v49 - 23, 72, 72, "stonebk2.icn", 2, 0, -1, 16, 1);
    else
      guiObjc = 0;
    if ( !guiObjc )
      MemError();
    heroWindow::AddWidget((heroWindow *)*a14, guiObjc, -1);
    v26 = (iconWidget *)operator new(45);
    if ( v26 )
      guiObjd = (widget *)iconWidget::iconWidget(v26, v46 - 40, v49 - 23, 72, 72, "stonebk2.icn", 3, 0, -1, 16, 1);
    else
      guiObjd = 0;
    if ( !guiObjd )
      MemError();
    heroWindow::AddWidget((heroWindow *)*a14, guiObjd, -1);
    for ( k = 0; k < v45; ++k )
    {
      v25 = (iconWidget *)operator new(45);
      if ( v25 )
      {
        v16 = Random(4, 5);
        guiObje = (widget *)iconWidget::iconWidget(
                              v25,
                              (_WORD)v46 + 48 * k - 24,
                              v48 - 40,
                              72,
                              72,
                              "stonebk2.icn",
                              v16,
                              0,
                              -1,
                              16,
                              1);
      }
      else
      {
        guiObje = 0;
      }
      if ( !guiObje )
        MemError();
      heroWindow::AddWidget((heroWindow *)*a14, guiObje, -1);
      v24 = (iconWidget *)operator new(45);
      if ( v24 )
      {
        v17 = Random(8, 9);
        guiObjf = (widget *)iconWidget::iconWidget(
                              v24,
                              (_WORD)v46 + 48 * k - 24,
                              v49 - 23,
                              72,
                              72,
                              "stonebk2.icn",
                              v17,
                              0,
                              -1,
                              16,
                              1);
      }
      else
      {
        guiObjf = 0;
      }
      if ( !guiObjf )
        MemError();
      heroWindow::AddWidget((heroWindow *)*a14, guiObjf, -1);
    }
    for ( l = 0; ; ++l )
    {
      result = (a7 - 1) / 48 + 1;
      if ( l >= v50 )
        break;
      v23 = (iconWidget *)operator new(45);
      if ( v23 )
      {
        v18 = Random(10, 11);
        guiObjg = (widget *)iconWidget::iconWidget(
                              v23,
                              v46 - 40,
                              (_WORD)v48 + 48 * l - 24,
                              72,
                              72,
                              "stonebk2.icn",
                              v18,
                              0,
                              -1,
                              16,
                              1);
      }
      else
      {
        guiObjg = 0;
      }
      if ( !guiObjg )
        MemError();
      heroWindow::AddWidget((heroWindow *)*a14, guiObjg, -1);
      v22 = (iconWidget *)operator new(45);
      if ( v22 )
      {
        v19 = Random(6, 7);
        guiObjh = (widget *)iconWidget::iconWidget(
                              v22,
                              v47 - 23,
                              (_WORD)v48 + 48 * l - 24,
                              72,
                              72,
                              "stonebk2.icn",
                              v19,
                              0,
                              -1,
                              16,
                              1);
      }
      else
      {
        guiObjh = 0;
      }
      if ( !guiObjh )
        MemError();
      heroWindow::AddWidget((heroWindow *)*a14, guiObjh, -1);
    }
  }
  return result;
}

//----- (00438CD0) --------------------------------------------------------
BOOL __fastcall TestDynamicWindow(int a1, int a2)
{
  INPUT_EVENT_CODE v3; // [sp+Ch] [bp-50h]@3
  tag_message a2a; // [sp+20h] [bp-3Ch]@3
  char v5; // [sp+3Ch] [bp-20h]@1
  char v6; // [sp+40h] [bp-1Ch]@1
  heroWindow *window; // [sp+44h] [bp-18h]@1
  int v8; // [sp+48h] [bp-14h]@1
  char v9; // [sp+4Ch] [bp-10h]@1
  char v10; // [sp+50h] [bp-Ch]@1
  char v11; // [sp+54h] [bp-8h]@1
  char v12; // [sp+58h] [bp-4h]@1

  SetupDynamicWindow(
    0,
    0,
    1,
    640,
    480,
    48 * a1,
    48 * a2,
    (int *)&v10,
    (int *)&v6,
    (int)&v11,
    (int)&v9,
    (int)&v5,
    (int)&v12,
    (int *)&window,
    0);
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  v8 = 0;
  inputManager::Flush(gpInputManager);
  while ( !v8 )
  {
    Process1WindowsMessage();
    v3 = inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2a)->eventCode;
    if ( v3 == 1 || v3 == 8 || v3 == 32 )
      v8 = 1;
  }
  heroWindowManager::RemoveWindow(gpWindowManager, window);
  return operator delete(window);
}

//----- (00438DE0) --------------------------------------------------------
void __fastcall HandleRemoteDeadPlayerExit(int a1)
{
  int v1; // eax@5
  int v2; // ST1C_4@5
  char v3; // [sp+16h] [bp-2h]@0

  if ( giThisGamePos == a1 )
  {
    if ( !game::TransmitSaveGame(gpGame, (giThisNetPos + 1) % iLastMsgNumHumanPlayers, 1, 0) )
      ShutDown(0);
    RemoteCleanup();
  }
  else
  {
    v1 = a1;
    LOBYTE(v2) = gbGamePosToNetPos[a1];
    *(_WORD *)((char *)&v2 + 1) = (unsigned __int8)a1;
    BYTE3(v2) = 0;
    LOBYTE(v1) = v3;
    v1 <<= 16;
    LOWORD(v1) = 1;
    ReceiveRemotePlayerExit(v2, v1);
  }
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524730: using guessed type int giThisGamePos;

//----- (00438E80) --------------------------------------------------------
void __cdecl HandleRemoteSuddenExit()
{
  char v0; // [sp+Ch] [bp-Ch]@3
  char v1; // [sp+Dh] [bp-Bh]@3
  char v2; // [sp+Eh] [bp-Ah]@3
  char v3; // [sp+Fh] [bp-9h]@3
  char v4; // [sp+10h] [bp-8h]@3
  int v5; // [sp+14h] [bp-4h]@3

  if ( gbGameInitialized )
  {
    if ( gbRemoteOn )
    {
      v0 = giThisNetPos;
      v1 = giThisGamePos;
      v2 = gbThisNetGotAdventureControl;
      v3 = 0;
      v4 = 0;
      v5 = giThisNetPos == 0;
      LogStr("HRSE1");
      TransmitRemoteData(&v0, v5, 7u, 31, 0, 0, 2);
      LogStr("HRSE2");
      DelayMilli(500);
    }
  }
}
// 4F7494: using guessed type int gbRemoteOn;
// 4F7498: using guessed type int gbGameInitialized;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 524730: using guessed type int giThisGamePos;

//----- (00438F30) --------------------------------------------------------
int __cdecl DropDownToOnePlayer()
{
  signed int i; // [sp+Ch] [bp-4h]@1

  RemoteCleanup();
  iLastMsgNumHumanPlayers = 1;
  for ( i = 0; i < 6; ++i )
  {
    if ( giThisNetPos != i )
      gbHumanPlayer[i] = 0;
  }
  return ComputeAdvNetControl();
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (00438FA0) --------------------------------------------------------
heroWindow *__fastcall ReceiveHostReportsPlayerExit(int a1, int a2, int a3, int a4)
{
  heroWindow *result; // eax@4
  int v5; // [sp+10h] [bp-200h]@1
  char msg; // [sp+14h] [bp-1FCh]@12
  int v7; // [sp+208h] [bp-8h]@1
  int i; // [sp+20Ch] [bp-4h]@17

  v5 = a1;
  v7 = 0;
  if ( !a2 )
  {
    if ( (_BYTE)a4 )
    {
      if ( (char)a3 == giThisNetPos )
      {
        RemoteCleanup();
        sprintf(gText, "You have been eliminated from the game!!!");
        result = NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        gbGameOver = 1;
        giEndSequence = 0;
        return result;
      }
      sprintf(gText, "%s has been vanquished!", (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4);
      NormalDialog(gText, 1, -1, -1, 9, gpGame->players[SBYTE1(a3)].color, -1, -1, -1, 5000);
    }
    else if ( BYTE2(a4) )
    {
      if ( BYTE3(a3) )
        sprintf(
          &msg,
          "Host player %s reports that player %s has been timed out of the game.  The game will continue with a computer player filling in for %s.",
          (char *)&gsNetPlayerInfo + 34 * a1 + 4,
          (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4,
          (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4);
      else
        sprintf(
          &msg,
          "Host player %s reports that player %s has exited the game.  The game will continue with a computer player filling in for %s.",
          (char *)&gsNetPlayerInfo + 34 * a1 + 4,
          (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4,
          (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4);
      v7 = 1;
    }
    else
    {
      game::SaveGame(gpGame, "PLYREXIT", 1, 0);
      sprintf(
        gText,
        "%s left the game, and the %s decided to terminate the entire game.  The game has been saved as 'PLYREXIT'.  Do you wish to play on alone with the computer taking over for all human players?",
        (char *)&gsNetPlayerInfo + 34 * (char)a3 + 4,
        (char *)&gsNetPlayerInfo + 34 * v5 + 4);
      NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        DropDownToOnePlayer();
      }
      else
      {
        RemoteCleanup();
        ShutDown(0);
      }
    }
  }
  if ( (char)a3 < giThisNetPos )
    --giThisNetPos;
  gbHumanPlayer[SBYTE1(a3)] = 0;
  for ( i = (char)a3; i < 5; ++i )
  {
    lLastHeartbeatReceive[i] = dword_526DB4[i];
    *((_DWORD *)&giNetPosToDCOPos + i) = dword_522B7C[i];
    strcpy((char *)&gsNetPlayerInfo + 34 * i + 4, (char *)&gsNetPlayerInfo + 34 * (i + 1) + 4);
  }
  for ( i = 0; i < 6; ++i )
  {
    if ( gbGamePosToNetPos[i] == (char)a3 )
    {
      gbGamePosToNetPos[i] = -1;
    }
    else if ( gbGamePosToNetPos[i] > (char)a3 )
    {
      --gbGamePosToNetPos[i];
    }
  }
  --iLastMsgNumHumanPlayers;
  iLastDiffSendTo = -2;
  result = (heroWindow *)SBYTE2(a3);
  if ( BYTE2(a3) )
    result = (heroWindow *)ComputeAdvNetControl();
  if ( v7 )
    result = NormalDialog(&msg, 1, -1, -1, -1, -1, -1, -1, -1, 5000);
  return result;
}
// 4EF268: using guessed type int gbGameOver;
// 4F31B8: using guessed type int iLastDiffSendTo;
// 522B7C: using guessed type int dword_522B7C[];
// 522FF8: using guessed type int giEndSequence;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 526DB0: using guessed type int lLastHeartbeatReceive[];
// 526DB4: using guessed type int dword_526DB4[];

//----- (00439380) --------------------------------------------------------
void __stdcall ReceiveRemotePlayerExit(int a1, int a2)
{
  void *v2; // eax@2
  int v3; // eax@26
  signed int v4; // [sp+Ch] [bp-10h]@1
  int i; // [sp+10h] [bp-Ch]@15

  v4 = 0;
  lLastHeartbeatReceive[(char)a1] = 199999999;
  game::SaveGame(gpGame, "PLYREXIT", 1, 0);
  if ( (_BYTE)a2 )
  {
    BYTE2(a2) = 1;
    v2 = (void *)(char)a1;
    if ( (char)a1 == giThisNetPos )
    {
      v4 = 1;
    }
    else
    {
      sprintf(gText, "%s has been vanquished!", (char *)&gsNetPlayerInfo + 34 * (char)a1 + 4);
      v2 = NormalDialog(gText, 1, -1, -1, 9, gpGame->players[SBYTE1(a1)].color, -1, -1, -1, 5000);
      BYTE2(a2) = 1;
    }
  }
  else
  {
    if ( BYTE3(a1) )
      sprintf(
        gText,
        "%s has been timed out of the game.  The current game has been saved as 'PLYREXIT'.  Do you wish to continue playing with a computer player filling in for %s?",
        (char *)&gsNetPlayerInfo + 34 * (char)a1 + 4,
        (char *)&gsNetPlayerInfo + 34 * (char)a1 + 4);
    else
      sprintf(
        gText,
        "%s is exiting the game.  The current game has been saved as 'PLYREXIT'.  Do you wish to continue playing with a computer player filling in for %s?",
        (char *)&gsNetPlayerInfo + 34 * (char)a1 + 4,
        (char *)&gsNetPlayerInfo + 34 * (char)a1 + 4);
    NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
    v2 = gpWindowManager;
    BYTE2(a2) = gpWindowManager->buttonPressedCode == 30725;
  }
  if ( iLastMsgNumHumanPlayers == 2 )
  {
    if ( (_BYTE)a2 && !BYTE1(a2) )
      TransmitRemoteData(&a1, 1 - giThisNetPos, 7u, 33, 1, 1, -1);
    if ( !v4 )
    {
      --iLastMsgNumHumanPlayers;
      gbHumanPlayer[SBYTE1(a1)] = 0;
      RemoteCleanup();
      ComputeAdvNetControl();
    }
  }
  else
  {
    for ( i = 0; i < 6; ++i )
    {
      if ( (char)a1 != i || !(_BYTE)a2 || BYTE1(a2) )
      {
        v2 = (void *)(char)a1;
        if ( (char)a1 == i )
          continue;
        v2 = (void *)iLastMsgNumHumanPlayers;
        if ( i >= iLastMsgNumHumanPlayers )
          continue;
        v2 = (void *)i;
        if ( giThisNetPos == i )
          continue;
      }
      v2 = (void *)TransmitRemoteData(&a1, i, 7u, 33, 1, 1, -1);
    }
    if ( !v4 )
    {
      LOBYTE(v2) = BYTE2(a2);
      v3 = (_DWORD)v2 << 16;
      LOWORD(v3) = a2;
      ReceiveHostReportsPlayerExit(0, 1, a1, v3);
    }
  }
  if ( v4 )
  {
    sprintf(gText, "You have been eliminated from the game!!!");
    RemoteCleanup();
    NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
    gbGameOver = 1;
    giEndSequence = 0;
  }
  else if ( !BYTE2(a2) )
  {
    ShutDown(0);
  }
}
// 4EF268: using guessed type int gbGameOver;
// 522FF8: using guessed type int giEndSequence;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 526DB0: using guessed type int lLastHeartbeatReceive[];

//----- (004396F0) --------------------------------------------------------
signed int __cdecl CheckMem()
{
  giTotalHighMem = 16000;
  giHighMemBuffer = 8000;
  return 1;
}
// 4F74AC: using guessed type int giHighMemBuffer;
// 524780: using guessed type int giTotalHighMem;

//----- (00439720) --------------------------------------------------------
int __fastcall GetManaCost(int spell, hero *hro)
{
  int cost; // [sp+14h] [bp-4h]@1

  cost = gsSpellInfo[spell].cost;
  if ( hro )
  {
    if ( hero::HasArtifact(hro, ARTIFACT_EVIL_EYE) && (spell == SPELL_CURSE || spell == SPELL_MASS_CURSE) )
      cost >>= 1;
    if ( hero::HasArtifact(hro, ARTIFACT_SKULLCAP)
      && (spell == SPELL_BERZERKER || spell == SPELL_HYPNOTIZE || spell == SPELL_PARALYZE || spell == SPELL_BLIND) )
      cost >>= 1;
    if ( hero::HasArtifact(hro, ARTIFACT_SNAKE_RING) && (spell == SPELL_BLESS || spell == SPELL_MASS_BLESS) )
      cost >>= 1;
    if ( hero::HasArtifact(hro, ARTIFACT_ELEMENTAL_RING)
      && (spell == SPELL_SUMMON_EARTH_ELEMENTAL
       || spell == SPELL_SUMMON_AIR_ELEMENTAL
       || spell == SPELL_SUMMON_FIRE_ELEMENTAL
       || spell == SPELL_SUMMON_WATER_ELEMENTAL) )
      cost >>= 1;
  }
  return cost;
}

//----- (00439830) --------------------------------------------------------
void __fastcall SetWinText(heroWindow *window, int screenIdx)
{
  tag_message msg; // [sp+14h] [bp-24h]@4
  int i; // [sp+30h] [bp-8h]@1
  int numAffected; // [sp+34h] [bp-4h]@1

  numAffected = 0;
  for ( i = 0; i < 73; ++i )
  {
    if ( gWinSetup[i].screenIdx == screenIdx )
    {
      ++numAffected;
      msg.eventCode = INPUT_GUI_MESSAGE_CODE;
      msg.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
      msg.yCoordOrFieldID = gWinSetup[i].fieldID;
      msg.payload = gWinSetup[i].label;
      heroWindow::BroadcastMessage(window, &msg);
    }
  }
}

//----- (004398D0) --------------------------------------------------------
void __cdecl CheckShingleUpdate()
{
  if ( gShingleAnim )
  {
    if ( KBTickCount() > iNextShingleAnim )
    {
      iNextShingleAnim = KBTickCount() + 250;
      iShingleAnimFrame = (iShingleAnimFrame + 1) % 39;
      icon::DrawToBuffer(gShingleAnim, 0, 0, iShingleAnimFrame + 1, 0);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 46, 176, 0x8Bu, 187);
    }
  }
}
// 4F1CB0: using guessed type int iNextShingleAnim;
// 50DFC4: using guessed type int iShingleAnimFrame;

//----- (00439960) --------------------------------------------------------
heroWindow *__fastcall NormalDialog(char *msg, int a2, int x, int y, int img1Type, int img1Arg, int img2Type, int img2Arg, int writeOr, signed int a10)
{
  __int16 v10; // ST54_2@186
  __int16 v11; // ST50_2@195
  __int16 v12; // ST4C_2@202
  heroWindow *result; // eax@227
  char *msga; // [sp+18h] [bp-114h]@1
  textWidget *v16; // [sp+34h] [bp-F8h]@212
  border *v17; // [sp+38h] [bp-F4h]@207
  textWidget *v18; // [sp+3Ch] [bp-F0h]@201
  textWidget *v19; // [sp+40h] [bp-ECh]@194
  textWidget *v20; // [sp+44h] [bp-E8h]@185
  iconWidget *v21; // [sp+48h] [bp-E4h]@178
  iconWidget *v22; // [sp+4Ch] [bp-E0h]@171
  iconWidget *v23; // [sp+50h] [bp-DCh]@164
  iconWidget *v24; // [sp+54h] [bp-D8h]@157
  iconWidget *v25; // [sp+58h] [bp-D4h]@152
  iconWidget *v26; // [sp+5Ch] [bp-D0h]@145
  iconWidget *v27; // [sp+60h] [bp-CCh]@138
  iconWidget *this; // [sp+64h] [bp-C8h]@132
  heroWindow *v29; // [sp+68h] [bp-C4h]@48
  char *plusOneBuf; // [sp+6Ch] [bp-C0h]@201
  __int16 height; // [sp+70h] [bp-BCh]@117
  int a3; // [sp+74h] [bp-B8h]@185
  int a3a; // [sp+74h] [bp-B8h]@190
  widget *v34; // [sp+78h] [bp-B4h]@208
  int borderSpriteIdx; // [sp+7Ch] [bp-B0h]@78
  signed int v36; // [sp+84h] [bp-A8h]@7
  heroWindow *v37; // [sp+88h] [bp-A4h]@13
  int spriteIdx; // [sp+8Ch] [bp-A0h]@218
  int v39; // [sp+90h] [bp-9Ch]@41
  char *content; // [sp+94h] [bp-98h]@212
  signed int v41; // [sp+98h] [bp-94h]@7
  tag_message event; // [sp+9Ch] [bp-90h]@53
  int v43; // [sp+B8h] [bp-74h]@13
  int v44; // [sp+BCh] [bp-70h]@13
  textWidget *component; // [sp+C0h] [bp-6Ch]@69
  int i; // [sp+C4h] [bp-68h]@15
  int v47; // [sp+C8h] [bp-64h]@7
  int v48; // [sp+CCh] [bp-60h]@7
  int numLines; // [sp+D0h] [bp-5Ch]@13
  int msgHeight; // [sp+D4h] [bp-58h]@13
  int v51; // [sp+D8h] [bp-54h]@7
  int width; // [sp+DCh] [bp-50h]@7
  int v53; // [sp+E0h] [bp-4Ch]@18
  int v54; // [sp+E4h] [bp-48h]@13
  int v55; // [sp+E8h] [bp-44h]@13
  int v56; // [sp+ECh] [bp-40h]@13
  int windowType; // [sp+F0h] [bp-3Ch]@39
  char filename; // [sp+F4h] [bp-38h]@48
  int imgArgs[2]; // [sp+104h] [bp-28h]@13
  int v60; // [sp+10Ch] [bp-20h]@41
  int buf[2]; // [sp+110h] [bp-1Ch]@70
  int imgTypes[2]; // [sp+118h] [bp-14h]@13
  signed int protoCategory; // [sp+120h] [bp-Ch]@218
  widget *guiObj; // [sp+124h] [bp-8h]@69

  msga = msg;
  if ( !gbRemoteOn )
    a10 = 0;
  if ( a10 <= 1 || a10 >= 20000 )
    giDialogTimeout = a10;
  else
    giDialogTimeout = KBTickCount() + a10;
  v51 = 0;
  v47 = 0;
  v36 = 100;
  width = 0;
  v48 = 0;
  v41 = 0;
  if ( img1Type == 25 && img1Arg >= 100 )
  {
    img1Arg -= 100;
    v41 = 1;
  }
  if ( img1Type >= 19 && img1Type <= 24 )
    img1Type = -1;
  v37 = pNormalDialogWindow;
  v54 = giResType1;
  v44 = giResExtra1;
  v56 = giResType2;
  v43 = giResExtra2;
  giResType1 = img1Type;
  giResExtra1 = img1Arg;
  giResType2 = img2Type;
  giResExtra2 = img2Arg;
  imgTypes[0] = img1Type;
  imgArgs[0] = img1Arg;
  imgTypes[1] = img2Type;
  imgArgs[1] = img2Arg;
  numLines = font::LineLength(bigFont, msga, 244);
  msgHeight = 16 * numLines;
  v55 = 0;
  if ( a2 != 4 )
    msgHeight += 39;
  for ( i = 0; i < 2; ++i )
  {
    switch ( imgTypes[i] )
    {
      case 7:
        v53 = 76;
        break;
      case 10:
        v53 = 28;
        break;
      case 11:
        v53 = 57;
        break;
      case 12:
        v53 = 62;
        break;
      case 13:
        v53 = 59;
        break;
      case 14:
        v53 = (unsigned int)(imgArgs[i] + 1) < 1 ? 64 : 76;
        break;
      case 9:
        v53 = 55;
        break;
      case 15:
        v53 = 111;
        break;
      case 6:
        v53 = 26;
        break;
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        v53 = 44;
        break;
      case 8:
        v53 = 79;
        break;
      case 17:
        v53 = 81;
        break;
      case 18:
        v53 = 105;
        break;
      case 25:
        v53 = 105;
        break;
      default:
        v53 = 0;
        break;
    }
    if ( v53 > v55 )
      v55 = v53;
  }
  if ( v55 > 0 )
    msgHeight += v55 + 14;
  windowType = (msgHeight - 25) / 45;
  if ( windowType > 6 )
    windowType = 6;
  v60 = 306;
  v39 = 45 * windowType + 180;
  if ( x == -1 || v60 + x >= 639 )
    x = 159;
  if ( y == -1 || v39 + y >= 479 )
  {
    y = (480 - v39) / 2;
    if ( y > 28 )
      y = 28;
  }
  sprintf(&filename, "evntwin%d.bin", windowType);
  v29 = (heroWindow *)operator new(68);
  if ( v29 )
    pNormalDialogWindow = heroWindow::heroWindow(v29, x, y, &filename);
  else
    pNormalDialogWindow = 0;
  if ( !pNormalDialogWindow )
    MemError();
  event.eventCode = INPUT_GUI_MESSAGE_CODE;
  event.xCoordOrKeycode = 6;
  event.payload = (void *)6;
  if ( a2 != 7 && a2 != 8 )
  {
    event.yCoordOrFieldID = 30727;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  }
  if ( a2 != 7 )
  {
    event.yCoordOrFieldID = 30728;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  }
  if ( a2 != 6 && a2 != 3 )
  {
    event.yCoordOrFieldID = 30721;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  }
  if ( a2 != 5 && a2 != 1 && a2 != 3 )
  {
    event.yCoordOrFieldID = 30722;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  }
  if ( a2 != 2 )
  {
    event.yCoordOrFieldID = 30725;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
    event.yCoordOrFieldID = 30726;
    heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  }
  for ( i = 0; i < 2; ++i )
  {
    guiObj = 0;
    component = 0;
    if ( imgTypes[i] == -1 )
      break;
    buf[i] = (int)BaseAlloc(80u, "F:\\h2xsrc\\Source\\KB.CPP", word_50DFC8 + 187);
    if ( imgTypes[i] > 6 )
    {
      switch ( imgTypes[i] )
      {
        case 8:
          sprintf((char *)buf[i], "%s", gSpellNames[imgArgs[i]]);
          strcpy(&filename, "spells.icn");
          LOWORD(borderSpriteIdx) = gsSpellInfo[imgArgs[i]].spriteIdx;
          break;
        case 9:
          sprintf((char *)buf[i], "%s", unk_50E028);
          strcpy(&filename, "brcrest.icn");
          borderSpriteIdx = imgArgs[i];
          break;
        case 25:
          sprintf((char *)buf[i], "%s", unk_50E03C);
          strcpy(&filename, "primskil.icn");
          LOWORD(borderSpriteIdx) = 4;
          break;
        case 18:
          sprintf((char *)buf[i], "%s", &unk_50E054);
          strcpy(&filename, "strip.icn");
          LOWORD(borderSpriteIdx) = 12;
          break;
        case 17:
          sprintf((char *)buf[i], "%s", gSecondarySkills[imgArgs[i] / 3]);
          strcpy(&filename, "secskill.icn");
          borderSpriteIdx = imgArgs[i] / 3 + 1;
          break;
        case 15:
          sprintf((char *)buf[i], "%s", &unk_50E07C);
          sprintf(&filename, "surrendr.icn");
          LOWORD(borderSpriteIdx) = 4;
          break;
        default:
          if ( imgTypes[i] != 14 && imgTypes[i] != 12 && imgTypes[i] != 13 && imgTypes[i] != 10 && imgTypes[i] != 11 )
          {
            strcpy((char *)buf[i], byte_50E0A8);
            strcpy(&filename, "resource.icn");
            borderSpriteIdx = imgTypes[i];
          }
          else
          {
            strcpy((char *)buf[i], byte_50E094);
            strcpy(&filename, "expmrl.icn");
            borderSpriteIdx = imgTypes[i] - 10;
            if ( imgTypes[i] == 14 && imgArgs[i] != -1 )
              sprintf((char *)buf[i], "%d", imgArgs[i]);
          }
          break;
      }
    }
    else
    {
      if ( imgArgs[i] <= 0 )
      {
        if ( imgArgs[i] )
        {
          if ( imgArgs[i] >= -100000 )
            sprintf((char *)buf[i], "%d/day", -imgArgs[i]);
          else
            sprintf((char *)buf[i], "%d", imgArgs[i] + 100000);
        }
        else
        {
          strcpy((char *)buf[i], byte_50DFF8);
        }
      }
      else
      {
        sprintf((char *)buf[i], "%d", imgArgs[i]);
      }
      strcpy(&filename, "resource.icn");
      borderSpriteIdx = imgTypes[i];
    }
    switch ( imgTypes[i] )
    {
      case 25:
        width = 94;
        v53 = 105;
        break;
      case 7:
        width = 76;
        v53 = 76;
        break;
      case 10:
        width = 64;
        v53 = 28;
        break;
      case 11:
        width = 64;
        v53 = 57;
        break;
      case 12:
        width = 64;
        v53 = 62;
        break;
      case 13:
        width = 64;
        v53 = 59;
        break;
      case 14:
        width = 64;
        v53 = 64;
        break;
      case 9:
        width = 50;
        v53 = 55;
        break;
      case 15:
        width = 111;
        v53 = 105;
        break;
      case 6:
        width = 76;
        v53 = 26;
        break;
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        width = 38;
        v53 = 32;
        break;
      case 8:
        width = 70;
        v53 = 55;
        break;
      case 17:
        width = 75;
        v53 = 65;
        break;
      case 18:
        width = 94;
        v53 = 105;
        break;
      default:
        break;
    }
    height = v53;
    if ( strlen((char *)buf[i]) )
      v53 += 12;
    if ( i )
    {
      v51 = v60 - 87;
    }
    else if ( imgTypes[1] == -1 )
    {
      v51 = (v60 - 17) / 2 + 17;
    }
    else
    {
      v51 = 104;
    }
    v47 = v39 - v53 - 48;
    if ( a2 != 4 )
      v47 -= 39;
    if ( imgTypes[0] == 17 && imgTypes[1] == 17 )
    {
      if ( i )
        v51 += 4;
      else
        v51 -= 4;
    }
    this = (iconWidget *)operator new(45);
    if ( this )
      guiObj = (widget *)iconWidget::iconWidget(
                           this,
                           v51 + ((unsigned int)(imgTypes[i] - 8) < 1 ? 2 : 0) - width / 2,
                           v47,
                           width,
                           height,
                           &filename,
                           borderSpriteIdx,
                           0,
                           -1,
                           ((unsigned int)(imgTypes[i] - 8) < 1) + 16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    if ( imgTypes[i] == 7 )
    {
      v27 = (iconWidget *)operator new(45);
      if ( v27 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v27,
                             v51 - width / 2 + 6,
                             v47 + 6,
                             76,
                             76,
                             "artifact.icn",
                             LOWORD(imgArgs[i]) + 1,
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    }
    if ( imgTypes[i] == 25 )
    {
      v26 = (iconWidget *)operator new(45);
      if ( v26 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v26,
                             v51 - width / 2 + 6,
                             v47 + 6,
                             82,
                             93,
                             "primskil.icn",
                             imgArgs[i],
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
      strcpy((char *)buf[i], gStatNames[imgArgs[i]]);
    }
    if ( imgTypes[i] == 18 )
    {
      v25 = (iconWidget *)operator new(45);
      if ( v25 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v25,
                             v51 - width / 2 + 6,
                             v47 + 6,
                             82,
                             93,
                             "strip.icn",
                             gMonsterDatabase[imgArgs[i]].faction + 4,
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
      sprintf(gText, "monh%04d.icn", imgArgs[i]);
      v24 = (iconWidget *)operator new(45);
      if ( v24 )
        guiObj = (widget *)iconWidget::iconWidget(v24, v51 - width / 2 + 6, v47 + 6, 82, 93, gText, 0, 0, -1, 16, 1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    }
    if ( imgTypes[i] == 9 )
    {
      v23 = (iconWidget *)operator new(45);
      if ( v23 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v23,
                             v51 - width / 2 - 4,
                             v47 - 4,
                             58,
                             55,
                             "brcrest.icn",
                             6,
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    }
    if ( imgTypes[i] == 17 )
    {
      v22 = (iconWidget *)operator new(45);
      if ( v22 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v22,
                             v51 - width / 2 - 3,
                             v47 - 3,
                             71,
                             81,
                             "secskill.icn",
                             15,
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    }
    if ( imgTypes[i] == 15 )
    {
      sprintf(&filename, "port%04d.icn", imgArgs[i]);
      v21 = (iconWidget *)operator new(45);
      if ( v21 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v21,
                             v51 - width / 2 + 5,
                             v47 + 5,
                             101,
                             95,
                             &filename,
                             0,
                             0,
                             -1,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, guiObj, -1);
    }
    if ( imgTypes[i] == 17 )
    {
      a3 = v47 + v53 - 72;
      v20 = (textWidget *)operator new(43);
      if ( v20 )
      {
        v10 = v36++;
        component = textWidget::textWidget(
                      v20,
                      v51 - 50,
                      a3,
                      100,
                      (unsigned int)(imgTypes[i] - 8) < 1 ? 24 : 12,
                      (char *)buf[i],
                      "smalfont.fnt",
                      1,
                      v10,
                      512,
                      1);
      }
      else
      {
        component = 0;
      }
      if ( !component )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, (widget *)component, -1);
      buf[i] = (int)BaseAlloc(0x50u, "F:\\h2xsrc\\Source\\KB.CPP", word_50DFC8 + 431);
      a3a = v47 + v53 - 24;
      sprintf((char *)buf[i], "%s", secondarySkillLevels[imgArgs[i] % 3 + 1]);
    }
    else if ( imgTypes[i] == 25 )
    {
      a3a = v47 + v53 - 93;
    }
    else
    {
      a3a = v47 + v53 - 10;
    }
    v19 = (textWidget *)operator new(43);
    if ( v19 )
    {
      v11 = v36++;
      component = textWidget::textWidget(
                    v19,
                    v51 - 50,
                    a3a,
                    100,
                    (unsigned int)(imgTypes[i] - 8) < 1 ? 24 : 12,
                    (char *)buf[i],
                    "smalfont.fnt",
                    1,
                    v11,
                    512,
                    1);
    }
    else
    {
      component = 0;
    }
    if ( !component )
      MemError();
    heroWindow::AddWidget(pNormalDialogWindow, (widget *)component, -1);
    if ( imgTypes[i] == 25 && v41 )
    {
      plusOneBuf = (char *)BaseAlloc(5u, "F:\\h2xsrc\\Source\\KB.CPP", word_50DFC8 + 457);
      strcpy(plusOneBuf, "+1 ");
      v18 = (textWidget *)operator new(43);
      if ( v18 )
      {
        v12 = v36++;
        component = textWidget::textWidget(
                      v18,
                      v51 - 50,
                      v47 + (_WORD)v53 - 22,
                      100,
                      16,
                      plusOneBuf,
                      "bigfont.fnt",
                      1,
                      v12,
                      512,
                      1);
      }
      else
      {
        component = 0;
      }
      if ( !component )
        MemError();
      heroWindow::AddWidget(pNormalDialogWindow, (widget *)component, -1);
    }
    v17 = (border *)operator new(42);
    if ( v17 )
      v34 = (widget *)border::border(v17, v51 - width / 2, v47, width, v53, i + 7700, 1, 0, 0);
    else
      v34 = 0;
    heroWindow::AddWidget(pNormalDialogWindow, v34, -1);
  }
  event.eventCode = 512;
  event.xCoordOrKeycode = 3;
  event.yCoordOrFieldID = 1;
  event.payload = msga;
  heroWindow::BroadcastMessage(pNormalDialogWindow, &event);
  if ( writeOr == 1 )
  {
    content = (char *)BaseAlloc(3u, "F:\\h2xsrc\\Source\\KB.CPP", word_50DFC8 + 493);
    strcpy(content, "or");
    v16 = (textWidget *)operator new(43);
    if ( v16 )
      component = textWidget::textWidget(v16, v60 / 2 - 10, v47 + 43, 40, 12, content, "smalfont.fnt", 1, v36, 512, 1);
    else
      component = 0;
    if ( !component )
      MemError();
    heroWindow::AddWidget(pNormalDialogWindow, (widget *)component, -1);
  }
  protoCategory = gpMouseManager->cursorCategory;
  spriteIdx = gpMouseManager->spriteIdx;
  while ( gpMouseManager->cursorDisabled )
    mouseManager::ShowColorPointer(gpMouseManager);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  if ( a2 != 6 && a2 != 5 )
  {
    if ( a2 == 4 )
    {
      heroWindowManager::AddWindow(gpWindowManager, pNormalDialogWindow, -1, 1);
      QuickViewWait();
      heroWindowManager::RemoveWindow(gpWindowManager, pNormalDialogWindow);
    }
    else
    {
      heroWindowManager::DoDialog(gpWindowManager, pNormalDialogWindow, EventWindowHandler, 0);
    }
  }
  else
  {
    heroWindowManager::DoDialog(gpWindowManager, pNormalDialogWindow, (int (__fastcall *)(tag_message *))WaitHandler, 0);
  }
  operator delete(pNormalDialogWindow);
  mouseManager::SetPointer(gpMouseManager, byte_50E1C0, spriteIdx, protoCategory);
  giResType1 = v54;
  giResExtra1 = v44;
  giResType2 = v56;
  giResExtra2 = v43;
  result = v37;
  pNormalDialogWindow = v37;
  return result;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 4F7494: using guessed type int gbRemoteOn;
// 50DFC8: using guessed type __int16 word_50DFC8;
// 524228: using guessed type int giResType1;
// 524230: using guessed type int giResType2;
// 524788: using guessed type int giResExtra1;
// 524790: using guessed type int giResExtra2;

//----- (0043B010) --------------------------------------------------------
void __thiscall UpdateNormalDialog(void *this)
{
  int evt; // [sp+14h] [bp-1Ch]@1
  int v2; // [sp+18h] [bp-18h]@1
  int v3; // [sp+1Ch] [bp-14h]@1
  void *v4; // [sp+2Ch] [bp-4h]@1

  evt = 512;
  v2 = 3;
  v3 = 1;
  v4 = this;
  heroWindow::BroadcastMessage(pNormalDialogWindow, (tag_message *)&evt);
  heroWindow::DrawWindow(pNormalDialogWindow, 0, 0, 36864);
  heroWindow::DrawWindow(pNormalDialogWindow, 1, -65535, -256);
}

//----- (0043B090) --------------------------------------------------------
signed int __thiscall combatManager::Main(combatManager *this, tag_message *evt)
{
  int v2; // edx@7
  int v4; // [sp+14h] [bp-30h]@12
  combatManager *thisa; // [sp+18h] [bp-2Ch]@1
  tag_message a2; // [sp+1Ch] [bp-28h]@32
  char *v7; // [sp+38h] [bp-Ch]@10
  army *stack; // [sp+3Ch] [bp-8h]@23
  int v9; // [sp+40h] [bp-4h]@1

  thisa = this;
  v9 = 1;
  if ( !gbNoShowCombat )
  {
    if ( KBTickCount() > glTimers )
    {
      PollSound();
      glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
    }
    if ( KBTickCount() > nextCombatAnimationTime && !gbProcessingCombatAction )
    {
      gbProcessingCombatAction = 1;
      combatManager::CycleCombatScreen(thisa);
      gbProcessingCombatAction = 0;
    }
  }
  combatManager::CheckCastleAttack(thisa);
  if ( combatManager::CheckWin(thisa, evt) )
    return 2;
  if ( gbNoShowCombat )
  {
LABEL_23:
    stack = &thisa->creatures[thisa->activeStackOwner][thisa->activeStack];
    if ( stack->effectStrengths[5] )
    {
      army::GoBerserk(stack);
      if ( combatManager::CheckWin(thisa, evt) )
        return 2;
    }
    if ( !gbNoShowCombat )
    {
      if ( thisa->field_F2B3 )
      {
        while ( evt->eventCode != INPUT_KEYDOWN_EVENT_CODE
             && evt->eventCode != INPUT_LEFT_CLICK_EVENT_CODE
             && evt->eventCode != INPUT_RIGHT_CLICK
             && evt->eventCode )
          memcpy(evt, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
        if ( evt->eventCode )
          thisa->field_F2B3 = 0;
      }
      combatManager::CheckChangeSelector(thisa);
    }
    goto LABEL_36;
  }
  v7 = (char *)GetRemoteData(1, v2);
  if ( !v7 || v7[5] != 2 )
    goto LABEL_17;
  v4 = v7[6];
  if ( v4 == 11 )
  {
    PopNetBox(v7 + 9, (void *)*v7);
    goto LABEL_17;
  }
  if ( v4 != 23 )
  {
LABEL_17:
    if ( !gbThisNetHasControl )
    {
      if ( evt->eventCode == INPUT_KEYDOWN_EVENT_CODE )
      {
        if ( evt->xCoordOrKeycode == '<' )
          PopNetBox(0, (void *)0xFFFFFFFF);
      }
      return 1;
    }
    goto LABEL_23;
  }
  giNextAction = *(_DWORD *)(v7 + 9);
  giNextActionExtra = *(_DWORD *)(v7 + 13);
  giNextActionGridIndex = *(_DWORD *)(v7 + 17);
  giNextActionGridIndex2 = *(_DWORD *)(v7 + 21);
LABEL_36:
  if ( !giNextAction )
  {
    if ( thisa->playerID[thisa->currentActionSide] != -1
      && gbThisNetHumanPlayer[thisa->playerID[thisa->currentActionSide]]
      && !thisa->field_F2B3 )
      v9 = combatManager::ProcessCombatMsg(thisa, evt);
    else
      combatManager::CheckGetAIMove(thisa);
  }
  if ( giNextAction )
    v9 = combatManager::ProcessNextAction(thisa, evt);
  return v9;
}
// 4F31B0: using guessed type int gbProcessingCombatAction;
// 518CFC: using guessed type int gbNoShowCombat;
// 524C08: using guessed type int nextCombatAnimationTime;
// 524C60: using guessed type int gbThisNetHasControl;

//----- (0043B400) --------------------------------------------------------
bool __thiscall combatManager::ValidHexToStandOn(combatManager *this, signed int a2)
{
  bool result; // eax@2

  if ( a2 == -2 )
    result = 1;
  else
    result = a2 != -1
          && MAP_WIDTH - 1 != a2 % 13
          && a2 % 13
          && (!this->combatGrid[a2].isBlocked
           || gpCombatManager->isCastleBattle
           && (a2 == 58 || a2 == 59)
           && (gpCombatManager->drawBridgePosition != 4
            || gpCombatManager->currentActionSide == 1
            && gpCombatManager->combatGrid[58].unitOwner == -1
            && !gpCombatManager->combatGrid[58].numCorpses))
          && (this->combatGrid[a2].unitOwner == -1
           || this->combatGrid[a2].unitOwner == this->activeStackOwner
           && this->combatGrid[a2].stackIdx == this->activeStack);
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;

//----- (0043B590) --------------------------------------------------------
combatManager *__thiscall combatManager::SetCombatDirections(combatManager *this, int hexIdx)
{
  combatManager *result; // eax@1
  combatManager *thisa; // [sp+Ch] [bp-7Ch]@1
  int v4; // [sp+10h] [bp-78h]@2
  int v5[8]; // [sp+14h] [bp-74h]@31
  int v6; // [sp+34h] [bp-54h]@108
  army *thisb; // [sp+38h] [bp-50h]@2
  int v8; // [sp+3Ch] [bp-4Ch]@108
  int i; // [sp+40h] [bp-48h]@2
  char v10[6]; // [sp+44h] [bp-44h]@53
  char v11; // [sp+4Ah] [bp-3Eh]@71
  int v12; // [sp+4Ch] [bp-3Ch]@103
  int v13; // [sp+50h] [bp-38h]@2
  int v14; // [sp+54h] [bp-34h]@74
  army *v15; // [sp+58h] [bp-30h]@2
  int a2[8]; // [sp+5Ch] [bp-2Ch]@9
  int v17; // [sp+7Ch] [bp-Ch]@75
  char v18[8]; // [sp+80h] [bp-8h]@47

  thisa = this;
  result = this;
  if ( !this->field_F2B3 )
  {
    thisb = &this->creatures[this->activeStackOwner][this->activeStack];
    v4 = thisb->targetOwner;
    v13 = thisb->targetStackIdx;
    thisb->targetOwner = -1;
    thisb->targetStackIdx = -1;
    v15 = &this->creatures[v4][v13];
    for ( i = 0; i < 8; ++i )
    {
      if ( i != 6 && i != 7 )
      {
        a2[i] = thisa->hexNeighbors[hexIdx][i];
      }
      else if ( thisb->creature.creature_flags & 1 )
      {
        if ( thisb->facingRight == 1 )
        {
          if ( i == 6 )
            a2[6] = thisa->hexNeighbors[hexIdx][5];
          if ( i == 7 )
            a2[7] = thisa->hexNeighbors[hexIdx][3];
        }
        else
        {
          if ( i == 6 )
            a2[6] = thisa->hexNeighbors[hexIdx][0];
          if ( i == 7 )
            a2[7] = thisa->hexNeighbors[hexIdx][2];
        }
      }
      else
      {
        a2[i] = -1;
      }
      if ( thisb->creature.creature_flags & 1 && a2[i] != -1 )
      {
        if ( thisb->facingRight == 1 )
        {
          if ( i == 5 || i == 4 || i == 3 )
          {
            if ( a2[i] % 13 == 1 )
              a2[i] = -1;
            else
              --a2[i];
          }
          if ( a2[i] % 13 == 11 )
            v5[i] = -1;
          else
            v5[i] = a2[i] + 1;
        }
        else
        {
          if ( !i || i == 1 || i == 2 )
          {
            if ( a2[i] % 13 == 11 )
              a2[i] = -1;
            else
              ++a2[i];
          }
          if ( a2[i] % 13 == 1 )
            v5[i] = -1;
          else
            v5[i] = a2[i] - 1;
        }
      }
      else
      {
        v5[i] = -2;
      }
      v18[i] = combatManager::ValidHexToStandOn(thisa, a2[i]) && combatManager::ValidHexToStandOn(thisa, v5[i]);
    }
    if ( thisb->creature.creature_flags & 2 )
    {
      for ( i = 0; i < 8; ++i )
        v10[i] = v18[i];
    }
    else
    {
      for ( i = 0; i < 8; ++i )
      {
        if ( v18[i] )
          v10[i] = a2[i] == thisb->occupiedHex || army::ValidPath(thisb, a2[i], 1);
        else
          v10[i] = 0;
      }
    }
    *(_DWORD *)&thisa->_15[64] = 0;
    for ( i = 0; i < 8; ++i )
    {
      if ( v10[i] )
        ++*(_DWORD *)&thisa->_15[64];
    }
    if ( !*(_DWORD *)&thisa->_15[64] )
      v11 = 1;
    memset(&thisa->_15[36], 0xFFu, 0x18u);
    for ( i = 0; i < 8; ++i )
    {
      v14 = i;
      if ( i >= 6 )
      {
        if ( i == 6 )
          v17 = 7;
        else
          v17 = 6;
      }
      else
      {
        v17 = (i + 3) % 6;
      }
      if ( v10[v17] )
      {
        if ( v15->creature.creature_flags & 1 )
        {
          if ( i || thisa->combatGrid[hexIdx - 1].unitOwner != v4 || thisa->combatGrid[hexIdx - 1].stackIdx != v13 )
          {
            if ( i != 5
              || thisa->combatGrid[hexIdx + 1].unitOwner != v4
              || thisa->combatGrid[hexIdx + 1].stackIdx != v13 )
            {
              if ( i != 2
                || thisa->combatGrid[hexIdx - 1].unitOwner != v4
                || thisa->combatGrid[hexIdx - 1].stackIdx != v13 )
              {
                if ( i == 3
                  && thisa->combatGrid[hexIdx + 1].unitOwner == v4
                  && thisa->combatGrid[hexIdx + 1].stackIdx == v13 )
                  v14 = 7;
              }
              else
              {
                v14 = 7;
              }
            }
            else
            {
              v14 = 6;
            }
          }
          else
          {
            v14 = 6;
          }
        }
        if ( i >= 6 )
        {
          if ( i == 6 )
          {
            thisa->_15[47] = v14;
            thisa->_15[48] = v14;
            thisa->_15[49] = v14;
          }
          else
          {
            thisa->_15[36] = v14;
            thisa->_15[37] = v14;
            thisa->_15[59] = v14;
          }
        }
        else
        {
          memset(&thisa->_15[4 * v17 + 36], v14, 4u);
        }
      }
    }
    v12 = 24;
    while ( v12 > 0 )
    {
      for ( i = 0; i < 24; ++i )
      {
        if ( thisa->_15[i + 36] == -1 )
        {
          v6 = (i + 1) % 24;
          v8 = (i + 23) % 24;
          if ( thisa->_15[(i + 1) % 24 + 36] < 0 || thisa->_15[v6 + 36] > 7 )
          {
            if ( thisa->_15[v8 + 36] >= 0 && thisa->_15[v8 + 36] <= 7 )
              thisa->_15[i + 36] = thisa->_15[v8 + 36] + 10;
          }
          else
          {
            thisa->_15[i + 36] = thisa->_15[v6 + 36] + 10;
          }
        }
      }
      v12 = 0;
      for ( i = 0; i < 24; ++i )
      {
        if ( thisa->_15[i + 36] < 10 )
        {
          if ( thisa->_15[i + 36] == -1 )
            ++v12;
        }
        else
        {
          thisa->_15[i + 36] -= 10;
        }
      }
    }
    thisb->targetOwner = v4;
    result = (combatManager *)v13;
    thisb->targetStackIdx = v13;
  }
  return result;
}
// 43B590: using guessed type int a2[8];
// 43B590: using guessed type int var_74[8];
// 43B590: using guessed type char var_8[8];
// 43B590: using guessed type char var_44[6];

//----- (0043BE40) --------------------------------------------------------
void __thiscall combatManager::CheckSetMouseDirection(combatManager *this, int a2, int a3, signed int a4)
{
  signed int v4; // ST14_4@13
  combatManager *thisa; // [sp+14h] [bp-2Ch]@1
  signed int a2a; // [sp+18h] [bp-28h]@71
  army *v7; // [sp+1Ch] [bp-24h]@37
  signed int v8; // [sp+20h] [bp-20h]@37
  float v9; // [sp+24h] [bp-1Ch]@13
  int v10; // [sp+28h] [bp-18h]@37
  signed int v11; // [sp+30h] [bp-10h]@6
  int v12; // [sp+34h] [bp-Ch]@6
  int v13; // [sp+38h] [bp-8h]@37
  int v14; // [sp+3Ch] [bp-4h]@4
  int v15; // [sp+3Ch] [bp-4h]@6

  thisa = this;
  if ( !this->field_F2B3 && (*(_DWORD *)&this->_15[64] > 1 || *(_DWORD *)&this->_15[60] < 0) )
  {
    v14 = a2 - 44 * (a4 % 13 - 1) - 67;
    if ( !(a4 / 13 & 1) )
      v14 = a2 - 44 * (a4 % 13 - 1) - 89;
    v15 = v14 - 22;
    v12 = a3 - 63 - 42 * (a4 / 13) - 26;
    v11 = 0;
    if ( v15 >= 0 )
    {
      if ( v12 >= 0 )
        v11 = 6;
    }
    else if ( v12 >= 0 )
    {
      v11 = 12;
    }
    else
    {
      v11 = 18;
    }
    v4 = abs(v15);
    v9 = (double)v4 / (double)abs(v12);
    if ( v11 && v11 != 12 )
    {
      if ( v9 >= 0.27 )
      {
        if ( v9 >= 0.58 )
        {
          if ( v9 >= 1.0 )
          {
            if ( v9 >= 1.73 )
            {
              if ( v9 < 3.73 )
                ++v11;
            }
            else
            {
              v11 += 2;
            }
          }
          else
          {
            v11 += 3;
          }
        }
        else
        {
          v11 += 4;
        }
      }
      else
      {
        v11 += 5;
      }
    }
    else if ( v9 <= 3.73 )
    {
      if ( v9 <= 1.73 )
      {
        if ( v9 <= 1.0 )
        {
          if ( v9 <= 0.58 )
          {
            if ( v9 > 0.27 )
              ++v11;
          }
          else
          {
            v11 += 2;
          }
        }
        else
        {
          v11 += 3;
        }
      }
      else
      {
        v11 += 4;
      }
    }
    else
    {
      v11 += 5;
    }
    if ( thisa->_15[v11 + 36] != *(_DWORD *)&thisa->_15[60] )
    {
      *(_DWORD *)&thisa->_15[60] = thisa->_15[v11 + 36];
      v13 = OppositeDirection(thisa->_15[v11 + 36]);
      v10 = v13;
      v8 = -1;
      v7 = &thisa->creatures[thisa->activeStackOwner][thisa->activeStack];
      if ( v13 != 6 && v13 != 7 )
      {
        if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].facingRight == 1
          && thisa->creatures[thisa->activeStackOwner][thisa->activeStack].creature.creature_flags & 1 )
        {
          if ( v13 == 5 || v13 == 4 || v13 == 3 )
            --a4;
        }
        else if ( !thisa->creatures[thisa->activeStackOwner][thisa->activeStack].facingRight
  && thisa->creatures[thisa->activeStackOwner][thisa->activeStack].creature.creature_flags & 1
  && (!v13 || v13 == 1 || v13 == 2) )
        {
          ++a4;
        }
      }
      else if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].creature.creature_flags & 1 )
      {
        if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].facingRight != 1 || v13 != 6 )
        {
          if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].facingRight != 1 || v13 != 7 )
          {
            if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].facingRight || v13 != 6 )
            {
              v13 = 2;
              v8 = 3;
            }
            else
            {
              v13 = 0;
              v8 = 5;
            }
          }
          else
          {
            v13 = 3;
            v8 = 2;
          }
        }
        else
        {
          v13 = 5;
          v8 = 0;
        }
      }
      else
      {
        if ( thisa->combatGrid[a4 - 1].unitOwner == thisa->creatures[thisa->activeStackOwner][thisa->activeStack].targetOwner
          && thisa->combatGrid[a4 - 1].stackIdx == thisa->creatures[thisa->activeStackOwner][thisa->activeStack].targetStackIdx )
          --a4;
        if ( v13 == 6 )
          v13 = 0;
        else
          v13 = 2;
      }
      thisa->field_F2C7 = thisa->hexNeighbors[a4][v13];
      a2a = -2;
      if ( !v7->facingRight && v7->creature.creature_flags & 1 )
        a2a = thisa->field_F2C7 - 1;
      if ( v7->facingRight == 1 && v7->creature.creature_flags & 1 )
        a2a = thisa->field_F2C7 + 1;
      if ( !combatManager::ValidHexToStandOn(thisa, thisa->field_F2C7) || !combatManager::ValidHexToStandOn(thisa, a2a) )
      {
        if ( v7->creature.creature_flags & 1 && (v10 == 6 || v10 == 7) )
        {
          if ( v7->facingRight == 1 )
            ++thisa->field_F2C7;
          else
            --thisa->field_F2C7;
        }
        else if ( v8 != -1 )
        {
          thisa->field_F2C7 = thisa->hexNeighbors[a4][v8];
        }
      }
      mouseManager::SetPointer(gpMouseManager, *(_DWORD *)&thisa->_15[60] + 7);
    }
  }
}

//----- (0043C470) --------------------------------------------------------
signed int __stdcall combatManager::GetPointer(signed int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 == 13 )
  {
    result = 5;
  }
  else if ( a1 >= 1 && (a1 <= 3 || a1 == 5) )
  {
    result = a1;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (0043C500) --------------------------------------------------------
signed int __thiscall combatManager::ProcessCombatMsg(combatManager *this, tag_message *evt)
{
  int v2; // eax@41
  int v4; // [sp+18h] [bp-64h]@16
  INPUT_EVENT_CODE v5; // [sp+20h] [bp-5Ch]@1
  combatManager *thisa; // [sp+24h] [bp-58h]@1
  char a2; // [sp+28h] [bp-54h]@32
  int y; // [sp+44h] [bp-38h]@73
  int a1; // [sp+48h] [bp-34h]@73
  int v10; // [sp+4Ch] [bp-30h]@5
  int v11; // [sp+50h] [bp-2Ch]@32
  int v12; // [sp+6Ch] [bp-10h]@1
  signed int hexIdx; // [sp+70h] [bp-Ch]@34
  signed int a3; // [sp+74h] [bp-8h]@1
  signed int x; // [sp+78h] [bp-4h]@1

  thisa = this;
  x = evt->altXCoord;
  a3 = evt->altYCoord;
  v12 = 0;
  v5 = evt->eventCode;
  if ( v5 == INPUT_KEYDOWN_EVENT_CODE )
  {
    switch ( evt->xCoordOrKeycode )
    {
      case 60:
        PopNetBox(0, (void *)0xFFFFFFFF);
        break;
      case 61:
        heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 639u, 479);
        break;
      case 63:
        combatManager::SetCombatViewArmySmallLevel(this, (*(_DWORD *)&combatArmyInfoLevel + 1) % 3);
        break;
      case 64:
        combatManager::SetCombatGrid(
          this,
          1 - *(_DWORD *)&showCombatGrid,
          *(int *)&showCombatMouseHex,
          combatShadeLevel);
        break;
      case 65:
        combatManager::SetCombatGrid(
          this,
          *(int *)&showCombatGrid,
          1 - *(_DWORD *)&showCombatMouseHex,
          combatShadeLevel);
        break;
      case 66:
        combatManager::SetCombatGrid(this, *(int *)&showCombatGrid, *(int *)&showCombatMouseHex, 1 - combatShadeLevel);
        break;
      case 67:
        giSpellEffectShowType = (giSpellEffectShowType + 1) % 3;
        combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
        break;
      case 87:
        if ( evt->inputTypeBitmask & 3 )
        {
          combatManager::VaporizeCreature(this, 1, 1);
        }
        else if ( evt->inputTypeBitmask & 0xC )
        {
          combatManager::RippleCreature(this, 1, 1, 1);
          combatManager::RippleCreature(thisa, 1, 1, 2);
        }
        else
        {
          combatManager::RippleCreature(this, 1, 1, 0);
        }
        break;
      case 57:
        giNextAction = 3;
        break;
      case 2:
        mouseManager::MouseCoords(&a1, &y);
        break;
      case 35:
        if ( this->heroes[this->currentActionSide] )
        {
          mouseManager::SetPointer(gpMouseManager, 6);
          combatManager::ViewGeneral(thisa, thisa->currentActionSide, 1, 0);
          combatManager::ResetMouse(thisa);
        }
        break;
      case 20:
        mouseManager::SetPointer(gpMouseManager, 6);
        combatManager::ViewArmy(thisa, (int)&thisa->creatures[thisa->activeStackOwner][thisa->activeStack], 0);
        combatManager::ResetMouse(thisa);
        break;
      case 46:
        if ( this->heroes[this->currentActionSide] )
        {
          if ( combatManager::IsNegationSphereInEffect(this) )
          {
            NormalDialog(
              "The Sphere of Negation artifact is in effect for this battle, disabling all combat spells.",
              1,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
          }
          else if ( !*(&thisa->field_353F + thisa->currentActionSide) || giDebugLevel )
          {
            mouseManager::SetPointer(gpMouseManager, 6);
            giCurGeneral = thisa->currentActionSide;
            combatManager::ViewSpells(thisa, 0);
            combatManager::ResetMouse(thisa);
          }
          else
          {
            NormalDialog("You have already cast a spell this round.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
        }
        else
        {
          NormalDialog("You have no hero to cast a spell.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
        break;
      default:
        return 1;
    }
    return 1;
  }
  if ( v5 != INPUT_MOUSEMOVE_EVENT_CODE )
  {
    if ( v5 == INPUT_GUI_MESSAGE_CODE )
    {
      if ( BYTE1(evt->inputTypeBitmask) & 2 )
      {
        if ( evt->xCoordOrKeycode == 12 || evt->xCoordOrKeycode == 14 )
        {
          v10 = -1;
          switch ( evt->yCoordOrFieldID )
          {
            case 0x40:
              combatManager::RightClick((int)this, this->field_F2C3);
              break;
            case 1:
              v10 = 0;
              break;
            case 2:
              v10 = 1;
              break;
            case 3:
              v10 = 2;
              break;
            case 4:
              v10 = 3;
              break;
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
              v10 = 4;
              break;
            default:
              break;
          }
          if ( v10 != -1 )
            NormalDialog(cLongCombatHelp[v10], 4, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
      else
      {
        v4 = evt->xCoordOrKeycode;
        if ( v4 == 12 )
        {
          if ( evt->yCoordOrFieldID == 64 )
            combatManager::DoCommand((int)this, this->field_F2CF);
        }
        else if ( v4 == 13 )
        {
          switch ( evt->yCoordOrFieldID )
          {
            case 3:
              this->field_F2B3 = 1;
              break;
            case 2:
              giNextAction = 3;
              break;
            case 1:
              giNextAction = 7;
              break;
            case 4:
              combatManager::CombatSystemOptions(this);
              break;
            default:
              return 1;
          }
        }
      }
    }
    return 1;
  }
  if ( this->field_F2B3 )
    return 1;
  memcpy(&v11, inputManager::PeekEvent(gpInputManager, &a2), 0x1Cu);
  if ( v11 == 4 )
    return 1;
  if ( InCombatArea(evt->altXCoord, evt->altYCoord) )
    hexIdx = combatManager::GetGridIndex(thisa, x, a3);
  else
    hexIdx = -1;
  combatManager::UpdateMouseGrid(thisa, hexIdx, 0);
  if ( InCombatArea(evt->altXCoord, evt->altYCoord) )
  {
    if ( thisa->field_F2C3 == hexIdx && hexIdx != -1 )
    {
      if ( thisa->field_F2CF == 7 )
        combatManager::CheckSetMouseDirection(thisa, x, a3, hexIdx);
    }
    else
    {
      thisa->field_F2C3 = hexIdx;
      thisa->field_F2CB = -99;
      thisa->field_F2CF = combatManager::GetCommand(thisa, thisa->field_F2C3);
      *(_DWORD *)&thisa->_15[60] = -1;
      if ( thisa->field_F2CF == 7 )
      {
        combatManager::SetCombatDirections(thisa, hexIdx);
        combatManager::CheckSetMouseDirection(thisa, x, a3, hexIdx);
      }
      else
      {
        v2 = combatManager::GetPointer(thisa->field_F2CF, hexIdx);
        mouseManager::SetPointer(gpMouseManager, v2);
      }
    }
    if ( thisa->field_F2CB != thisa->field_F2CF )
    {
      thisa->field_F2CB = thisa->field_F2CF;
      combatManager::CombatMessage(thisa, thisa->field_F2CF);
    }
  }
  else
  {
    if ( x < 590 )
    {
      if ( x > 50 || a3 >= 460 )
      {
        if ( x > 50 )
          combatManager::CombatMessage(thisa, off_4F6600, 1, 0, 0);
        else
          combatManager::CombatMessage(thisa, off_4F65FC, 1, 0, 0);
      }
      else
      {
        combatManager::CombatMessage(thisa, off_4F65F8, 1, 0, 0);
      }
    }
    else
    {
      combatManager::CombatMessage(thisa, off_4F65F4, 1, 0, 0);
    }
    mouseManager::SetPointer(gpMouseManager, 6);
    thisa->field_F2C3 = -1;
    thisa->field_F2CB = -99;
  }
  return 1;
}
// 4F21F0: using guessed type int giDebugLevel;
// 4F38A0: using guessed type int giSpellEffectShowType;
// 524BE4: using guessed type int giCurGeneral;

//----- (0043CDF0) --------------------------------------------------------
signed int __thiscall combatManager::IsNegationSphereInEffect(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  thisa = this;
  for ( i = 0; i < 2; ++i )
  {
    if ( thisa->heroes[i] && hero::HasArtifact(thisa->heroes[i], ARTIFACT_SPHERE_OF_NEGATION) )
      return 1;
  }
  return 0;
}

//----- (0043CE60) --------------------------------------------------------
combatManager *__thiscall combatManager::ResetRound(combatManager *this)
{
  combatManager *result; // eax@15
  army *stack; // [sp+10h] [bp-10h]@5
  signed int i; // [sp+14h] [bp-Ch]@1
  spellpower_offset j; // [sp+18h] [bp-8h]@3

  this->field_33A1[1] = 0;
  this->field_33A1[0] = this->field_33A1[1];
  this->field_33A3[1] = 0;
  this->field_33A3[0] = this->field_33A3[1];
  this->shouldDoHeroFidget1[1] = 0;
  this->shouldDoHeroFidget1[0] = this->shouldDoHeroFidget1[1];
  this->shouldDoHeroFidget2[1] = 0;
  this->shouldDoHeroFidget2[0] = this->shouldDoHeroFidget2[1];
  this->timesCatapultMustFire[0] = *(_DWORD *)&this->_11[0];
  this->timesCatapultMustFire[1] = *(_DWORD *)&this->_11[4];
  this->timesGarrisonMustFire[0] = 1;
  this->timesGarrisonMustFire[1] = 1;
  this->field_3543 = 0;
  this->field_353F = this->field_3543;
  memset(gpCombatManager->shouldVanish, 0, 0x28u);
  gpCombatManager->anyStacksShouldVanish = 0;
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; j < MAX_STACKS; ++j )
    {
      stack = &this->creatures[i][j];
      if ( this->creatures[i][j].quantity > 0 )
      {
        *(_DWORD *)&this->creatures[i][j].creature.creature_flags &= 0xFF1Fu;
        if ( this->creatures[i][j].creatureIdx == CREATURE_TROLL
          || this->creatures[i][j].creatureIdx == CREATURE_WAR_TROLL )
          this->creatures[i][j].damage = 0;
        army::DecrementSpellRounds(stack);
        if ( !this->creatures[i][j].lifespan )
          army::ProcessDeath(stack, 1);
      }
    }
  }
  if ( gpCombatManager->anyStacksShouldVanish )
    combatManager::MakeCreaturesVanish(gpCombatManager);
  result = this;
  this->field_F2AB = 15;
  return result;
}

//----- (0043D070) --------------------------------------------------------
signed int __thiscall combatManager::CheckWin(combatManager *this, tag_message *evt)
{
  combatManager *thisa; // [sp+Ch] [bp-14h]@1
  signed int v4; // [sp+10h] [bp-10h]@15
  signed int i; // [sp+18h] [bp-8h]@15
  signed int combatOver; // [sp+1Ch] [bp-4h]@1

  thisa = this;
  combatOver = 0;
  if ( combatManager::IsWinner(this, this->currentActionSide) )
  {
    combatOver = 1;
    if ( combatManager::IsWinner(thisa, 1 - thisa->currentActionSide) )
      thisa->winningSide = -1;
    else
      thisa->winningSide = thisa->currentActionSide;
  }
  else if ( combatManager::IsWinner(thisa, 1 - thisa->currentActionSide) )
  {
    combatOver = 1;
    thisa->winningSide = 1 - thisa->currentActionSide;
  }
  else if ( thisa->field_F377[0] || thisa->field_F377[1] )
  {
    combatOver = 1;
    gbRetreatWin = 1;
    if ( thisa->field_F377[0] )
      thisa->winningSide = 1;
    else
      thisa->winningSide = 0;
  }
  if ( combatOver && thisa->winningSide != -1 )
  {
    v4 = 0;
    for ( i = 0; i < 20; ++i )
    {
      if ( thisa->creatures[thisa->winningSide][i].creatureIdx != -1
        && thisa->creatures[thisa->winningSide][i].quantity > 0 )
      {
        if ( !(HIBYTE(thisa->creatures[thisa->winningSide][i].creature.creature_flags) & 8) )
          v4 = 1;
      }
    }
    if ( !v4 )
      thisa->winningSide = -1;
  }
  if ( combatOver )
  {
    combatManager::DoVictory(thisa, thisa->winningSide);
    if ( !gbNoShowCombat )
    {
      evt->eventCode = 0x4000u;
      evt->xCoordOrKeycode = 1;
    }
  }
  return combatOver;
}
// 518CFC: using guessed type int gbNoShowCombat;
// 524210: using guessed type char gbRetreatWin;

//----- (0043D2F0) --------------------------------------------------------
signed int __thiscall combatManager::GetCommand(combatManager *this, int hex)
{
  signed int result; // eax@43
  combatManager *thisa; // [sp+14h] [bp-20h]@1
  int tempStack; // [sp+18h] [bp-1Ch]@24
  signed int tempOwner; // [sp+1Ch] [bp-18h]@24
  signed int returnedResult; // [sp+28h] [bp-Ch]@1
  signed int v7; // [sp+2Ch] [bp-8h]@1
  army *a; // [sp+30h] [bp-4h]@24

  thisa = this;
  returnedResult = 0;
  v7 = 0;
  switch ( hex )
  {
    case -1:
      returnedResult = 0;
      break;
    case 25:
      if ( this->heroes[1] )
      {
        if ( this->currentActionSide == 1 )
          returnedResult = 4;
        else
          returnedResult = 13;
      }
      else
      {
        returnedResult = 0;
      }
      break;
    case 26:
      if ( this->heroes[0] )
      {
        if ( this->currentActionSide )
          returnedResult = 13;
        else
          returnedResult = 4;
      }
      else
      {
        returnedResult = 0;
      }
      break;
    case 77:
      if ( this->isCastleBattle )
        returnedResult = 5;
      else
        returnedResult = 0;
      break;
    default:
      if ( hex % 13 == 12 )
      {
        returnedResult = 0;
      }
      else
      {
        tempOwner = this->combatGrid[hex].unitOwner;
        tempStack = this->combatGrid[hex].stackIdx;
        a = &this->creatures[this->activeStackOwner][this->activeStack];
        this->creatures[this->activeStackOwner][this->activeStack].targetOwner = -1;
        a->targetStackIdx = -1;
        if ( this->combatGrid[hex].isBlocked
          && (!gpCombatManager->isCastleBattle
           || hex != 58 && hex != 59
           || gpCombatManager->drawBridgePosition == 4
           && (gpCombatManager->currentActionSide != 1
            || gpCombatManager->combatGrid[58].unitOwner != -1
            || gpCombatManager->combatGrid[58].numCorpses)) )
        {
          returnedResult = 0;
        }
        else
        {
          if ( tempOwner == -1 )
          {
            if ( army::ValidPath(&this->creatures[this->activeStackOwner][this->activeStack], hex, 0) == 1 )
              returnedResult = (char)(2
                                    - ((*(_DWORD *)&thisa->creatures[thisa->activeStackOwner][thisa->activeStack].creature.creature_flags & (unsigned int)FLYER) < 1));
          }
          else
          {
            if ( this->activeStackOwner != tempOwner || this->activeStack != tempStack )
            {
              v7 = 1;
              if ( !gbProcessingCombatAction )
              {
                if ( !giNextAction )
                {
                  *(_DWORD *)&this->_15[104] = tempOwner;
                  *(_DWORD *)&this->_15[112] = tempStack;
                  combatManager::DrawSmallView(this, 1, 1);
                }
              }
            }
            if ( tempOwner >= 0 && tempOwner <= 1 )
            {
              if ( thisa->currentActionSide == tempOwner
                || thisa->activeStackOwner == tempOwner && thisa->activeStack == tempStack )
                return 5;
              a->targetOwner = tempOwner;
              a->targetStackIdx = tempStack;
              if ( a->creature.shots > 0 && army::GetAttackMask(a, a->occupiedHex, 1, -1) == 255 )
              {
                if ( combatManager::ShotIsThroughWall(thisa, a->owningSide, a->occupiedHex, hex) )
                  result = 15;
                else
                  result = 3;
                return result;
              }
              if ( army::ValidPath(a, hex, 0) == 1 )
                return 7;
              a->targetOwner = -1;
              a->targetStackIdx = -1;
              returnedResult = 0;
            }
          }
        }
      }
      break;
  }
  if ( !v7 )
  {
    if ( !gbProcessingCombatAction )
    {
      *(_DWORD *)&thisa->_15[104] = -1;
      combatManager::DrawSmallView(thisa, 1, 1);
    }
  }
  return returnedResult;
}
// 4F31B0: using guessed type int gbProcessingCombatAction;

//----- (0043D810) --------------------------------------------------------
int __thiscall combatManager::RightClick(int this, signed int a2)
{
  int result; // eax@2
  int thisa; // [sp+14h] [bp-14h]@1
  signed int v4; // [sp+1Ch] [bp-Ch]@15

  thisa = this;
  switch ( a2 )
  {
    case -1:
      result = 0;
      break;
    case 25:
      if ( *(_DWORD *)(this + 12939) )
      {
        combatManager::ViewGeneral((combatManager *)this, 1, 0, 1);
        combatManager::ResetMouse((combatManager *)thisa);
      }
      result = 0;
      break;
    case 26:
      if ( *(_DWORD *)(this + 12935) )
      {
        combatManager::ViewGeneral((combatManager *)this, 0, 0, 1);
        combatManager::ResetMouse((combatManager *)thisa);
      }
      result = 0;
      break;
    case 77:
      if ( *(_DWORD *)(this + 62259) )
        combatManager::ViewBallista((combatManager *)this, 1u);
      result = 0;
      break;
    default:
      if ( a2 % 13 == 12 )
      {
        result = 0;
      }
      else
      {
        v4 = *(_BYTE *)(98 * a2 + this + 1316);
        if ( *(_BYTE *)(98 * a2 + this + 1314)
          && (!gpCombatManager->isCastleBattle
           || a2 != 58 && a2 != 59
           || gpCombatManager->drawBridgePosition == 4
           && (gpCombatManager->currentActionSide != 1
            || gpCombatManager->combatGrid[58].unitOwner != -1
            || gpCombatManager->combatGrid[58].numCorpses)) )
        {
          result = 0;
        }
        else if ( v4 == -1 )
        {
          result = 0;
        }
        else if ( v4 >= 0 && v4 <= 1 )
        {
          mouseManager::SetPointer(gpMouseManager, 6);
          combatManager::ViewArmy(
            (void *)thisa,
            thisa + 24234 * v4 + 1154 * *(_BYTE *)(98 * *(_DWORD *)(thisa + 62147) + thisa + 1317) + 13647,
            1);
          combatManager::ResetMouse((combatManager *)thisa);
          result = 0;
        }
        else
        {
          result = 0;
        }
      }
      break;
  }
  return result;
}

//----- (0043DAC0) --------------------------------------------------------
void __thiscall combatManager::DoCommand(int this, __int32 a2)
{
  int thisa; // [sp+10h] [bp-10h]@1

  thisa = this;
  switch ( a2 )
  {
    case 1:
    case 2:
    case 3:
    case 15:
      giNextAction = 2;
      giNextActionGridIndex = *(_DWORD *)(this + 62147);
      giNextActionExtra = -1;
      break;
    case 7:
      giNextActionGridIndex = *(_DWORD *)(this + 62147);
      if ( *(_DWORD *)(this + 4 * *(_DWORD *)(this + 62127) + 13615) != -1
        && gbHumanPlayer[*(_DWORD *)(this + 4 * *(_DWORD *)(this + 62127) + 13615)]
        && !*(_DWORD *)(this + 62131) )
      {
        giNextAction = 6;
        giNextActionExtra = *(_DWORD *)(this + 62151);
      }
      else
      {
        giNextAction = 2;
        giNextActionExtra = -1;
      }
      break;
    case 4:
      mouseManager::SetPointer(gpMouseManager, 6);
      combatManager::ViewGeneral((combatManager *)thisa, *(_DWORD *)(thisa + 62127), 1, 0);
      combatManager::ResetMouse((combatManager *)thisa);
      break;
    case 13:
      mouseManager::SetPointer(gpMouseManager, 6);
      combatManager::ViewGeneral((combatManager *)thisa, 1 - *(_DWORD *)(thisa + 62127), 1, 0);
      combatManager::ResetMouse((combatManager *)thisa);
      break;
    case 5:
      mouseManager::SetPointer(gpMouseManager, 6);
      if ( *(_DWORD *)(thisa + 62147) == 77 )
        combatManager::ViewBallista((combatManager *)thisa, 0);
      else
        combatManager::ViewArmy(
          (void *)thisa,
          thisa
        + 24234 * *(_BYTE *)(98 * *(_DWORD *)(thisa + 62147) + thisa + 1316)
        + 1154 * *(_BYTE *)(98 * *(_DWORD *)(thisa + 62147) + thisa + 1317)
        + 13647,
          0);
      combatManager::ResetMouse((combatManager *)thisa);
      break;
    case 10:
      if ( combatManager::IsNegationSphereInEffect((combatManager *)this) )
      {
        NormalDialog(
          "The Sphere of Negation artifact is in effect for this battle, disabling all combat spells.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        combatManager::ViewSpells((combatManager *)thisa, 0);
        combatManager::ResetMouse((combatManager *)thisa);
      }
      break;
    case 11:
      NormalDialog("Are you sure you want to retreat?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode == 30725 )
        giNextAction = 4;
      combatManager::ResetMouse((combatManager *)thisa);
      break;
    case 12:
      if ( combatManager::DoSurrender((combatManager *)this) == 1 )
      {
        if ( gpGame->players[*(_DWORD *)(thisa + 4 * *(_DWORD *)(thisa + 62127) + 13615)].resources[6] >= giSurrenderCost )
        {
          giNextAction = 5;
          giNextActionExtra = giSurrenderCost;
        }
        else
        {
          NormalDialog("You don't have enough gold!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
      combatManager::ResetMouse((combatManager *)thisa);
      break;
    case 0:
      return;
  }
}
// 524CA0: using guessed type int giSurrenderCost;

//----- (0043DE80) --------------------------------------------------------
signed int __thiscall WinCombatHandler(tag_message *this)
{
  int v3; // [sp+1Ch] [bp-50h]@22
  char v4; // [sp+20h] [bp-4Ch]@21
  int v5; // [sp+48h] [bp-24h]@22
  int evt; // [sp+4Ch] [bp-20h]@21
  int v7; // [sp+50h] [bp-1Ch]@21
  int v8; // [sp+54h] [bp-18h]@25
  char *v9; // [sp+64h] [bp-8h]@21
  int v10; // [sp+68h] [bp-4h]@1

  v10 = 90;
  if ( giDialogTimeout && KBTickCount() > giDialogTimeout )
  {
    this->eventCode = INPUT_GUI_MESSAGE_CODE;
    gpWindowManager->buttonPressedCode = this->yCoordOrFieldID;
    this->yCoordOrFieldID = 10;
    this->xCoordOrKeycode = this->yCoordOrFieldID;
    giDialogTimeout = 0;
    return 2;
  }
  if ( this->eventCode != 512 || this->xCoordOrKeycode != 13 || this->yCoordOrFieldID != 30720 )
    goto LABEL_20;
  if ( dword_524C90 )
    goto LABEL_15;
  if ( iCurTransferArtifact + 1 >= iMaxTransferArtifacts )
  {
    if ( *(_DWORD *)&giSkeletonsCreated && !bSkeletonsShown )
    {
      bSkeletonsShown = 1;
      combatManager::ClearWinLoseBottom(gpCombatManager, gpCombatManager->combatEndWindow);
      combatManager::ShowSkeletons(gpCombatManager, (int)&gpCombatManager->combatEndWindow->idx);
      goto LABEL_20;
    }
    if ( gpCombatManager->eagleEyeSpellLearned[gpCombatManager->winningSide] != -1 )
    {
      combatManager::ClearWinLoseBottom(gpCombatManager, gpCombatManager->combatEndWindow);
      combatManager::ShowEagleEyeSpell((int)gpCombatManager, (int)&gpCombatManager->combatEndWindow->idx);
      gpCombatManager->eagleEyeSpellLearned[gpCombatManager->winningSide] = -1;
      goto LABEL_20;
    }
LABEL_15:
    gpWindowManager->buttonPressedCode = this->yCoordOrFieldID;
    this->yCoordOrFieldID = 10;
    this->xCoordOrKeycode = this->yCoordOrFieldID;
    return 2;
  }
  combatManager::ClearWinLoseBottom(gpCombatManager, gpCombatManager->combatEndWindow);
  ++iCurTransferArtifact;
  combatManager::ShowWinLoseArtifact(
    gpCombatManager,
    (int)&gpCombatManager->combatEndWindow->idx,
    iTransferArtifacts[iCurTransferArtifact]);
LABEL_20:
  if ( KBTickCount() > glTimers )
  {
    evt = 512;
    v7 = 9;
    v9 = &v4;
    ++giWinCmbtFrame;
    switch ( gbWhichAnimationPlaying )
    {
      case 1:
        v3 = giWinCmbtFrame % 20 + 1;
        v5 = 99;
        break;
      case 3:
        if ( giWinCmbtFrame == 43 )
        {
          sprintf(&v4, "cmbtfle2.icn");
          v8 = 200;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
          v8 = 201;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
        }
        if ( giWinCmbtFrame == 69 )
        {
          sprintf(&v4, "cmbtfle3.icn");
          v8 = 200;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
          v8 = 201;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
        }
        if ( giWinCmbtFrame >= 43 )
        {
          if ( giWinCmbtFrame >= 69 )
          {
            v3 = giWinCmbtFrame - 68;
            if ( giWinCmbtFrame - 68 > 25 )
              v3 = 25;
          }
          else
          {
            v3 = giWinCmbtFrame - 42;
          }
        }
        else
        {
          v3 = giWinCmbtFrame + 1;
        }
        v5 = 40;
        break;
      case 4:
        v3 = giWinCmbtFrame % 20 + 1;
        v5 = 99;
        break;
      default:
        if ( giWinCmbtFrame == 30 )
        {
          sprintf(&v4, "cmbtlos2.icn");
          v8 = 200;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
          v8 = 201;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
        }
        if ( giWinCmbtFrame == 59 )
        {
          sprintf(&v4, "cmbtlos3.icn");
          v8 = 200;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
          v8 = 201;
          heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, (tag_message *)&evt);
        }
        if ( giWinCmbtFrame >= 30 )
        {
          if ( giWinCmbtFrame >= 59 )
          {
            if ( giWinCmbtFrame == 80 )
              giWinCmbtFrame = 59;
            v3 = giWinCmbtFrame - 58;
            v5 = 100;
          }
          else
          {
            v3 = giWinCmbtFrame - 29;
            v5 = 50;
          }
        }
        else
        {
          v3 = giWinCmbtFrame + 1;
          v5 = 50;
        }
        break;
    }
    this->eventCode = 512;
    this->xCoordOrKeycode = 4;
    this->yCoordOrFieldID = 201;
    this->payload = (void *)v3;
    heroWindow::BroadcastMessage(gpCombatManager->combatEndWindow, this);
    heroWindow::DrawWindow(gpCombatManager->combatEndWindow, 1, 0, 32767);
    glTimers = KBTickCount() + v5;
  }
  return 1;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 524C6C: using guessed type int bSkeletonsShown;
// 524C70: using guessed type int gbWhichAnimationPlaying;
// 524C88: using guessed type int giWinCmbtFrame;
// 524C8C: using guessed type int iCurTransferArtifact;
// 524C90: using guessed type int dword_524C90;
// 524C9C: using guessed type int iMaxTransferArtifacts;

//----- (0043E400) --------------------------------------------------------
signed int __thiscall combatManager::ClearWinLoseBottom(void *this, void *a2)
{
  signed int result; // eax@9
  void *v3; // [sp+Ch] [bp-18h]@1
  int v4; // [sp+14h] [bp-10h]@7
  int v5; // [sp+1Ch] [bp-8h]@4
  signed int i; // [sp+20h] [bp-4h]@1

  v3 = this;
  for ( i = 0; i < 25; ++i )
  {
    if ( *(_DWORD *)((char *)v3 + 4 * i + 62515) )
    {
      heroWindow::RemoveWidget((heroWindow *)a2, *(widget **)((char *)v3 + 4 * i + 62515));
      v5 = *(_DWORD *)((char *)v3 + 4 * i + 62515);
      if ( v5 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
    if ( *(_DWORD *)((char *)v3 + 4 * i + 62615) )
    {
      heroWindow::RemoveWidget((heroWindow *)a2, *(widget **)((char *)v3 + 4 * i + 62615));
      v4 = *(_DWORD *)((char *)v3 + 4 * i + 62615);
      if ( v4 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
    *(_DWORD *)((char *)v3 + 4 * i + 62515) = 0;
    result = i;
    *(_DWORD *)((char *)v3 + 4 * i + 62615) = 0;
  }
  return result;
}

//----- (0043E510) --------------------------------------------------------
void __thiscall combatManager::ShowWinLoseArtifact(combatManager *this, int a2, int a3)
{
  int v3; // eax@16
  textWidget *v5; // [sp+18h] [bp-3Ch]@11
  iconWidget *v6; // [sp+1Ch] [bp-38h]@6
  iconWidget *v7; // [sp+20h] [bp-34h]@1
  char *content; // [sp+24h] [bp-30h]@11
  int evt; // [sp+28h] [bp-2Ch]@1
  int v10; // [sp+2Ch] [bp-28h]@1
  int v11; // [sp+30h] [bp-24h]@1
  char *v12; // [sp+40h] [bp-14h]@1
  __int16 v13; // [sp+44h] [bp-10h]@1
  __int16 v14; // [sp+48h] [bp-Ch]@1
  SAMPLE2 res; // [sp+4Ch] [bp-8h]@16

  v14 = 320;
  v13 = 458;
  sprintf(gText, "You have captured an enemy artifact!");
  evt = 512;
  v10 = 3;
  v11 = 101;
  v12 = gText;
  heroWindow::BroadcastMessage(this->combatEndWindow, (tag_message *)&evt);
  v7 = (iconWidget *)operator new(45);
  if ( v7 )
    *(_DWORD *)&this->_14[0] = iconWidget::iconWidget(v7, 136, 310, 80, 80, "winloseb.icn", 0, 0, 2001, 16, 1);
  else
    *(_DWORD *)&this->_14[0] = 0;
  if ( !*(_DWORD *)&this->_14[0] )
    MemError();
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)&this->_14[0], -1);
  v6 = (iconWidget *)operator new(45);
  if ( v6 )
    *(_DWORD *)&this->_14[4] = iconWidget::iconWidget(v6, 144, 318, 64, 64, "artifact.icn", a3 + 1, 0, 2002, 16, 1);
  else
    *(_DWORD *)&this->_14[4] = 0;
  if ( !*(_DWORD *)&this->_14[4] )
    MemError();
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)&this->_14[4], -1);
  content = (char *)BaseAlloc(0x3Cu, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E34C + 43);
  sprintf(content, gArtifactNames[a3]);
  v5 = (textWidget *)operator new(43);
  if ( v5 )
    *(_DWORD *)&this->_14[100] = textWidget::textWidget(v5, 16, 397, 320, 12, content, "smalfont.fnt", 1, 2101, 512, 1);
  else
    *(_DWORD *)&this->_14[100] = 0;
  if ( !*(_DWORD *)&this->_14[100] )
    MemError();
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)&this->_14[100], -1);
  heroWindow::DrawWindow(gpCombatManager->combatEndWindow);
  res = NULL_SAMPLE2;
  v3 = SRandom(1, 5);
  sprintf(gText, "pickup%02d.82M", v3);
  res = (SAMPLE2)LoadPlaySample(gText);
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
}
// 50E34C: using guessed type __int16 word_50E34C;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0043E7B0) --------------------------------------------------------
void __thiscall combatManager::ShowSkeletons(combatManager *this, int a2)
{
  int v2; // eax@14
  combatManager *v3; // [sp+Ch] [bp-3Ch]@1
  textWidget *v4; // [sp+18h] [bp-30h]@6
  iconWidget *v5; // [sp+1Ch] [bp-2Ch]@1
  char *content; // [sp+20h] [bp-28h]@6
  int evt; // [sp+24h] [bp-24h]@14
  int v8; // [sp+28h] [bp-20h]@14
  int v9; // [sp+2Ch] [bp-1Ch]@14
  char *v10; // [sp+3Ch] [bp-Ch]@14
  SAMPLE2 res; // [sp+40h] [bp-8h]@14

  v3 = this;
  v5 = (iconWidget *)operator new(45);
  if ( v5 )
    *(_DWORD *)&v3->_14[0] = iconWidget::iconWidget(v5, 173, 270, 32, 30, "mons32.icn", 47, 0, 900, 16, 1);
  else
    *(_DWORD *)&v3->_14[0] = 0;
  if ( !*(_DWORD *)&v3->_14[0] )
    MemError();
  content = (char *)BaseAlloc(9u, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E3D8 + 19);
  sprintf(content, "%d", *(_DWORD *)&giSkeletonsCreated);
  v4 = (textWidget *)operator new(43);
  if ( v4 )
    *(_DWORD *)&v3->_14[100] = textWidget::textWidget(v4, 165, 300, 32, 12, content, "smalfont.fnt", 1, 901, 512, 1);
  else
    *(_DWORD *)&v3->_14[100] = 0;
  if ( !*(_DWORD *)&v3->_14[100] )
    MemError();
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)&v3->_14[0], -1);
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)&v3->_14[100], -1);
  if ( *(_DWORD *)&giSkeletonsCreated <= 1 )
    sprintf(
      gText,
      "Practicing the dark arts of necromancy, you are able to raise one of the enemy's dead to return under your service as a Skeleton.");
  else
    sprintf(
      gText,
      "Practicing the dark arts of necromancy, you are able to raise %d of the enemy's dead to return under your service as Skeletons.",
      *(_DWORD *)&giSkeletonsCreated);
  evt = 512;
  v8 = 3;
  v9 = 101;
  v10 = gText;
  heroWindow::BroadcastMessage(v3->combatEndWindow, (tag_message *)&evt);
  heroWindow::DrawWindow(gpCombatManager->combatEndWindow);
  res = NULL_SAMPLE2;
  v2 = SRandom(1, 5);
  sprintf(gText, "pickup%02d.82M", v2);
  res = (SAMPLE2)LoadPlaySample(gText);
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
}
// 50E3D8: using guessed type __int16 word_50E3D8;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0043E9F0) --------------------------------------------------------
void __thiscall combatManager::ShowEagleEyeSpell(int this, int a2)
{
  int v2; // eax@16
  int v3; // [sp+Ch] [bp-4Ch]@1
  textWidget *v4; // [sp+18h] [bp-40h]@11
  iconWidget *v5; // [sp+1Ch] [bp-3Ch]@6
  iconWidget *v6; // [sp+20h] [bp-38h]@1
  char *content; // [sp+24h] [bp-34h]@11
  int evt; // [sp+2Ch] [bp-2Ch]@16
  int v9; // [sp+30h] [bp-28h]@16
  int v10; // [sp+34h] [bp-24h]@16
  char *v11; // [sp+44h] [bp-14h]@16
  int v12; // [sp+48h] [bp-10h]@1
  SAMPLE2 res; // [sp+4Ch] [bp-Ch]@16
  int v14; // [sp+54h] [bp-4h]@1

  v3 = this;
  v14 = *(_WORD *)(this + 2 * *(_DWORD *)(this + 63603) + 12886);
  v12 = 105;
  v6 = (iconWidget *)operator new(45);
  if ( v6 )
    *(_DWORD *)(v3 + 62515) = iconWidget::iconWidget(v6, v12 + 16, 275, 0, 0, "townwind.icn", 0, 0, 902, 16, 1);
  else
    *(_DWORD *)(v3 + 62515) = 0;
  if ( !*(_DWORD *)(v3 + 62515) )
    MemError();
  v5 = (iconWidget *)operator new(45);
  if ( v5 )
    *(_DWORD *)(v3 + 62519) = iconWidget::iconWidget(
                                v5,
                                v12 + 36,
                                280,
                                72,
                                51,
                                "spells.icn",
                                gsSpellInfo[v14].spriteIdx,
                                0,
                                903,
                                17,
                                1);
  else
    *(_DWORD *)(v3 + 62519) = 0;
  if ( !*(_DWORD *)(v3 + 62519) )
    MemError();
  content = (char *)BaseAlloc(0xC8u, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E530 + 34);
  sprintf(content, "%s", gSpellNames[v14]);
  v4 = (textWidget *)operator new(43);
  if ( v4 )
    *(_DWORD *)(v3 + 62615) = textWidget::textWidget(v4, v12 + 34, 332, 80, 24, content, "smalfont.fnt", 1, 904, 512, 1);
  else
    *(_DWORD *)(v3 + 62615) = 0;
  if ( !*(_DWORD *)(v3 + 62615) )
    MemError();
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)(v3 + 62515), -1);
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)(v3 + 62519), -1);
  heroWindow::AddWidget((heroWindow *)a2, *(widget **)(v3 + 62615), -1);
  sprintf(
    gText,
    "Through eagle-eyed observation, %s is able to learn the magic spell '%s'.",
    *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 63603) + 12935) + 10,
    gSpellNames[v14]);
  evt = 512;
  v9 = 3;
  v10 = 101;
  v11 = gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(v3 + 63595), (tag_message *)&evt);
  heroWindow::DrawWindow(gpCombatManager->combatEndWindow);
  res = NULL_SAMPLE2;
  v2 = SRandom(1, 5);
  sprintf(gText, "pickup%02d.82M", v2);
  res = (SAMPLE2)LoadPlaySample(gText);
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
}
// 50E530: using guessed type __int16 word_50E530;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0043ECF0) --------------------------------------------------------
void __thiscall combatManager::ShowDeadArmies(combatManager *ecx0, heroWindow *window)
{
  int v2; // eax@35
  int v3; // ST1C_4@40
  int v4; // ST14_4@40
  int v5; // ebx@40
  int v6; // ST04_4@40
  int v7; // ebx@40
  IconEntry *v8; // eax@40
  textWidget *v10; // [sp+10h] [bp-1A0h]@44
  iconWidget *this; // [sp+14h] [bp-19Ch]@39
  textWidget *v12; // [sp+18h] [bp-198h]@29
  textWidget *v13; // [sp+1Ch] [bp-194h]@23
  textWidget *v14; // [sp+20h] [bp-190h]@13
  icon *res; // [sp+24h] [bp-18Ch]@35
  int lossesToDisplay; // [sp+28h] [bp-188h]@37
  int v17; // [sp+2Ch] [bp-184h]@37
  char *content; // [sp+30h] [bp-180h]@13
  char *contenta; // [sp+30h] [bp-180h]@23
  char *contentb; // [sp+30h] [bp-180h]@29
  char *contentc; // [sp+30h] [bp-180h]@44
  int distinctCreaturesLost[2]; // [sp+50h] [bp-160h]@6
  int j; // [sp+58h] [bp-158h]@6
  int i; // [sp+5Ch] [bp-154h]@1
  int v25; // [sp+60h] [bp-150h]@21
  __int16 v26; // [sp+64h] [bp-14Ch]@1
  int numLostCreature[2][20]; // [sp+68h] [bp-148h]@10
  __int16 v28; // [sp+108h] [bp-A8h]@1
  int idxOfLostCreature[2][20]; // [sp+10Ch] [bp-A4h]@10
  int v30; // [sp+1ACh] [bp-4h]@37

  v28 = 320;
  v26 = 458;
  for ( i = 0; i < 25; ++i )
  {
    *(_DWORD *)&ecx0->_14[4 * i] = 0;
    *(_DWORD *)&ecx0->_14[4 * i + 100] = 0;
  }
  for ( i = 0; i < 2; ++i )
  {
    distinctCreaturesLost[i] = 0;
    for ( j = 0; j < 20; ++j )
    {
      if ( ecx0->creatures[i][j].creatureIdx != -1 )
      {
        if ( ecx0->creatures[i][j].initialQuantity > ecx0->creatures[i][j].quantity )
        {
          idxOfLostCreature[i][distinctCreaturesLost[i]] = ecx0->creatures[i][j].creatureIdx;
          numLostCreature[i][distinctCreaturesLost[i]++] = ecx0->creatures[i][j].initialQuantity
                                                         - ecx0->creatures[i][j].quantity;
        }
      }
    }
  }
  content = (char *)BaseAlloc(30u, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E5E0 + 35);
  sprintf(content, "Battlefield Casualties");
  v14 = (textWidget *)operator new(43);
  if ( v14 )
    ecx0->battlefieldCasualtiesTextWidget = textWidget::textWidget(
                                              v14,
                                              16,
                                              263,
                                              320,
                                              20,
                                              content,
                                              "smalfont.fnt",
                                              1,
                                              2110,
                                              512,
                                              1);
  else
    ecx0->battlefieldCasualtiesTextWidget = 0;
  if ( !ecx0->battlefieldCasualtiesTextWidget )
    MemError();
  heroWindow::AddWidget(window, (widget *)ecx0->battlefieldCasualtiesTextWidget, -1);
  for ( i = 0; i < 2; ++i )
  {
    if ( i )
      v25 = 346;
    else
      v25 = 279;
    contenta = (char *)BaseAlloc(0x1Eu, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E5E0 + 56);
    sprintf(contenta, &aAttacker[("Defender" - "Attacker") & ((i == 0) - 1)]);
    v13 = (textWidget *)operator new(43);
    if ( v13 )
      ecx0->sideCasualtiesTitleTextWidget[i] = (int)textWidget::textWidget(
                                                      v13,
                                                      16,
                                                      v25 + 3,
                                                      320,
                                                      20,
                                                      contenta,
                                                      "smalfont.fnt",
                                                      1,
                                                      2110,
                                                      512,
                                                      1);
    else
      ecx0->sideCasualtiesTitleTextWidget[i] = 0;
    if ( !ecx0->sideCasualtiesTitleTextWidget[i] )
      MemError();
    heroWindow::AddWidget(window, (widget *)ecx0->sideCasualtiesTitleTextWidget[i], -1);
    if ( distinctCreaturesLost[i] <= 0 )
    {
      contentb = (char *)BaseAlloc(0xAu, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E5E0 + 75);
      sprintf(contentb, "None");
      v12 = (textWidget *)operator new(43);
      if ( v12 )
        *(_DWORD *)&ecx0->_14[28 * i + 100] = textWidget::textWidget(
                                                v12,
                                                16,
                                                v25 + 21,
                                                320,
                                                20,
                                                contentb,
                                                "smalfont.fnt",
                                                1,
                                                5 * i + 2100,
                                                512,
                                                1);
      else
        *(_DWORD *)&ecx0->_14[28 * i + 100] = 0;
      if ( !*(_DWORD *)&ecx0->_14[28 * i + 100] )
        MemError();
      heroWindow::AddWidget(window, *(widget **)&ecx0->_14[28 * i + 100], -1);
    }
    res = resourceManager::GetIcon(gpResourceManager, "mons32.icn");
    v2 = distinctCreaturesLost[i];
    if ( v2 >= 7 )
      v2 = 7;
    lossesToDisplay = v2;
    v30 = 40;
    v17 = (320 - 40 * v2) / 2 + 3;
    for ( j = 0; j < lossesToDisplay; ++j )
    {
      this = (iconWidget *)operator new(45);
      if ( this )
      {
        v3 = j + 5 * i + 2000;
        v4 = idxOfLostCreature[i][j];
        v5 = v25 + 19 - GetIconEntry(res, idxOfLostCreature[i][j])->offsetY;
        v6 = v5 - GetIconEntry(res, idxOfLostCreature[i][j])->height + 32;
        v7 = v17 + v30 * j + 16 - GetIconEntry(res, idxOfLostCreature[i][j])->offsetX;
        v8 = GetIconEntry(res, idxOfLostCreature[i][j]);
        *(_DWORD *)&ecx0->_14[4 * (j + 7 * i)] = iconWidget::iconWidget(
                                                   this,
                                                   (32 - v8->width) / 2 + (_WORD)v7 + 1,
                                                   v6,
                                                   32,
                                                   28,
                                                   "mons32.icn",
                                                   v4,
                                                   0,
                                                   v3,
                                                   16,
                                                   1);
      }
      else
      {
        *(_DWORD *)&ecx0->_14[4 * (j + 7 * i)] = 0;
      }
      if ( !*(_DWORD *)&ecx0->_14[4 * (j + 7 * i)] )
        MemError();
      contentc = (char *)BaseAlloc(9u, "F:\\h2xsrc\\Source\\COMMAND.CPP", word_50E5E0 + 119);
      sprintf(contentc, "%d", numLostCreature[i][j]);
      v10 = (textWidget *)operator new(43);
      if ( v10 )
        *(_DWORD *)&ecx0->_14[4 * (j + 7 * i) + 100] = textWidget::textWidget(
                                                         v10,
                                                         (_WORD)v17 + v30 * (_WORD)j + 16,
                                                         v25 + 53,
                                                         32,
                                                         12,
                                                         contentc,
                                                         "smalfont.fnt",
                                                         1,
                                                         (_WORD)j + 5 * i + 2100,
                                                         512,
                                                         1);
      else
        *(_DWORD *)&ecx0->_14[4 * (j + 7 * i) + 100] = 0;
      if ( !*(_DWORD *)&ecx0->_14[4 * (j + 7 * i) + 100] )
        MemError();
      heroWindow::AddWidget(window, *(widget **)&ecx0->_14[4 * (j + 7 * i)], -1);
      heroWindow::AddWidget(window, *(widget **)&ecx0->_14[4 * (j + 7 * i) + 100], -1);
    }
    resourceManager::Dispose(gpResourceManager, (resource *)res);
  }
}
// 50E5E0: using guessed type __int16 word_50E5E0;
// 43ECF0: using guessed type int distinctCreaturesLost[2];

//----- (0043F6E0) --------------------------------------------------------
int __thiscall combatManager::DoVictory(combatManager *this, signed int side)
{
  int result; // eax@113
  combatManager *thisa; // [sp+18h] [bp-F8h]@1
  heroWindow *v4; // [sp+24h] [bp-ECh]@76
  char a2; // [sp+28h] [bp-E8h]@90
  int numArtifactsToSteal; // [sp+C0h] [bp-50h]@53
  int evt; // [sp+C4h] [bp-4Ch]@98
  int v8; // [sp+C8h] [bp-48h]@98
  int v9; // [sp+CCh] [bp-44h]@98
  char *v10; // [sp+DCh] [bp-34h]@98
  int i; // [sp+E0h] [bp-30h]@4
  int v12; // [sp+E8h] [bp-28h]@4
  int tick; // [sp+ECh] [bp-24h]@39
  int k; // [sp+F0h] [bp-20h]@39
  int v15; // [sp+F4h] [bp-1Ch]@1
  int v16; // [sp+F8h] [bp-18h]@6
  int v17; // [sp+FCh] [bp-14h]@6
  int j; // [sp+100h] [bp-10h]@6
  int creaturesKilled; // [sp+104h] [bp-Ch]@4
  army *stack; // [sp+108h] [bp-8h]@8
  int v21; // [sp+10Ch] [bp-4h]@37

  thisa = this;
  v15 = 0;
  if ( this->heroes[1] && this->heroes[1]->isCaptain )
    this->heroes[1] = 0;
  dword_524C90 = 0;
  gbWhichAnimationPlaying = 1;
  giWinCmbtFrame = 0;
  *(_DWORD *)&giSkeletonsCreated = 0;
  iMaxTransferArtifacts = 0;
  iCurTransferArtifact = -1;
  bSkeletonsShown = 0;
  creaturesKilled = 0;
  v12 = 0;
  for ( i = 0; i < 2; ++i )
  {
    v16 = 0;
    v17 = -1;
    for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
    {
      stack = &this->creatures[i][j];
      if ( this->creatures[i][j].quantity > 0 )
      {
        v17 = j;
        if ( stack->temporaryQty > 0 )
          stack->quantity -= stack->temporaryQty;
        if ( stack->quantity < 0 )
          stack->quantity = 0;
        v16 += stack->quantity;
      }
      if ( i == side
        && stack->quantity > 0
        && !(HIBYTE(stack->creature.creature_flags) & ATTR_MIRROR_IMAGE)
        && stack->creatureIdx != CREATURE_EARTH_ELEMENTAL
        && stack->creatureIdx != CREATURE_AIR_ELEMENTAL
        && stack->creatureIdx != CREATURE_FIRE_ELEMENTAL
        && stack->creatureIdx != CREATURE_WATER_ELEMENTAL
        && stack->creatureIdx != CREATURE_SKELETON )
        ++v12;
      if ( 1 - i == side )
        creaturesKilled += stack->initialQuantity - stack->quantity;
    }
    if ( !v16 && v17 != -1 )
      this->creatures[i][v17].quantity = 1;
  }
  if ( side != -1 )
  {
    if ( v12 < 5 )
    {
      if ( this->heroes[side] )
      {
        if ( hero::GetSSLevel(this->heroes[side], SECONDARY_SKILL_NECROMANCY) )
        {
          *(_DWORD *)&giSkeletonsCreated = (signed __int64)((double)hero::GetSSLevel(
                                                                      thisa->heroes[side],
                                                                      SECONDARY_SKILL_NECROMANCY)
                                                          * 0.1
                                                          * (double)creaturesKilled);
          if ( *(_DWORD *)&giSkeletonsCreated <= 0 )
          {
            if ( creaturesKilled )
              *(_DWORD *)&giSkeletonsCreated = 1;
          }
        }
      }
    }
  }
  thisa->field_F357 = 1;
  combatManager::FreeArmies(thisa);
  combatManager::CombatMessage(thisa, byte_50E6F8, 1, 1, 0);
  mouseManager::SetPointer(gpMouseManager, 6);
  v21 = 8;
  if ( thisa->terrainType == 7 )
    v21 = 5;
  tick = KBTickCount();
  for ( k = 0; v21 > k; ++k )
  {
    PollSound();
    DelayTil(&tick);
    tick = KBTickCount() + 60;
    DimBitmapArea(gpWindowManager->screenBuffer, 0, 0, 640, 480, 3);
    PollSound();
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x27Fu, 479);
    PollSound();
  }
  if ( side == -1 )
  {
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 30);
    combatManager::DoLoseWindow(thisa);
  }
  else if ( side >= 0 && side <= 1 )
  {
    if ( thisa->heroes[side] )
    {
      if ( thisa->eagleEyeSpellLearned[side] != -1 )
        thisa->heroes[side]->spellsLearned[thisa->eagleEyeSpellLearned[side]] = 1;
      thisa->experienceForDefeating[1 - side] = combatManager::ExperienceValueOfStack(thisa, 1 - side);
      if ( gbRetreatWin )
        thisa->experienceForDefeating[1 - side] -= 500;
      if ( thisa->castles[1] && !side )
        thisa->experienceForDefeating[1] += 500;
      v15 = advManager::GiveExperience(
              thisa->heroes[side],
              thisa->experienceForDefeating[1 - side],
              (unsigned int)gbThisNetHumanPlayer[thisa->heroes[side]->ownerIdx] < 1);
      if ( !gbRetreatWin )
      {
        numArtifactsToSteal = 0;
        if ( thisa->heroes[0] )
        {
          if ( thisa->heroes[1] )
          {
            for ( k = 0; k < 14; ++k )
            {
              if ( thisa->heroes[side]->artifacts[k] == -1 )
                ++numArtifactsToSteal;
            }
            for ( k = 0; k < 14; ++k )
            {
              if ( thisa->heroes[1 - side]->artifacts[k] >= 8
                && thisa->heroes[1 - side]->artifacts[k] != ARTIFACT_MAGIC_BOOK
                && iMaxTransferArtifacts < numArtifactsToSteal )
              {
                iTransferArtifacts[iMaxTransferArtifacts] = thisa->heroes[1 - side]->artifacts[k];
                iTransferArtifactsInfo[iMaxTransferArtifacts++] = thisa->heroes[1 - side]->scrollSpell[k];
              }
            }
          }
        }
      }
    }
    if ( giCurPlayer != -1 && gbThisNetHumanPlayer[giCurPlayer] && thisa->playerID[side] == giCurPlayer
      || giCurPlayer != -1
      && thisa->playerID[side] != -1
      && !gbThisNetHumanPlayer[giCurPlayer]
      && gbThisNetHumanPlayer[thisa->playerID[side]]
      || thisa->playerID[side] != -1 && gbThisNetHumanPlayer[thisa->playerID[side]] )
    {
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 29);
      v4 = (heroWindow *)operator new(68);
      if ( v4 )
        thisa->combatEndWindow = heroWindow::heroWindow(v4, 143, 10, "wincmbt.bin");
      else
        thisa->combatEndWindow = 0;
      if ( !thisa->combatEndWindow )
        MemError();
      if ( thisa->heroes[side] )
      {
        if ( gbCombatSurrender )
        {
          sprintf(gText, cBattleResults);
        }
        else if ( gbRetreatWin )
        {
          sprintf(gText, off_4F686C);
        }
        else
        {
          sprintf(gText, off_4F6870);
        }
        if ( v15 <= 0 || side != 1 || iLastMsgNumHumanPlayers <= 1 )
          sprintf(&a2, off_4F6874, thisa->heroes[side]->name, thisa->experienceForDefeating[1 - side]);
        else
          sprintf(&a2, off_4F6890, thisa->heroes[1]->name, thisa->experienceForDefeating[0], v15);
        strcat(gText, &a2);
        hero::ApplyBattleWinTemps(thisa->heroes[side]);
      }
      else if ( gbCombatSurrender )
      {
        sprintf(gText, cBattleResults);
      }
      else if ( gbRetreatWin )
      {
        sprintf(gText, off_4F686C);
      }
      else
      {
        sprintf(gText, off_4F6870);
      }
      evt = 512;
      v8 = 3;
      v9 = 101;
      v10 = gText;
      heroWindow::BroadcastMessage(thisa->combatEndWindow, (tag_message *)&evt);
      combatManager::ShowDeadArmies(thisa, thisa->combatEndWindow);
      if ( gbRemoteOn && !gbThisNetGotAdventureControl )
        giDialogTimeout = KBTickCount() + 15000;
      heroWindowManager::DoDialog(
        gpWindowManager,
        thisa->combatEndWindow,
        (int (__fastcall *)(tag_message *))WinCombatHandler,
        0);
      giDialogTimeout = 0;
      operator delete(thisa->combatEndWindow);
      if ( thisa->heroes[1 - side] )
        hero::ApplyBattleLossTemps(thisa->heroes[1 - side]);
    }
    else
    {
      if ( thisa->heroes[side] )
        hero::ApplyBattleWinTemps(thisa->heroes[side]);
      if ( thisa->heroes[1 - side] )
        hero::ApplyBattleLossTemps(thisa->heroes[1 - side]);
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 30);
      combatManager::DoLoseWindow(thisa);
    }
  }
  gMapX = gpAdvManager->viewX;
  result = gpAdvManager->viewY;
  gMapY = gpAdvManager->viewY;
  return result;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F7494: using guessed type int gbRemoteOn;
// 523450: using guessed type char gbCombatSurrender;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 5240A8: using guessed type int gpSoundManager;
// 524210: using guessed type char gbRetreatWin;
// 524214: using guessed type int gMapX;
// 524218: using guessed type int gMapY;
// 524C6C: using guessed type int bSkeletonsShown;
// 524C70: using guessed type int gbWhichAnimationPlaying;
// 524C88: using guessed type int giWinCmbtFrame;
// 524C8C: using guessed type int iCurTransferArtifact;
// 524C90: using guessed type int dword_524C90;
// 524C9C: using guessed type int iMaxTransferArtifacts;

//----- (00440290) --------------------------------------------------------
void __thiscall combatManager::DoLoseWindow(combatManager *this)
{
  heroWindow *dialog; // [sp+18h] [bp-5Ch]@16
  char v3; // [sp+1Ch] [bp-58h]@12
  tag_message evt; // [sp+50h] [bp-24h]@33
  int v5; // [sp+6Ch] [bp-8h]@1
  bool side; // [sp+70h] [bp-4h]@3

  v5 = 0;
  if ( this->playerID[0] == giCurPlayer && gbThisNetHumanPlayer[this->playerID[0]] )
  {
    side = 0;
  }
  else if ( this->playerID[1] == giCurPlayer && gbThisNetHumanPlayer[this->playerID[1]] )
  {
    side = 1;
  }
  else
  {
    side = this->playerID[0] == -1 || !gbThisNetHumanPlayer[this->playerID[0]];
  }
  dword_524C90 = 1;
  if ( gbCombatSurrender )
  {
    sprintf(&v3, "cmbtsurr.icn");
    gbWhichAnimationPlaying = 4;
  }
  else if ( gbRetreatWin )
  {
    sprintf(&v3, "cmbtfle1.icn");
    gbWhichAnimationPlaying = 3;
  }
  else
  {
    sprintf(&v3, "cmbtlos1.icn");
    gbWhichAnimationPlaying = 2;
  }
  dialog = (heroWindow *)operator new(68);
  if ( dialog )
    this->combatEndWindow = heroWindow::heroWindow(dialog, 143, 10, "wincmbt.bin");
  else
    this->combatEndWindow = 0;
  if ( !this->combatEndWindow )
    MemError();
  if ( this->heroes[side] )
  {
    if ( gbCombatSurrender )
    {
      sprintf(gText, off_4F6878, this->heroes[side]->name);
    }
    else if ( gbRetreatWin )
    {
      sprintf(gText, off_4F687C, this->heroes[side]->name);
    }
    else
    {
      sprintf(gText, off_4F6880, this->heroes[side]->name);
    }
  }
  else if ( gbCombatSurrender )
  {
    sprintf(gText, off_4F6884);
  }
  else if ( gbRetreatWin )
  {
    sprintf(gText, off_4F6888);
  }
  else
  {
    sprintf(gText, off_4F688C);
  }
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_ICON;
  evt.yCoordOrFieldID = 200;
  evt.payload = &v3;
  heroWindow::BroadcastMessage(this->combatEndWindow, &evt);
  evt.yCoordOrFieldID = 201;
  evt.payload = &v3;
  heroWindow::BroadcastMessage(this->combatEndWindow, &evt);
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
  evt.yCoordOrFieldID = 101;
  evt.payload = gText;
  heroWindow::BroadcastMessage(this->combatEndWindow, &evt);
  combatManager::ShowDeadArmies(this, this->combatEndWindow);
  if ( gbRemoteOn && !gbThisNetGotAdventureControl )
    giDialogTimeout = KBTickCount() + 15000;
  heroWindowManager::DoDialog(
    gpWindowManager,
    this->combatEndWindow,
    (int (__fastcall *)(tag_message *))WinCombatHandler,
    0);
  giDialogTimeout = 0;
  operator delete(this->combatEndWindow);
  this->combatEndWindow = NULL;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F7494: using guessed type int gbRemoteOn;
// 523450: using guessed type char gbCombatSurrender;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 524210: using guessed type char gbRetreatWin;
// 524C70: using guessed type int gbWhichAnimationPlaying;
// 524C90: using guessed type int dword_524C90;

//----- (00440650) --------------------------------------------------------
bool __thiscall combatManager::DoSurrender(combatManager *this)
{
  heroWindow *thisa; // [sp+2Ch] [bp-34h]@11
  int evt; // [sp+34h] [bp-2Ch]@16
  int v5; // [sp+38h] [bp-28h]@16
  int v6; // [sp+3Ch] [bp-24h]@16
  char *v7; // [sp+4Ch] [bp-14h]@16
  int i; // [sp+50h] [bp-10h]@1
  __int16 v9; // [sp+54h] [bp-Ch]@11
  __int16 v10; // [sp+58h] [bp-8h]@11
  int window; // [sp+5Ch] [bp-4h]@12

  giSurrenderCost = 0;
  for ( i = 0; i < 20; ++i )
  {
    if ( this->creatures[this->currentActionSide][i].creatureIdx >= 0 )
    {
      if ( this->creatures[this->currentActionSide][i].quantity > 0 )
        giSurrenderCost += this->creatures[this->currentActionSide][i].quantity
                         * gMonsterDatabase[this->creatures[this->currentActionSide][i].creatureIdx].cost;
    }
  }
  if ( hero::HasArtifact(this->heroes[this->currentActionSide], ARTIFACT_STATESMANS_QUILL) )
    giSurrenderCost = (signed __int64)((double)giSurrenderCost * 0.1);
  else
    giSurrenderCost = (signed __int64)((double)giSurrenderCost * 0.5);
  giSurrenderCost = (signed __int64)((1.0 - (double)this->heroes[this->currentActionSide]->secondarySkillLevel[4] * 0.2)
                                   * (double)giSurrenderCost);
  v9 = 1;
  v10 = 30;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    window = (int)heroWindow::heroWindow(thisa, 74, 80, "surrendr.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  evt = 512;
  v5 = 9;
  v6 = 1;
  sprintf(gText, "port%04d.icn", this->heroes[1 - this->currentActionSide]->heroID);
  v7 = gText;
  heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  if ( this->heroes[1 - this->currentActionSide]->isCaptain )
    v5 = 5;
  else
    v5 = 6;
  v6 = 30;
  v7 = (char *)4;
  heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  if ( this->heroes[1 - this->currentActionSide]->isCaptain )
  {
    v5 = 4;
    if ( this->playerID[1 - this->currentActionSide] == -1 )
      v7 = (char *)6;
    else
      v7 = (char *)gpGame->players[this->playerID[1 - this->currentActionSide]].color;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  v7 = gText;
  v5 = 3;
  v6 = 2;
  sprintf(
    gText,
    "%s states:\n\n\"I will accept your surrender and grant you and your troops safe passage for the price of %d gold.\"",
    this->heroes[1 - this->currentActionSide]->name,
    giSurrenderCost);
  heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  heroWindowManager::DoDialog(gpWindowManager, (heroWindow *)window, TrueFalseDialogHandler, 0);
  operator delete((void *)window);
  return gpWindowManager->buttonPressedCode == 30722;
}
// 524CA0: using guessed type int giSurrenderCost;

//----- (00440A90) --------------------------------------------------------
void __thiscall combatManager::CheckChangeSelector(combatManager *this)
{
  int v1; // edx@2
  combatManager *thisa; // [sp+Ch] [bp-8h]@1
  army *stack; // [sp+10h] [bp-4h]@2

  thisa = this;
  if ( !gbNoShowCombat )
  {
    v1 = this->activeStack;
    stack = &this->creatures[this->activeStackOwner][v1];
    if ( !this->field_F2B7 || this->creatures[this->activeStackOwner][v1].occupiedHex != this->field_F2BB )
    {
      combatManager::UpdateGrid(this, v1, 0, 1);
      giNewMonsterCycleFrame = 7;
      thisa->field_F2BB = stack->occupiedHex;
      thisa->field_F2B7 = 1;
      combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
    }
    combatManager::SetupSmallView(thisa);
  }
}
// 4F1CB8: using guessed type int giNewMonsterCycleFrame;
// 518CFC: using guessed type int gbNoShowCombat;

//----- (00440B70) --------------------------------------------------------
void __thiscall combatManager::CheckCastleAttack(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( this->isCastleBattle && !this->currentActionSide )
  {
    while ( thisa->timesCatapultMustFire[thisa->currentActionSide] > 0 )
    {
      combatManager::CatAttack(thisa, thisa->currentActionSide);
      --thisa->timesCatapultMustFire[thisa->currentActionSide];
    }
  }
  if ( thisa->isCastleBattle && thisa->currentActionSide == 1 )
  {
    while ( thisa->timesGarrisonMustFire[thisa->currentActionSide] > 0 )
    {
      combatManager::KeepAttack(thisa, 0);
      combatManager::KeepAttack(thisa, 1);
      combatManager::KeepAttack(thisa, 2);
      --thisa->timesGarrisonMustFire[thisa->currentActionSide];
    }
  }
}

//----- (00440C60) --------------------------------------------------------
void __thiscall combatManager::CheckGetAIMove(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-8h]@1
  int a3; // [sp+10h] [bp-4h]@1

  thisa = this;
  a3 = combatManager::AICheckRetreat((int)this);
  if ( *(&thisa->field_353F + thisa->currentActionSide)
    || thisa->playerID[thisa->currentActionSide] != -1
    && gbThisNetHumanPlayer[thisa->playerID[thisa->currentActionSide]]
    && !*(_DWORD *)&autoCombatUseSpells
    || !combatManager::DoSpellAI(thisa, thisa->currentActionSide, a3) )
  {
    if ( combatManager::AICheckRetreat((int)thisa) )
      giNextAction = 4;
    else
      combatManager::DoCompAI(thisa, thisa->currentActionSide);
  }
}

//----- (00440D40) --------------------------------------------------------
void __thiscall combatManager::GetControl(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  this->field_F2C3 = -1;
  this->field_F2CB = -99;
  this->field_F2CB = -99;
  if ( gpCombatManager->ready == 1 )
    mouseManager::SetPointer(gpMouseManager, 6);
  combatManager::CheckChangeSelector(thisa);
  if ( gbRemoteOn
    && *(_QWORD *)&thisa->playerID[0] >= 0i64
    && gbHumanPlayer[thisa->playerID[1]]
    && (gbHumanPlayer[thisa->playerID[0]] || !gbHumanPlayer[thisa->playerID[0]] && thisa->playerID[1]) )
    gbThisNetHasControl = thisa->playerID[thisa->currentActionSide] == -1
                       || !gbHumanPlayer[thisa->playerID[thisa->currentActionSide]]
                       || gbThisNetHumanPlayer[thisa->playerID[thisa->currentActionSide]];
  else
    gbThisNetHasControl = 1;
  *(_DWORD *)&thisa->_15[104] = -1;
  combatManager::SetupSmallView(thisa);
  combatManager::ResetMouse(thisa);
}
// 4F7494: using guessed type int gbRemoteOn;
// 524C60: using guessed type int gbThisNetHasControl;

//----- (00440ED0) --------------------------------------------------------
void __thiscall combatManager::ResetMouse(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-28h]@1
  tag_message a2; // [sp+10h] [bp-24h]@5
  int y; // [sp+2Ch] [bp-8h]@5
  int x; // [sp+30h] [bp-4h]@5

  thisa = this;
  if ( !gbNoShowCombat )
  {
    if ( gbThisNetHasControl
      && this->playerID[this->currentActionSide] >= 0
      && gbHumanPlayer[this->playerID[this->currentActionSide]] )
    {
      this->field_F2C3 = -1;
      combatManager::ClearCombatMessages(this, 0);
      mouseManager::MouseCoords(&x, &y);
      a2.eventCode = INPUT_MOUSEMOVE_EVENT_CODE;
      a2.altXCoord = x;
      a2.xCoordOrKeycode = x;
      a2.altYCoord = y;
      a2.yCoordOrFieldID = y;
      combatManager::ProcessCombatMsg(thisa, &a2);
    }
    else
    {
      mouseManager::SetPointer(gpMouseManager, 6);
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;
// 524C60: using guessed type int gbThisNetHasControl;

//----- (00440FB0) --------------------------------------------------------
int __thiscall combatManager::ProcessNextAction(combatManager *this, tag_message *a2)
{
  int v2; // edx@6
  int v3; // ecx@32
  int v4; // ecx@32
  combatManager *thisa; // [sp+10h] [bp-28h]@1
  int v7; // [sp+14h] [bp-24h]@15
  Spell v8; // [sp+18h] [bp-20h]@15
  int v9; // [sp+1Ch] [bp-1Ch]@15
  int v10; // [sp+20h] [bp-18h]@15
  int v11; // [sp+24h] [bp-14h]@15
  int v12; // [sp+28h] [bp-10h]@17
  int v13; // [sp+2Ch] [bp-Ch]@1
  int v14; // [sp+30h] [bp-8h]@1
  army *v15; // [sp+34h] [bp-4h]@17

  thisa = this;
  combatManager::ClearCombatMessages(this, 0);
  v13 = 1;
  v14 = 0;
  gbProcessingCombatAction = 1;
  if ( *(_DWORD *)&thisa->_15[100] != -1 || *(_DWORD *)&thisa->_15[104] != -1 )
  {
    *(_DWORD *)&thisa->_15[104] = -1;
    *(_DWORD *)&thisa->_15[100] = *(_DWORD *)&thisa->_15[104];
    v14 = 1;
  }
  if ( giNextAction )
    LogInt(
      (int)"Process Act",
      giNextAction,
      giNextActionGridIndex,
      giNextActionGridIndex2,
      giNextActionExtra,
      thisa->activeStackOwner,
      thisa->activeStack,
      thisa->creatures[thisa->activeStackOwner][thisa->activeStack].occupiedHex);
  mouseManager::SetPointer(gpMouseManager, 6);
  combatManager::UpdateMouseGrid(thisa, -1, 1);
  memset(thisa->field_49F, 0, 0x75u);
  if ( combatManager::UpdateGrid(thisa, v2, 0, 0) )
    v14 = 1;
  if ( v14 )
    combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
  if ( gbThisNetHasControl )
  {
    if ( gbRemoteOn )
    {
      if ( *(_QWORD *)&thisa->playerID[0] >= 0i64 )
      {
        if ( gbHumanPlayer[thisa->playerID[1]] )
        {
          if ( gbHumanPlayer[thisa->playerID[0]] )
          {
            v7 = giNextAction;
            v8 = giNextActionExtra;
            v9 = giNextActionGridIndex;
            v10 = giNextActionGridIndex2;
            LogInt(
              (int)"About to T",
              *(&iCombatControlNetPos + 1 - thisa->currentActionSide),
              -999,
              -999,
              -999,
              -999,
              -999,
              -999);
            v11 = TransmitRemoteData(&v7, *(&iCombatControlNetPos + 1 - thisa->currentActionSide), 0x10u, 23, 1, 1, -1);
            LogStr("Post T");
            if ( !v11 )
              ShutDown(0);
          }
        }
      }
    }
  }
  v15 = &thisa->creatures[thisa->activeStackOwner][thisa->activeStack];
  v12 = 0;
  if ( !combatManager::CheckWin(thisa, a2) )
  {
    switch ( giNextAction )
    {
      case 1:
        combatManager::ResetCyclingCreatures(thisa);
        combatManager::CastSpell(thisa, giNextActionExtra, giNextActionGridIndex, 0, giNextActionGridIndex2);
        if ( thisa->creatures[thisa->activeStackOwner][thisa->activeStack].quantity <= 0 )
          v12 = 1;
        combatManager::ResetCycleTimers(thisa);
        goto LABEL_36;
      case 2:
        combatManager::ResetCyclingCreatures(thisa);
        army::MoveAttack(v15, giNextActionGridIndex, 0);
        *(_DWORD *)&v15->creature.creature_flags |= MAYBE_NOT_LOST_TURN;
        if ( combatManager::CheckWin(thisa, a2) )
        {
          v13 = 2;
          break;
        }
        combatManager::CheckApplyGoodMorale(thisa, thisa->activeStackOwner, thisa->activeStack);
        v12 = 1;
        combatManager::ResetCycleTimers(thisa);
        goto LABEL_36;
      case 6:
        combatManager::ResetCyclingCreatures(thisa);
        if ( giNextActionExtra != -1 && v15->occupiedHex != giNextActionExtra )
          army::MoveAttack(v15, giNextActionExtra, 1);
        army::MoveAttack(v15, giNextActionGridIndex, 0);
        *(_DWORD *)&v15->creature.creature_flags |= MAYBE_NOT_LOST_TURN;
        if ( combatManager::CheckWin(thisa, a2) )
        {
          v13 = 2;
        }
        else
        {
          combatManager::CheckApplyGoodMorale(thisa, thisa->activeStackOwner, thisa->activeStack);
          v12 = 1;
          combatManager::ResetCycleTimers(thisa);
LABEL_36:
          giNextAction = 0;
          if ( combatManager::CheckWin(thisa, a2) )
          {
            v13 = 2;
          }
          else
          {
            combatManager::TestRaiseDoor(thisa);
            if ( v12 && !combatManager::GetNextArmy(thisa, 1) )
            {
              combatManager::ResetRound(thisa);
              combatManager::GetNextArmy(thisa, 1);
            }
            combatManager::CheckChangeSelector(thisa);
          }
        }
        break;
      case 4:
        thisa->field_F377[thisa->currentActionSide] = 1;
        gbRetreatWin = 1;
        combatManager::ResetCycleTimers(thisa);
        goto LABEL_36;
      case 5:
        gbCombatSurrender = 1;
        gbRetreatWin = 1;
        thisa->field_351F[thisa->currentActionSide] = 1;
        v3 = thisa->playerID[thisa->currentActionSide];
        gpGame->players[v3].resources[6] -= giNextActionExtra;
        v4 = thisa->playerID[1 - thisa->currentActionSide];
        gpGame->players[v4].resources[6] += giNextActionExtra;
        combatManager::ResetCycleTimers(thisa);
        goto LABEL_36;
      case 3:
        *(_DWORD *)&v15->creature.creature_flags |= MAYBE_NOT_LOST_TURN;
        v12 = 1;
        goto LABEL_36;
      case 7:
        *(_DWORD *)&v15->creature.creature_flags |= 0x1000u;
        v12 = 1;
        goto LABEL_36;
      case 0:
        goto LABEL_36;
    }
  }
  gbProcessingCombatAction = 0;
  combatManager::ResetMouse(thisa);
  return v13;
}
// 4F31B0: using guessed type int gbProcessingCombatAction;
// 4F7494: using guessed type int gbRemoteOn;
// 523450: using guessed type char gbCombatSurrender;
// 524210: using guessed type char gbRetreatWin;
// 524C60: using guessed type int gbThisNetHasControl;

//----- (00441610) --------------------------------------------------------
void __thiscall combatManager::ResetCyclingCreatures(combatManager *this)
{
  char *v1; // eax@17
  combatManager *thisa; // [sp+Ch] [bp-18h]@1
  signed int i; // [sp+10h] [bp-14h]@1
  signed int k; // [sp+10h] [bp-14h]@12
  int j; // [sp+18h] [bp-Ch]@3
  int l; // [sp+18h] [bp-Ch]@14
  int v7; // [sp+1Ch] [bp-8h]@1

  thisa = this;
  v7 = 0;
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
    {
      if ( !(gpCombatManager->creatures[i][j].creature.creature_flags & DEAD)
        && gpCombatManager->creatures[i][j].animationType >= 8 )
      {
        if ( gpCombatManager->creatures[i][j].animationType <= 12 )
        {
          ++v7;
          ++gpCombatManager->limitCreature[i][j];
        }
      }
    }
  }
  if ( v7 )
  {
    combatManager::DrawFrame(gpCombatManager, 0, 1, 1, 1, 75, 1, 1);
    for ( k = 0; k < 2; ++k )
    {
      for ( l = 0; gpCombatManager->numCreatures[k] > l; ++l )
      {
        if ( !(gpCombatManager->creatures[k][l].creature.creature_flags & DEAD) )
        {
          v1 = (char *)gpCombatManager + 24234 * k + 1154 * l;
          *(_DWORD *)(v1 + 13773) = 7;
          *(_DWORD *)(v1 + 13777) = 0;
          *(_DWORD *)(v1 + 13885) = KBTickCount();
        }
      }
    }
    thisa->lastHeroAnimationCompleteTime[0] = KBTickCount();
    thisa->lastHeroAnimationCompleteTime[1] = KBTickCount();
    combatManager::DrawFrame(gpCombatManager, 1, 1, 0, 0, 75, 1, 1);
  }
}

//----- (00441850) --------------------------------------------------------
void __thiscall combatManager::ResetCycleTimers(combatManager *this)
{
  signed int i; // [sp+10h] [bp-10h]@1
  int v3; // [sp+14h] [bp-Ch]@1
  army *v4; // [sp+18h] [bp-8h]@5
  int j; // [sp+1Ch] [bp-4h]@3

  v3 = KBTickCount();
  this->lastHeroAnimationCompleteTime[0] = KBTickCount();
  this->lastHeroAnimationCompleteTime[1] = KBTickCount();
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
    {
      v4 = &gpCombatManager->creatures[i][j];
      gpCombatManager->creatures[i][j].baseFidgetTime = v3;
      if ( v4->frameInfo.maxFidgetDelay > 51 )
        v4->baseFidgetTime -= Random(50, v4->frameInfo.maxFidgetDelay);
    }
  }
}

//----- (00441950) --------------------------------------------------------
bool __fastcall InCombatArea(signed int x, signed int y)
{
  return x >= 0 && x < 640 && y >= 0 && y < 443;
}

//----- (004419B0) --------------------------------------------------------
signed __int64 __thiscall combatManager::CycleCombatScreen(combatManager *this)
{
  double v1; // st7@75
  int v2; // ST34_4@85
  signed __int64 result; // qax@97
  float v5; // [sp+24h] [bp-4Ch]@73
  float v6; // [sp+28h] [bp-48h]@73
  signed int j; // [sp+2Ch] [bp-44h]@8
  signed int k; // [sp+2Ch] [bp-44h]@67
  char creatureShouldDoSomeAnimation[2][20]; // [sp+30h] [bp-40h]@8
  int l; // [sp+58h] [bp-18h]@73
  int i; // [sp+5Ch] [bp-14h]@1
  int v12; // [sp+60h] [bp-10h]@1
  army *creat; // [sp+64h] [bp-Ch]@1
  int nextHeroAnimation[2]; // [sp+68h] [bp-8h]@26

  combatManager::CheckUpdateCombatMessages(this);
  creat = 0;
  v12 = 0;
  combatManager::ResetLimitCreature(gpCombatManager);
  for ( i = 0; i < 2; ++i )
  {
    if ( this->heroFlagIcon[i] )
    {
      if ( this->heroes[i] )
        this->heroFlagIconIdx[i] = (this->heroFlagIconIdx[i] + 1) % 5;
      ++this->field_F427[i];
    }
  }
  memset(creatureShouldDoSomeAnimation, 0, 40u);
  for ( j = 0; j < 2; ++j )
  {
    for ( i = 0; gpCombatManager->numCreatures[j] > i; ++i )
    {
      creat = &gpCombatManager->creatures[j][i];
      if ( !(gpCombatManager->creatures[j][i].creature.creature_flags & DEAD)
        && !creat->effectStrengths[6]
        && !creat->effectStrengths[2]
        && !creat->effectStrengths[11]
        && (creat->animationType >= 8 && creat->animationType <= 12
         || creat->animationType == 7 && creat->baseFidgetTime + creat->frameInfo.maxFidgetDelay < KBTickCount()) )
      {
        ++v12;
        ++creatureShouldDoSomeAnimation[j][i];
        ++this->limitCreature[j][i];
      }
    }
  }
  for ( i = 0; i < 2; ++i )
  {
    nextHeroAnimation[i] = -1;
    if ( this->heroIcon[i] )
    {
      if ( this->heroAnimationType[i] != 1
        && this->heroAnimationType[i] != 2
        && this->heroAnimationType[i] != 9
        && this->heroAnimationType[i] != 10
        && this->heroAnimationType[i] != 11 )
      {
        if ( this->heroAnimationType[i] || this->field_33A1[i] || !this->shouldDoHeroFidget1[i] )
        {
          if ( this->heroAnimationType[i] || this->field_33A3[i] || !this->shouldDoHeroFidget2[i] )
          {
            if ( !this->heroAnimationType[i] && this->lastHeroAnimationCompleteTime[i] + 4500 < KBTickCount() )
            {
              if ( sCmbtHero[this->heroType[i]].numFidgets <= 1 )
                nextHeroAnimation[i] = 9;
              else
                nextHeroAnimation[i] = Random(0, sCmbtHero[this->heroType[i]].numFidgets - 1) + 9;
              this->field_F41F[i] = 1;
            }
          }
          else if ( this->playerID[this->currentActionSide] != -1 && gbThisNetHumanPlayer[this->playerID[this->currentActionSide]] )
          {
            this->shouldDoHeroFidget2[i] = 0;
            this->shouldDoHeroFidget1[i] = this->shouldDoHeroFidget2[i];
            this->field_33A3[i] = 1;
            if ( sCmbtHero[this->heroType[i]].animationLength[2] > 0 )
            {
              nextHeroAnimation[i] = 2;
              this->field_F41F[i] = 1;
            }
          }
          else
          {
            this->shouldDoHeroFidget2[i] = 0;
            this->shouldDoHeroFidget1[i] = this->shouldDoHeroFidget2[i];
          }
        }
        else if ( this->playerID[this->currentActionSide] != -1 && gbThisNetHumanPlayer[this->playerID[this->currentActionSide]] )
        {
          this->shouldDoHeroFidget2[i] = 0;
          this->shouldDoHeroFidget1[i] = this->shouldDoHeroFidget2[i];
          this->field_33A1[i] = 1;
          if ( sCmbtHero[this->heroType[i]].animationLength[1] > 0 )
          {
            nextHeroAnimation[i] = 1;
            this->field_F41F[i] = 1;
          }
        }
        else
        {
          this->shouldDoHeroFidget2[i] = 0;
          this->shouldDoHeroFidget1[i] = this->shouldDoHeroFidget2[i];
        }
      }
      else
      {
        this->field_F41F[i] = 1;
      }
    }
  }
  if ( this->heroIcon[0] )
    this->field_F41F[0] = 1;
  if ( this->heroIcon[1] )
    this->field_F41F[1] = 1;
  if ( v12 || this->field_F41F[0] || this->field_F41F[1] || this->field_F427[0] || this->field_F427[1] )
  {
    combatManager::DrawFrame(gpCombatManager, 0, 1, 1, 1, 75, 1, 1);
    for ( k = 0; k < 2; ++k )
    {
      for ( i = 0; gpCombatManager->numCreatures[k] > i; ++i )
      {
        creat = &gpCombatManager->creatures[k][i];
        if ( creatureShouldDoSomeAnimation[k][i] )
        {
          if ( creat->animationType == ANIMATION_TYPE_STANDING )
          {
            v5 = (double)Random(1, 100) / 100.0;
            v6 = 0.0;
            creat->curFidget = creat->frameInfo.numberOfFidgets - 1;
            for ( l = 0; creat->frameInfo.numberOfFidgets - 1 > l; ++l )
            {
              v1 = creat->frameInfo.fidgetProbabilities[l] + v6;
              v6 = v1;
              if ( v1 > v5 )
              {
                creat->curFidget = l;
                l = 99;
              }
            }
            creat->animationType = creat->curFidget + 8;
            creat->animationFrame = 0;
          }
          else
          {
            ++creat->animationFrame;
            if ( !creat->frameInfo.maxFidgetDelay && creat->frameInfo.numberOfFidgets == 1 && Random(0, 100) < 8 )
              --creat->animationFrame;
            if ( creat->frameInfo.animationLengths[creat->curFidget + 8] <= creat->animationFrame )
            {
              creat->animationType = 7;
              creat->animationFrame = 0;
              creat->baseFidgetTime = KBTickCount();
              if ( creat->frameInfo.maxFidgetDelay > 0 )
              {
                v2 = Random(0, creat->frameInfo.maxFidgetDelay);
                creat->baseFidgetTime = (signed __int64)((double)v2 * 0.5
                                                       - (double)creat->frameInfo.maxFidgetDelay * 0.25
                                                       + (double)creat->baseFidgetTime);
              }
            }
          }
        }
      }
    }
    for ( i = 0; i < 2; ++i )
    {
      if ( this->field_F41F[i] )
      {
        if ( nextHeroAnimation[i] == -1 )
        {
          ++this->heroAnimationFrameCount[i];
          if ( sCmbtHero[this->heroType[i]].animationLength[this->heroAnimationType[i]] <= this->heroAnimationFrameCount[i] )
          {
            this->heroAnimationType[i] = 0;
            this->heroAnimationFrameCount[i] = 0;
            this->lastHeroAnimationCompleteTime[i] = KBTickCount();
          }
        }
        else
        {
          this->heroAnimationType[i] = nextHeroAnimation[i];
          this->heroAnimationFrameCount[i] = 0;
        }
      }
    }
    combatManager::DrawFrame(this, 1, 1, 0, 0, 75, 1, 1);
  }
  result = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 150.0);
  nextCombatAnimationTime = result;
  return result;
}
// 524C08: using guessed type int nextCombatAnimationTime;
// 4419B0: using guessed type int nextHeroAnimation[2];

//----- (00442380) --------------------------------------------------------
void __thiscall combatManager::SetCombatViewArmySmallLevel(combatManager *this, int level)
{
  *(_DWORD *)&combatArmyInfoLevel = level;
  combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
  WritePrefs();
}

//----- (004423C0) --------------------------------------------------------
void __thiscall combatManager::SetCombatGrid(combatManager *this, int a2, int a3, LONG a4)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( *(_DWORD *)&showCombatGrid != a2 || *(_DWORD *)&showCombatMouseHex != a3 || combatShadeLevel != a4 )
  {
    combatManager::UpdateMouseGrid(this, -1, 0);
    *(_DWORD *)&showCombatGrid = a2;
    *(_DWORD *)&showCombatMouseHex = a3;
    combatShadeLevel = a4;
    thisa->zeroedAfterAnimatingDeathAndHolySpells = 0;
    combatManager::SetupGridForArmy(thisa, &thisa->creatures[thisa->activeStackOwner][thisa->activeStack]);
    combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
    combatManager::ResetMouse(thisa);
    WritePrefs();
  }
}

//----- (004424B0) --------------------------------------------------------
void __thiscall combatManager::AddArmy(combatManager *this, int side, int creat, int num, int hex, int attrs, int a7)
{
  army *creature; // ST38_4@17
  int v8; // edx@20
  int newStackIDx; // [sp+10h] [bp-10h]@1
  spellpower_offset i; // [sp+14h] [bp-Ch]@1
  signed int replacingStack; // [sp+18h] [bp-8h]@1

  newStackIDx = -1;
  replacingStack = 0;
  for ( i = 0; i < MAX_STACKS; ++i )
  {
    if ( this->creatures[side][i].creatureIdx == -1 )
    {
      newStackIDx = i;
      break;
    }
    if ( !this->creatures[side][i].quantity
      && this->creatures[side][i].creature.creature_flags & DEAD
      && (HIBYTE(this->creatures[side][i].creature.creature_flags) & ATTR_MIRROR_IMAGE
       || this->creatures[side][i].creatureIdx == CREATURE_EARTH_ELEMENTAL
       || this->creatures[side][i].creatureIdx == CREATURE_AIR_ELEMENTAL
       || this->creatures[side][i].creatureIdx == CREATURE_FIRE_ELEMENTAL
       || this->creatures[side][i].creatureIdx == CREATURE_WATER_ELEMENTAL) )
    {
      newStackIDx = i;
      replacingStack = 1;
      break;
    }
  }
  if ( newStackIDx != -1 && this->combatGrid[hex].unitOwner == -1 )
  {
    creature = &this->creatures[side][newStackIDx];
    army::Init(&this->creatures[side][newStackIDx], creat, num, side, newStackIDx, hex, -1);
    army::LoadResources(creature);
    *(_DWORD *)&creature->creature.creature_flags |= attrs;
    if ( !replacingStack )
      ++this->numCreatures[side];
    if ( a7 )
    {
      combatManager::ResetLimitCreature(this);
      ++this->limitCreature[side][newStackIDx];
      combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
      heroWindowManager::SaveFizzleSource(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      combatManager::UpdateGrid(this, v8, 0, 1);
      combatManager::DrawFrame(this, 0, 0, 0, 0, 75, 1, 1);
      heroWindowManager::FizzleForward(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1,
        75,
        0,
        0);
    }
  }
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00442860) --------------------------------------------------------
void __thiscall combatManager::SetupSmallView(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-Ch]@1

  thisa = this;
  if ( *(_DWORD *)&this->_15[104] == -1 && this->field_F557 != -1 )
    combatManager::DrawSmallView(this, 1, 1);
  if ( gbThisNetHasControl
    && thisa->playerID[thisa->currentActionSide] != -1
    && gbHumanPlayer[thisa->playerID[thisa->currentActionSide]] )
  {
    if ( *(_DWORD *)&thisa->_15[100] != thisa->currentActionSide || *(_DWORD *)&thisa->_15[108] != thisa->activeStack )
    {
      if ( *(_DWORD *)&thisa->_15[100] != -1 && *(_DWORD *)&thisa->_15[100] != thisa->currentActionSide )
      {
        if ( thisa->field_F553 != -1 )
        {
          *(_DWORD *)&thisa->_15[100] = -1;
          combatManager::DrawSmallView(thisa, 0, 1);
        }
      }
      *(_DWORD *)&thisa->_15[100] = thisa->currentActionSide;
      *(_DWORD *)&thisa->_15[108] = thisa->activeStack;
      combatManager::DrawSmallView(thisa, 0, 1);
    }
  }
  else
  {
    *(_DWORD *)&thisa->_15[100] = -1;
    if ( thisa->field_F553 != -1 )
      combatManager::DrawSmallView(thisa, 0, 1);
  }
}
// 524C60: using guessed type int gbThisNetHasControl;

//----- (004429D0) --------------------------------------------------------
heroWindow *__thiscall combatManager::ViewBallista(combatManager *this, unsigned int a2)
{
  char buf[300]; // [sp+10h] [bp-134h]@1
  int attack; // [sp+13Ch] [bp-8h]@1
  int numArchers; // [sp+140h] [bp-4h]@1

  town::CalcNumLevelArchers(this->castles[1], &numArchers, &attack);
  sprintf(gText, "Ballista");
  strcpy(buf, byte_50E800);
  if ( this->ballistaDestroyed )
  {
    sprintf(buf, "\n\nThe %s is destroyed.", "Ballista");
  }
  else if ( attack <= 0 )
  {
    sprintf(buf, "\n\nThe %s fires with the strength of %d Archers.", "Ballista", numArchers);
  }
  else
  {
    sprintf(
      buf,
      "\n\nThe %s fires with the strength of %d Archers, each with a +%d bonus to their attack skill.",
      "Ballista",
      numArchers,
      attack);
  }
  strcat(gText, buf);
  strcpy(buf, byte_50E8D0);
  if ( BYTE1(this->castles[1]->buildingsBuiltFlags) & 1 )
  {
    if ( this->turretStatus[0] == 2 )
    {
      sprintf(buf, "\n\nThe %s is destroyed.", "Left Turret");
    }
    else if ( this->turretStatus[0] == 1 )
    {
      if ( attack <= 0 )
        sprintf(buf, "\n\nThe %s fires with the strength of %d Archers.", "Left Turret", numArchers / 2);
      else
        sprintf(
          buf,
          "\n\nThe %s fires with the strength of %d Archers, each with a +%d bonus to their attack skill.",
          "Left Turret",
          numArchers / 2,
          attack);
    }
    strcat(gText, buf);
  }
  if ( BYTE1(this->castles[1]->buildingsBuiltFlags) & 2 )
  {
    strcpy(buf, byte_50E9A0);
    if ( this->turretStatus[3] == 2 )
    {
      sprintf(buf, "\n\nThe %s is destroyed.", "Right Turret");
    }
    else if ( this->turretStatus[3] == 1 )
    {
      if ( attack <= 0 )
        sprintf(buf, "\n\nThe %s fires with the strength of %d Archers.", "Right Turret", numArchers / 2);
      else
        sprintf(
          buf,
          "\n\nThe %s fires with the strength of %d Archers, each with a +%d bonus to their attack skill.",
          "Right Turret",
          numArchers / 2,
          attack);
    }
    strcat(gText, buf);
  }
  return NormalDialog(gText, a2 < 1 ? 1 : 4, -1, -1, -1, 0, -1, 0, -1, 0);
}

//----- (00442CB0) --------------------------------------------------------
advManager *__thiscall advManager::advManager(advManager *this)
{
  advManager *thisa; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1
  signed int j; // [sp+10h] [bp-4h]@4
  signed int k; // [sp+10h] [bp-4h]@7
  signed int l; // [sp+10h] [bp-4h]@10
  signed int m; // [sp+10h] [bp-4h]@13

  thisa = this;
  baseManager::baseManager((baseManager *)this);
  thisa->vtable = (managerVtable *)&advManager::_vftable_;
  thisa->groundTileset = 0;
  thisa->radarIcon = 0;
  thisa->viewX = 0;
  thisa->viewY = 0;
  thisa->field_1F6 = 0;
  thisa->field_1FA = 0;
  thisa->field_1FE = 0;
  thisa->field_202 = 0;
  thisa->field_206 = 0;
  thisa->field_36 = -1;
  thisa->field_272 = 0;
  thisa->identifyCast = 0;
  thisa->field_276 = 1;
  thisa->field_BA = 0;
  for ( i = 0; i < 64; ++i )
    thisa->field_CE[i] = 0;
  for ( j = 0; j < 8; ++j )
    thisa->heroIcons[j] = 0;
  for ( k = 0; k < 6; ++k )
  {
    thisa->flagIcons1[k] = 0;
    thisa->flagIcons2[k] = 0;
  }
  for ( l = 0; l < 28; ++l )
    thisa->loopSamples[l] = 0;
  for ( m = 0; m < 9; ++m )
    thisa->walkSamples[m] = 0;
  thisa->radarIcon = 0;
  thisa->clopIcon = 0;
  thisa->boatShadowIcon = 0;
  thisa->shadowIcon = 0;
  thisa->groundTileset = 0;
  thisa->clofTileset = 0;
  thisa->stonTileset = 0;
  thisa->adventureScreen = 0;
  thisa->sizeOfSomethingMapRelated = 0;
  thisa->heroMobilized = 0;
  thisa->field_2AA = 0;
  bShowIt = 1;
  thisa->field_2B2 = -99;
  thisa->field_2B6 = -99;
  thisa->field_20A = 0;
  thisa->field_20E = 4;
  thisa->field_212 = 11;
  thisa->field_216 = 13;
  thisa->map = game::GetWorldMapData(gpGame);
  gMapX = 0;
  gMapY = 0;
  thisa->field_286 = 0;
  thisa->field_28A = 0;
  thisa->field_28E = 0;
  return thisa;
}
// 4EA290: using guessed type int (__stdcall *advManager___vftable_)(int);
// 524214: using guessed type int gMapX;
// 524218: using guessed type int gMapY;
// 524C14: using guessed type int bShowIt;

//----- (00442FC0) --------------------------------------------------------
// Bringing up Hero Info or Kingdom Overview and switching back does not call this to be called. Towns and battles do, though.
int __thiscall advManager::Open(advManager *this, int idx)
{
  int v2; // ST48_4@100
  int v3; // ST44_4@100
  iconWidget *v6; // [sp+10h] [bp-1Ch]@15
  iconWidget *thisb; // [sp+14h] [bp-18h]@10
  heroWindow *window; // [sp+18h] [bp-14h]@5
  signed int i; // [sp+24h] [bp-8h]@1
  signed int j; // [sp+24h] [bp-8h]@35
  signed int k; // [sp+24h] [bp-8h]@89
  signed int l; // [sp+24h] [bp-8h]@92
  int v13; // [sp+28h] [bp-4h]@98

  iCurBottomView = 0;
  this->field_37A = 0;
  bShowIt = 0;
  this->field_BA = 0;
  for ( i = 0; i < 12; ++i )
  {
    this->someComponents[0][i] = 0;
    this->someComponents[1][i] = 0;
  }
  if ( !this->adventureScreen )
  {
    window = (heroWindow *)operator new(68);
    if ( window )
      this->adventureScreen = heroWindow::heroWindow(window, 0, 0, "adv_wind.bin");
    else
      this->adventureScreen = 0;
    if ( !this->adventureScreen )
      MemError();
    thisb = (iconWidget *)operator new(45);
    if ( thisb )
      this->heroScrollbarKnob = iconWidget::iconWidget(thisb, 540, 195, 8, 17, "scroll.icn", 4, 0, 26, 16, 1);
    else
      this->heroScrollbarKnob = 0;
    if ( !this->heroScrollbarKnob )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, (widget *)this->heroScrollbarKnob, -1);
    v6 = (iconWidget *)operator new(45);
    if ( v6 )
      this->castleScrollbarKnob = iconWidget::iconWidget(v6, 612, 195, 8, 17, "scroll.icn", 4, 0, 27, 16, 1);
    else
      this->castleScrollbarKnob = 0;
    if ( !this->castleScrollbarKnob )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, (widget *)this->castleScrollbarKnob, -1);
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] )
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  else
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 1, -999);
  if ( !this->sizeOfSomethingMapRelated )
  {
    this->sizeOfSomethingMapRelated = (int)operator new(2 * MAP_HEIGHT * MAP_WIDTH);
    if ( !this->sizeOfSomethingMapRelated )
      MemError();
  }
  this->field_A2 = 0;
  heroWindowManager::AddWindow(gpWindowManager, this->adventureScreen, 0, 1);
  if ( !this->groundTileset )
    this->groundTileset = resourceManager::GetTileset(gpResourceManager, "ground32.til");
  if ( !this->clofTileset )
    this->clofTileset = resourceManager::GetTileset(gpResourceManager, "clof32.til");
  if ( !this->stonTileset )
    this->stonTileset = resourceManager::GetTileset(gpResourceManager, "ston.til");
  if ( !this->clopIcon )
    this->clopIcon = resourceManager::GetIcon(gpResourceManager, "clop32.icn");
  for ( j = 0; j < 64; ++j )
  {
    if ( strlen(gTilesetFiles[j]) > 1 && !this->field_CE[j] && j != 21 )
    {
      if ( j != 38 )
        this->field_CE[j] = (int)resourceManager::GetIcon(gpResourceManager, gTilesetFiles[j]);
    }
  }
  if ( !this->heroIcons[0] )
    this->heroIcons[0] = resourceManager::GetIcon(gpResourceManager, "kngt32.icn");
  if ( !this->heroIcons[1] )
    this->heroIcons[1] = resourceManager::GetIcon(gpResourceManager, "barb32.icn");
  if ( !this->heroIcons[2] )
    this->heroIcons[2] = resourceManager::GetIcon(gpResourceManager, "sorc32.icn");
  if ( !this->heroIcons[3] )
    this->heroIcons[3] = resourceManager::GetIcon(gpResourceManager, "wrlk32.icn");
  if ( !this->heroIcons[4] )
    this->heroIcons[4] = resourceManager::GetIcon(gpResourceManager, "wzrd32.icn");
  if ( !this->heroIcons[5] )
    this->heroIcons[5] = resourceManager::GetIcon(gpResourceManager, "necr32.icn");
  if ( !this->boatIcon )
    this->boatIcon = resourceManager::GetIcon(gpResourceManager, "boat32.icn");
  if ( !this->frothIcon )
    this->frothIcon = resourceManager::GetIcon(gpResourceManager, "froth.icn");
  gbLoadingMonoIcon = 1;
  if ( !this->shadowIcon )
    this->shadowIcon = resourceManager::GetIcon(gpResourceManager, "shadow32.icn");
  if ( !this->boatShadowIcon )
    this->boatShadowIcon = resourceManager::GetIcon(gpResourceManager, "boatshad.icn");
  gbLoadingMonoIcon = 0;
  if ( !this->flagIcons1[0] )
    this->flagIcons1[0] = resourceManager::GetIcon(gpResourceManager, "b-flag32.icn");
  if ( !this->flagIcons1[1] )
    this->flagIcons1[1] = resourceManager::GetIcon(gpResourceManager, "g-flag32.icn");
  if ( !this->flagIcons1[2] )
    this->flagIcons1[2] = resourceManager::GetIcon(gpResourceManager, "r-flag32.icn");
  if ( !this->flagIcons1[3] )
    this->flagIcons1[3] = resourceManager::GetIcon(gpResourceManager, "y-flag32.icn");
  if ( !this->flagIcons1[4] )
    this->flagIcons1[4] = resourceManager::GetIcon(gpResourceManager, "o-flag32.icn");
  if ( !this->flagIcons1[5] )
    this->flagIcons1[5] = resourceManager::GetIcon(gpResourceManager, "p-flag32.icn");
  if ( !this->flagIcons2[0] )
    this->flagIcons2[0] = resourceManager::GetIcon(gpResourceManager, "b-bflg32.icn");
  if ( !this->flagIcons2[1] )
    this->flagIcons2[1] = resourceManager::GetIcon(gpResourceManager, "g-bflg32.icn");
  if ( !this->flagIcons2[2] )
    this->flagIcons2[2] = resourceManager::GetIcon(gpResourceManager, "r-bflg32.icn");
  if ( !this->flagIcons2[3] )
    this->flagIcons2[3] = resourceManager::GetIcon(gpResourceManager, "y-bflg32.icn");
  if ( !this->flagIcons2[4] )
    this->flagIcons2[4] = resourceManager::GetIcon(gpResourceManager, "o-bflg32.icn");
  if ( !this->flagIcons2[5] )
    this->flagIcons2[5] = resourceManager::GetIcon(gpResourceManager, "p-bflg32.icn");
  gbLoadingMonoIcon = 1;
  if ( !this->radarIcon )
    this->radarIcon = resourceManager::GetIcon(gpResourceManager, "radar.icn");
  gbLoadingMonoIcon = 0;
  for ( k = 0; k < 28; ++k )
    this->loopSamples[k] = 0;
  for ( l = 0; l < 4; ++l )
  {
    this->field_2C2[l][0] = -1;
    this->field_2C2[l][1] = 127;
    this->field_2BE = 0;
  }
  advManager::GetCursorSampleSet(this, *(signed int *)&walkSpeed);
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    SetNoDialogMenus(1);
  }
  else
  {
    game::TurnOnAIMusic();
    SetNoDialogMenus(0);
  }
  glTimers = KBTickCount() + 120;
  v13 = *(_DWORD *)&soundVolume;
  if ( *(_DWORD *)&soundVolume )
    *(_DWORD *)&soundVolume = 10;
  advManager::SetInitialMapOrigin(this);
  bShowIt = gbThisNetHumanPlayer[giCurPlayer];
  v2 = giCurPlayer;
  v3 = bShowIt;
  giCurPlayer = giCurWatchPlayer;
  gpCurPlayer = &gpGame->players[giCurWatchPlayer];
  bShowIt = 1;
  advManager::RedrawAdvScreen(this, 1, 0);
  giCurPlayer = v2;
  bShowIt = v3;
  gpCurPlayer = &gpGame->players[v2];
  if ( !gbThisNetHumanPlayer[v2] )
    game::ShowComputerScreen();
  KBChangeMenu(hmnuAdv);
  advManager::ForceNewHover(this);
  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
  giBottomViewOverride = 0;
  *(_DWORD *)&soundVolume = v13;
  soundManager::AdjustSoundVolumes((soundManager *)gpSoundManager);
  this->type = 1024;
  this->idx = idx;
  this->ready = 1;
  strcpy(this->name, "advManager");
  return 0;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F2E70: using guessed type int gbLoadingMonoIcon;
// 50EAA0: using guessed type int iCurBottomView;
// 523EDC: using guessed type int giCurWatchPlayer;
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 524C14: using guessed type int bShowIt;

//----- (00443990) --------------------------------------------------------
void *__thiscall advManager::Close(void *this)
{
  void *result; // eax@32
  void *thisa; // [sp+Ch] [bp-18h]@1
  signed int i; // [sp+20h] [bp-4h]@9
  signed int j; // [sp+20h] [bp-4h]@15
  signed int k; // [sp+20h] [bp-4h]@18
  signed int l; // [sp+20h] [bp-4h]@22
  signed int m; // [sp+20h] [bp-4h]@27

  thisa = this;
  advManager::ClearBottomView((advManager *)this);
  mouseManager::SetPointer(gpMouseManager, -1);
  if ( bEnteringTown && !*(_DWORD *)&useOpera && *(_DWORD *)&useCDMusic )
  {
    soundManager::StopAllSamples((soundManager *)gpSoundManager, 0);
  }
  else
  {
    soundManager::StopAllSamples((soundManager *)gpSoundManager, 1);
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
  }
  if ( *(_DWORD *)((char *)thisa + 186) )
  {
    BaseFree(*(void **)((char *)thisa + 186), (int)"F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50EC80 + 22);
    *(_DWORD *)((char *)thisa + 186) = 0;
  }
  if ( gAdvDisposeLevel <= 1 )
  {
    for ( i = 0; i < 64; ++i )
    {
      if ( *(_DWORD *)((char *)thisa + 4 * i + 206) )
        resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * i + 206));
      *(_DWORD *)((char *)thisa + 4 * i + 206) = 0;
    }
  }
  if ( gAdvDisposeLevel <= 0 )
  {
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 462));
    *(_DWORD *)((char *)thisa + 462) = 0;
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 466));
    *(_DWORD *)((char *)thisa + 466) = 0;
    for ( j = 0; j < 8; ++j )
    {
      resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * j + 538));
      *(_DWORD *)((char *)thisa + 4 * j + 538) = 0;
    }
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 570));
    *(_DWORD *)((char *)thisa + 570) = 0;
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 574));
    *(_DWORD *)((char *)thisa + 574) = 0;
    for ( k = 0; k < 6; ++k )
    {
      resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * k + 578));
      *(_DWORD *)((char *)thisa + 4 * k + 578) = 0;
      resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * k + 602));
      *(_DWORD *)((char *)thisa + 4 * k + 602) = 0;
    }
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 194));
    *(_DWORD *)((char *)thisa + 194) = 0;
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 198));
    *(_DWORD *)((char *)thisa + 198) = 0;
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 202));
    *(_DWORD *)((char *)thisa + 202) = 0;
  }
  for ( l = 0; l < 28; ++l )
  {
    if ( *(_DWORD *)((char *)thisa + 4 * l + 738) )
      resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * l + 738));
    *(_DWORD *)((char *)thisa + 4 * l + 738) = 0;
  }
  for ( m = 0; m < 9; ++m )
  {
    resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * m + 850));
    *(_DWORD *)((char *)thisa + 4 * m + 850) = 0;
  }
  heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)((char *)thisa + 154));
  operator delete(*(void **)((char *)thisa + 154));
  *(_DWORD *)((char *)thisa + 154) = 0;
  if ( *(_DWORD *)((char *)thisa + 158) )
    operator delete(*(void **)((char *)thisa + 158));
  *(_DWORD *)((char *)thisa + 158) = 0;
  iCurBottomView = 0;
  result = thisa;
  *(_DWORD *)((char *)thisa + 50) = 0;
  return result;
}
// 4F7490: using guessed type int gAdvDisposeLevel;
// 50EAA0: using guessed type int iCurBottomView;
// 50EC80: using guessed type __int16 word_50EC80;
// 51256C: using guessed type int bEnteringTown;
// 5240A8: using guessed type int gpSoundManager;

//----- (00443DA0) --------------------------------------------------------
void __thiscall advManager::GetCursorSampleSet(advManager *this, signed int speed)
{
  advManager *thisa; // [sp+Ch] [bp-2Ch]@1
  signed int i; // [sp+10h] [bp-28h]@3
  int v4[9]; // [sp+14h] [bp-24h]@3

  thisa = this;
  if ( speed >= 1 )
    speed = 2;
  v4[0] = 0;
  v4[1] = 3;
  v4[2] = 5;
  v4[3] = 3;
  v4[4] = 4;
  v4[5] = 5;
  v4[6] = 6;
  v4[7] = 3;
  v4[8] = 3;
  for ( i = 0; i < 9; ++i )
  {
    sprintf(gText, "wsnd%1d%1d.82M", speed, v4[i]);
    thisa->walkSamples[i] = resourceManager::GetSample(gpResourceManager, gText);
    thisa->walkSamples[i]->field_28 = 64;
    thisa->walkSamples[i]->codeThing = 2;
  }
}

//----- (00443E90) --------------------------------------------------------
mapCell *__thiscall advManager::DoAdvCommand(advManager *this)
{
  mapCell *v1; // eax@58
  mapCell *v2; // eax@59
  char v5; // [sp+14h] [bp-78h]@32
  tag_message a2; // [sp+30h] [bp-5Ch]@25
  int i; // [sp+4Ch] [bp-40h]@18
  signed int a8; // [sp+50h] [bp-3Ch]@20
  int a6; // [sp+54h] [bp-38h]@20
  char v10; // [sp+58h] [bp-34h]@1
  int v11; // [sp+5Ch] [bp-30h]@25
  mapCell *loc; // [sp+78h] [bp-14h]@1
  int v13; // [sp+7Ch] [bp-10h]@12
  hero *v14; // [sp+80h] [bp-Ch]@2
  town *v15; // [sp+84h] [bp-8h]@50
  char v16; // [sp+88h] [bp-4h]@1

  loc = 0;
  v16 = 0;
  v10 = 0;
  if ( gpCurPlayer->curHeroIdx == -1 )
    v14 = 0;
  else
    v14 = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  switch ( this->field_36 + 1 )
  {
    case 2:
      if ( v14 )
      {
        *(_DWORD *)&v14->field_21 = this->field_1EE;
        *(_DWORD *)&v14->field_25 = this->field_1F2;
        goto LABEL_7;
      }
      break;
    case 8:
LABEL_7:
      if ( v14 )
      {
        if ( *(_DWORD *)&v14->field_21 != -1 )
        {
          if ( *(_DWORD *)&v14->field_25 != -1 )
          {
            searchArray::BuildPath(
              gpSearchArray,
              v14->x,
              v14->y,
              *(_DWORD *)&v14->field_21,
              *(_DWORD *)&v14->field_25,
              59999);
            if ( gpSearchArray->field_8 > 0 )
            {
              v13 = this->field_A2;
              advManager::MobilizeCurrHero(this, 1);
              if ( *(_DWORD *)&showRoute || v13 )
              {
                advManager::ShowRoute(this, 0, 0, 0);
              }
              else if ( this->field_A2 && this->field_36 != 7 )
              {
                advManager::HideRoute(this, 1, 0, 1);
              }
              mouseManager::HideColorPointer(gpMouseManager);
              inputManager::Flush(gpInputManager);
              for ( i = gpSearchArray->field_8 - 1; i >= 0; --i )
              {
                loc = advManager::MoveHero(
                        this,
                        *((_BYTE *)&gpSearchArray->field_2418 + i),
                        (unsigned int)i < 1,
                        &TrigX,
                        &TrigX + 1,
                        (int)&a6,
                        0,
                        (signed int)&a8,
                        0);
                advManager::UpdateHeroLocator(this, -1, 1, 1);
                if ( loc || a6 || a8 || gbHitEvent )
                  break;
                memcpy(&v11, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
                while ( v11 )
                {
                  if ( v11 == 1 || v11 == 8 || v11 == 32 || v11 == 512 )
                  {
                    v16 = 1;
                    advManager::StopCursor(this, 1);
                    goto LABEL_34;
                  }
                  Process1WindowsMessage();
                  memcpy(&v11, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v5), 0x1Cu);
                }
              }
LABEL_34:
              if ( i <= 0 && v14->x == *(_DWORD *)&v14->field_21 && *(_DWORD *)&v14->field_25 == v14->y
                || v16 && !*(_DWORD *)&showRoute
                || loc )
              {
                advManager::HideRoute(this, 1, 1, 1);
              }
              else if ( this->field_36 == 7 || *(_DWORD *)&showRoute )
              {
                advManager::ShowRoute(this, 0, 1, 1);
              }
              while ( gpMouseManager->cursorDisabled )
                mouseManager::ShowColorPointer(gpMouseManager);
              soundManager::SwitchAmbientMusic(
                (soundManager *)gpSoundManager,
                (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
              advManager::UpdBottomView(this, 1, 1, 1);
              if ( loc )
              {
                advManager::StopCursor(this, 1);
                advManager::DoEvent(this, loc, TrigX, *(&TrigX + 1));
                loc = 0;
              }
              advManager::Reseed(0, 0);
              v10 = 1;
              advManager::CheckDimHero(this);
            }
          }
        }
      }
      break;
    case 7:
      advManager::DemobilizeCurrHero(this);
      mouseManager::SetPointer(gpMouseManager, 0);
      v15 = &gpGame->castles[v14->occupiedObjVal];
      town::View(v15, 0);
      loc = 0;
      break;
    case 4:
      advManager::DemobilizeCurrHero(this);
      mouseManager::SetPointer(gpMouseManager, 0);
      loc = advManager::GetCell(
              this,
              gpGame->castles[LOBYTE(gpCurPlayer->field_45)].x,
              gpGame->castles[LOBYTE(gpCurPlayer->field_45)].y);
      town::View(&gpGame->castles[LOBYTE(gpCurPlayer->field_45)], 0);
      loc = 0;
      break;
    case 3:
      if ( v14 )
      {
        mouseManager::SetPointer(gpMouseManager, 0);
        if ( gbLowMemory )
          advManager::SetEnvironmentOrigin(this, -1, -1, 1);
        advManager::TrimLoopingSounds(this, 0);
        HeroView(gpCurPlayer->curHeroIdx, 0, 0);
        if ( gbLowMemory )
          advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
        advManager::RedrawAdvScreen(this, 1, 0);
        heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
      }
      break;
    case 5:
      v1 = advManager::GetCell(this, this->viewX + this->xOff, this->viewY + this->yOff);
      advManager::SetHeroContext(
        this,
        (unsigned __int8)((unsigned __int8)(v1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        0);
      break;
    case 6:
      v2 = advManager::GetCell(this, this->viewX + this->xOff, this->viewY + this->yOff);
      advManager::SetTownContext(
        this,
        (unsigned __int8)((unsigned __int8)(v2->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
      break;
    case 0:
      break;
  }
  this->field_36 = -1;
  this->yOff = -1;
  this->xOff = this->yOff;
  if ( v10 )
    advManager::ForceNewHover(this);
  return loc;
}
// 4F74A8: using guessed type int gbLowMemory;
// 523ECC: using guessed type int gbHitEvent;
// 5240A8: using guessed type int gpSoundManager;

//----- (00444550) --------------------------------------------------------
void __thiscall advManager::CheckSetEvilInterface(void *this, int a2, int a3)
{
  int v3; // ST18_4@17
  void *thisa; // [sp+Ch] [bp-2Ch]@1
  signed int v5; // [sp+14h] [bp-24h]@3
  int evt; // [sp+18h] [bp-20h]@14
  int v7; // [sp+1Ch] [bp-1Ch]@14
  unsigned int v8; // [sp+20h] [bp-18h]@16
  unsigned int v9; // [sp+30h] [bp-8h]@16
  int i; // [sp+34h] [bp-4h]@14

  thisa = this;
  if ( a3 == -1 )
    a3 = giCurWatchPlayer;
  v5 = 0;
  if ( *(_DWORD *)&evilInterfaceUsage != 2 || gbUseEvilInterface )
  {
    if ( *(_DWORD *)&evilInterfaceUsage == 1 && gbUseEvilInterface )
    {
      v5 = 1;
    }
    else if ( !*(_DWORD *)&evilInterfaceUsage && gpGame->players[a3]._4_1 != gbUseEvilInterface )
    {
      v5 = 1;
    }
  }
  else
  {
    v5 = 1;
  }
  if ( v5 )
  {
    gbUseEvilInterface = 1 - gbUseEvilInterface;
    if ( a2 )
    {
      evt = 512;
      v7 = 60;
      for ( i = 0; i < 37; ++i )
      {
        v8 = resourceManager::MakeId(gpResourceManager, cEvilTranslate[i][1 - gbUseEvilInterface], 0);
        v9 = resourceManager::MakeId(gpResourceManager, cEvilTranslate[i][gbUseEvilInterface], 0);
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)thisa + 154), (tag_message *)&evt);
      }
      v3 = bShowIt;
      bShowIt = 1;
      advManager::RedrawAdvScreen((advManager *)thisa, 1, 1);
      bShowIt = v3;
    }
  }
}
// 4F19D4: using guessed type int gbUseEvilInterface;
// 523EDC: using guessed type int giCurWatchPlayer;
// 524C14: using guessed type int bShowIt;

//----- (004446F0) --------------------------------------------------------
signed int __thiscall advManager::Main(advManager *this, tag_message *evt)
{
  int v2; // edx@1
  signed int result; // eax@5
  int v4; // edx@6
  int v5; // eax@166
  const CHAR *v6; // [sp+0h] [bp-54h]@0
  int v7; // [sp+14h] [bp-40h]@22
  INPUT_EVENT_CODE v8; // [sp+18h] [bp-3Ch]@21
  signed int a8; // [sp+20h] [bp-34h]@175
  int a6; // [sp+24h] [bp-30h]@175
  hero *v12; // [sp+28h] [bp-2Ch]@83
  int v13; // [sp+2Ch] [bp-28h]@27
  hero *hro; // [sp+30h] [bp-24h]@46
  int a2; // [sp+34h] [bp-20h]@45
  mapCell *loc; // [sp+38h] [bp-1Ch]@20
  int v17; // [sp+3Ch] [bp-18h]@156
  int i; // [sp+40h] [bp-14h]@66
  int v19; // [sp+4Ch] [bp-8h]@20
  int a3; // [sp+50h] [bp-4h]@20

  if ( KBTickCount() > glTimers && advManager::ComboDraw(this, 1) )
    advManager::UpdateScreen(this, 1, 0);
  if ( gbGameOver )
  {
    evt->eventCode = 16384;
    evt->xCoordOrKeycode = 1;
    return 2;
  }
  advManager::CheckHandleNet(this, v2);
  if ( !gbThisNetGotAdventureControl )
    return advManager::CheckHandleNetPlayerWait(this, (int)evt, 0);
  if ( !gbHumanPlayer[giCurPlayer] )
  {
    philAI::DoAI((void *)gpPhilAI, giCurPlayer);
    game::NextPlayer(gpGame);
    return 1;
  }
  if ( giScreenScroll && gbForegroundApp )
    advManager::CheckScreenScroll(this);
  if ( !gbNoSound && *(_DWORD *)&Data && giForceSwitchMusic > 0 && KBTickCount() - giForceSwitchMusic > 6000 )
  {
    giForceSwitchMusic = -1;
    if ( *(_BYTE *)(gpSoundManager + 1404) == 21 )
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
    advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
  }
  v19 = 1;
  a3 = 0;
  loc = 0;
  if ( evt->eventCode )
  {
    v8 = evt->eventCode;
    if ( v8 == INPUT_KEYDOWN_EVENT_CODE )
    {
      a2 = -1;
      if ( gpCurPlayer->curHeroIdx == -1 )
        hro = 0;
      else
        hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
      if ( giDebugLevel >= 1
        || evt->xCoordOrKeycode != 61
        && evt->xCoordOrKeycode != 62
        && evt->xCoordOrKeycode != 63
        && evt->xCoordOrKeycode != 64
        && evt->xCoordOrKeycode != 65
        && evt->xCoordOrKeycode != 66
        && evt->xCoordOrKeycode != 67
        && evt->xCoordOrKeycode != 68
        && evt->xCoordOrKeycode != 87
        && evt->xCoordOrKeycode != 88 )
      {
        switch ( evt->xCoordOrKeycode )
        {
          case 60:
            CreateColorTables(v6);
            PopNetBox(0, (void *)0xFFFFFFFF);
            break;
          case 64:
            game::CheckHeroConsistency(gpGame);
            break;
          case 65:
            gpCurPlayer->_3[0] += 12;
            if ( hro )
              advManager::GiveExperience(hro, 3000, 1);
            break;
          case 67:
            for ( i = 0; i < 7; ++i )
            {
              if ( i == 6 )
                gpCurPlayer->resources[6] += 1000;
              else
                gpCurPlayer->resources[i] += 10;
            }
            break;
          case 11:
            i = 0;
            goto LABEL_83;
          case 2:
            i = 1;
            goto LABEL_83;
          case 3:
            i = 2;
            goto LABEL_83;
          case 4:
            i = 3;
            goto LABEL_83;
          case 5:
            i = 4;
            goto LABEL_83;
          case 6:
            i = 5;
            goto LABEL_83;
          case 7:
            i = 6;
            goto LABEL_83;
          case 8:
            i = 7;
            goto LABEL_83;
          case 9:
            i = 8;
            goto LABEL_83;
          case 10:
            i = 9;
LABEL_83:
            v12 = 0;
            if ( gpCurPlayer->curHeroIdx != -1 )
              v12 = &gpGame->heroes[gpCurPlayer->curHeroIdx];
            dword_50ECB0 = 10 * dword_50ECB0 % 10000000 + i;
            if ( !gbRemoteOn )
            {
              if ( dword_50ECB0 % 100000 == 32167 && v12 )
              {
                gpGame->_B[1] = 1;
                if ( gbInCampaign )
                  gpGame->_11[72] = 1;
                game::GiveArmy(&v12->army, 37, 5, -1);
                advManager::UpdBottomView(this, 1, 1, 1);
              }
              if ( dword_50ECB0 % 1000 == 911 )
              {
                gpGame->_B[1] = 1;
                if ( gbInCampaign )
                  gpGame->_11[72] = 1;
                CheckEndGame(1, 0);
              }
              if ( dword_50ECB0 % 10000 == 1313 )
              {
                gpGame->_B[1] = 1;
                CheckEndGame(2, 0);
              }
            }
            if ( dword_50ECB0 % 10000000 == 8675309 )
            {
              gpGame->_B[1] = 1;
              if ( gbInCampaign )
                gpGame->_11[72] = 1;
              game::SetVisibility(gpGame, 30, 30, 0, 180);
              game::SetVisibility(gpGame, 30, 30, 1, 180);
              game::SetVisibility(gpGame, 30, 30, 2, 180);
              game::SetVisibility(gpGame, 30, 30, 3, 180);
              game::SetVisibility(gpGame, 30, 30, 4, 180);
              game::SetVisibility(gpGame, 30, 30, 5, 180);
              advManager::Reseed(0, 0);
              advManager::UpdateRadar(this, 1, 0);
              advManager::CompleteDraw(this, 0);
              advManager::UpdateScreen(this, 0, 0);
            }
            if ( dword_50ECB0 % 1000 == 411 )
            {
              sprintf(gText, "Coordinates at top left corner of view:\n\n  X: %d\n  Y: %d", this->viewX, this->viewY);
              NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
            break;
          case 72:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 0, 0);
            else
              a2 = 0;
            break;
          case 73:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 1, 0);
            else
              a2 = 1;
            break;
          case 77:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 2, 0);
            else
              a2 = 2;
            break;
          case 81:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 3, 0);
            else
              a2 = 3;
            break;
          case 80:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 4, 0);
            else
              a2 = 4;
            break;
          case 79:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 5, 0);
            else
              a2 = 5;
            break;
          case 75:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 6, 0);
            else
              a2 = 6;
            break;
          case 71:
            if ( evt->inputTypeBitmask & 0xC )
              advManager::ScreenScroll(this, 7, 0);
            else
              a2 = 7;
            break;
          case 46:
            advManager::CheckCastSpell(this);
            break;
          case 32:
            advManager::ProcessSearch(this, -1i64);
            break;
          case 25:
            advManager::ViewPuzzle(this);
            break;
          case 47:
            advManager::ViewWorld(this, v4, 53, 0, 0);
            break;
          case 49:
            i = 101;
            strcpy(gText, "Are you sure you want to restart?  (Your current game will be lost)");
            goto LABEL_143;
          case 38:
            i = 102;
            strcpy(gText, "Are you sure you want to load a new game?  (Your current game will be lost)");
            goto LABEL_143;
          case 16:
            i = 105;
            strcpy(gText, "Are you sure you want to quit?");
LABEL_143:
            a3 = 1;
            NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
            if ( gpWindowManager->buttonPressedCode == 30726 )
              a3 = 0;
            else
              gGameCommand = i;
            break;
          case 31:
            SaveGame();
            break;
          case 23:
            if ( gbInCampaign )
            {
              advManager::SetEnvironmentOrigin(this, -1, -1, 1);
              game::ShowCampaignInfo(gpGame, 1, 0);
              advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
              advManager::RedrawAdvScreen(this, 1, 0);
              soundManager::SwitchAmbientMusic(
                (soundManager *)gpSoundManager,
                (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
            }
            else if ( xIsPlayingExpansionCampaign )
            {
              advManager::SetEnvironmentOrigin(this, -1, -1, 1);
              ExpCampaign::ShowInfo((int)&xCampaign, 1, 0);
              advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
              advManager::RedrawAdvScreen(this, 1, 0);
              soundManager::SwitchAmbientMusic(
                (soundManager *)gpSoundManager,
                (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
            }
            else
            {
              game::ShowScenInfo(gpGame);
            }
            break;
          case 20:
            if ( gpCurPlayer->numCastles >= 0 )
            {
              if ( LOBYTE(gpCurPlayer->field_45) == -1 )
              {
                v17 = gpCurPlayer->castlesOwned[0];
              }
              else
              {
                v17 = 0;
                for ( i = 0; gpCurPlayer->numCastles > i; ++i )
                {
                  if ( gpCurPlayer->castlesOwned[i] == LOBYTE(gpCurPlayer->field_45) )
                  {
                    if ( gpCurPlayer->numCastles - 1 == i )
                      v17 = gpCurPlayer->castlesOwned[0];
                    else
                      v17 = gpCurPlayer->castlesOwned[i + 1];
                  }
                }
              }
              advManager::SetTownContext(this, v17);
            }
            break;
          case 35:
            v5 = playerData::NextHero(gpCurPlayer, 0);
            advManager::SetHeroContext(this, v5, 0);
            break;
          case 28:
            if ( LOBYTE(gpCurPlayer->field_45) == -1 )
            {
              if ( gpCurPlayer->curHeroIdx != -1 )
              {
                this->field_36 = 2;
                advManager::DoAdvCommand(this);
              }
            }
            else
            {
              this->field_36 = 3;
              advManager::DoAdvCommand(this);
            }
            break;
          case 66:
          case 1:
            break;
        }
        if ( gpCurPlayer->curHeroIdx != -1 && a2 >= 0 )
        {
          advManager::HideRoute(this, 1, 1, 1);
          mouseManager::HideColorPointer(gpMouseManager);
          loc = advManager::MoveHero(this, a2, 1, &TrigX, &TrigX + 1, (int)&a6, 0, (signed int)&a8, 0);
          advManager::UpdateHeroLocator(this, -1, 1, 1);
          while ( gpMouseManager->cursorDisabled )
            mouseManager::ShowColorPointer(gpMouseManager);
          soundManager::SwitchAmbientMusic(
            (soundManager *)gpSoundManager,
            (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
          if ( loc )
          {
            advManager::StopCursor(this, 1);
            advManager::DoEvent(this, loc, TrigX, *(&TrigX + 1));
            loc = 0;
          }
          advManager::Reseed(0, 0);
          advManager::ForceNewHover(this);
          advManager::UpdBottomView(this, 1, 1, 1);
          advManager::CheckDimHero(this);
        }
      }
      goto LABEL_185;
    }
    if ( v8 == 4 )
    {
      v19 = advManager::ProcessHover(this, evt->altXCoord, evt->altYCoord);
    }
    else if ( v8 == 512 )
    {
      v7 = evt->xCoordOrKeycode;
      if ( v7 == 12 )
        goto LABEL_194;
      if ( v7 == 13 )
      {
        if ( !(BYTE1(evt->inputTypeBitmask) & 2) )
          v19 = advManager::ProcessDeSelect(this, (GUIMessage *)evt, (int)&a3, (int)&loc);
        goto LABEL_185;
      }
      if ( v7 == 14 )
      {
        if ( !(BYTE1(evt->inputTypeBitmask) & 2) )
          goto LABEL_195;
LABEL_194:
        v13 = -1;
        switch ( evt->yCoordOrFieldID )
        {
          case 1:
            v13 = 0;
            break;
          case 2:
            v13 = 1;
            break;
          case 3:
            v13 = 2;
            break;
          case 4:
            v13 = 3;
            break;
          case 5:
            v13 = 4;
            break;
          case 6:
            v13 = 5;
            break;
          case 7:
            v13 = 6;
            break;
          case 8:
            v13 = 7;
            break;
          default:
            break;
        }
        if ( v13 >= 0 )
          NormalDialog(gEventText[v13 + 122], 4, -1, -1, -1, 0, -1, 0, -1, 0);
        else
LABEL_195:
          v19 = advManager::ProcessSelect((int)this, evt, (int)&loc);
      }
    }
  }
LABEL_185:
  if ( loc )
    advManager::DoEvent(this, loc, TrigX, *(&TrigX + 1));
  if ( gbGameOver || a3 == 1 || giMenuCommand != -1 )
  {
    evt->eventCode = 16384;
    evt->xCoordOrKeycode = 1;
    result = 2;
  }
  else
  {
    result = v19;
  }
  return result;
}
// 4EF268: using guessed type int gbGameOver;
// 4F0A10: using guessed type int gbForegroundApp;
// 4F19A4: using guessed type int giScreenScroll;
// 4F19A8: using guessed type int giMenuCommand;
// 4F21F0: using guessed type int giDebugLevel;
// 4F747C: using guessed type int giForceSwitchMusic;
// 4F7494: using guessed type int gbRemoteOn;
// 50ECB0: using guessed type int dword_50ECB0;
// 523408: using guessed type int gGameCommand;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 523F24: using guessed type int gbNoSound;
// 5240A8: using guessed type int gpSoundManager;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (004456D0) --------------------------------------------------------
void __stdcall advManager::Reseed(int a1, int a2)
{
  giSeedingValid = 0;
}
// 5247C0: using guessed type int giSeedingValid;

//----- (00445700) --------------------------------------------------------
signed int __thiscall advManager::ProcessSelect(int this, tag_message *evt, int a3)
{
  advManager *thisa; // [sp+28h] [bp-9Ch]@1
  char v5; // [sp+2Ch] [bp-98h]@120
  tag_message a2a; // [sp+48h] [bp-7Ch]@115
  bool v7; // [sp+64h] [bp-60h]@67
  hero *v8; // [sp+68h] [bp-5Ch]@67
  int v9; // [sp+6Ch] [bp-58h]@113
  float v10; // [sp+88h] [bp-3Ch]@98
  int v11; // [sp+8Ch] [bp-38h]@115
  int v12; // [sp+90h] [bp-34h]@122
  int v13; // [sp+94h] [bp-30h]@126
  mapCell *cell; // [sp+A8h] [bp-1Ch]@31
  int v15; // [sp+ACh] [bp-18h]@1
  int objOrHeroIdx; // [sp+B0h] [bp-14h]@3
  int quickViewY; // [sp+B4h] [bp-10h]@1
  int v18; // [sp+B8h] [bp-Ch]@38
  int quickViewX; // [sp+BCh] [bp-8h]@1
  int v20; // [sp+C0h] [bp-4h]@2

  thisa = (advManager *)this;
  v15 = 1;
  quickViewX = evt->altXCoord;
  quickViewY = evt->altYCoord;
  switch ( evt->yCoordOrFieldID )
  {
    case 0x69:
    case 0x70:
    case 0x77:
    case 0x7E:
      v20 = (evt->yCoordOrFieldID - 105) / 7;
      if ( gpCurPlayer->numHeroes > v20 )
      {
        objOrHeroIdx = *(&gpCurPlayer->heroesOwned[v20] + gpCurPlayer->field_3);
        if ( BYTE1(evt->inputTypeBitmask) & 2 )
        {
          advManager::HeroQuickView((advManager *)this, objOrHeroIdx, v20, -1, -1);
        }
        else if ( gpCurPlayer->curHeroIdx == objOrHeroIdx )
        {
          *(_DWORD *)(this + 54) = 2;
          advManager::DoAdvCommand((advManager *)this);
        }
        else
        {
          advManager::HideRoute((advManager *)this, 1, 0, 1);
          advManager::SetHeroContext(thisa, objOrHeroIdx, 0);
        }
      }
      break;
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
      objOrHeroIdx = *(&gpCurPlayer->_3[evt->yCoordOrFieldID + 36] + HIBYTE(gpCurPlayer->field_45));
      if ( BYTE1(evt->inputTypeBitmask) & 2 )
      {
        advManager::TownQuickView((void *)this, objOrHeroIdx, evt->yCoordOrFieldID - 16, -1, -1);
      }
      else
      {
        advManager::HideRoute((advManager *)this, 1, 0, 1);
        if ( LOBYTE(gpCurPlayer->field_45) == objOrHeroIdx )
        {
          thisa->field_36 = 3;
          *(_DWORD *)a3 = advManager::DoAdvCommand(thisa);
        }
        else
        {
          advManager::SetTownContext(thisa, objOrHeroIdx);
        }
      }
      break;
    case 0x1A:
      advManager::DoHeroKnob((void *)this);
      break;
    case 0x16:
      quickViewY -= 194;
      if ( gpCurPlayer->numHeroes <= 4 )
      {
        v20 = 0;
      }
      else
      {
        v20 = quickViewY / 92 / (gpCurPlayer->numHeroes - 3);
        if ( gpCurPlayer->numHeroes - 4 < v20 )
          v20 = gpCurPlayer->numHeroes - 4;
      }
      gpCurPlayer->field_3 = v20;
      advManager::UpdateHeroLocators((advManager *)this, 1, 1);
      break;
    case 0x1B:
      advManager::DoTownKnob((void *)this);
      break;
    case 0x19:
      quickViewY -= 194;
      if ( gpCurPlayer->numCastles <= 4 )
      {
        v20 = 0;
      }
      else
      {
        v20 = quickViewY / 92 / (gpCurPlayer->numCastles - 3);
        if ( gpCurPlayer->numCastles - 4 < v20 )
          v20 = gpCurPlayer->numCastles - 4;
      }
      HIBYTE(gpCurPlayer->field_45) = v20;
      advManager::UpdateTownLocators((void *)this, 1, 1);
      break;
    case 0xA:
      if ( !(unsigned __int8)(*(&mapRevealed[*(_DWORD *)(this + 470)]
                              + *(_DWORD *)(this + 486)
                              + MAP_WIDTH * (*(_DWORD *)(this + 474) + *(_DWORD *)(this + 490))) & giCurPlayerBit) )
        v15 = 0;
      cell = advManager::GetCell(
               (advManager *)this,
               *(_DWORD *)(this + 470) + *(_DWORD *)(this + 486),
               *(_DWORD *)(this + 474) + *(_DWORD *)(this + 490));
      if ( BYTE1(evt->inputTypeBitmask) & 2 )
      {
        if ( v15 )
        {
          if ( thisa->xOff == 7 && thisa->yOff == 7 && gpCurPlayer->curHeroIdx != -1 && thisa->heroMobilized )
          {
            objOrHeroIdx = LOCATION_HERO;
            v18 = gpCurPlayer->curHeroIdx;
          }
          else
          {
            objOrHeroIdx = cell->objType & 0x7F;
            v18 = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          }
          if ( objOrHeroIdx == LOCATION_TOWN )
          {
            quickViewX = 32 * thisa->xOff - 89;
            if ( quickViewX < 30 )
              quickViewX = 30;
            if ( quickViewX + 224 > 448 )
              quickViewX = 224;
            quickViewY = 32 * thisa->yOff - 70;
            if ( quickViewY < 16 )
              quickViewY = 16;
            if ( quickViewY + 186 > 464 )
              quickViewY = 278;
            advManager::TownQuickView(thisa, v18, -1, quickViewX, quickViewY);
          }
          else if ( objOrHeroIdx == LOCATION_HERO )
          {
            quickViewX = 32 * thisa->xOff - 73;
            if ( quickViewX < 30 )
              quickViewX = 30;
            if ( quickViewX + 192 > 448 )
              quickViewX = 256;
            quickViewY = 32 * thisa->yOff - 72;
            if ( quickViewY < 16 )
              quickViewY = 16;
            if ( quickViewY + 190 > 464 )
              quickViewY = 274;
            advManager::HeroQuickView(thisa, v18, -1, quickViewX, quickViewY);
          }
          else if ( (unsigned __int8)*(&mapRevealed[thisa->viewX] + thisa->xOff + MAP_WIDTH * (thisa->viewY + thisa->yOff)) & (unsigned __int8)giCurPlayerBit )
          {
            advManager::QuickInfo(thisa, thisa->xOff, thisa->yOff);
          }
        }
        else
        {
          advManager::QuickInfo(thisa, thisa->xOff, thisa->yOff);
        }
      }
      else if ( v15 )
      {
        v8 = 0;
        v7 = 0;
        if ( gpCurPlayer->curHeroIdx != -1 )
        {
          v8 = &gpGame->heroes[gpCurPlayer->curHeroIdx];
          v7 = game::IsMobile(gpGame, v8->idx);
        }
        if ( v8 )
        {
          if ( thisa->xOff == 7 && thisa->yOff == 7 && gpCurPlayer->curHeroIdx != -1 && thisa->heroMobilized )
          {
            thisa->field_36 = 2;
            advManager::DoAdvCommand(thisa);
          }
          else if ( (!v7
   || evt->inputTypeBitmask & 0xC
   || *(_DWORD *)&showRoute
   && (*(_DWORD *)&v8->field_21 != thisa->field_1EE || *(_DWORD *)&v8->field_25 != thisa->field_1F2))
  && *(&gpSearchArray->field_2414[MAP_WIDTH * thisa->field_1F2].field_4 + 9 * thisa->field_1EE) & 1 )
          {
            *(_DWORD *)&v8->field_21 = thisa->field_1EE;
            *(_DWORD *)&v8->field_25 = thisa->field_1F2;
            advManager::ShowRoute(thisa, 1, 1, 1);
          }
          else
          {
            *(_DWORD *)a3 = advManager::DoAdvCommand(thisa);
          }
        }
        else
        {
          objOrHeroIdx = cell->objType & 0x7F;
          v18 = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
          if ( objOrHeroIdx == 42 )
          {
            if ( gpCurPlayer->curHeroIdx == v18 )
            {
              thisa->field_36 = 2;
              advManager::DoAdvCommand(thisa);
            }
            else if ( gpGame->heroes[v18].ownerIdx == giCurPlayer )
            {
              advManager::SetHeroContext(thisa, v18, 0);
            }
          }
          if ( objOrHeroIdx == 35 )
          {
            if ( LOBYTE(gpCurPlayer->field_45) == v18 )
            {
              thisa->field_36 = 3;
              *(_DWORD *)a3 = advManager::DoAdvCommand(thisa);
            }
            else if ( gpGame->castles[v18].ownerIdx == giCurPlayer )
            {
              advManager::SetTownContext(thisa, v18);
            }
          }
        }
      }
      break;
    case 9:
      if ( BYTE1(evt->inputTypeBitmask) & 2 )
      {
        NormalDialog(
          "{World Map}\n\nA miniature view of the known world.  Left click to move viewing area.",
          4,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::DemobilizeCurrHero((advManager *)this);
        switch ( MAP_HEIGHT )
        {
          case 36:
            v10 = 4.0;
            break;
          case 72:
            v10 = 2.0;
            break;
          case 108:
            v10 = 1.3333;
            break;
          default:
            v10 = 1.0;
            break;
        }
        quickViewX = (signed __int64)((double)(quickViewX - 480) / v10);
        quickViewY = (signed __int64)((double)(quickViewY - 16) / v10);
        thisa->viewX = quickViewX - 7;
        thisa->viewY = quickViewY - 7;
        if ( thisa->viewX < -7 )
          thisa->viewX = -7;
        if ( thisa->viewY < -7 )
          thisa->viewY = -7;
        if ( MAP_WIDTH - 8 < thisa->viewX )
          thisa->viewX = MAP_WIDTH - 8;
        if ( MAP_HEIGHT - 8 < thisa->viewY )
          thisa->viewY = MAP_HEIGHT - 8;
        advManager::UpdateRadar(thisa, 1, 0);
        advManager::CompleteDraw(thisa, 0);
        advManager::UpdateScreen(thisa, 0, 0);
        v9 = 0;
        while ( v9 != 16 )
        {
          Process1WindowsMessage();
          memcpy(&v9, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2a), 0x1Cu);
          memcpy(&v11, &v9, 0x1Cu);
          while ( v9 != 16 && v9 )
          {
            if ( v9 == 4 )
              memcpy(&v11, &v9, 0x1Cu);
            Process1WindowsMessage();
            memcpy(&v9, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v5), 0x1Cu);
          }
          if ( v11 == 4 )
          {
            if ( v12 < 480 )
              v12 = 480;
            if ( v12 >= 624 )
              v12 = 623;
            if ( v13 < 16 )
              v13 = 16;
            if ( v13 >= 160 )
              v13 = 159;
            (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
            quickViewX = (signed __int64)((double)(v12 - 480) / v10);
            quickViewY = (signed __int64)((double)(v13 - 16) / v10);
            thisa->viewX = quickViewX - 7;
            thisa->viewY = quickViewY - 7;
            if ( thisa->viewX < -7 )
              thisa->viewX = -7;
            if ( thisa->viewY < -7 )
              thisa->viewY = -7;
            if ( MAP_WIDTH - 8 < thisa->viewX )
              thisa->viewX = MAP_WIDTH - 8;
            if ( MAP_HEIGHT - 8 < thisa->viewY )
              thisa->viewY = MAP_HEIGHT - 8;
            advManager::UpdateRadar(thisa, 1, 0);
            advManager::CompleteDraw(thisa, 0);
            advManager::UpdateScreen(thisa, 0, 0);
            v11 = 0;
          }
        }
      }
      break;
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x14:
    case 0x15:
    case 0x17:
    case 0x18:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x4B:
    case 0x4C:
    case 0x4D:
    case 0x4E:
    case 0x4F:
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
    case 0x5D:
    case 0x5E:
    case 0x5F:
    case 0x60:
    case 0x61:
    case 0x62:
    case 0x63:
    case 0x64:
    case 0x65:
    case 0x66:
    case 0x67:
    case 0x68:
    case 0x6A:
    case 0x6B:
    case 0x6C:
    case 0x6D:
    case 0x6E:
    case 0x6F:
    case 0x71:
    case 0x72:
    case 0x73:
    case 0x74:
    case 0x75:
    case 0x76:
    case 0x78:
    case 0x79:
    case 0x7A:
    case 0x7B:
    case 0x7C:
    case 0x7D:
      break;
  }
  if ( BYTE1(evt->inputTypeBitmask) & 2 && evt->yCoordOrFieldID >= 2000 && evt->yCoordOrFieldID <= 2200 )
    NormalDialog(
      "{Status Window}\n\nThis window provides information on the status of your hero or kingdom, and shows the date.  Left click here to cycle through these windows.",
      4,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
  return 1;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (00446570) --------------------------------------------------------
signed int __thiscall advManager::ProcessDeSelect(advManager *this, GUIMessage *evt, int a3, int a4)
{
  int v4; // eax@20
  int v5; // eax@26
  signed int v8; // [sp+14h] [bp-4h]@23

  switch ( evt->fieldID )
  {
    case 0x17:
      if ( (signed int)HIBYTE(gpCurPlayer->field_45) > 0 )
      {
        --HIBYTE(gpCurPlayer->field_45);
        advManager::UpdateTownLocators(this, 1, 1);
      }
      break;
    case 0x18:
      if ( HIBYTE(gpCurPlayer->field_45) + 4 < gpCurPlayer->numCastles )
      {
        ++HIBYTE(gpCurPlayer->field_45);
        advManager::UpdateTownLocators(this, 1, 1);
      }
      break;
    case 0x14:
      if ( gpCurPlayer->field_3 > 0 )
      {
        --gpCurPlayer->field_3;
        advManager::UpdateHeroLocators(this, 1, 1);
      }
      break;
    case 0x15:
      if ( gpCurPlayer->field_3 + 4 < gpCurPlayer->numHeroes )
      {
        ++gpCurPlayer->field_3;
        advManager::UpdateHeroLocators(this, 1, 1);
      }
      break;
    case 2:
      this->field_36 = 7;
      *(_DWORD *)a4 = advManager::DoAdvCommand(this);
      break;
    case 5:
      advManager::AdvPanel(this);
      break;
    case 6:
      *(_DWORD *)a3 = advManager::ControlPanel(this);
      break;
    case 4:
      if ( !playerData::HasMobileHero(gpCurPlayer)
        || (NormalDialog(
              "One or more heroes may still move, are you sure you want to end your turn?",
              2,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0),
            gpWindowManager->buttonPressedCode != 30726) )
        game::NextPlayer(gpGame);
      break;
    case 1:
      advManager::HideRoute(this, 1, 0, 1);
      v4 = playerData::NextHero(gpCurPlayer, 1);
      advManager::SetHeroContext(this, v4, 0);
      break;
    case 3:
      if ( gbLowMemory )
        advManager::SetEnvironmentOrigin(this, -1, -1, 1);
      advManager::TrimLoopingSounds(this, 0);
      game::Overview(gpGame);
      v8 = 1;
      if ( giOverviewReturnAction == 1 )
      {
        mouseManager::SetPointer(gpMouseManager, 0);
        if ( gbLowMemory )
          advManager::SetEnvironmentOrigin(this, -1, -1, 1);
        advManager::TrimLoopingSounds(this, 0);
        v5 = (int)hero::GetOccupiedTown(&gpGame->heroes[giOverviewReturnAction]);
        HeroView(giOverviewReturnActionExtra, v5, 1);
        if ( gbLowMemory )
          advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
      }
      else if ( giOverviewReturnAction == 2 )
      {
        advManager::DemobilizeCurrHero(this);
        mouseManager::SetPointer(gpMouseManager, 0);
        town::View(&gpGame->castles[giOverviewReturnActionExtra], 1);
        v8 = 0;
      }
      else if ( gbLowMemory )
      {
        advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
      }
      advManager::RedrawAdvScreen(this, 1, 0);
      if ( v8 )
        heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
      break;
    case 8:
      advManager::CheckCastSpell(this);
      break;
    case 7:
      advManager::SystemOptions(this);
      break;
    default:
      break;
  }
  if ( evt->fieldID >= 2000 && evt->fieldID <= 2200 )
  {
    if ( giBottomViewOverride == 2 )
    {
      giBottomViewOverride = 1;
    }
    else if ( giBottomViewOverride )
    {
      giBottomViewOverride = 0;
    }
    else if ( iCurBottomView == 2 )
    {
      giBottomViewOverride = 1;
    }
    else
    {
      giBottomViewOverride = 2;
    }
    giBottomViewOverrideEndTime = KBTickCount() + 3000;
    advManager::UpdBottomView(this, 1, 1, 1);
  }
  return 1;
}
// 4F74A8: using guessed type int gbLowMemory;
// 50EAA0: using guessed type int iCurBottomView;
// 52405C: using guessed type int giBottomViewOverride;
// 524238: using guessed type int giOverviewReturnAction;
// 524798: using guessed type int giBottomViewOverrideEndTime;

//----- (004469E0) --------------------------------------------------------
signed int __thiscall advManager::ProcessSearch(advManager *this, __int64 a2)
{
  unsigned __int16 v3; // ax@21
  unsigned __int16 v4; // ax@21
  char v6; // [sp+1Ch] [bp-34h]@29
  mapCell *v7; // [sp+3Ch] [bp-14h]@9
  int i; // [sp+40h] [bp-10h]@48
  __int64 res; // [sp+44h] [bp-Ch]@1
  char *hro; // [sp+4Ch] [bp-4h]@1

  res = (__int64)NULL_SAMPLE2;
  hro = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  if ( gpGame->heroes[gpCurPlayer->curHeroIdx].remainingMobility != gpGame->heroes[gpCurPlayer->curHeroIdx].mobility )
  {
    if ( gbHumanPlayer[giCurPlayer] )
    {
      NormalDialog("Digging for artifacts requires a whole day, try again tomorrow.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      return 1;
    }
LABEL_52:
    gpCurPlayer->field_40 = 0;
    return 1;
  }
  if ( hero::NumArtifacts((hero *)hro) == 14 )
  {
    if ( gbHumanPlayer[giCurPlayer] )
    {
      NormalDialog(
        "Searching for the Ultimate Artifact is fruitless.  Your hero could not carry it even if he found it - all his artifact slots are full.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
      return 1;
    }
    goto LABEL_52;
  }
  advManager::MobilizeCurrHero(this, 0);
  advManager::CompleteDraw(this, 0);
  advManager::UpdateScreen(this, 0, 0);
  if ( (_DWORD)a2 == -1 )
  {
    LODWORD(a2) = this->viewX + 7;
    HIDWORD(a2) = this->viewY + 7;
  }
  v7 = advManager::GetCell(this, a2, SHIDWORD(a2));
  if ( v7->objectIndex != 255 && (((unsigned __int8)v7->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 47
    || v7->overlayIndex != 255 )
  {
    if ( gbHumanPlayer[giCurPlayer] )
    {
      NormalDialog("Try searching on clear ground.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      return 1;
    }
    goto LABEL_52;
  }
  if ( !giGroundToTerrain[v7->groundIndex] )
  {
    if ( gbHumanPlayer[giCurPlayer] )
    {
      NormalDialog("Try looking on land!!!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      return 1;
    }
    goto LABEL_52;
  }
  if ( gbHumanPlayer[giCurPlayer] )
    res = LoadPlaySample("DIGSOUND.82M");
  if ( v7->objectIndex == 255 || (((unsigned __int8)v7->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 47 )
  {
    v7->bitfield_1_hasObject_1_isRoad_6_objTileset = v7->bitfield_1_hasObject_1_isRoad_6_objTileset & 3 | 0xE0;
    v7->objectIndex = -116;
    v3 = v7->field_4_1_1_isShadow_1_13_extraInfo;
    LOBYTE(v3) = v3 | 1;
    v7->field_4_1_1_isShadow_1_13_extraInfo = v3;
    v4 = v7->field_4_1_1_isShadow_1_13_extraInfo;
    LOBYTE(v4) = v4 | 2;
    v7->field_4_1_1_isShadow_1_13_extraInfo = v4;
    v7->displayFlags |= 0x80u;
  }
  advManager::CompleteDraw(this, 0);
  advManager::UpdateScreen(this, 0, 0);
  if ( gpGame->field_6395 != (_DWORD)a2 || gpGame->field_6396 != HIDWORD(a2) || gpGame->field_6397 == -1 )
  {
    if ( gbHumanPlayer[giCurPlayer] )
      NormalDialog("Nothing here.\nWhere could it be?", 1, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  else if ( hero::NumArtifacts((hero *)hro) < 14 )
  {
    v6 = 0;
    if ( xIsPlayingExpansionCampaign )
      v6 = ExpCampaign::IsSpecialUA((int)&xCampaign);
    if ( gbHumanPlayer[giCurPlayer] )
    {
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 41);
      if ( v6 )
        sprintf(
          gText,
          "%s%s",
          "Congratulations! After spending many hours digging here, you have uncovered the ",
          gArtifactNames[98]);
      else
        sprintf(
          gText,
          "%s%s",
          "Congratulations! After spending many hours digging here, you have uncovered the ",
          gArtifactNames[gpGame->field_6397]);
      NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( v6 )
        hero::ViewArtifact(98, 0, -1);
      else
        hero::ViewArtifact(gpGame->field_6397, 0, -1);
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
    }
    if ( v6 )
      GiveArtifact((hero *)hro, ARTIFACT_SPHERE_OF_NEGATION, 1, -1);
    else
      GiveArtifact((hero *)hro, (ARTIFACT)gpGame->field_6397, 1, -1);
    gpGame->field_6397 = -1;
  }
  else if ( gbHumanPlayer[giCurPlayer] )
  {
    NormalDialog("You have no room to carry another artifact!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  if ( gbHumanPlayer[giCurPlayer] )
    WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
  for ( i = 0; gpGame->numPlayers > i; ++i )
    ComputeUALoc(i);
  *(_DWORD *)(hro + 53) = 0;
  advManager::UpdBottomView(this, 1, 1, 1);
  advManager::CheckDimHero(this);
  advManager::Reseed(0, 0);
  CheckEndGame(0, 0);
  return 1;
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 5240A8: using guessed type int gpSoundManager;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (00446FB0) --------------------------------------------------------
signed int __thiscall advManager::ProcessHover(void *this, signed int a2, signed int a3)
{
  signed int result; // eax@3
  int thisa; // [sp+10h] [bp-28h]@1
  int spriteIdxArg; // [sp+14h] [bp-24h]@49
  int v6; // [sp+18h] [bp-20h]@46
  char *v7; // [sp+1Ch] [bp-1Ch]@27
  int v8; // [sp+20h] [bp-18h]@19
  int v9; // [sp+28h] [bp-10h]@4
  int v10; // [sp+2Ch] [bp-Ch]@4

  thisa = (int)this;
  if ( !InMapArea(a2, a3) )
  {
    if ( gpMouseManager->spriteIdx < 32 || gpMouseManager->spriteIdx >= 40 || !advManager::MouseInScrollZone() )
      mouseManager::SetPointer(gpMouseManager, 0);
    return 1;
  }
  if ( a2 > 480 )
  {
    mouseManager::SetPointer(gpMouseManager, 0);
    return 1;
  }
  v10 = a2 / 32;
  v9 = a3 / 32;
  if ( a2 / 32 < 0 )
    v10 = 0;
  if ( v9 < 0 )
    v9 = 0;
  if ( v10 > 14 )
    v10 = 14;
  if ( v9 > 14 )
    v9 = 14;
  if ( *(_DWORD *)(thisa + 486) == v10 && *(_DWORD *)(thisa + 490) == v9 )
    return 1;
  *(_DWORD *)(thisa + 54) = -1;
  *(_DWORD *)(thisa + 486) = v10;
  *(_DWORD *)(thisa + 490) = v9;
  *(_DWORD *)(thisa + 494) = v10 + *(_DWORD *)(thisa + 470);
  *(_DWORD *)(thisa + 498) = v9 + *(_DWORD *)(thisa + 474);
  if ( *(_QWORD *)(thisa + 494) < 0i64
    || *(_DWORD *)(thisa + 494) > MAP_WIDTH - 1
    || *(_DWORD *)(thisa + 498) > MAP_HEIGHT - 1
    || !(unsigned __int8)(*(&mapRevealed[*(_DWORD *)(thisa + 494)] + MAP_WIDTH * *(_DWORD *)(thisa + 498)) & giCurPlayerBit) )
  {
    mouseManager::SetPointer(gpMouseManager, 0);
    return 1;
  }
  v8 = (int)advManager::GetCell((advManager *)thisa, *(_DWORD *)(thisa + 494), *(_DWORD *)(thisa + 498));
  if ( gpCurPlayer->curHeroIdx == -1 )
  {
    if ( (*(_BYTE *)(v8 + 9) & 0x7F) != 35
      || gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)].ownerIdx != giCurPlayer )
    {
      if ( (*(_BYTE *)(v8 + 9) & 0x7F) != 42
        || gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)].ownerIdx != giCurPlayer )
      {
        mouseManager::SetPointer(gpMouseManager, 0);
        result = 1;
      }
      else
      {
        mouseManager::SetPointer(gpMouseManager, 2);
        *(_DWORD *)(thisa + 54) = 2;
        result = 1;
      }
    }
    else
    {
      mouseManager::SetPointer(gpMouseManager, 3);
      *(_DWORD *)(thisa + 54) = 3;
      result = 1;
    }
    return result;
  }
  v7 = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  if ( v10 == gpGame->heroes[gpCurPlayer->curHeroIdx].x - *(_DWORD *)(thisa + 470)
    && v9 == gpGame->heroes[gpCurPlayer->curHeroIdx].y - *(_DWORD *)(thisa + 474) )
  {
    mouseManager::SetPointer(gpMouseManager, 2);
    *(_DWORD *)(thisa + 54) = 2;
    return 1;
  }
  if ( !(*(_BYTE *)(v8 + 8) & 8) )
  {
    if ( *(_DWORD *)(thisa + 634) != 6
      && !giGroundToTerrain[*(_WORD *)v8]
      && *(_BYTE *)(v8 + 9) != 170
      && *(_BYTE *)(v8 + 9) != 171
      && *(_BYTE *)(v8 + 9) != 160
      || *(_DWORD *)(thisa + 634) == 6 && giGroundToTerrain[*(_WORD *)v8] && *(_BYTE *)(v8 + 9) != 28 )
    {
      gpSearchArray->field_8 = 0;
      mouseManager::SetPointer(gpMouseManager, 0);
      return 1;
    }
    advManager::SeedTo(thisa, *(_QWORD *)(thisa + 494));
    if ( !(*(&gpSearchArray->field_2414[MAP_WIDTH * *(_DWORD *)(thisa + 498)].field_4 + 9 * *(_DWORD *)(thisa + 494)) & 1) )
    {
      mouseManager::SetPointer(gpMouseManager, 0);
      return 1;
    }
    if ( (signed int)*(__int16 *)((char *)&gpSearchArray->field_2414[MAP_WIDTH * *(_DWORD *)(thisa + 498)].field_2
                                + 9 * *(_DWORD *)(thisa + 494)) > *(_DWORD *)(v7 + 53) )
    {
      v6 = (*(__int16 *)((char *)&gpSearchArray->field_2414[MAP_WIDTH * *(_DWORD *)(thisa + 498)].field_2
                       + 9 * *(_DWORD *)(thisa + 494))
          - *(_DWORD *)(v7 + 53))
         / *(_DWORD *)(v7 + 49)
         + 1;
      if ( v6 > 3 )
        v6 = 3;
    }
    else
    {
      v6 = 0;
    }
    spriteIdxArg = 6 * v6;
    switch ( *(_BYTE *)(v8 + 9) & 0x7F )
    {
      case 0x2B:
        if ( *(_DWORD *)(thisa + 634) == 6 )
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg);
        }
        else
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 6);
          *(_DWORD *)(thisa + 54) = 1;
        }
        return 1;
      case 0x1C:
        if ( *(_DWORD *)(thisa + 634) == 6 )
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 7);
        }
        else if ( *(&mapRevealed[*(_DWORD *)(thisa + 494)] + MAP_WIDTH * *(_DWORD *)(thisa + 498)) & 0x80 )
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 5);
        }
        else
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 4);
        }
        *(_DWORD *)(thisa + 54) = 1;
        return 1;
      case 0x18:
        mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 5);
        *(_DWORD *)(thisa + 54) = 1;
        return 1;
      case 0x2A:
        if ( gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)].ownerIdx == giCurPlayer )
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 8);
          *(_DWORD *)(thisa + 54) = 1;
        }
        else
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 5);
          *(_DWORD *)(thisa + 54) = 1;
        }
        return 1;
      case 0x23:
        if ( !(*(_BYTE *)(v8 + 9) & 0x80)
          || gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)].ownerIdx == giCurPlayer
          || !town::HasGarrison(&gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)]) )
          goto LABEL_69;
        mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 5);
        *(_DWORD *)(thisa + 54) = 1;
        return 1;
      default:
LABEL_69:
        if ( !(*(&mapRevealed[*(_DWORD *)(thisa + 494)] + MAP_WIDTH * *(_DWORD *)(thisa + 498)) & 0x80)
          || *(_DWORD *)(thisa + 634) == 6
          || *(_BYTE *)(v8 + 9) & 0x80 && StopOnTrigger(v8) )
        {
          if ( *(_BYTE *)(v8 + 9) & 0x80 )
          {
            if ( *(_DWORD *)(thisa + 634) == 6 )
            {
              if ( giGroundToTerrain[*(_WORD *)v8] )
                mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 6);
              else
                mouseManager::SetPointer(gpMouseManager, v6 + 28);
            }
            else if ( giGroundToTerrain[*(_WORD *)v8] )
            {
              mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 9);
            }
            else
            {
              if ( *(_BYTE *)(v8 + 9) != 160 )
              {
                mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 4);
                return 1;
              }
              mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 9);
            }
          }
          else if ( *(_DWORD *)(thisa + 634) == 6 )
          {
            mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 6);
          }
          else
          {
            mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 4);
          }
        }
        else
        {
          mouseManager::SetPointer(gpMouseManager, spriteIdxArg + 5);
        }
        *(_DWORD *)(thisa + 54) = 1;
        return 1;
    }
  }
  if ( (*(_BYTE *)(v8 + 9) & 0x7F) != 35
    || gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v8 + 4) >> 8) >> -5)].ownerIdx != giCurPlayer )
  {
    gpSearchArray->field_8 = 0;
    mouseManager::SetPointer(gpMouseManager, 0);
    result = 1;
  }
  else
  {
    mouseManager::SetPointer(gpMouseManager, 3);
    *(_DWORD *)(thisa + 54) = 5;
    result = 1;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (00447A00) --------------------------------------------------------
void __thiscall advManager::UpdateScreen(advManager *this, int a2, int a3)
{
  if ( a3 || bShowIt )
  {
    PollSound();
    giScrollX = this->field_1F6;
    giScrollY = this->field_1FA;
    if ( giLimitUpdMinX == -1 )
      BlitBitmapToScreen(gpWindowManager->screenBuffer, 16, 16, 0x1C0u, 448, 16, 16);
    else
      BlitBitmapToScreen(
        gpWindowManager->screenBuffer,
        giLimitUpdMinX,
        giLimitUpdMinY,
        giLimitUpdMaxX - giLimitUpdMinX,
        giLimitUpdMaxY - giLimitUpdMinY,
        giLimitUpdMinX,
        giLimitUpdMinY);
    giScrollY = 0;
    giScrollX = 0;
    PollSound();
    if ( KBTickCount() > glTimers )
    {
      ++this->field_202;
      ++this->field_1FE;
      if ( this->field_1FE >= 6 )
        this->field_1FE = 0;
      glTimers = KBTickCount() + 120;
      if ( this->field_1FE != 1 && this->field_1FE != 3 && this->field_1FE != 5 )
      {
        ++this->field_20A;
        this->field_20A %= 18;
        ++this->field_212;
        this->field_212 %= 18;
      }
      else
      {
        ++this->field_20E;
        this->field_20E %= 18;
        ++this->field_216;
        this->field_216 %= 18;
      }
    }
    giLimitUpdMinX = -1;
    Process1WindowsMessage();
  }
  else if ( KBTickCount() > glTimers )
  {
    glTimers = KBTickCount() + 120;
  }
}
// 4F2E78: using guessed type int giScrollX;
// 4F2E7C: using guessed type int giScrollY;
// 524C14: using guessed type int bShowIt;
// 524D18: using guessed type int giLimitUpdMaxX;
// 524D1C: using guessed type int giLimitUpdMaxY;

//----- (00447C20) --------------------------------------------------------
void __thiscall advManager::CompleteDraw(advManager *ecx0, int left, int top, int a6, int a5)
{
  int v5; // edx@1
  signed int a4; // [sp+10h] [bp-8h]@5
  signed int a4a; // [sp+10h] [bp-8h]@11
  signed int a4b; // [sp+10h] [bp-8h]@20
  signed int a4c; // [sp+10h] [bp-8h]@46
  signed int a4d; // [sp+10h] [bp-8h]@52
  int a3; // [sp+14h] [bp-4h]@7
  int a3a; // [sp+14h] [bp-4h]@13
  int a3b; // [sp+14h] [bp-4h]@17
  int a3c; // [sp+14h] [bp-4h]@23
  int a3d; // [sp+14h] [bp-4h]@26
  int a3e; // [sp+14h] [bp-4h]@30
  int a3f; // [sp+14h] [bp-4h]@33
  int a3g; // [sp+14h] [bp-4h]@36
  int a3h; // [sp+14h] [bp-4h]@40
  int a3i; // [sp+14h] [bp-4h]@43
  int a3j; // [sp+14h] [bp-4h]@48
  int a3k; // [sp+14h] [bp-4h]@54

  PollSound();
  if ( a6 || bShowIt )
  {
    giLimitUpdMinX = -1;
    ecx0->field_1DE = ecx0->viewX;
    ecx0->field_1E2 = ecx0->viewY;
    if ( gbAllBlack )
    {
      ecx0->viewY = 0;
      ecx0->viewX = ecx0->viewY;
    }
    gpMouseManager->couldBeShowMouse = 0;
    ecx0->field_2A2 = 0;
    ecx0->field_2AE = 0;
    for ( a4 = 0; a4 < 15; ++a4 )
    {
      for ( a3 = 0; a3 < 15; ++a3 )
        advManager::DrawCell(ecx0, a3 + left, top + a4, a3, a4, 1, a6);
    }
    for ( a4a = 0; a4a < 15; ++a4a )
    {
      for ( a3a = 0; a3a < 15; ++a3a )
        advManager::DrawCell(ecx0, a3a + left, top + a4a, a3a, a4a, -128, a6);
    }
    for ( a3b = 0; a3b < 15; ++a3b )
      advManager::DrawCell(ecx0, a3b + left, top, a3b, 0, 2, a6);
    for ( a4b = 1; a4b < 15; ++a4b )
    {
      PollSound();
      if ( ecx0->field_27E <= 4 )
      {
        for ( a3e = 14; a3e >= 0; --a3e )
          advManager::DrawCell(ecx0, a3e + left, top + a4b - 1, a3e, a4b - 1, 8, a6);
        for ( a3f = 14; a3f >= 0; --a3f )
          advManager::DrawCell(ecx0, a3f + left, top + a4b - 1, a3f, a4b - 1, 4, a6);
      }
      else
      {
        for ( a3c = 0; a3c < 15; ++a3c )
          advManager::DrawCell(ecx0, a3c + left, top + a4b - 1, a3c, a4b - 1, 8, a6);
        for ( a3d = 0; a3d < 15; ++a3d )
          advManager::DrawCell(ecx0, a3d + left, top + a4b - 1, a3d, a4b - 1, 4, a6);
      }
      for ( a3g = 0; a3g < 15; ++a3g )
        advManager::DrawCell(ecx0, a3g + left, top + a4b, a3g, a4b, 2, a6);
    }
    for ( a3h = 0; a3h < 15; ++a3h )
      advManager::DrawCell(ecx0, a3h + left, top + 14, a3h, 14, 8, a6);
    for ( a3i = 0; a3i < 15; ++a3i )
      advManager::DrawCell(ecx0, a3i + left, top + 14, a3i, 14, 4, a6);
    for ( a4c = 0; a4c < 15; ++a4c )
    {
      for ( a3j = 0; a3j < 15; ++a3j )
        advManager::DrawCell(ecx0, a3j + left, top + a4c, a3j, a4c, 64, a6);
    }
    for ( a4d = 0; a4d < 15; ++a4d )
    {
      for ( a3k = 0; a3k < 15; ++a3k )
        advManager::DrawCell(ecx0, a3k + left, top + a4d, a3k, a4d, 32, a6);
    }
    advManager::DrawAdventureBorder((int)ecx0, v5);
    gpMouseManager->couldBeShowMouse = 1;
    PollSound();
    if ( a5 )
      advManager::UpdBottomView(ecx0, 0, 1, 1);
    if ( gbAllBlack )
    {
      ecx0->viewX = ecx0->field_1DE;
      ecx0->viewY = ecx0->field_1E2;
    }
  }
}
// 4F7470: using guessed type int gbAllBlack;
// 524C14: using guessed type int bShowIt;

//----- (00448110) --------------------------------------------------------
void __thiscall advManager::CompleteDraw(advManager *this, int a4)
{
  advManager::CompleteDraw(this, this->viewX, this->viewY, a4, 1);
}

//----- (00448150) --------------------------------------------------------
int __stdcall advManager::GetCloudLookup(int a1, int a2)
{
  signed int v3; // [sp+10h] [bp-4h]@1

  v3 = 0;
  if ( a1 >= 1 )
  {
    if ( MAP_WIDTH - 1 <= a1 )
      v3 = 50;
  }
  else
  {
    v3 = 200;
  }
  if ( a2 >= 1 )
  {
    if ( MAP_HEIGHT - 1 <= a2 )
      v3 |= 0x64u;
  }
  else
  {
    v3 |= 0x91u;
  }
  if ( v3 )
  {
    if ( !(v3 & 1) && !(unsigned __int8)(*(&mapRevealed[a1] + MAP_WIDTH * (a2 - 1)) & giCurWatchPlayerBit) )
      v3 |= 1u;
    if ( !(v3 & 2) && !(unsigned __int8)(*(&mapRevealed[a2 * MAP_WIDTH + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 2u;
    if ( !(v3 & 4) && !(unsigned __int8)(*(&mapRevealed[a1] + MAP_WIDTH * (a2 + 1)) & giCurWatchPlayerBit) )
      v3 |= 4u;
    if ( !(v3 & 8) && !(unsigned __int8)(*(&mapRevealed[a2 * MAP_WIDTH - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 8u;
    if ( !(v3 & 0x10) && !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 - 1) + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x10u;
    if ( !(v3 & 0x20) && !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 + 1) + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x20u;
    if ( !(v3 & 0x40) && !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 + 1) - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x40u;
    if ( !(v3 & 0x80) && !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 - 1) - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x80u;
  }
  else
  {
    if ( !(unsigned __int8)(*(&mapRevealed[a1] + MAP_WIDTH * (a2 - 1)) & giCurWatchPlayerBit) )
      v3 = 1;
    if ( !(unsigned __int8)(*(&mapRevealed[a2 * MAP_WIDTH + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 2u;
    if ( !(unsigned __int8)(*(&mapRevealed[a1] + MAP_WIDTH * (a2 + 1)) & giCurWatchPlayerBit) )
      v3 |= 4u;
    if ( !(unsigned __int8)(*(&mapRevealed[a2 * MAP_WIDTH - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 8u;
    if ( !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 - 1) + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x10u;
    if ( !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 + 1) + 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x20u;
    if ( !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 + 1) - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x40u;
    if ( !(unsigned __int8)(*(&mapRevealed[MAP_WIDTH * (a2 - 1) - 1] + a1) & giCurWatchPlayerBit) )
      v3 |= 0x80u;
  }
  return (unsigned __int8)giCloudType[v3];
}
// 448150: using guessed type _DWORD __stdcall advManager__GetCloudLookup(_DWORD, _DWORD);
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5306F0: using guessed type char giCurWatchPlayerBit;

//----- (00448500) --------------------------------------------------------
void __thiscall advManager::DrawCell(advManager *this, int x, int y, int a3, int a4, char a5, int a6)
{
  signed int v8; // [sp+10h] [bp-18h]@201
  signed int v9; // [sp+14h] [bp-14h]@194
  int v10; // [sp+1Ch] [bp-Ch]@199
  int v11; // [sp+20h] [bp-8h]@182
  int v12; // [sp+24h] [bp-4h]@127

  if ( !a6 && !bShowIt )
    return;
  dword_524D10 = 32 * a3;
  ::y = 32 * a4;
  currentlyDrawnMapTile = advManager::GetCell(this, x, y);
  if ( !gbAllBlack && ((signed __int64)__PAIR__(y, x) < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) )
  {
    idx = -1;
    if ( x == -1 )
    {
      if ( y == -1 )
      {
        idx = 16;
      }
      else if ( y == MAP_HEIGHT )
      {
        idx = 19;
      }
      else if ( y >= 0 && y < MAP_HEIGHT )
      {
        idx = (y & 3) + 32;
      }
    }
    else if ( x == MAP_WIDTH )
    {
      if ( y == -1 )
      {
        idx = 17;
      }
      else if ( y == MAP_HEIGHT )
      {
        idx = 18;
      }
      else if ( y >= 0 && y < MAP_HEIGHT )
      {
        idx = (y & 3) + 24;
      }
    }
    else if ( y == -1 )
    {
      if ( x >= 0 && x < MAP_WIDTH )
        idx = (x & 3) + 20;
    }
    else if ( y == MAP_HEIGHT && x >= 0 && x < MAP_WIDTH )
    {
      idx = (x & 3) + 28;
    }
    if ( idx == -1 )
      idx = (((unsigned __int64)(x + 16) >> 32) ^ abs(x + 16) & 3)
          + 4 * ((((unsigned __int64)(y + 16) >> 32) ^ abs(y + 16) & 3) - ((unsigned __int64)(y + 16) >> 32))
          - ((unsigned __int64)(x + 16) >> 32);
    TileToBitmap(this->stonTileset, idx, gpWindowManager->screenBuffer, dword_524D10, ::y);
    return;
  }
  if ( !gbAllBlack && (unsigned __int8)(*(&mapRevealed[x] + MAP_WIDTH * y) & giCurWatchPlayerBit) || gbDrawingPuzzle )
  {
    dword_524CF8 = 0;
  }
  else
  {
    dword_524CF8 = 1;
    if ( gbAllBlack )
      dword_524D24 = 0;
    else
      dword_524D24 = advManager::GetCloudLookup(x, y);
    if ( !dword_524D24 )
    {
      if ( a5 & 0x20 )
        TileToBitmap(this->clofTileset, ((_BYTE)x + (_BYTE)y) & 3, gpWindowManager->screenBuffer, dword_524D10, ::y);
      return;
    }
    if ( dword_524D24 < 100 )
    {
      dword_524CD4 = 0;
    }
    else
    {
      dword_524CD4 = 1;
      dword_524D24 -= 100;
    }
    if ( (dword_524D24 == 1 || dword_524D24 == 5) && x & 1 )
      ++dword_524D24;
    if ( dword_524D24 == 3 && y & 1 )
      ++dword_524D24;
  }
  if ( !(a5 & 0x20) || gbDrawingPuzzle )
  {
    if ( a5 & 1 )
    {
      LOWORD(word_524CAC) = currentlyDrawnMapTile->displayFlags;
      LOWORD(word_524CAC) = (_WORD)word_524CAC << 14;
      LOWORD(word_524CAC) = word_524CAC | currentlyDrawnMapTile->groundIndex;
      TileToBitmap(this->groundTileset, (unsigned __int16)word_524CAC, gpWindowManager->screenBuffer, dword_524D10, ::y);
      if ( currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo & 1
        && (!gbDrawingPuzzle
         || (((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 56
         || currentlyDrawnMapTile->objectIndex != 140) )
      {
        if ( !gbDrawingPuzzle
          || bPuzzleDraw[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F] )
        {
          IconToBitmap(
            (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawnMapTile->objectIndex,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
                             currentlyDrawnMapTile->objectIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawnMapTile->objectIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
      }
      if ( currentlyDrawnMapTile->extraIdx
        && *(&this->map->cellExtras->objectIndex + 8 * currentlyDrawnMapTile->extraIdx - currentlyDrawnMapTile->extraIdx) != 255 )
        currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                      + 8 * currentlyDrawnMapTile->extraIdx
                                                      - currentlyDrawnMapTile->extraIdx);
      else
        currentlyDrawingMapCellExtra = 0;
      while ( currentlyDrawingMapCellExtra )
      {
        if ( currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 & 1
          && (!gbDrawingPuzzle || bPuzzleDraw[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F]) )
        {
          IconToBitmap(
            (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawingMapCellExtra->objectIndex,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawingMapCellExtra->_1_q_7_objTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
                             currentlyDrawingMapCellExtra->objectIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawingMapCellExtra->objectIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
        if ( currentlyDrawingMapCellExtra->nextIdx
          && *(&this->map->cellExtras->objectIndex
             + 8 * currentlyDrawingMapCellExtra->nextIdx
             - currentlyDrawingMapCellExtra->nextIdx) != 255 )
          currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                        + 8 * currentlyDrawingMapCellExtra->nextIdx
                                                        - currentlyDrawingMapCellExtra->nextIdx);
        else
          currentlyDrawingMapCellExtra = 0;
      }
      if ( (currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1
        && !(currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo & 1)
        && (!gbDrawingPuzzle
         || bPuzzleDraw[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F]) )
      {
        IconToBitmap(
          (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
          gpWindowManager->screenBuffer,
          dword_524D10,
          ::y,
          currentlyDrawnMapTile->objectIndex,
          0,
          0,
          0,
          0x1E0u,
          480,
          0);
        if ( currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset & 1 )
        {
          dword_524CE4 = GetIconEntry(
                           (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
                           currentlyDrawnMapTile->objectIndex)->someSortOfLength & 0x1F;
          IconToBitmap(
            (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawnMapTile->objectIndex + this->field_202 % dword_524CE4 + 1,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
        }
      }
      if ( currentlyDrawnMapTile->extraIdx
        && *(&this->map->cellExtras->objectIndex + 8 * currentlyDrawnMapTile->extraIdx - currentlyDrawnMapTile->extraIdx) != 255 )
        currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                      + 8 * currentlyDrawnMapTile->extraIdx
                                                      - currentlyDrawnMapTile->extraIdx);
      else
        currentlyDrawingMapCellExtra = 0;
      while ( currentlyDrawingMapCellExtra )
      {
        if ( ((unsigned __int8)currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 >> 1) & 1
          && !(currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 & 1)
          && (!gbDrawingPuzzle || bPuzzleDraw[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F]) )
        {
          IconToBitmap(
            (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawingMapCellExtra->objectIndex,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawingMapCellExtra->_1_q_7_objTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
                             currentlyDrawingMapCellExtra->objectIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawingMapCellExtra->objectIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
        if ( currentlyDrawingMapCellExtra->nextIdx
          && *(&this->map->cellExtras->objectIndex
             + 8 * currentlyDrawingMapCellExtra->nextIdx
             - currentlyDrawingMapCellExtra->nextIdx) != 255 )
          currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                        + 8 * currentlyDrawingMapCellExtra->nextIdx
                                                        - currentlyDrawingMapCellExtra->nextIdx);
        else
          currentlyDrawingMapCellExtra = 0;
      }
    }
    if ( a5 & 2 )
    {
      if ( currentlyDrawnMapTile->objectIndex != 255
        && !(currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo & 1)
        && !((currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1)
        && !((currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 2) & 1)
        && (((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 12
        && (!gbDrawingPuzzle
         || bPuzzleDraw[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F]) )
      {
        IconToBitmap(
          (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
          gpWindowManager->screenBuffer,
          dword_524D10,
          ::y,
          currentlyDrawnMapTile->objectIndex,
          0,
          0,
          0,
          0x1E0u,
          480,
          0);
        if ( currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset & 1 )
        {
          dword_524CE4 = GetIconEntry(
                           (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
                           currentlyDrawnMapTile->objectIndex)->someSortOfLength & 0x1F;
          v12 = this->field_202 % dword_524CE4;
          if ( currentlyDrawnMapTile->objType == 223 )
          {
            if ( (unsigned __int8)(currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
              v12 = this->field_202 % (dword_524CE4 - 1);
            else
              v12 = dword_524CE4 - 1;
          }
          IconToBitmap(
            (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            v12 + currentlyDrawnMapTile->objectIndex + 1,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
        }
      }
      if ( currentlyDrawnMapTile->extraIdx
        && *(&this->map->cellExtras->objectIndex + 8 * currentlyDrawnMapTile->extraIdx - currentlyDrawnMapTile->extraIdx) != 255 )
        currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                      + 8 * currentlyDrawnMapTile->extraIdx
                                                      - currentlyDrawnMapTile->extraIdx);
      else
        currentlyDrawingMapCellExtra = 0;
      while ( currentlyDrawingMapCellExtra )
      {
        if ( !(currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 & 1)
          && !(((unsigned __int8)currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 >> 1) & 1)
          && !(((unsigned __int8)currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 >> 2) & 1)
          && ((currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F) != 12
          && (!gbDrawingPuzzle || bPuzzleDraw[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F]) )
        {
          IconToBitmap(
            (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawingMapCellExtra->objectIndex,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawingMapCellExtra->_1_q_7_objTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
                             currentlyDrawingMapCellExtra->objectIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawingMapCellExtra->objectIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
        if ( currentlyDrawingMapCellExtra->nextIdx
          && *(&this->map->cellExtras->objectIndex
             + 8 * currentlyDrawingMapCellExtra->nextIdx
             - currentlyDrawingMapCellExtra->nextIdx) != 255 )
          currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                        + 8 * currentlyDrawingMapCellExtra->nextIdx
                                                        - currentlyDrawingMapCellExtra->nextIdx);
        else
          currentlyDrawingMapCellExtra = 0;
      }
    }
    if ( (a5 & 8 || a5 & 0x80) && !gbDrawingPuzzle )
    {
      dword_524D04 = 0;
      dword_524CDC = 0;
      if ( a5 & 8 )
      {
        if ( x > 0 )
        {
          dword_524D08 = (int)advManager::GetCell(this, x - 1, y);
          if ( *(_BYTE *)(dword_524D08 + 9) == 151 )
          {
            dword_524EA8 = (int)&gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(dword_524D08 + 4) >> 8) >> -5)];
            if ( *(_BYTE *)(dword_524EA8 + 3) == 59 )
            {
              IconToBitmap(
                (icon *)this->field_CE[10],
                gpWindowManager->screenBuffer,
                dword_524D10 - 16,
                ::y,
                (x + y + this->field_202) % 15,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
            else if ( *(_BYTE *)(dword_524EA8 + 3) != -1 )
            {
              IconToBitmap(
                (icon *)this->field_CE[39],
                gpWindowManager->screenBuffer,
                dword_524D10 - 32,
                ::y,
                *(_BYTE *)(dword_524EA8 + 3) - 62,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
          }
        }
        if ( (((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 12 )
        {
          if ( this->field_2B2 != x || this->field_2B6 != y )
          {
            IconToBitmap(
              (icon *)this->field_CE[20],
              gpWindowManager->screenBuffer,
              dword_524D10 + 16,
              ::y + 30,
              9 * currentlyDrawnMapTile->objectIndex,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
            if ( currentlyDrawnMapTile->objectIndex != 59 && currentlyDrawnMapTile->objectIndex != 60 )
              dword_524D14 = (unsigned __int8)monAnimDrawFrame[*(&this->field_20A + (x & 3))];
            else
              dword_524D14 = *(&this->field_20A + (x & 3)) % 6;
            IconToBitmap(
              (icon *)this->field_CE[20],
              gpWindowManager->screenBuffer,
              dword_524D10 + 16,
              ::y + 30,
              dword_524D14 + 9 * currentlyDrawnMapTile->objectIndex + 1,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
          else
          {
            IconToBitmap(
              (icon *)this->field_CE[20],
              gpWindowManager->screenBuffer,
              dword_524D10 + 16,
              ::y + 30,
              8 - (this->field_2BA < 1u) + 9 * currentlyDrawnMapTile->objectIndex,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
      }
      if ( currentlyDrawnMapTile->objType == 171 )
      {
        dword_524E74 = -1;
        dword_524EA0 = 6;
        spriteIdx = advManager::GetCursorBaseFrame(gpGame->boats[(unsigned __int8)((unsigned __int8)(currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].field_3);
        dword_524D04 = 1;
        dword_524D2C = -10;
      }
      else
      {
        dword_524D2C = 0;
        if ( currentlyDrawnMapTile->objType == 170 )
        {
          dword_524CDC = (int)&gpGame->heroes[(unsigned __int8)((unsigned __int8)(currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
          dword_524E74 = gpGame->players[*(_BYTE *)(dword_524CDC + 3)].color;
          dword_524EA0 = *(_BYTE *)(dword_524CDC + 227) & 0x80 ? 6 : *(_BYTE *)(dword_524CDC + 23);
          spriteIdx = advManager::GetCursorBaseFrame(*(_BYTE *)(dword_524CDC + 44));
          dword_524D04 = 1;
          if ( *(_BYTE *)(dword_524CDC + 227) & 0x80 )
            dword_524D2C = -10;
        }
      }
      if ( dword_524D04 )
      {
        if ( spriteIdx & 0x80 )
        {
          if ( a5 & 0x80 )
          {
            if ( this->field_276 && dword_524EA0 != 6 )
            {
              v11 = spriteIdx & 0x7F;
              if ( v11 == 51 )
                v11 = 56;
              if ( v11 == 50 )
                v11 = 57;
              if ( v11 == 49 )
                v11 = 58;
              if ( v11 == 47 )
                v11 = 55;
              if ( v11 == 46 )
                v11 = 55;
              if ( v11 < 9 || v11 >= 36 )
                v9 = 0;
              else
                v9 = 50;
              IconToBitmap(
                this->shadowIcon,
                gpWindowManager->screenBuffer,
                dword_524D10,
                ::y + 31,
                v9 + v11,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
            if ( this->field_276 && dword_524EA0 == 6 )
            {
              v10 = spriteIdx & 0x7F;
              if ( v10 < 9 || v10 >= 36 )
                v8 = 0;
              else
                v8 = 36;
              IconToBitmap(
                this->boatShadowIcon,
                gpWindowManager->screenBuffer,
                dword_524D10,
                dword_524D2C + ::y + 31,
                v8 + v10,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
          }
          else
          {
            if ( dword_524EA0 == 6 && !(currentlyDrawnMapTile->displayFlags & 4) )
              FlipIconToBitmap(
                this->frothIcon,
                gpWindowManager->screenBuffer,
                dword_524D10 + 32,
                dword_524D2C + ::y + 31,
                spriteIdx & 0x7F,
                1,
                0,
                0,
                480,
                480,
                0);
            FlipIconToBitmap(
              (icon *)this->heroIcons[dword_524EA0],
              gpWindowManager->screenBuffer,
              dword_524D10 + 32,
              dword_524D2C + ::y + 31,
              spriteIdx & 0x7F,
              1,
              0,
              0,
              480,
              480,
              0);
            if ( dword_524E74 != -1 )
            {
              if ( dword_524EA0 == 6 )
                FlipIconToBitmap(
                  (icon *)this->flagIcons2[dword_524E74],
                  gpWindowManager->screenBuffer,
                  dword_524D10 + 32,
                  dword_524D2C + ::y + 31,
                  spriteIdx & 0x7F,
                  1,
                  0,
                  0,
                  480,
                  480,
                  0);
              else
                FlipIconToBitmap(
                  (icon *)this->flagIcons1[dword_524E74],
                  gpWindowManager->screenBuffer,
                  dword_524D10 + 32,
                  ::y + 31,
                  (spriteIdx & 0x7F)
                + (((unsigned __int64)this->field_202 >> 32) ^ abs(this->field_202) & 7)
                - ((unsigned __int64)this->field_202 >> 32)
                + 56,
                  1,
                  0,
                  0,
                  480,
                  480,
                  0);
            }
          }
        }
        else if ( a5 & 0x80 )
        {
          if ( this->field_276 && dword_524EA0 != 6 && a5 & 0x80 )
            IconToBitmap(
              this->shadowIcon,
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y + 31,
              spriteIdx,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
          if ( this->field_276 && dword_524EA0 == 6 )
            IconToBitmap(
              this->boatShadowIcon,
              gpWindowManager->screenBuffer,
              dword_524D10,
              dword_524D2C + ::y + 31,
              spriteIdx,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
        }
        else
        {
          if ( dword_524EA0 == 6 && !(currentlyDrawnMapTile->displayFlags & 4) )
            IconToBitmap(
              this->frothIcon,
              gpWindowManager->screenBuffer,
              dword_524D10,
              dword_524D2C + ::y + 31,
              spriteIdx,
              1,
              0,
              0,
              0x1E0u,
              480,
              0);
          IconToBitmap(
            (icon *)this->heroIcons[dword_524EA0],
            gpWindowManager->screenBuffer,
            dword_524D10,
            dword_524D2C + ::y + 31,
            spriteIdx,
            1,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( dword_524E74 != -1 )
          {
            if ( dword_524EA0 == 6 )
              IconToBitmap(
                (icon *)this->flagIcons2[dword_524E74],
                gpWindowManager->screenBuffer,
                dword_524D10,
                dword_524D2C + ::y + 31,
                spriteIdx & 0x7F,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
            else
              IconToBitmap(
                (icon *)this->flagIcons1[dword_524E74],
                gpWindowManager->screenBuffer,
                dword_524D10,
                ::y + 31,
                (spriteIdx & 0x7F)
              + (((unsigned __int64)this->field_202 >> 32) ^ abs(this->field_202) & 7)
              - ((unsigned __int64)this->field_202 >> 32)
              + 56,
                1,
                0,
                0,
                0x1E0u,
                480,
                0);
          }
        }
      }
      if ( this->field_272
        && currentlyDrawnMapTile->displayFlags & 0x40
        && (!this->field_2A2 || a5 & 0x80)
        && this->viewX + 7 == x
        && this->viewY + 7 == y
        && !(a5 & 0x80) )
      {
        advManager::DrawCursorShadow(this);
        advManager::DrawCursor(this);
        this->field_2A2 = 1;
      }
    }
    if ( a5 & 4 || a5 & 0x40 )
    {
      if ( a5 & 4 && currentlyDrawnMapTile->objectIndex != 255 )
      {
        if ( (currentlyDrawnMapTile->field_4_1_1_isShadow_1_13_extraInfo >> 2) & 1
          && (!gbDrawingPuzzle
           || bPuzzleDraw[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F]) )
        {
          IconToBitmap(
            (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawnMapTile->objectIndex,
            0,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
                             currentlyDrawnMapTile->objectIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawnMapTile->objectIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
        if ( currentlyDrawnMapTile->extraIdx
          && *(&this->map->cellExtras->objectIndex
             + 8 * currentlyDrawnMapTile->extraIdx
             - currentlyDrawnMapTile->extraIdx) != 255 )
          currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                        + 8 * currentlyDrawnMapTile->extraIdx
                                                        - currentlyDrawnMapTile->extraIdx);
        else
          currentlyDrawingMapCellExtra = 0;
        while ( currentlyDrawingMapCellExtra )
        {
          if ( ((unsigned __int8)currentlyDrawingMapCellExtra->field_4_1_1_1_isShadow_5 >> 2) & 1
            && (!gbDrawingPuzzle || bPuzzleDraw[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F]) )
          {
            IconToBitmap(
              (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawingMapCellExtra->objectIndex,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
            if ( currentlyDrawingMapCellExtra->_1_q_7_objTileset & 1 )
            {
              dword_524CE4 = GetIconEntry(
                               (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
                               currentlyDrawingMapCellExtra->objectIndex)->someSortOfLength & 0x1F;
              IconToBitmap(
                (icon *)this->field_CE[(currentlyDrawingMapCellExtra->_1_q_7_objTileset >> 1) & 0x7F],
                gpWindowManager->screenBuffer,
                dword_524D10,
                ::y,
                currentlyDrawingMapCellExtra->objectIndex + this->field_202 % dword_524CE4 + 1,
                0,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
          }
          if ( currentlyDrawingMapCellExtra->nextIdx
            && *(&this->map->cellExtras->objectIndex
               + 8 * currentlyDrawingMapCellExtra->nextIdx
               - currentlyDrawingMapCellExtra->nextIdx) != 255 )
            currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                          + 8 * currentlyDrawingMapCellExtra->nextIdx
                                                          - currentlyDrawingMapCellExtra->nextIdx);
          else
            currentlyDrawingMapCellExtra = 0;
        }
      }
      if ( currentlyDrawnMapTile->overlayIndex != 255
        && (a5 & 4
         && !(((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 1) & 1)
         || a5 & 0x40
         && ((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 1) & 1) )
      {
        if ( !gbDrawingPuzzle
          || bPuzzleDraw[((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F] )
        {
          IconToBitmap(
            (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F],
            gpWindowManager->screenBuffer,
            dword_524D10,
            ::y,
            currentlyDrawnMapTile->overlayIndex,
            (((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F) == 14,
            0,
            0,
            0x1E0u,
            480,
            0);
          if ( currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset & 1 )
          {
            dword_524CE4 = GetIconEntry(
                             (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F],
                             currentlyDrawnMapTile->overlayIndex)->someSortOfLength & 0x1F;
            IconToBitmap(
              (icon *)this->field_CE[((unsigned __int8)currentlyDrawnMapTile->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawnMapTile->overlayIndex + this->field_202 % dword_524CE4 + 1,
              0,
              0,
              0,
              0x1E0u,
              480,
              0);
          }
        }
      }
      if ( currentlyDrawnMapTile->extraIdx
        && *(&this->map->cellExtras->field_6 + 8 * currentlyDrawnMapTile->extraIdx - currentlyDrawnMapTile->extraIdx) != 255 )
        currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                      + 8 * currentlyDrawnMapTile->extraIdx
                                                      - currentlyDrawnMapTile->extraIdx);
      else
        currentlyDrawingMapCellExtra = 0;
      while ( currentlyDrawingMapCellExtra )
      {
        if ( a5 & 4 && !(((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 1) & 1)
          || a5 & 0x40 && ((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 1) & 1 )
        {
          if ( !gbDrawingPuzzle
            || bPuzzleDraw[((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F] )
          {
            IconToBitmap(
              (icon *)this->field_CE[((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F],
              gpWindowManager->screenBuffer,
              dword_524D10,
              ::y,
              currentlyDrawingMapCellExtra->field_6,
              (((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F) == 14,
              0,
              0,
              0x1E0u,
              480,
              0);
            if ( currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q & 1 )
            {
              dword_524CE4 = GetIconEntry(
                               (icon *)this->field_CE[((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F],
                               currentlyDrawingMapCellExtra->field_6)->someSortOfLength & 0x1F;
              IconToBitmap(
                (icon *)this->field_CE[((unsigned __int8)currentlyDrawingMapCellExtra->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F],
                gpWindowManager->screenBuffer,
                dword_524D10,
                ::y,
                currentlyDrawingMapCellExtra->field_6 + this->field_202 % dword_524CE4 + 1,
                0,
                0,
                0,
                0x1E0u,
                480,
                0);
            }
          }
        }
        if ( currentlyDrawingMapCellExtra->nextIdx
          && *(&this->map->cellExtras->field_6
             + 8 * currentlyDrawingMapCellExtra->nextIdx
             - currentlyDrawingMapCellExtra->nextIdx) != 255 )
          currentlyDrawingMapCellExtra = (mapCellExtra *)((char *)this->map->cellExtras
                                                        + 8 * currentlyDrawingMapCellExtra->nextIdx
                                                        - currentlyDrawingMapCellExtra->nextIdx);
        else
          currentlyDrawingMapCellExtra = 0;
      }
    }
  }
  else if ( dword_524CF8 )
  {
    if ( dword_524CD4 )
      FlipIconToBitmap(
        this->clopIcon,
        gpWindowManager->screenBuffer,
        dword_524D10 + 31,
        ::y,
        dword_524D24 - 1,
        0,
        0,
        0,
        0,
        0,
        0);
    else
      IconToBitmap(this->clopIcon, gpWindowManager->screenBuffer, dword_524D10, ::y, dword_524D24 - 1, 0, 0, 0, 0, 0, 0);
  }
  else if ( this->field_A2 && *(_WORD *)(2 * x + 2 * MAP_WIDTH * y + this->sizeOfSomethingMapRelated) )
  {
    if ( (*(_WORD *)(2 * x + 2 * MAP_WIDTH * y + this->sizeOfSomethingMapRelated) >> 8) & 1 )
      IconToBitmapColorTable(
        (icon *)this->field_CE[17],
        gpWindowManager->screenBuffer,
        dword_524D10 - 12,
        ::y + 2,
        (unsigned __int8)(*(_WORD *)(2 * x + 2 * MAP_WIDTH * y + this->sizeOfSomethingMapRelated) - 1),
        1,
        0,
        0,
        0x1E0u,
        480,
        0,
        gColorTableRed,
        1);
    else
      IconToBitmap(
        (icon *)this->field_CE[17],
        gpWindowManager->screenBuffer,
        dword_524D10 - 12,
        ::y + 2,
        (unsigned __int8)(*(_WORD *)(2 * x + 2 * MAP_WIDTH * y + this->sizeOfSomethingMapRelated) - 1),
        1,
        0,
        0,
        0x1E0u,
        480,
        0);
  }
}
// 448150: using guessed type _DWORD __stdcall advManager__GetCloudLookup(_DWORD, _DWORD);
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F5460: using guessed type int gbDrawingPuzzle;
// 4F7470: using guessed type int gbAllBlack;
// 524C14: using guessed type int bShowIt;
// 524CD4: using guessed type int dword_524CD4;
// 524CDC: using guessed type int dword_524CDC;
// 524CE4: using guessed type int dword_524CE4;
// 524CF8: using guessed type int dword_524CF8;
// 524D04: using guessed type int dword_524D04;
// 524D08: using guessed type int dword_524D08;
// 524D14: using guessed type int dword_524D14;
// 524D24: using guessed type int dword_524D24;
// 524D2C: using guessed type int dword_524D2C;
// 524E74: using guessed type int dword_524E74;
// 524EA0: using guessed type int dword_524EA0;
// 524EA8: using guessed type int dword_524EA8;
// 5306F0: using guessed type char giCurWatchPlayerBit;

//----- (0044A9E0) --------------------------------------------------------
mapCell *__thiscall advManager::GetCell(advManager *this, int col, int row)
{
  mapCell *result; // eax@4

  if ( (signed __int64)__PAIR__(row, col) >= 0 && MAP_WIDTH > col && MAP_HEIGHT > row )
    result = &this->map->tiles[row * this->map->width] + col;
  else
    result = this->map->tiles;
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (0044AA80) --------------------------------------------------------
void __thiscall advManager::UpdateRadar(advManager *this, int a2, int a3)
{
  advManager *v3; // [sp+4Ch] [bp-74h]@1
  signed int v4; // [sp+50h] [bp-70h]@84
  signed int v5; // [sp+54h] [bp-6Ch]@76
  signed int v6; // [sp+58h] [bp-68h]@66
  signed int v7; // [sp+5Ch] [bp-64h]@46
  int v8; // [sp+60h] [bp-60h]@50
  int v9; // [sp+64h] [bp-5Ch]@44
  int v10; // [sp+64h] [bp-5Ch]@65
  int v11; // [sp+64h] [bp-5Ch]@75
  int v12; // [sp+64h] [bp-5Ch]@83
  int v13; // [sp+68h] [bp-58h]@39
  int v14; // [sp+6Ch] [bp-54h]@13
  float v15; // [sp+74h] [bp-4Ch]@111
  int v16; // [sp+78h] [bp-48h]@65
  signed int v17; // [sp+7Ch] [bp-44h]@109
  int i; // [sp+80h] [bp-40h]@20
  signed int v19; // [sp+88h] [bp-38h]@2
  int v20; // [sp+8Ch] [bp-34h]@2
  int v21; // [sp+90h] [bp-30h]@65
  int a4; // [sp+94h] [bp-2Ch]@109
  int j; // [sp+9Ch] [bp-24h]@33
  signed int v24; // [sp+A0h] [bp-20h]@2
  int v25; // [sp+A4h] [bp-1Ch]@2
  int v26; // [sp+ACh] [bp-14h]@22
  unsigned __int8 v27; // [sp+B0h] [bp-10h]@1
  int v28; // [sp+B4h] [bp-Ch]@12
  int v29; // [sp+B8h] [bp-8h]@12
  signed __int8 *v30; // [sp+BCh] [bp-4h]@13

  v3 = this;
  v27 = 36;
  if ( a3 )
  {
    v24 = this->viewX - 2;
    v19 = this->viewY - 2;
    v25 = this->viewX + 16;
    v20 = this->viewY + 16;
    if ( v24 < 0 )
      v24 = 0;
    if ( v19 < 0 )
      v19 = 0;
    if ( MAP_WIDTH - 1 < v25 )
      v25 = MAP_WIDTH - 1;
    if ( MAP_HEIGHT - 1 < v20 )
      v20 = MAP_HEIGHT - 1;
  }
  else
  {
    v24 = 0;
    v19 = 0;
    v25 = MAP_WIDTH - 1;
    v20 = MAP_HEIGHT - 1;
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    gpAdvManager->field_37A = 0;
    v29 = 0;
    v28 = 0;
    switch ( MAP_HEIGHT )
    {
      case 36:
        v30 = &gpWindowManager->screenBuffer->contents[128 * (20 * v19 + 80) + 480];
        v14 = 4 * v24;
        break;
      case 72:
        v30 = &gpWindowManager->screenBuffer->contents[128 * (10 * v19 + 80) + 480];
        v14 = 2 * v24;
        break;
      case 108:
        v30 = &gpWindowManager->screenBuffer->contents[128 * (5 * ((v19 + 2) / 3 + v19) + 80) + 480];
        v14 = (v24 + 2) / 3 + v24;
        v28 = v24 % 3;
        v29 = v19 % 3;
        break;
      default:
        v30 = &gpWindowManager->screenBuffer->contents[128 * (5 * v19 + 80) + 480];
        v14 = v24;
        break;
    }
    for ( i = v19; v20 >= i; ++i )
    {
      v26 = (int)&v30[v14];
      switch ( MAP_HEIGHT )
      {
        case 36:
          v30 += 2560;
          break;
        case 72:
          v30 += 1280;
          break;
        case 108:
          ++v29;
          if ( v29 > 2 )
            v29 = 0;
          if ( v29 )
            v30 += 640;
          else
            v30 += 1280;
          break;
        case 144:
          v30 += 640;
          break;
        default:
          break;
      }
      for ( j = v24; j <= v25; ++j )
      {
        if ( !gbAllBlack && (unsigned __int8)(*(&mapRevealed[j] + MAP_WIDTH * i) & giCurPlayerBit) )
        {
          v13 = (int)(&v3->map->tiles[i * v3->map->width] + j);
          if ( *(_BYTE *)(v13 + 8) & 0x40 && v3->viewX + 7 == j && v3->viewY + 7 == i )
          {
            v27 = byte_4F0A48[gpGame->players[giCurPlayer].color];
          }
          else if ( (*(_BYTE *)(v13 + 9) & 0x7F) == 42 )
          {
            v9 = gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)];
            if ( giCurPlayer == v9 )
            {
              if ( v9 < 0 )
                v7 = 6;
              else
                v7 = gpGame->players[v9].color;
              v27 = byte_4F0A48[v7];
            }
          }
          else
          {
            v8 = -1;
            if ( *(_BYTE *)(v13 + 3) == 255 )
            {
              if ( *(_BYTE *)(v13 + 7) != 255 )
                v8 = (*(_BYTE *)(v13 + 6) >> 2) & 0x3F;
            }
            else
            {
              v8 = (*(_BYTE *)(v13 + 2) >> 2) & 0x3F;
            }
            if ( *(_BYTE *)(v13 + 9) == 35
              || v8 == 14
              && j > 0
              && MAP_WIDTH - 1 > j
              && *(&v3->map->tiles[i * v3->map->width].objType + 4 * (3 * j - 3)) == 163
              || *(&v3->map->tiles[i * v3->map->width].objType + 4 * (3 * j + 3)) == 163 )
              v8 = 35;
            if ( v8 != 62 || *(_BYTE *)(v13 + 9) != 103 )
            {
              switch ( v8 )
              {
                case 35:
                case 36:
                  v10 = gpGame->field_2773[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)];
                  v21 = gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)].x;
                  v16 = gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)].y;
                  if ( v10 < 0 )
                    v6 = 6;
                  else
                    v6 = gpGame->players[v10].color;
                  v27 = byte_4F0A48[v6];
                  if ( v16 - 2 > i || i > v16 || v21 - 2 > j || v21 + 2 < j )
                    goto LABEL_88;
                  break;
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 31:
                case 32:
                case 33:
                case 34:
                case 42:
                case 43:
                case 44:
                case 49:
                  switch ( *(_BYTE *)(v13 + 9) )
                  {
                    case 1:
                    case 0x17:
                    case 0x1D:
                    case 0x81:
                    case 0x97:
                    case 0x9D:
                      v11 = gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)];
                      if ( v11 < 0 )
                        v5 = 6;
                      else
                        v5 = gpGame->players[v11].color;
                      v27 = byte_4F0A48[v5];
                      break;
                    default:
                      v27 = byte_4F0A28[(unsigned __int8)giGroundToTerrain[*(_WORD *)v13]] + 3;
                      break;
                  }
                  break;
                default:
LABEL_88:
                  switch ( *(_BYTE *)(v13 + 9) )
                  {
                    case 1:
                    case 0x17:
                    case 0x1D:
                    case 0x81:
                    case 0x97:
                    case 0x9D:
                      v12 = gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v13 + 4) >> 8) >> -5)];
                      if ( v12 < 0 )
                        v4 = 6;
                      else
                        v4 = gpGame->players[v12].color;
                      v27 = byte_4F0A48[v4];
                      break;
                    default:
                      v27 = byte_4F0A28[(unsigned __int8)giGroundToTerrain[*(_WORD *)v13]];
                      break;
                  }
                  break;
              }
            }
            else
            {
              v27 = byte_4F0A28[(unsigned __int8)giGroundToTerrain[*(_WORD *)v13]] + 3;
            }
          }
        }
        else
        {
          v27 = 36;
        }
        switch ( MAP_HEIGHT )
        {
          case 36:
            memset((void *)v26, v27, 4u);
            memset((void *)(v26 + 640), v27, 4u);
            memset((void *)(v26 + 1280), v27, 4u);
            memset((void *)(v26 + 1920), v27, 4u);
            v26 += 4;
            break;
          case 72:
            memset((void *)v26, v27, 2u);
            memset((void *)(v26 + 640), v27, 2u);
            v26 += 2;
            break;
          case 108:
            if ( v28 )
            {
              if ( v29 )
              {
                *(_BYTE *)v26++ = v27;
              }
              else
              {
                *(_BYTE *)v26 = v27;
                *(_BYTE *)(v26++ + 640) = v27;
              }
            }
            else if ( v29 )
            {
              *(_BYTE *)v26 = v27;
              *(_BYTE *)(v26 + 1) = v27;
              v26 += 2;
            }
            else
            {
              *(_BYTE *)v26 = v27;
              *(_BYTE *)(v26 + 1) = v27;
              *(_BYTE *)(v26 + 640) = v27;
              *(_BYTE *)(v26 + 641) = v27;
              v26 += 2;
            }
            ++v28;
            if ( v28 > 2 )
              v28 = 0;
            break;
          case 144:
            *(_BYTE *)v26++ = v27;
            break;
          default:
            continue;
        }
      }
    }
    a4 = -1;
    v17 = 0;
    if ( gbInViewWorld )
    {
      switch ( MAP_HEIGHT )
      {
        case 36:
          v15 = 4.0;
          v17 = 1;
          break;
        case 72:
          v15 = 2.0;
          if ( giViewWorldScale > 6 )
            a4 = 6;
          else
            v17 = 1;
          break;
        case 108:
          v15 = 1.33;
          if ( giViewWorldScale > 4 )
          {
            if ( giViewWorldScale == 6 )
              a4 = 9;
            else
              a4 = 8;
          }
          else
          {
            v17 = 1;
          }
          break;
        default:
          v15 = 1.0;
          if ( giViewWorldScale == 4 )
          {
            a4 = 7;
          }
          else if ( giViewWorldScale == 6 )
          {
            a4 = 6;
          }
          else
          {
            a4 = 4;
          }
          break;
      }
    }
    else
    {
      switch ( MAP_HEIGHT )
      {
        case 36:
          a4 = 5;
          v15 = 4.0;
          break;
        case 72:
          a4 = 3;
          v15 = 2.0;
          break;
        case 108:
          a4 = 2;
          v15 = 1.33;
          break;
        default:
          a4 = 1;
          v15 = 1.0;
          break;
      }
    }
    if ( !v17 )
    {
      if ( gbInViewWorld )
        icon::ClipFillToBuffer(
          v3->radarIcon,
          (signed __int64)((double)iVWMapOriginX * v15 + 480.0),
          (signed __int64)((double)iVWMapOriginY * v15 + 16.0),
          a4,
          -75,
          0,
          480,
          16,
          0x90u,
          144);
      else
        icon::ClipFillToBuffer(
          v3->radarIcon,
          (signed __int64)((double)v3->viewX * v15 + 480.0),
          (signed __int64)((double)v3->viewY * v15 + 16.0),
          a4,
          -75,
          0,
          480,
          16,
          0x90u,
          144);
    }
    if ( a2 )
    {
      if ( a3 )
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          (signed __int64)((double)v24 * v15 + 480.0),
          (signed __int64)((double)v19 * v15 + 16.0),
          (signed __int64)((double)(v25 - v24 + 1) * v15),
          (signed __int64)((double)(v20 - v19 + 1) * v15));
      else
        heroWindowManager::UpdateScreenRegion(gpWindowManager, 480, 16, 0x90u, 144);
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F7470: using guessed type int gbAllBlack;
// 519244: using guessed type int gbInViewWorld;
// 52FF5C: using guessed type int iVWMapOriginX;
// 52FF60: using guessed type int iVWMapOriginY;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (0044BAD0) --------------------------------------------------------
BOOL __thiscall advManager::QuickInfo(advManager *ecx0, int a2, int a3)
{
  char *v3; // ST28_4@74
  char *v4; // eax@74
  char *v5; // ST28_4@80
  char *v6; // eax@80
  __int16 v7; // ax@83
  advManager *v9; // [sp+18h] [bp-1F4h]@1
  heroWindow *this; // [sp+24h] [bp-1E8h]@12
  bool v11; // [sp+2Ch] [bp-1E0h]@68
  signed int v12; // [sp+3Ch] [bp-1D0h]@89
  signed int v13; // [sp+3Ch] [bp-1D0h]@125
  Event evt; // [sp+40h] [bp-1CCh]@154
  char a2a; // [sp+5Ch] [bp-1B0h]@74
  char a1; // [sp+124h] [bp-E8h]@151
  hero *curHero; // [sp+1ECh] [bp-20h]@1
  int yOff; // [sp+1F0h] [bp-1Ch]@8
  int xOff; // [sp+1F4h] [bp-18h]@4
  heroWindow *window; // [sp+1F8h] [bp-14h]@13
  int v21; // [sp+1FCh] [bp-10h]@87
  mapCell *v22; // [sp+200h] [bp-Ch]@1
  int v23; // [sp+204h] [bp-8h]@17
  int v24; // [sp+208h] [bp-4h]@87

  v9 = ecx0;
  v22 = 0;
  curHero = 0;
  if ( gpCurPlayer->curHeroIdx == -1 )
    curHero = 0;
  else
    curHero = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  xOff = 32 * a2 - 57;
  if ( xOff < 30 )
    xOff = 30;
  if ( xOff + 160 > 464 )
    xOff = 304;
  yOff = 32 * a3 - 25;
  if ( yOff < 16 )
    yOff = 16;
  if ( yOff + 96 > 448 )
    yOff = 352;
  this = (heroWindow *)operator new(68);
  if ( this )
    window = heroWindow::heroWindow(this, xOff, yOff, "qwikinfo.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  v23 = 0;
  if ( a2 + v9->viewX >= 0 && a2 + v9->viewX < MAP_WIDTH && a3 + v9->viewY >= 0 && a3 + v9->viewY < MAP_HEIGHT )
  {
    v22 = advManager::GetCell(v9, a2 + v9->viewX, a3 + v9->viewY);
    if ( (unsigned __int8)*(&mapRevealed[a2] + v9->viewX + MAP_WIDTH * (a3 + v9->viewY)) & (unsigned __int8)giCurPlayerBit )
    {
      switch ( v22->objType & 0x7F )
      {
        case LOCATION_ARTIFACT:
          sprintf(gText, "%s", "Artifact");
          break;
        case LOCATION_OBELISK:
          if ( !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_0[("(not visited)" - "(already visited)") & (((gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                                                                                          + 47] & (1 << giCurPlayer)) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_GAZEBO:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_1[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->gazeboesVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_FORT:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_2[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->fortsVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_WITCH_DOCTORS_HUT:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_3[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->witchDoctorHutsVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_MERCENARY_CAMP:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_4[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->mercenaryCampsVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_STANDING_STONES:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_5[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->standingStonesVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_TREE_OF_KNOWLEDGE:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_6[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->treesOfKnowledgeVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_XANADU:
          if ( !curHero || !(v22->objType & 0x80) )
            goto LABEL_145;
          sprintf(
            gText,
            "%s\n\n%s",
            (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
            &aAlreadyVisit_7[("(not visited)" - "(already visited)") & ((((1 << ((v22->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & curHero->xanadusVisited) != 0)
                                                                      - 1)]);
          break;
        case LOCATION_BUOY:
          v23 = 2;
          goto LABEL_145;
        case LOCATION_FOUNTAIN:
          v23 = 4;
          goto LABEL_145;
        case LOCATION_OASIS:
          v23 = 8;
          goto LABEL_145;
        case LOCATION_FAERIE_RING:
          v23 = 16;
          goto LABEL_145;
        case LOCATION_TEMPLE:
          v23 = 256;
          goto LABEL_145;
        case LOCATION_WATERING_HOLE:
          v23 = 512;
          goto LABEL_145;
        case LOCATION_MAGIC_WELL:
          v23 = 4096;
          goto LABEL_145;
        case LOCATION_IDOL:
          v23 = 8192;
          goto LABEL_145;
        case 0:
        case LOCATION_EVENT:
        case LOCATION_ARMY_CAMP|LOCATION_SKELETON:
        case LOCATION_WINDMILL|LOCATION_SKELETON:
        case LOCATION_NOTHING_SPECIAL|LOCATION_ALCHEMIST_LAB:
          v11 = v22->objectIndex != 255
             && (((unsigned __int8)v22->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 47
             || v22->overlayIndex != 255;
          sprintf(
            gText,
            "%s\n%s",
            terrainNames[(unsigned __int8)giGroundToTerrain[v22->groundIndex]],
            &aNoDigging[("(digging ok)" - "(no digging)") & ((v11 != 0) - 1)]);
          break;
        case LOCATION_ABANDONED_MINE:
          sprintf(gText, "%s", (&adventureMapLocations)[4 * (v22->objType & 0x7F)]);
          goto LABEL_74;
        case LOCATION_MINE:
          if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType == -1 )
          {
            sprintf(
              gText,
              "%s %s",
              gResourceNames[gpGame->mines[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type],
              "Mine");
          }
          else
          {
            sprintf(
              gText,
              "%s %s",
              gResourceNames[gpGame->mines[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type],
              "Mine");
LABEL_74:
            v3 = gArmyNamesPlural[gpGame->mines[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType];
            v4 = advManager::GetArmySizeName(
                   gpGame->mines[(unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty,
                   2);
            sprintf(&a2a, "\n\nguarded by %s %s", v4, v3);
            strcat(gText, &a2a);
          }
          break;
        case LOCATION_RESOURCE:
          sprintf(gText, "%s", *(char **)((char *)gResourceNames + 2 * (v22->objectIndex & 0xFE)));
          break;
        case LOCATION_ARMY_CAMP:
          if ( advManager::IsCrystalBallInEffect(a2 + v9->viewX, a3 + v9->viewY, 8) )
          {
            sprintf(
              gText,
              "%d %s",
              (unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              gArmyNamesPlural[v22->objectIndex]);
          }
          else
          {
            v5 = gArmyNamesPlural[v22->objectIndex];
            v6 = advManager::GetArmySizeName(
                   (unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
                   1);
            sprintf(gText, "%s %s", v6, v5);
          }
          break;
        case LOCATION_BARRIER:
        case LOCATION_TRAVELLER_TENT:
          if ( v22->objType & 0x80 )
          {
            v7 = v22->field_4_1_1_isShadow_1_13_extraInfo >> 3;
            sprintf(gText, (&adventureMapLocations)[4 * (v22->objType & 0x7F)], xBarrierColor[v7 & 7]);
            gText[0] = toupper(gText[0]);
          }
          else
          {
            sprintf(gText, "%s", terrainNames[(unsigned __int8)giGroundToTerrain[v22->groundIndex]]);
          }
          break;
        case LOCATION_ALCHEMIST_TOWER:
          if ( v22->objectIndex == 255 )
          {
            v21 = v22->overlayIndex;
            v24 = ((unsigned __int8)v22->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F;
          }
          else
          {
            v21 = v22->objectIndex;
            v24 = ((unsigned __int8)v22->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F;
          }
          v12 = -1;
          if ( v24 == 61 )
          {
            if ( v21 >= 0 )
            {
              if ( v21 >= 4 )
              {
                if ( v21 < 72 )
                {
                  v12 = 1;
                  v23 = 4194304;
                }
              }
              else
              {
                v12 = 0;
              }
            }
          }
          else if ( v24 == 62 )
          {
            if ( v21 >= 0 )
            {
              if ( v21 >= 5 )
              {
                if ( v21 >= 10 )
                {
                  if ( v21 >= 47 )
                  {
                    if ( v21 < 111 )
                    {
                      v12 = 6;
                      v23 = 2097152;
                    }
                  }
                  else
                  {
                    v12 = 5;
                    v23 = 1048576;
                  }
                }
                else
                {
                  v12 = -1;
                }
              }
              else
              {
                v12 = 4;
                v23 = 8388608;
              }
            }
          }
          else if ( v24 == 63 && v21 >= 0 )
          {
            if ( v21 >= 32 )
            {
              if ( v21 < 59 )
                v12 = 3;
            }
            else
            {
              v12 = 2;
            }
          }
          if ( v12 == -1 )
            sprintf(gText, "Unknown");
          else
            sprintf(gText, (&off_4F7220)[4 * v12]);
          if ( curHero && v23 )
          {
            strcat(gText, "\n\n");
            strcat(
              gText,
              &aAlreadyVisit_8[("(not visited)" - "(already visited)") & (((curHero->flags & v23) != 0) - 1)]);
          }
          break;
        case LOCATION_EXPANSION_DWELLING:
          if ( v22->overlayIndex == 255 )
          {
            v21 = v22->objectIndex;
            v24 = ((unsigned __int8)v22->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F;
          }
          else
          {
            v21 = v22->overlayIndex;
            v24 = ((unsigned __int8)v22->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F;
          }
          v13 = -1;
          if ( v24 == 61 && v21 >= 72 )
          {
            if ( v21 >= 78 )
            {
              if ( v21 >= 112 )
              {
                if ( v21 >= 120 )
                {
                  if ( v21 >= 129 )
                  {
                    if ( v21 < 137 )
                      v13 = 4;
                  }
                  else
                  {
                    v13 = 3;
                  }
                }
                else
                {
                  v13 = 2;
                }
              }
              else
              {
                v13 = 1;
              }
            }
            else
            {
              v13 = 0;
            }
          }
          if ( v13 == -1 )
            sprintf(gText, "Unknown");
          else
            sprintf(gText, (&off_4F7240)[4 * v13]);
          break;
        case LOCATION_ROCK:
          if ( (((unsigned __int8)v22->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 62 )
            goto LABEL_145;
          sprintf(gText, "Reefs");
          break;
        default:
LABEL_145:
          if ( v23 && curHero )
            sprintf(
              gText,
              "%s\n\n%s",
              (&adventureMapLocations)[4 * (v22->objType & 0x7F)],
              &aAlreadyVisited[("(not visited)" - "(already visited)") & (((curHero->flags & v23) != 0) - 1)]);
          else
            sprintf(gText, "%s", (&adventureMapLocations)[4 * (v22->objType & 0x7F)]);
          break;
      }
    }
    else
    {
      sprintf(gText, "%s", "Uncharted Territory");
    }
  }
  else
  {
    sprintf(gText, "%s", "Border");
  }
  strcpy(&a1, gText);
  if ( giDebugLevel > 0 && v22 )
    sprintf(
      gText,
      "gi%d obtile%d obi%d ot%d ei%d bl%d %s X%d Y%d",
      v22->groundIndex,
      ((unsigned __int8)v22->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F,
      v22->objectIndex,
      v22->objType,
      (unsigned __int8)((unsigned __int8)(v22->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
      v22->displayFlags & 8,
      &a1,
      a2 + v9->viewX,
      a3 + v9->viewY);
  *(_QWORD *)&evt.inputEvt.eventCode = 12884902400i64;
  evt.inputEvt.yCoordOrFieldID = 1;
  evt.inputEvt.payload = gText;
  heroWindow::BroadcastMessage(window, &evt.inputEvt);
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  QuickViewWait();
  heroWindowManager::RemoveWindow(gpWindowManager, window);
  return operator delete(window);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F21F0: using guessed type int giDebugLevel;
// 4F7200: using guessed type char *xBarrierColor[15];
// 532C5C: using guessed type char giCurPlayerBit;

//----- (0044CD30) --------------------------------------------------------
void __thiscall advManager::UpdateHeroLocator(advManager *this, int a2, int a3, int a4)
{
  int v4; // ST20_4@24
  int v5; // ST24_4@24
  advManager *v6; // [sp+Ch] [bp-3Ch]@1
  char *v7; // [sp+18h] [bp-30h]@21
  int v8; // [sp+1Ch] [bp-2Ch]@3
  GUIMessage evt; // [sp+20h] [bp-28h]@10
  int i; // [sp+3Ch] [bp-Ch]@4
  int v11; // [sp+40h] [bp-8h]@10
  signed int lowID; // [sp+44h] [bp-4h]@10

  v6 = this;
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    if ( a2 != -1 )
      goto LABEL_30;
    v8 = gpCurPlayer->curHeroIdx;
    if ( v8 != -1 )
    {
      for ( i = 0; i < 4; ++i )
      {
        if ( *(&gpCurPlayer->heroesOwned[i] + gpCurPlayer->field_3) == v8 )
          a2 = i;
      }
      if ( a2 != -1 )
      {
LABEL_30:
        lowID = 7 * a2 + 100;
        evt.eventCode = INPUT_GUI_MESSAGE_CODE;
        v11 = *(&gpCurPlayer->heroesOwned[a2] + gpCurPlayer->field_3);
        evt.messageType = 8;
        evt.fieldID = 7 * a2 + 106;
        if ( gpCurPlayer->curHeroIdx != v11 || gpCurPlayer->curHeroIdx == -1 || gbAllBlack )
          evt.payload = (void *)36;
        else
          evt.payload = (void *)153;
        heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
        if ( v11 == -1 || gbAllBlack )
        {
          evt.fieldID = lowID + 5;
          evt.messageType = 4;
          evt.payload = (void *)(a2 + 1);
          heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          evt.messageType = 6;
          evt.payload = (void *)4;
          for ( i = 0; i <= 3; ++i )
          {
            evt.fieldID = lowID + i;
            heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          }
        }
        else
        {
          v7 = (char *)&gpGame->heroes[v11];
          evt.fieldID = lowID + 5;
          evt.messageType = 4;
          evt.payload = (void *)21;
          heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          evt.messageType = 5;
          evt.payload = (void *)6;
          for ( i = 0; i <= 6; ++i )
          {
            evt.fieldID = lowID + i;
            heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          }
          v4 = GetMobilityFrame(*(_DWORD *)(v7 + 53));
          evt.fieldID = lowID + 1;
          evt.messageType = 4;
          evt.payload = (void *)v4;
          heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          v5 = GetManaFrame(*(_WORD *)v7);
          evt.fieldID = lowID + 3;
          evt.messageType = 4;
          evt.payload = (void *)v5;
          heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
          evt.fieldID = lowID + 2;
          evt.messageType = 4;
          evt.payload = (void *)(unsigned __int8)v7[24];
          heroWindow::BroadcastMessage(v6->adventureScreen, (tag_message *)&evt);
        }
        if ( a3 )
        {
          heroWindow::DrawWindow(v6->adventureScreen, 0, lowID, lowID + 6);
          if ( a4 )
            heroWindowManager::UpdateScreenRegion(gpWindowManager, 481, 32 * a2 + 177, 0x36u, 30);
        }
      }
    }
  }
}
// 4F7470: using guessed type int gbAllBlack;

//----- (0044D080) --------------------------------------------------------
void __thiscall advManager::UpdateHeroLocators(advManager *this, int a2, int a3)
{
  int a2a; // [sp+20h] [bp-4h]@2

  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    for ( a2a = 0; a2a < 4; ++a2a )
      advManager::UpdateHeroLocator(this, a2a, 0, 0);
    if ( gpCurPlayer->numHeroes >= 5 )
      this->heroScrollbarKnob->offsetY = (signed __int64)((double)gpCurPlayer->field_3
                                                        * (73.0
                                                         / (double)((signed int)gpCurPlayer->numHeroes - 4))
                                                        + 195.0);
    else
      this->heroScrollbarKnob->offsetY = 232;
    if ( a2 )
      heroWindow::DrawWindow(this->adventureScreen, a3);
  }
}

//----- (0044D170) --------------------------------------------------------
void __thiscall advManager::UpdateTownLocators(void *this, int a2, int a3)
{
  void *v3; // [sp+14h] [bp-30h]@1
  int evt; // [sp+20h] [bp-24h]@2
  int v5; // [sp+24h] [bp-20h]@4
  int v6; // [sp+28h] [bp-1Ch]@4
  int v7; // [sp+38h] [bp-Ch]@7
  unsigned int i; // [sp+3Ch] [bp-8h]@4
  int j; // [sp+40h] [bp-4h]@2

  v3 = this;
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    evt = 512;
    for ( j = 0; j < 4; ++j )
    {
      i = *(&gpCurPlayer->castlesOwned[j] + HIBYTE(gpCurPlayer->field_45));
      v5 = 8;
      v6 = j + 32;
      if ( LOBYTE(gpCurPlayer->field_45) == -1 || LOBYTE(gpCurPlayer->field_45) != i || gbAllBlack )
        v7 = 36;
      else
        v7 = 153;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
      v6 = j + 16;
      if ( i == -1 || gbAllBlack )
      {
        v5 = 4;
        v7 = j + 5;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
        v5 = 6;
        v7 = 2;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
        v5 = 6;
        v7 = 4;
        v6 = j + 300;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
      }
      else
      {
        v5 = 5;
        v7 = 2;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
        v5 = 4;
        v7 = gpGame->castles[i].factionID + 9;
        if ( !(gpGame->castles[i].buildingsBuiltFlags & 0x40) )
          v7 += 6;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
        if ( BitTest(gpGame->field_27BB, i) )
          v5 = 5;
        else
          v5 = 6;
        v7 = 4;
        v6 = j + 300;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 154), (tag_message *)&evt);
      }
    }
    *(_WORD *)(*(_DWORD *)((char *)v3 + 182) + 26) = gpCurPlayer->numCastles >= 5 ? (unsigned __int16)(signed __int64)((double)HIBYTE(gpCurPlayer->field_45) * (74.0 / (double)((signed int)gpCurPlayer->numCastles - 4)) + 195.0) : 232;
    if ( a2 )
      heroWindow::DrawWindow(*(heroWindow **)((char *)v3 + 154), a3);
  }
}
// 4F7470: using guessed type int gbAllBlack;

//----- (0044D440) --------------------------------------------------------
int __thiscall advManager::UpdBottomView(advManager *this, int a2, int a3, int a4)
{
  int result; // eax@1
  signed int v6; // [sp+14h] [bp-4h]@1

  v6 = 0;
  result = a2;
  gbForceUpdate = a2;
  if ( giBottomViewOverride == 6 )
    return result;
  if ( giBottomViewOverride > 0 )
  {
    if ( KBTickCount() <= giBottomViewOverrideEndTime )
    {
      switch ( giBottomViewOverride )
      {
        case 1:
          v6 = advManager::UpdBottomViewNewTurn(this);
          break;
        case 2:
          v6 = advManager::UpdBottomViewKingdom(this);
          break;
        case 5:
          v6 = advManager::UpdBottomViewResMsg(this);
          break;
      }
      goto LABEL_20;
    }
    giBottomViewOverride = 0;
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] && !gbAllBlack && gpGame->players[giCurPlayer].color == gpCurPlayer->color )
  {
    if ( gpCurPlayer->curHeroIdx == -1 )
      v6 = advManager::UpdBottomViewKingdom(this);
    else
      v6 = advManager::UpdBottomViewHero(this);
  }
  else
  {
    v6 = advManager::UpdBottomViewEnemyTurn(this);
  }
LABEL_20:
  if ( v6 && a3 )
  {
    heroWindow::DrawWindow(this->adventureScreen, 0, 2000, 2200);
    if ( a4 )
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 480, 392, 0x8Fu, 71);
  }
  return gbForceUpdate;
}
// 4F7470: using guessed type int gbAllBlack;
// 50EAB0: using guessed type int gbForceUpdate;
// 52405C: using guessed type int giBottomViewOverride;
// 524798: using guessed type int giBottomViewOverrideEndTime;

//----- (0044D610) --------------------------------------------------------
signed int __thiscall advManager::ClearBottomView(advManager *this)
{
  signed int result; // eax@10
  widget *v3; // [sp+14h] [bp-10h]@8
  widget *v4; // [sp+1Ch] [bp-8h]@5
  signed int i; // [sp+20h] [bp-4h]@2

  if ( iCurBottomView )
  {
    for ( i = 0; i < 12; ++i )
    {
      if ( this->someComponents[0][i] )
      {
        heroWindow::RemoveWidget(this->adventureScreen, this->someComponents[0][i]);
        v4 = this->someComponents[0][i];
        if ( v4 )
          ((void (__thiscall *)(widget *))v4->vtable->cleanUp)(v4);
      }
      if ( this->someComponents[1][i] )
      {
        heroWindow::RemoveWidget(this->adventureScreen, this->someComponents[1][i]);
        v3 = this->someComponents[1][i];
        if ( v3 )
          ((void (__thiscall *)(widget *))v3->vtable->cleanUp)(v3);
      }
      this->someComponents[0][i] = 0;
      result = i;
      this->someComponents[1][i] = 0;
    }
    giBottomViewPlayer = -1;
    iCurBottomView = 0;
    iLastAnimFrame = -1;
  }
  return result;
}
// 50EAA0: using guessed type int iCurBottomView;
// 50EAA4: using guessed type int giBottomViewPlayer;
// 524CB0: using guessed type int iLastAnimFrame;

//----- (0044D750) --------------------------------------------------------
int __thiscall advManager::UpdBottomViewEnemyTurn(void *this)
{
  void *v2; // [sp+Ch] [bp-38h]@1
  iconWidget *v3; // [sp+10h] [bp-34h]@45
  iconWidget *v4; // [sp+14h] [bp-30h]@32
  iconWidget *v5; // [sp+18h] [bp-2Ch]@20
  iconWidget *v6; // [sp+1Ch] [bp-28h]@7
  iconWidget *thisa; // [sp+20h] [bp-24h]@2
  int evt; // [sp+24h] [bp-20h]@1
  int v9; // [sp+28h] [bp-1Ch]@19
  int v10; // [sp+2Ch] [bp-18h]@19
  int v11; // [sp+3Ch] [bp-8h]@19
  int v12; // [sp+40h] [bp-4h]@1

  v2 = this;
  v12 = 0;
  evt = 512;
  if ( iCurBottomView != 4 )
  {
    v12 = 1;
    gbForceUpdate = 1;
    advManager::ClearBottomView((advManager *)this);
    iCurBottomView = 4;
    thisa = (iconWidget *)operator new(45);
    if ( thisa )
      *(_DWORD *)((char *)v2 + 58) = iconWidget::iconWidget(thisa, 480, 392, 143, 71, "stonback.icn", 0, 0, 2000, 16, 1);
    else
      *(_DWORD *)((char *)v2 + 58) = 0;
    if ( !*(_DWORD *)((char *)v2 + 58) )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)((char *)v2 + 154), *(widget **)((char *)v2 + 58), 1000);
    v6 = (iconWidget *)operator new(45);
    if ( v6 )
      *(_DWORD *)((char *)v2 + 62) = iconWidget::iconWidget(v6, 493, 403, 118, 51, "hourglas.icn", 0, 0, 2001, 16, 1);
    else
      *(_DWORD *)((char *)v2 + 62) = 0;
    if ( !*(_DWORD *)((char *)v2 + 62) )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)((char *)v2 + 154), *(widget **)((char *)v2 + 62), 1010);
  }
  if ( gbForceUpdate || KBTickCount() - iLastSandAnimTime > 300 )
  {
    iLastSandAnimTime = KBTickCount();
    iLastAnimFrame = *(_DWORD *)((char *)v2 + 510);
    if ( KBTickCount() - iLastNewSandAnimTime > 300 )
    {
      iLastNewSandAnimTime = KBTickCount();
      ++iSandAnim;
      if ( iSandAnim >= 20 )
        iSandAnim = 16;
      v12 = 1;
      if ( *(_DWORD *)((char *)v2 + 70) )
      {
        v9 = 4;
        v10 = 2003;
        v11 = iSandAnim + 11;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v2 + 154), (tag_message *)&evt);
      }
      else
      {
        v5 = (iconWidget *)operator new(45);
        if ( v5 )
          *(_DWORD *)((char *)v2 + 70) = iconWidget::iconWidget(
                                           v5,
                                           559,
                                           405,
                                           50,
                                           47,
                                           "hourglas.icn",
                                           iSandAnim + 11,
                                           0,
                                           2003,
                                           16,
                                           1);
        else
          *(_DWORD *)((char *)v2 + 70) = 0;
        if ( !*(_DWORD *)((char *)v2 + 70) )
          MemError();
        heroWindow::AddWidget(*(heroWindow **)((char *)v2 + 154), *(widget **)((char *)v2 + 70), 1020);
      }
    }
  }
  if ( gbForceUpdate || giBottomViewPlayer != giCurPlayer )
  {
    v12 = 1;
    giBottomViewPlayer = giCurPlayer;
    if ( giCurPlayer != giCurPlayer )
      LODWORD(iCurHourGlassPhase) = 0;
    if ( *(_DWORD *)((char *)v2 + 66) )
    {
      v9 = 4;
      v10 = 2002;
      v11 = gpGame->players[(char)giCurPlayer].color;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v2 + 154), (tag_message *)&evt);
    }
    else
    {
      v4 = (iconWidget *)operator new(45);
      if ( v4 )
        *(_DWORD *)((char *)v2 + 66) = iconWidget::iconWidget(
                                         v4,
                                         495,
                                         405,
                                         50,
                                         47,
                                         "brcrest.icn",
                                         gpGame->players[(char)giCurPlayer].color,
                                         0,
                                         2002,
                                         16,
                                         1);
      else
        *(_DWORD *)((char *)v2 + 66) = 0;
      if ( !*(_DWORD *)((char *)v2 + 66) )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)((char *)v2 + 154), *(widget **)((char *)v2 + 66), 1030);
    }
  }
  if ( gbForceUpdate
    || SHIDWORD(iCurHourGlassPhase) > (signed int)iCurHourGlassPhase
    || SHIDWORD(iCurHourGlassPhase) < 0
    || SHIDWORD(iCurHourGlassPhase) < (signed int)iCurHourGlassPhase && KBTickCount() - giLastHourGlassUpdateTime >= 700 )
  {
    v12 = 1;
    HIDWORD(iCurHourGlassPhase) = iCurHourGlassPhase;
    giLastHourGlassUpdateTime = KBTickCount();
    if ( *(_DWORD *)((char *)v2 + 74) )
    {
      v9 = 4;
      v10 = 2004;
      v11 = iCurHourGlassPhase + 1;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v2 + 154), (tag_message *)&evt);
    }
    else
    {
      v3 = (iconWidget *)operator new(45);
      if ( v3 )
        *(_DWORD *)((char *)v2 + 74) = iconWidget::iconWidget(
                                         v3,
                                         559,
                                         405,
                                         50,
                                         47,
                                         "hourglas.icn",
                                         iCurHourGlassPhase + 1,
                                         0,
                                         2004,
                                         16,
                                         1);
      else
        *(_DWORD *)((char *)v2 + 74) = 0;
      if ( !*(_DWORD *)((char *)v2 + 74) )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)((char *)v2 + 154), *(widget **)((char *)v2 + 74), 1040);
    }
  }
  return v12;
}
// 50EA90: using guessed type int iSandAnim;
// 50EA94: using guessed type int giLastHourGlassUpdateTime;
// 50EAA0: using guessed type int iCurBottomView;
// 50EAA4: using guessed type int giBottomViewPlayer;
// 50EAA8: using guessed type __int64 iCurHourGlassPhase;
// 50EAB0: using guessed type int gbForceUpdate;
// 50F3D0: using guessed type int iLastSandAnimTime;
// 50F3D4: using guessed type int iLastNewSandAnimTime;
// 524CB0: using guessed type int iLastAnimFrame;

//----- (0044DC70) --------------------------------------------------------
signed int __thiscall advManager::UpdBottomViewNewTurn(advManager *this)
{
  signed int result; // eax@3
  textWidget *v3; // [sp+10h] [bp-20h]@24
  textWidget *thisa; // [sp+14h] [bp-1Ch]@19
  iconWidget *v5; // [sp+18h] [bp-18h]@14
  iconWidget *v6; // [sp+1Ch] [bp-14h]@9
  char *content; // [sp+20h] [bp-10h]@19
  char *v8; // [sp+24h] [bp-Ch]@24
  __int16 imgIdx; // [sp+2Ch] [bp-4h]@1

  imgIdx = 0;
  if ( gbForceUpdate || iCurBottomView != 1 )
  {
    advManager::ClearBottomView(this);
    iCurBottomView = 1;
    if ( gpGame->day == 1 && (gpGame->month != 1 || gpGame->week != 1 || gpGame->day != 1) )
      imgIdx = gpGame->week;
    v6 = (iconWidget *)operator new(45);
    if ( v6 )
      this->someComponents[0][0] = (widget *)iconWidget::iconWidget(
                                               v6,
                                               480,
                                               392,
                                               159,
                                               71,
                                               "stonback.icn",
                                               0,
                                               0,
                                               2000,
                                               16,
                                               1);
    else
      this->someComponents[0][0] = 0;
    if ( !this->someComponents[0][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][0], -1);
    v5 = (iconWidget *)operator new(45);
    if ( v5 )
      this->someComponents[0][1] = (widget *)iconWidget::iconWidget(
                                               v5,
                                               480,
                                               392,
                                               143,
                                               71,
                                               "sunmoon.icn",
                                               imgIdx,
                                               0,
                                               2001,
                                               16,
                                               1);
    else
      this->someComponents[0][1] = 0;
    if ( !this->someComponents[0][1] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][1], -1);
    content = (char *)BaseAlloc(0x1Eu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F424 + 41);
    sprintf(content, "%s: %d  %s: %d", "Month", gpGame->month, "Week", gpGame->week);
    thisa = (textWidget *)operator new(43);
    if ( thisa )
      this->someComponents[1][0] = (widget *)textWidget::textWidget(
                                               thisa,
                                               479,
                                               424,
                                               145,
                                               12,
                                               content,
                                               "smalfont.fnt",
                                               1,
                                               2100,
                                               512,
                                               1);
    else
      this->someComponents[1][0] = 0;
    if ( !this->someComponents[1][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][0], -1);
    v8 = (char *)BaseAlloc(0x1Eu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F424 + 67);
    sprintf(v8, "%s: %d", "Day", gpGame->day);
    v3 = (textWidget *)operator new(43);
    if ( v3 )
      this->someComponents[1][0] = (widget *)textWidget::textWidget(
                                               v3,
                                               479,
                                               438,
                                               145,
                                               25,
                                               v8,
                                               "bigfont.fnt",
                                               1,
                                               2100,
                                               512,
                                               1);
    else
      this->someComponents[1][0] = 0;
    if ( !this->someComponents[1][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][0], -1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 50EAA0: using guessed type int iCurBottomView;
// 50EAB0: using guessed type int gbForceUpdate;
// 50F424: using guessed type __int16 word_50F424;

//----- (0044DFE0) --------------------------------------------------------
signed int __thiscall advManager::UpdBottomViewResMsg(advManager *this)
{
  signed int result; // eax@3
  int v2; // ST24_4@11
  unsigned int v3; // eax@11
  textWidget *v5; // [sp+10h] [bp-28h]@25
  iconWidget *v6; // [sp+14h] [bp-24h]@20
  textWidget *thisa; // [sp+18h] [bp-20h]@11
  iconWidget *v8; // [sp+1Ch] [bp-1Ch]@4
  char *v9; // [sp+20h] [bp-18h]@25
  __int16 height; // [sp+24h] [bp-14h]@18
  int v11; // [sp+2Ch] [bp-Ch]@9
  signed int width; // [sp+30h] [bp-8h]@18
  char *content; // [sp+34h] [bp-4h]@11

  if ( gbForceUpdate || iCurBottomView != 5 )
  {
    advManager::ClearBottomView(this);
    iCurBottomView = 5;
    v8 = (iconWidget *)operator new(45);
    if ( v8 )
      this->someComponents[0][0] = (widget *)iconWidget::iconWidget(
                                               v8,
                                               480,
                                               392,
                                               159,
                                               71,
                                               "stonback.icn",
                                               0,
                                               0,
                                               2000,
                                               16,
                                               1);
    else
      this->someComponents[0][0] = 0;
    if ( !this->someComponents[0][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][0], -1);
    LOWORD(v11) = 0;
    if ( *(_DWORD *)&giBottomViewResource < 0 )
      v11 = 32 - 6 * font::LineLength(smallFont, gcBottomViewText, 143);
    v2 = word_50F4C4 + 38;
    v3 = strlen(gcBottomViewText);
    content = (char *)BaseAlloc(v3 + 1, "F:\\h2xsrc\\Source\\ADVMGR.CPP", v2);
    sprintf(content, gcBottomViewText);
    thisa = (textWidget *)operator new(43);
    if ( thisa )
      this->someComponents[1][0] = (widget *)textWidget::textWidget(
                                               thisa,
                                               480,
                                               v11 + 398,
                                               143,
                                               36,
                                               content,
                                               "smalfont.fnt",
                                               1,
                                               2100,
                                               512,
                                               1);
    else
      this->someComponents[1][0] = 0;
    if ( !this->someComponents[1][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][0], -1);
    if ( *(_DWORD *)&giBottomViewResource >= 0 )
    {
      if ( *(_DWORD *)&giBottomViewResource == 6 )
      {
        width = 76;
        height = 26;
      }
      else
      {
        width = 38;
        height = 32;
      }
      v6 = (iconWidget *)operator new(45);
      if ( v6 )
        this->someComponents[0][1] = (widget *)iconWidget::iconWidget(
                                                 v6,
                                                 (143 - width) / 2 + 480,
                                                 463 - height - 14,
                                                 width,
                                                 height,
                                                 "resource.icn",
                                                 giBottomViewResource,
                                                 0,
                                                 2001,
                                                 16,
                                                 1);
      else
        this->someComponents[0][1] = 0;
      if ( !this->someComponents[0][1] )
        MemError();
      heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][1], -1);
      v9 = (char *)BaseAlloc(8u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F4C4 + 80);
      sprintf(v9, "%d", giBottomViewResourceQty);
      v5 = (textWidget *)operator new(43);
      if ( v5 )
        this->someComponents[1][1] = (widget *)textWidget::textWidget(
                                                 v5,
                                                 511,
                                                 453,
                                                 80,
                                                 12,
                                                 v9,
                                                 "smalfont.fnt",
                                                 1,
                                                 2101,
                                                 512,
                                                 1);
      else
        this->someComponents[1][1] = 0;
      if ( !this->someComponents[1][1] )
        MemError();
      heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][1], -1);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 50EAA0: using guessed type int iCurBottomView;
// 50EAB0: using guessed type int gbForceUpdate;
// 50F4C4: using guessed type __int16 word_50F4C4;
// 5249E4: using guessed type int giBottomViewResourceQty;

//----- (0044E340) --------------------------------------------------------
signed int __thiscall advManager::UpdBottomViewKingdom(advManager *this)
{
  signed int result; // eax@3
  textWidget *thisa; // [sp+10h] [bp-54h]@27
  iconWidget *v4; // [sp+14h] [bp-50h]@9
  iconWidget *v5; // [sp+18h] [bp-4Ch]@4
  int v6; // [sp+1Ch] [bp-48h]@4
  char content[36]; // [sp+20h] [bp-44h]@22
  char v8; // [sp+44h] [bp-20h]@4
  char v9; // [sp+45h] [bp-1Fh]@4
  char v10; // [sp+46h] [bp-1Eh]@4
  char v11; // [sp+47h] [bp-1Dh]@4
  char v12; // [sp+48h] [bp-1Ch]@4
  char v13; // [sp+49h] [bp-1Bh]@4
  char v14; // [sp+4Ah] [bp-1Ah]@4
  char v15; // [sp+4Bh] [bp-19h]@4
  char v16; // [sp+4Ch] [bp-18h]@4
  char v17; // [sp+50h] [bp-14h]@4
  char v18; // [sp+51h] [bp-13h]@4
  char v19; // [sp+52h] [bp-12h]@4
  char v20; // [sp+53h] [bp-11h]@4
  char v21; // [sp+54h] [bp-10h]@4
  char v22; // [sp+55h] [bp-Fh]@4
  char v23; // [sp+56h] [bp-Eh]@4
  char v24; // [sp+57h] [bp-Dh]@4
  char v25; // [sp+58h] [bp-Ch]@4
  int i; // [sp+5Ch] [bp-8h]@14
  int v27; // [sp+60h] [bp-4h]@4

  if ( gbForceUpdate || iCurBottomView != 2 )
  {
    advManager::ClearBottomView(this);
    iCurBottomView = 2;
    v17 = 59;
    v18 = 59;
    v19 = 59;
    v20 = 59;
    v21 = 59;
    v22 = 59;
    v23 = 28;
    v24 = 28;
    v25 = 28;
    v8 = 15;
    v9 = 38;
    v10 = 61;
    v11 = 85;
    v12 = 109;
    v13 = -124;
    v14 = 123;
    v15 = 27;
    v16 = 80;
    v6 = 0;
    v27 = 0;
    v5 = (iconWidget *)operator new(45);
    if ( v5 )
      this->someComponents[0][0] = (widget *)iconWidget::iconWidget(
                                               v5,
                                               480,
                                               392,
                                               159,
                                               71,
                                               "stonback.icn",
                                               0,
                                               0,
                                               2000,
                                               16,
                                               1);
    else
      this->someComponents[0][0] = 0;
    if ( !this->someComponents[0][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][0], -1);
    v4 = (iconWidget *)operator new(45);
    if ( v4 )
      this->someComponents[0][1] = (widget *)iconWidget::iconWidget(
                                               v4,
                                               481,
                                               393,
                                               143,
                                               71,
                                               "ressmall.icn",
                                               0,
                                               0,
                                               2001,
                                               16,
                                               1);
    else
      this->someComponents[0][1] = 0;
    if ( !this->someComponents[0][1] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][1], -1);
    for ( i = 0; gpCurPlayer->numCastles > i; ++i )
    {
      if ( gpGame->castles[gpCurPlayer->castlesOwned[i]].buildingsBuiltFlags & 0x40 )
        ++v27;
      else
        ++v6;
    }
    for ( i = 0; i < 9; ++i )
    {
      *(_DWORD *)&content[4 * i] = BaseAlloc(8u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F544 + 50);
      if ( i >= 7 )
      {
        if ( i == 7 )
          sprintf(*(char **)&content[28], "%d", v27);
        else
          sprintf(*(char **)&content[4 * i], "%d", v6);
      }
      else
      {
        sprintf(*(char **)&content[4 * i], "%d", gpCurPlayer->resources[i]);
      }
      thisa = (textWidget *)operator new(43);
      if ( thisa )
        this->someComponents[1][i] = (widget *)textWidget::textWidget(
                                                 thisa,
                                                 (unsigned __int8)*(&v8 + i) + 464,
                                                 *(&v17 + i) + 395,
                                                 32,
                                                 12,
                                                 *(char **)&content[4 * i],
                                                 "smalfont.fnt",
                                                 1,
                                                 i + 2100,
                                                 512,
                                                 1);
      else
        this->someComponents[1][i] = 0;
      if ( !this->someComponents[1][i] )
        MemError();
      heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][i], -1);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 50EAA0: using guessed type int iCurBottomView;
// 50EAB0: using guessed type int gbForceUpdate;
// 50F544: using guessed type __int16 word_50F544;

//----- (0044E6B0) --------------------------------------------------------
signed int __thiscall advManager::UpdBottomViewHero(advManager *this)
{
  signed int result; // eax@3
  __int16 v2; // ST1C_2@36
  char *v3; // ST10_4@36
  __int16 v4; // bx@36
  __int16 v5; // ax@36
  textWidget *thisa; // [sp+10h] [bp-8Ch]@35
  iconWidget *v8; // [sp+14h] [bp-88h]@30
  iconWidget *v9; // [sp+18h] [bp-84h]@4
  char v10[41]; // [sp+1Ch] [bp-80h]@18
  IconEntry *v11; // [sp+4Ch] [bp-50h]@21
  __int16 imgIdx[2]; // [sp+50h] [bp-4Ch]@17
  int v13; // [sp+54h] [bp-48h]@28
  int v14; // [sp+58h] [bp-44h]@28
  int v15; // [sp+5Ch] [bp-40h]@15
  int v16; // [sp+60h] [bp-3Ch]@21
  icon *res; // [sp+64h] [bp-38h]@15
  int v18; // [sp+6Ch] [bp-30h]@21
  char str[20]; // [sp+70h] [bp-2Ch]@18
  int i; // [sp+84h] [bp-18h]@9
  hero *v21; // [sp+88h] [bp-14h]@4
  int v22; // [sp+8Ch] [bp-10h]@21
  int v23; // [sp+90h] [bp-Ch]@21
  int v24; // [sp+94h] [bp-8h]@4
  int v25; // [sp+98h] [bp-4h]@30

  if ( gbForceUpdate || iCurBottomView != 3 )
  {
    advManager::ClearBottomView(this);
    iCurBottomView = 3;
    v21 = &gpGame->heroes[gpCurPlayer->curHeroIdx];
    v24 = 0;
    v9 = (iconWidget *)operator new(45);
    if ( v9 )
      this->someComponents[0][0] = (widget *)iconWidget::iconWidget(
                                               v9,
                                               480,
                                               392,
                                               143,
                                               71,
                                               "stonback.icn",
                                               0,
                                               0,
                                               2000,
                                               16,
                                               1);
    else
      this->someComponents[0][0] = 0;
    if ( !this->someComponents[0][0] )
      MemError();
    heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][0], -1);
    for ( i = 0; i < 5; ++i )
    {
      if ( v21->army.creatureTypes[i] != -1 )
        ++v24;
    }
    if ( v24 )
    {
      v15 = 0;
      res = resourceManager::GetIcon(gpResourceManager, "mons32.icn");
      for ( i = 0; i < 5; ++i )
      {
        *(_DWORD *)imgIdx = v21->army.creatureTypes[i];
        if ( *(_DWORD *)imgIdx != -1 )
        {
          v10[0] = 50;
          v10[1] = 3;
          v10[2] = 96;
          v10[3] = 3;
          v10[4] = 50;
          v10[5] = 17;
          v10[6] = 73;
          v10[7] = 17;
          v10[8] = 96;
          v10[9] = 17;
          v10[10] = 27;
          v10[11] = 32;
          v10[12] = 73;
          v10[13] = 32;
          v10[14] = 119;
          v10[15] = 32;
          v10[16] = 3;
          v10[17] = -1;
          v10[18] = -1;
          v10[19] = -1;
          v10[20] = -1;
          v10[21] = 2;
          v10[22] = 4;
          v10[23] = -1;
          v10[24] = -1;
          v10[25] = -1;
          v10[26] = 0;
          v10[27] = 1;
          v10[28] = 6;
          v10[29] = -1;
          v10[30] = -1;
          v10[31] = 0;
          v10[32] = 1;
          v10[33] = 5;
          v10[34] = 6;
          v10[35] = -1;
          v10[36] = 0;
          v10[37] = 1;
          v10[38] = 5;
          v10[39] = 6;
          v10[40] = 7;
          *(_DWORD *)&str[4 * v15] = BaseAlloc(6u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F5A0 + 68);
          if ( v21->army.quantities[i] <= 1999 )
            sprintf(*(char **)&str[4 * v15], "%d", v21->army.quantities[i]);
          else
            sprintf(*(char **)&str[4 * v15], "%dk", v21->army.quantities[i] / 1000);
          v16 = *(&v10[5 * v24 + 11] + v15);
          v23 = (unsigned __int8)v10[2 * v16];
          v22 = (unsigned __int8)v10[2 * v16 + 1];
          v18 = v22 + 25;
          v11 = &res->headersAndImageData[*(_DWORD *)imgIdx];
          if ( v16 && v16 != 1 )
          {
            if ( v11->height < 37 )
              v22 += 37 - v11->height;
          }
          else
          {
            v18 -= 2;
            if ( v11->height < 35 )
              v22 += 35 - v11->height;
          }
          v13 = font::LineWidth(smallFont, *(const char **)&str[4 * v15]);
          v14 = v13 + v11->width;
          if ( v14 > 45 )
            v14 = 45;
          v23 -= (v14 + 1) / 2;
          v25 = v23 + v14 - 1 - (v13 - 1);
          v8 = (iconWidget *)operator new(45);
          if ( v8 )
            this->someComponents[0][v15 + 2] = (widget *)iconWidget::iconWidget(
                                                           v8,
                                                           v23 + 480,
                                                           v22 + 392,
                                                           32,
                                                           28,
                                                           "mons32.icn",
                                                           imgIdx[0],
                                                           0,
                                                           v15 + 2002,
                                                           16,
                                                           1);
          else
            this->someComponents[0][v15 + 2] = 0;
          if ( !this->someComponents[0][v15 + 2] )
            MemError();
          thisa = (textWidget *)operator new(43);
          if ( thisa )
          {
            v2 = v15 + 2101;
            v3 = *(char **)&str[4 * v15];
            v4 = v21->army.quantities[i] <= 1999 ? 0 : 4;
            v5 = strlen(*(char **)&str[4 * v15]);
            this->someComponents[1][v15 + 1] = (widget *)textWidget::textWidget(
                                                           thisa,
                                                           v25 + 480,
                                                           v18 + 392,
                                                           5 * v5 + v4,
                                                           12,
                                                           v3,
                                                           "smalfont.fnt",
                                                           1,
                                                           v2,
                                                           512,
                                                           1);
          }
          else
          {
            this->someComponents[1][v15 + 1] = 0;
          }
          if ( !this->someComponents[1][v15 + 1] )
            MemError();
          heroWindow::AddWidget(this->adventureScreen, this->someComponents[0][v15 + 2], -1);
          heroWindow::AddWidget(this->adventureScreen, this->someComponents[1][v15++ + 1], -1);
        }
      }
      resourceManager::Dispose(gpResourceManager, (resource *)res);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 50EAA0: using guessed type int iCurBottomView;
// 50EAB0: using guessed type int gbForceUpdate;
// 50F5A0: using guessed type __int16 word_50F5A0;

//----- (0044EC40) --------------------------------------------------------
void __thiscall advManager::HeroQuickView(advManager *this, int a2, int a3, int a4, int a5)
{
  char v5; // al@28
  char v6; // al@29
  int v7; // ebx@36
  int v8; // ST04_4@36
  int v9; // ebx@36
  IconEntry *v10; // eax@36
  int v11; // ebx@62
  int v12; // ST04_4@62
  IconEntry *v13; // eax@62
  char *v14; // eax@66
  int v15; // ebx@78
  int v16; // ST04_4@78
  IconEntry *v17; // eax@78
  char *v18; // eax@82
  textWidget *v20; // [sp+1Ch] [bp-E0h]@82
  iconWidget *v21; // [sp+20h] [bp-DCh]@77
  textWidget *v22; // [sp+24h] [bp-D8h]@66
  iconWidget *v23; // [sp+28h] [bp-D4h]@61
  textWidget *v24; // [sp+2Ch] [bp-D0h]@40
  iconWidget *thisa; // [sp+30h] [bp-CCh]@35
  heroWindow *v26; // [sp+34h] [bp-C8h]@13
  heroWindow *v27; // [sp+38h] [bp-C4h]@7
  PRIMARY_SKILL v28; // [sp+3Ch] [bp-C0h]@50
  signed int v29; // [sp+40h] [bp-BCh]@49
  int v30; // [sp+40h] [bp-BCh]@73
  int v31; // [sp+44h] [bp-B8h]@73
  int a4a; // [sp+48h] [bp-B4h]@57
  int a4b; // [sp+48h] [bp-B4h]@73
  signed int v34; // [sp+4Ch] [bp-B0h]@50
  int imgIdx; // [sp+50h] [bp-ACh]@61
  int imgIdxa; // [sp+50h] [bp-ACh]@77
  int v37; // [sp+54h] [bp-A8h]@57
  int v38; // [sp+58h] [bp-A4h]@30
  int a7; // [sp+5Ch] [bp-A0h]@34
  int v40; // [sp+60h] [bp-9Ch]@30
  tag_message evt; // [sp+6Ch] [bp-90h]@1
  __int16 v42; // [sp+88h] [bp-74h]@1
  icon *res; // [sp+8Ch] [bp-70h]@2
  __int16 v44; // [sp+90h] [bp-6Ch]@1
  __int16 v45; // [sp+94h] [bp-68h]@1
  __int16 v46; // [sp+98h] [bp-64h]@1
  __int16 v47; // [sp+9Ch] [bp-60h]@1
  char content[20]; // [sp+A0h] [bp-5Ch]@40
  PRIMARY_SKILL i; // [sp+B4h] [bp-48h]@18
  int v50; // [sp+B8h] [bp-44h]@88
  int v51; // [sp+BCh] [bp-40h]@88
  __int16 v52; // [sp+C0h] [bp-3Ch]@1
  heroWindow *window; // [sp+C4h] [bp-38h]@8
  hero *hro; // [sp+C8h] [bp-34h]@2
  int guiObj[5]; // [sp+CCh] [bp-30h]@36
  int numStacks; // [sp+E0h] [bp-1Ch]@18
  __int16 v57; // [sp+E4h] [bp-18h]@1
  int v58[5]; // [sp+E8h] [bp-14h]@41

  v46 = 22;
  v45 = 124;
  v44 = 32;
  v57 = 32;
  v47 = 1;
  v42 = 2;
  v52 = 8;
  evt.eventCode = 512;
  if ( a2 == -1 )
    return;
  res = resourceManager::GetIcon(gpResourceManager, "mons32.icn");
  hro = &gpGame->heroes[a2];
  if ( gpGame->heroes[a2].ownerIdx == giCurPlayer
    || this->identifyCast == 1
    || advManager::IsCrystalBallInEffect(hro->x, hro->y, 8) )
  {
    if ( a4 == -1 )
    {
      a4 = 288;
      a5 = 30 * a3 + 97;
    }
    v27 = (heroWindow *)operator new(68);
    if ( v27 )
      window = heroWindow::heroWindow(v27, a4, a5, "qhero0.bin");
    else
      window = 0;
    if ( !window )
      MemError();
    SetWinText(window, 18);
  }
  else
  {
    v26 = (heroWindow *)operator new(68);
    if ( v26 )
      window = heroWindow::heroWindow(v26, a4, a5, "qhero1.bin");
    else
      window = 0;
    if ( !window )
      MemError();
  }
  evt.xCoordOrKeycode = 4;
  evt.yCoordOrFieldID = 2;
  evt.payload = (void *)hro->heroID;
  heroWindow::BroadcastMessage(window, &evt);
  evt.xCoordOrKeycode = 4;
  evt.yCoordOrFieldID = 8;
  evt.payload = (void *)(2 * gpGame->players[hro->ownerIdx].color);
  heroWindow::BroadcastMessage(window, &evt);
  ++evt.yCoordOrFieldID;
  ++evt.payload;
  heroWindow::BroadcastMessage(window, &evt);
  sprintf(gText, "%s", hro->name);
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 1;
  evt.payload = gText;
  heroWindow::BroadcastMessage(window, &evt);
  numStacks = 0;
  for ( i = 0; (signed int)i < 5; ++i )
  {
    if ( hro->army.creatureTypes[i] != -1 )
      ++numStacks;
  }
  if ( hro->ownerIdx == giCurPlayer || this->identifyCast == 1 || advManager::IsCrystalBallInEffect(hro->x, hro->y, 8) )
  {
    for ( i = 0; (signed int)i < 4; ++i )
    {
      v5 = hero::Stats(hro, i);
      sprintf(gText, "%d", v5);
      evt.yCoordOrFieldID = i + 3;
      evt.payload = gText;
      heroWindow::BroadcastMessage(window, &evt);
    }
    v6 = hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
    sprintf(gText, "%d/%d", hro->spellpoints, 10 * v6);
    evt.yCoordOrFieldID = 7;
    evt.payload = gText;
    heroWindow::BroadcastMessage(window, &evt);
    if ( numStacks )
    {
      v38 = (160 - 32 * numStacks) / 2 + 22;
      v40 = 0;
      for ( i = 0; numStacks > i; ++i )
      {
        while ( hro->army.creatureTypes[v40] == -1 )
          ++v40;
        a7 = hro->army.creatureTypes[v40];
        if ( a7 != -1 )
        {
          thisa = (iconWidget *)operator new(45);
          if ( thisa )
          {
            v7 = 124 - GetIconEntry(res, a7)->offsetY;
            v8 = v7 - GetIconEntry(res, a7)->height + 30;
            v9 = v38 + 32 * i - GetIconEntry(res, a7)->offsetX;
            v10 = GetIconEntry(res, a7);
            guiObj[i] = (int)iconWidget::iconWidget(
                               thisa,
                               (32 - v10->width) / 2 + (_WORD)v9 + 1,
                               v8,
                               32,
                               32,
                               "mons32.icn",
                               a7,
                               0,
                               -1,
                               16,
                               1);
          }
          else
          {
            guiObj[i] = 0;
          }
          if ( !guiObj[i] )
            MemError();
          *(_DWORD *)&content[4 * i] = BaseAlloc(5u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F600 + 155);
          sprintf(*(char **)&content[4 * i], "%d", hro->army.quantities[v40]);
          v24 = (textWidget *)operator new(43);
          if ( v24 )
            v58[i] = (int)textWidget::textWidget(
                            v24,
                            v38 + 32 * i,
                            156,
                            32,
                            12,
                            *(char **)&content[4 * i],
                            "smalfont.fnt",
                            1,
                            -1,
                            512,
                            1);
          else
            v58[i] = 0;
          if ( !v58[i] )
            MemError();
          heroWindow::AddWidget(window, (widget *)guiObj[i], -1);
          heroWindow::AddWidget(window, (widget *)v58[i], -1);
        }
        ++v40;
      }
    }
    goto LABEL_88;
  }
  if ( numStacks )
  {
    v29 = 73;
    if ( numStacks < 1 )
      goto LABEL_52;
    if ( numStacks <= 3 )
    {
      v29 = 95;
      v28 = numStacks;
      v34 = 0;
    }
    else
    {
      if ( numStacks != 4 )
      {
LABEL_52:
        v28 = 2;
        v34 = 3;
        goto LABEL_57;
      }
      v28 = 2;
      v34 = 2;
    }
LABEL_57:
    v37 = 0;
    a4a = 160 / v28;
    for ( i = 0; v28 > i; ++i )
    {
      while ( hro->army.creatureTypes[v37] == -1 )
        ++v37;
      imgIdx = hro->army.creatureTypes[v37];
      v23 = (iconWidget *)operator new(45);
      if ( v23 )
      {
        v11 = v29 - GetIconEntry(res, imgIdx)->offsetY;
        v12 = v11 - GetIconEntry(res, imgIdx)->height + 30;
        LOWORD(v11) = (160 / v28 - 32) / 2 + 22 + a4a * (_WORD)i - GetIconEntry(res, imgIdx)->offsetX;
        v13 = GetIconEntry(res, imgIdx);
        guiObj[i] = (int)iconWidget::iconWidget(
                           v23,
                           (32 - v13->width) / 2 + (_WORD)v11 + 1,
                           v12,
                           32,
                           32,
                           "mons32.icn",
                           imgIdx,
                           0,
                           -1,
                           16,
                           1);
      }
      else
      {
        guiObj[i] = 0;
      }
      if ( !guiObj[i] )
        MemError();
      *(_DWORD *)&content[4 * i] = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F600 + 227);
      v14 = advManager::GetArmySizeName(hro->army.quantities[v37], 0);
      strcpy(*(char **)&content[4 * i], v14);
      v22 = (textWidget *)operator new(43);
      if ( v22 )
        v58[i] = (int)textWidget::textWidget(
                        v22,
                        a4a * (_WORD)i + 22,
                        v29 + 32,
                        a4a,
                        12,
                        *(char **)&content[4 * i],
                        "smalfont.fnt",
                        1,
                        -1,
                        512,
                        1);
      else
        v58[i] = 0;
      if ( !v58[i] )
        MemError();
      heroWindow::AddWidget(window, (widget *)guiObj[i], -1);
      heroWindow::AddWidget(window, (widget *)v58[i], -1);
      ++v37;
    }
    if ( v34 )
    {
      a4b = 160 / v34;
      v31 = (160 / v34 - 32) / 2 + 22;
      v30 = v29 + 44;
      for ( i = v28; v34 + v28 > i; ++i )
      {
        while ( hro->army.creatureTypes[v37] == -1 )
          ++v37;
        imgIdxa = hro->army.creatureTypes[v37];
        v21 = (iconWidget *)operator new(45);
        if ( v21 )
        {
          v15 = v30 - GetIconEntry(res, imgIdxa)->offsetY;
          v16 = v15 - GetIconEntry(res, imgIdxa)->height + 36;
          LOWORD(v15) = (_WORD)v31 + (_WORD)a4b * (i - 2) - GetIconEntry(res, imgIdxa)->offsetX;
          v17 = GetIconEntry(res, imgIdxa);
          guiObj[i] = (int)iconWidget::iconWidget(
                             v21,
                             (32 - v17->width) / 2 + (_WORD)v15 + 1,
                             v16,
                             32,
                             32,
                             "mons32.icn",
                             imgIdxa,
                             0,
                             -1,
                             16,
                             1);
        }
        else
        {
          guiObj[i] = 0;
        }
        if ( !guiObj[i] )
          MemError();
        *(_DWORD *)&content[4 * i] = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F600 + 270);
        v18 = advManager::GetArmySizeName(hro->army.quantities[v37], 0);
        strcpy(*(char **)&content[4 * i], v18);
        v20 = (textWidget *)operator new(43);
        if ( v20 )
          v58[i] = (int)textWidget::textWidget(
                          v20,
                          (_WORD)a4b * (i - 2) + 22,
                          v30 + 38,
                          a4b,
                          12,
                          *(char **)&content[4 * i],
                          "smalfont.fnt",
                          1,
                          -1,
                          512,
                          1);
        else
          v58[i] = 0;
        if ( !v58[i] )
          MemError();
        heroWindow::AddWidget(window, (widget *)guiObj[i], -1);
        heroWindow::AddWidget(window, (widget *)v58[i], -1);
        ++v37;
      }
    }
  }
LABEL_88:
  v51 = this->viewX;
  v50 = this->viewY;
  this->viewX = hro->x - 7;
  this->viewY = hro->y - 7;
  advManager::UpdateRadar(this, 1, 0);
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  QuickViewWait();
  heroWindowManager::RemoveWindow(gpWindowManager, window);
  operator delete(window);
  this->viewX = v51;
  this->viewY = v50;
  advManager::UpdateRadar(this, 1, 0);
  advManager::CompleteDraw(this, 0);
  advManager::UpdateScreen(this, 0, 0);
  if ( evt.eventCode == 8 && hro->ownerIdx == giCurPlayer )
    advManager::SetHeroContext(this, hro->idx, 0);
  resourceManager::Dispose(gpResourceManager, (resource *)res);
}
// 50F600: using guessed type __int16 word_50F600;
// 44EC40: using guessed type int guiObj[5];
// 44EC40: using guessed type int var_14[5];

//----- (0044F960) --------------------------------------------------------
char *__stdcall advManager::GetArmySizeName(signed int amt, int queryType)
{
  char *result; // eax@2

  if ( giDebugLevel <= 0 )
  {
    if ( amt >= 5 )
    {
      if ( amt >= 10 )
      {
        if ( amt >= 20 )
        {
          if ( amt >= 50 )
          {
            if ( amt >= 100 )
            {
              if ( amt >= 250 )
              {
                if ( amt >= 500 )
                {
                  if ( amt >= 1000 )
                    result = legionStrings[queryType];
                  else
                    result = zoundsStrings[queryType];
                }
                else
                {
                  result = swarmStrings[queryType];
                }
              }
              else
              {
                result = throngStrings[queryType];
              }
            }
            else
            {
              result = hordeStrings[queryType];
            }
          }
          else
          {
            result = lotsStrings[queryType];
          }
        }
        else
        {
          result = packStrings[queryType];
        }
      }
      else
      {
        result = severalStrings[queryType];
      }
    }
    else
    {
      result = gArmySizeNames[queryType];
    }
  }
  else
  {
    sprintf(cArmySizeName, "%d", amt);
    result = cArmySizeName;
  }
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;
// 4F7038: using guessed type char *gArmySizeNames[27];
// 4F7044: using guessed type char *severalStrings[24];
// 4F7050: using guessed type char *packStrings[21];
// 4F705C: using guessed type char *lotsStrings[18];
// 4F7068: using guessed type char *hordeStrings[15];
// 4F7074: using guessed type char *throngStrings[12];
// 4F7080: using guessed type char *swarmStrings[9];
// 4F708C: using guessed type char *zoundsStrings[6];
// 4F7098: using guessed type char *legionStrings[3];

//----- (0044FA80) --------------------------------------------------------
void __thiscall advManager::TownQuickView(void *this, int a2, int a3, int a4, int a5)
{
  const char *v5; // eax@24
  __int16 v6; // ST14_2@57
  int v7; // ebx@57
  int v8; // ST04_4@57
  int v9; // ebx@57
  IconEntry *v10; // eax@57
  char *v11; // eax@64
  __int16 v12; // ST14_2@78
  int v13; // ebx@78
  int v14; // ST04_4@78
  int v15; // ebx@78
  IconEntry *v16; // eax@78
  char *v17; // eax@85
  void *v18; // [sp+10h] [bp-E8h]@1
  textWidget *v19; // [sp+1Ch] [bp-DCh]@87
  iconWidget *v20; // [sp+20h] [bp-D8h]@77
  textWidget *v21; // [sp+24h] [bp-D4h]@66
  iconWidget *thisa; // [sp+28h] [bp-D0h]@56
  textWidget *v23; // [sp+2Ch] [bp-CCh]@34
  heroWindow *v24; // [sp+30h] [bp-C8h]@4
  signed int v25; // [sp+34h] [bp-C4h]@41
  signed int v26; // [sp+38h] [bp-C0h]@40
  int v27; // [sp+38h] [bp-C0h]@73
  int v28; // [sp+3Ch] [bp-BCh]@48
  int v29; // [sp+40h] [bp-B8h]@48
  int v30; // [sp+40h] [bp-B8h]@73
  signed int v31; // [sp+44h] [bp-B4h]@48
  char a1[20]; // [sp+4Ch] [bp-ACh]@61
  int v33; // [sp+60h] [bp-98h]@48
  int v34; // [sp+64h] [bp-94h]@41
  int a7; // [sp+68h] [bp-90h]@56
  int v36[5]; // [sp+6Ch] [bp-8Ch]@57
  int v37; // [sp+80h] [bp-78h]@48
  int v38[5]; // [sp+84h] [bp-74h]@67
  char *content; // [sp+98h] [bp-60h]@31
  widget *guiObj; // [sp+9Ch] [bp-5Ch]@35
  __int16 v41; // [sp+A0h] [bp-58h]@1
  __int16 v42; // [sp+A4h] [bp-54h]@1
  tag_message evt; // [sp+A8h] [bp-50h]@16
  icon *res; // [sp+C4h] [bp-34h]@2
  __int16 v45; // [sp+C8h] [bp-30h]@1
  __int16 v46; // [sp+CCh] [bp-2Ch]@1
  int i; // [sp+D0h] [bp-28h]@24
  int v48; // [sp+D4h] [bp-24h]@93
  int v49; // [sp+D8h] [bp-20h]@93
  int v50; // [sp+DCh] [bp-1Ch]@11
  __int16 v51; // [sp+E0h] [bp-18h]@1
  heroWindow *window; // [sp+E4h] [bp-14h]@5
  town *v53; // [sp+E8h] [bp-10h]@2
  int v54; // [sp+ECh] [bp-Ch]@16
  __int16 v55; // [sp+F0h] [bp-8h]@1
  __int16 v56; // [sp+F4h] [bp-4h]@1

  v18 = this;
  v41 = 192;
  v46 = 22;
  v45 = 32;
  v55 = 32;
  v56 = 1;
  v42 = 2;
  v51 = 8;
  if ( a2 == -1 )
    return;
  res = resourceManager::GetIcon(gpResourceManager, "mons32.icn");
  v53 = &gpGame->castles[a2];
  if ( a4 == -1 )
  {
    a4 = 328;
    a5 = 176;
  }
  v24 = (heroWindow *)operator new(68);
  if ( v24 )
    window = heroWindow::heroWindow(v24, a4, a5, "qtown1.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  if ( v53->ownerIdx != giCurPlayer && giDebugLevel < 2 )
  {
    v50 = game::getNumberOfThievesGuilds(gpGame, giCurPlayer);
    if ( v50 > 2 )
      v50 = 2;
  }
  else
  {
    v50 = 3;
  }
  if ( advManager::IsCrystalBallInEffect(v53->x, v53->y, 8) )
    v50 = 3;
  SetWinText(window, 19);
  v54 = 0;
  evt.eventCode = 512;
  evt.xCoordOrKeycode = 4;
  evt.yCoordOrFieldID = 2;
  evt.payload = (void *)(v53->factionID + 9);
  if ( !(gpGame->castles[a2].buildingsBuiltFlags & 0x40) )
    evt.payload = (char *)evt.payload + 6;
  heroWindow::BroadcastMessage(window, &evt);
  if ( v50 != 3 || !BitTest(gpGame->field_27BB, v53->idx) )
  {
    evt.xCoordOrKeycode = 6;
    evt.yCoordOrFieldID = 300;
    evt.payload = (void *)4;
    heroWindow::BroadcastMessage(window, &evt);
  }
  if ( v53->ownerIdx == -1 )
  {
    evt.xCoordOrKeycode = 6;
    evt.yCoordOrFieldID = 8;
    evt.payload = (void *)4;
    heroWindow::BroadcastMessage(window, &evt);
    ++evt.yCoordOrFieldID;
    heroWindow::BroadcastMessage(window, &evt);
  }
  else
  {
    evt.xCoordOrKeycode = 4;
    evt.yCoordOrFieldID = 8;
    evt.payload = (void *)(2 * gpGame->players[v53->ownerIdx].color);
    heroWindow::BroadcastMessage(window, &evt);
    ++evt.yCoordOrFieldID;
    ++evt.payload;
    heroWindow::BroadcastMessage(window, &evt);
  }
  v5 = GetTownName(v53->idx);
  sprintf(gText, v5);
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 1;
  evt.payload = gText;
  heroWindow::BroadcastMessage(window, &evt);
  v54 = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( v53->garrison.creatureTypes[i] != -1 )
      ++v54;
  }
  if ( v50 && v54 )
  {
    v26 = 76;
    if ( v54 < 1 )
      goto LABEL_43;
    if ( v54 <= 3 )
    {
      v26 = 98;
      v25 = v54;
      v34 = 0;
    }
    else
    {
      if ( v54 != 4 )
      {
LABEL_43:
        v25 = 2;
        v34 = 3;
        goto LABEL_48;
      }
      v25 = 2;
      v34 = 2;
    }
LABEL_48:
    v37 = 0;
    v28 = 0;
    v33 = 192 / v25;
    v29 = (192 / v25 - 32) / 2 + 22;
    v31 = 0;
    for ( i = 0; i < v25; ++i )
    {
      if ( v54 == 5 )
      {
        if ( i )
          v31 = -12;
        else
          v31 = 12;
      }
      while ( v53->garrison.creatureTypes[v28] == -1 )
        ++v28;
      a7 = v53->garrison.creatureTypes[v28];
      thisa = (iconWidget *)operator new(45);
      if ( thisa )
      {
        v6 = a7;
        v7 = v26 - GetIconEntry(res, a7)->offsetY;
        v8 = v7 - GetIconEntry(res, a7)->height + 30;
        v9 = v31 + v29 + v33 * v37 - GetIconEntry(res, a7)->offsetX;
        v10 = GetIconEntry(res, a7);
        v36[v37] = (int)iconWidget::iconWidget(
                          thisa,
                          (32 - v10->width) / 2 + (_WORD)v9 + 1,
                          v8,
                          32,
                          32,
                          "mons32.icn",
                          v6,
                          0,
                          -1,
                          16,
                          1);
      }
      else
      {
        v36[v37] = 0;
      }
      if ( !v36[v37] )
        MemError();
      *(_DWORD *)&a1[4 * v37] = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F6E8 + 214);
      if ( v50 == 3 )
      {
        sprintf(*(char **)&a1[4 * v37], "%d", v53->garrison.quantities[v28]);
      }
      else if ( v50 == 2 )
      {
        v11 = advManager::GetArmySizeName(v53->garrison.quantities[v28], 0);
        strcpy(*(char **)&a1[4 * v37], v11);
      }
      else
      {
        strcpy(*(char **)&a1[4 * v37], "???");
      }
      v21 = (textWidget *)operator new(43);
      if ( v21 )
        v38[v37] = (int)textWidget::textWidget(
                          v21,
                          (_WORD)v31 + (_WORD)v29 + v33 * (_WORD)v37 - 14,
                          v26 + 32,
                          60,
                          12,
                          *(char **)&a1[4 * v37],
                          "smalfont.fnt",
                          1,
                          -1,
                          512,
                          1);
      else
        v38[v37] = 0;
      if ( !v38[v37] )
        MemError();
      heroWindow::AddWidget(window, (widget *)v36[v37], -1);
      heroWindow::AddWidget(window, (widget *)v38[v37++], -1);
      ++v28;
    }
    if ( v34 )
    {
      v33 = 192 / v34;
      v30 = (192 / v34 - 32) / 2 + 22;
      v27 = v26 + 44;
      for ( i = v25; v34 + v25 > i; ++i )
      {
        while ( v53->garrison.creatureTypes[v28] == -1 )
          ++v28;
        a7 = v53->garrison.creatureTypes[v28];
        v20 = (iconWidget *)operator new(45);
        if ( v20 )
        {
          v12 = a7;
          v13 = v27 - GetIconEntry(res, a7)->offsetY;
          v14 = v13 - GetIconEntry(res, a7)->height + 30;
          v15 = v30 + v33 * (v37 - v25) - GetIconEntry(res, a7)->offsetX;
          v16 = GetIconEntry(res, a7);
          v36[v37] = (int)iconWidget::iconWidget(
                            v20,
                            (32 - v16->width) / 2 + (_WORD)v15 + 1,
                            v14,
                            32,
                            32,
                            "mons32.icn",
                            v12,
                            0,
                            -1,
                            16,
                            1);
        }
        else
        {
          v36[v37] = 0;
        }
        if ( !v36[v37] )
          MemError();
        *(_DWORD *)&a1[4 * v37] = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F6E8 + 264);
        if ( v50 == 3 )
        {
          sprintf(*(char **)&a1[4 * v37], "%d", v53->garrison.quantities[v28]);
        }
        else if ( v50 == 2 )
        {
          v17 = advManager::GetArmySizeName(v53->garrison.quantities[v28], 0);
          strcpy(*(char **)&a1[4 * v37], v17);
        }
        else
        {
          strcpy(*(char **)&a1[4 * v37], "???");
        }
        v19 = (textWidget *)operator new(43);
        if ( v19 )
          v38[v37] = (int)textWidget::textWidget(
                            v19,
                            (_WORD)v30 + (_WORD)v33 * (v37 - (_WORD)v25) - 14,
                            v27 + 32,
                            60,
                            12,
                            *(char **)&a1[4 * v37],
                            "smalfont.fnt",
                            1,
                            -1,
                            512,
                            1);
        else
          v38[v37] = 0;
        if ( !v38[v37] )
          MemError();
        heroWindow::AddWidget(window, (widget *)v36[v37], -1);
        heroWindow::AddWidget(window, (widget *)v38[v37++], -1);
        ++v28;
      }
    }
    goto LABEL_93;
  }
  content = (char *)BaseAlloc(0x14u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F6E8 + 131);
  if ( v50 )
    sprintf(content, "None");
  else
    sprintf(content, "Unknown");
  v23 = (textWidget *)operator new(43);
  if ( v23 )
    guiObj = (widget *)textWidget::textWidget(v23, 13, 117, 211, 12, content, "smalfont.fnt", 1, -1, 512, 1);
  else
    guiObj = 0;
  if ( !guiObj )
    MemError();
  heroWindow::AddWidget(window, guiObj, -1);
LABEL_93:
  heroWindowManager::AddWindow(gpWindowManager, window, -1, 1);
  v49 = *(_DWORD *)((char *)v18 + 470);
  v48 = *(_DWORD *)((char *)v18 + 474);
  *(_DWORD *)((char *)v18 + 470) = v53->x - 7;
  *(_DWORD *)((char *)v18 + 474) = v53->y - 7;
  advManager::UpdateRadar((advManager *)v18, 1, 0);
  QuickViewWait();
  heroWindowManager::RemoveWindow(gpWindowManager, window);
  operator delete(window);
  *(_DWORD *)((char *)v18 + 470) = v49;
  *(_DWORD *)((char *)v18 + 474) = v48;
  advManager::UpdateRadar((advManager *)v18, 1, 0);
  advManager::CompleteDraw((advManager *)v18, 0);
  advManager::UpdateScreen((advManager *)v18, 0, 0);
  if ( evt.eventCode == 8 && v53->ownerIdx == giCurPlayer )
    advManager::SetTownContext((advManager *)v18, v53->idx);
  resourceManager::Dispose(gpResourceManager, (resource *)res);
}
// 4F21F0: using guessed type int giDebugLevel;
// 50F6E8: using guessed type __int16 word_50F6E8;
// 44FA80: using guessed type int var_8C[5];
// 44FA80: using guessed type int var_74[5];

//----- (004506B0) --------------------------------------------------------
void __thiscall advManager::RedrawAdvScreen(advManager *this, int a2, int a3)
{
  if ( bShowIt )
  {
    resourceManager::GetBackdrop(gpResourceManager, "advbord.icn", gpWindowManager->screenBuffer, 1);
    if ( a3 )
    {
      BaseFree((void *)this->field_BA, (int)"F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50F7C0 + 9);
      this->field_BA = 0;
    }
    advManager::SaveAdventureBorder((int)this);
    advManager::UpdateHeroLocators(this, 0, 0);
    advManager::UpdateTownLocators(this, 0, 0);
    advManager::UpdBottomView(this, 1, 0, 0);
    heroWindow::DrawWindow(this->adventureScreen, 0);
    if ( a2 )
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
    advManager::UpdateRadar(this, a2, 0);
    advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
    if ( a2 )
      advManager::UpdateScreen(this, 0, 0);
  }
}
// 50F7C0: using guessed type __int16 word_50F7C0;
// 524C14: using guessed type int bShowIt;

//----- (004507D0) --------------------------------------------------------
playerData *__cdecl advManager::DeactivateCurrTown()
{
  playerData *result; // eax@1

  result = gpCurPlayer;
  LOBYTE(gpCurPlayer->field_45) = -1;
  return result;
}

//----- (004507F0) --------------------------------------------------------
playerData *__thiscall advManager::DeactivateCurrHero(advManager *this)
{
  playerData *result; // eax@1

  advManager::DemobilizeCurrHero(this);
  result = gpCurPlayer;
  gpCurPlayer->curHeroIdx = -1;
  return result;
}

//----- (00450820) --------------------------------------------------------
void __thiscall advManager::MobilizeCurrHero(advManager *this, int a2)
{
  if ( gpCurPlayer->curHeroIdx != -1 )
  {
    if ( !this->heroMobilized )
      advManager::SetHeroContext(this, gpCurPlayer->curHeroIdx, a2);
  }
}

//----- (00450880) --------------------------------------------------------
void __thiscall advManager::DemobilizeCurrHero(advManager *thisa)
{
  mapCell *tile; // [sp+10h] [bp-8h]@3
  hero *hro; // [sp+14h] [bp-4h]@3

  if ( gpCurPlayer->curHeroIdx != -1 && thisa->heroMobilized )
  {
    thisa->heroMobilized = 0;
    hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
    advManager::StopCursor(thisa, 1);
    tile = advManager::GetCell(thisa, hro->x, hro->y);
    hro->occupiedObjType = tile->objType;
    hro->occupiedObjVal = (unsigned __int8)((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
    HIBYTE(hro->field_2B) = LOBYTE(thisa->field_27E);
    if ( thisa->field_27A == 6 )
      hro->flags |= 0x80u;
    tile->objType = 170;
    tile->field_4_1_1_isShadow_1_13_extraInfo = tile->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * hro->idx;
    tile->displayFlags &= 0xBFu;
    thisa->field_272 = 0;
    advManager::CompleteDraw(thisa, thisa->viewX, thisa->viewY, 0, 1);
    advManager::UpdateScreen(thisa, 0, 0);
  }
}

//----- (004509F0) --------------------------------------------------------
advManager *__thiscall advManager::SetTownContext(advManager *this, int a2)
{
  advManager *result; // eax@12
  int v4; // [sp+10h] [bp-Ch]@1
  int v5; // [sp+10h] [bp-Ch]@10
  signed int i; // [sp+14h] [bp-8h]@1
  char *v7; // [sp+18h] [bp-4h]@1

  advManager::DeactivateCurrHero(this);
  LOBYTE(gpCurPlayer->field_45) = a2;
  v7 = (char *)&gpGame->castles[LOBYTE(gpCurPlayer->field_45)];
  this->viewX = gpGame->castles[LOBYTE(gpCurPlayer->field_45)].x - 7;
  this->viewY = (unsigned __int8)v7[5] - 7;
  v4 = 0;
  for ( i = 0; gpCurPlayer->numCastles > i; ++i )
  {
    if ( gpCurPlayer->castlesOwned[i] == a2 )
      v4 = i;
  }
  if ( SHIBYTE(gpCurPlayer->field_45) <= v4 )
  {
    if ( HIBYTE(gpCurPlayer->field_45) + 3 < v4 )
      HIBYTE(gpCurPlayer->field_45) = v4 - 3;
  }
  else
  {
    HIBYTE(gpCurPlayer->field_45) = v4;
  }
  advManager::UpdateHeroLocators(this, 1, 1);
  advManager::UpdateTownLocators(this, 1, 1);
  advManager::HideRoute(this, 0, 0, 1);
  advManager::UpdBottomView(this, 1, 1, 1);
  advManager::UpdateRadar(this, 1, 0);
  advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
  advManager::UpdateScreen(this, 0, 0);
  advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
  v5 = (unsigned __int8)giGroundToTerrain[advManager::GetCell(this, (unsigned __int8)v7[4], (unsigned __int8)v7[5])->groundIndex];
  if ( this->currentTerrain != v5 )
  {
    this->currentTerrain = v5;
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
  }
  inputManager::ForceMouseMove();
  result = this;
  this->xOff = 0;
  return result;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00450C10) --------------------------------------------------------
void __thiscall advManager::SetHeroContext(advManager *this, int heroIdx, int a3)
{
  mapCell *v4; // [sp+10h] [bp-10h]@5
  int heroOwnedIdx; // [sp+14h] [bp-Ch]@5
  int heroOwnedIdxa; // [sp+14h] [bp-Ch]@18
  signed int i; // [sp+18h] [bp-8h]@5
  hero *hro; // [sp+1Ch] [bp-4h]@2

  if ( heroIdx != -1 )
  {
    advManager::DeactivateCurrTown();
    advManager::HideRoute(this, 0, 0, 1);
    advManager::DeactivateCurrHero(this);
    this->heroMobilized = 1;
    gpCurPlayer->curHeroIdx = heroIdx;
    hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
    this->viewX = gpGame->heroes[gpCurPlayer->curHeroIdx].x - 7;
    this->viewY = hro->y - 7;
    this->field_29A = 7;
    this->field_292 = this->field_29A;
    this->field_29E = -1;
    this->field_296 = this->field_29E;
    if ( hro->flags & HERO_AT_SEA )
      this->field_27A = 6;
    else
      this->field_27A = hro->factionID;
    this->field_27E = HIBYTE(hro->field_2B);
    this->field_282 = advManager::GetCursorBaseFrame(this->field_27E);
    v4 = advManager::GetCell(this, hro->x, hro->y);
    v4->displayFlags |= 0x40u;
    game::RestoreCell(hro->x, hro->y, hro->occupiedObjType, hro->occupiedObjVal, 0, 4);
    heroOwnedIdx = 0;
    for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
    {
      if ( gpCurPlayer->heroesOwned[i] == heroIdx )
        heroOwnedIdx = i;
    }
    if ( gpCurPlayer->field_3 <= heroOwnedIdx )
    {
      if ( gpCurPlayer->field_3 + 3 < heroOwnedIdx )
        gpCurPlayer->field_3 = heroOwnedIdx - 3;
    }
    else
    {
      gpCurPlayer->field_3 = heroOwnedIdx;
    }
    advManager::UpdateHeroLocators(this, 1, 1);
    advManager::UpdateTownLocators(this, 1, 1);
    if ( !a3 && (this->ready == 1 || gbThisNetHumanPlayer[giCurPlayer]) )
    {
      advManager::Reseed(0, 0);
      advManager::SeedTo((int)this, *(_QWORD *)&hro->field_21);
      advManager::ShowRoute(this, 0, 0, 1);
    }
    advManager::UpdBottomView(this, 1, 1, 1);
    this->field_272 = 1;
    advManager::UpdateRadar(this, 1, 0);
    advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
    advManager::UpdateScreen(this, 0, 0);
    advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
    heroOwnedIdxa = (unsigned __int8)giGroundToTerrain[v4->groundIndex];
    if ( this->currentTerrain != heroOwnedIdxa )
    {
      this->currentTerrain = heroOwnedIdxa;
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
    }
    if ( !gbHeroMoving )
    {
      inputManager::ForceMouseMove();
      this->xOff = 0;
    }
  }
}
// 4F3084: using guessed type int gbHeroMoving;
// 5240A8: using guessed type int gpSoundManager;

//----- (00450FB0) --------------------------------------------------------
void __thiscall advManager::DoHeroKnob(void *this)
{
  void *thisa; // [sp+14h] [bp-78h]@1
  char v2; // [sp+18h] [bp-74h]@14
  tag_message a2; // [sp+34h] [bp-58h]@1
  int v4; // [sp+50h] [bp-3Ch]@10
  int y; // [sp+54h] [bp-38h]@1
  int v6; // [sp+58h] [bp-34h]@1
  int v7; // [sp+60h] [bp-2Ch]@5
  int x; // [sp+74h] [bp-18h]@1
  int v9; // [sp+78h] [bp-14h]@1
  int v10; // [sp+7Ch] [bp-10h]@1
  int v11; // [sp+80h] [bp-Ch]@1
  double v12; // [sp+84h] [bp-8h]@1

  thisa = this;
  v11 = gpCurPlayer->field_3;
  v10 = gpCurPlayer->numHeroes;
  v12 = 73.0 / (double)(v10 - 4);
  mouseManager::MouseCoords(&x, &y);
  v9 = y - *(_WORD *)(*(_DWORD *)((char *)thisa + 178) + 26);
  inputManager::Flush(gpInputManager);
  memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
  while ( v6 != 16 && v6 != 64 )
  {
    if ( v6 == 4 )
    {
      if ( v9 + 195 > v7 )
        v7 = v9 + 195;
      if ( v9 + 268 < v7 )
        v7 = v9 + 268;
      (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
      *(_WORD *)(*(_DWORD *)((char *)thisa + 178) + 26) = v7 - v9;
      heroWindow::DrawWindow(*(heroWindow **)((char *)thisa + 154));
      if ( v10 > 4 )
      {
        v4 = (signed __int64)((double)((signed int)*(_WORD *)(*(_DWORD *)((char *)thisa + 178) + 26) - 195) / v12);
        if ( v4 != v11 )
        {
          gpCurPlayer->field_3 = v4;
          if ( v10 - 3 < v4 )
            v4 = v10 - 3;
          advManager::UpdateHeroLocators((advManager *)thisa, 0, 1);
          *(_WORD *)(*(_DWORD *)((char *)thisa + 178) + 26) = v7 - v9;
          heroWindow::DrawWindow(*(heroWindow **)((char *)thisa + 154));
          v11 = v4;
        }
      }
    }
    Process1WindowsMessage();
    memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v2), 0x1Cu);
  }
  *(_WORD *)(*(_DWORD *)((char *)thisa + 178) + 22) &= 0xFFFEu;
  advManager::UpdateHeroLocators((advManager *)thisa, 1, 1);
}

//----- (004511B0) --------------------------------------------------------
void __thiscall advManager::DoTownKnob(void *this)
{
  void *v1; // [sp+14h] [bp-78h]@1
  char v2; // [sp+18h] [bp-74h]@14
  tag_message a2; // [sp+34h] [bp-58h]@1
  int v4; // [sp+50h] [bp-3Ch]@10
  int y; // [sp+54h] [bp-38h]@1
  int v6; // [sp+58h] [bp-34h]@1
  int v7; // [sp+60h] [bp-2Ch]@5
  int x; // [sp+74h] [bp-18h]@1
  int v9; // [sp+78h] [bp-14h]@1
  int v10; // [sp+7Ch] [bp-10h]@1
  int v11; // [sp+80h] [bp-Ch]@1
  double v12; // [sp+84h] [bp-8h]@1

  v1 = this;
  v11 = HIBYTE(gpCurPlayer->field_45);
  v10 = gpCurPlayer->numCastles;
  v12 = 73.0 / (double)(v10 - 4);
  mouseManager::MouseCoords(&x, &y);
  v9 = y - *(_WORD *)(*(_DWORD *)((char *)v1 + 182) + 26);
  inputManager::Flush(gpInputManager);
  memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
  while ( v6 != 16 && v6 != 64 )
  {
    if ( v6 == 4 )
    {
      if ( v9 + 195 > v7 )
        v7 = v9 + 195;
      if ( v9 + 268 < v7 )
        v7 = v9 + 268;
      (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
      *(_WORD *)(*(_DWORD *)((char *)v1 + 182) + 26) = v7 - v9;
      heroWindow::DrawWindow(*(heroWindow **)((char *)v1 + 154));
      if ( v10 > 4 )
      {
        v4 = (signed __int64)((double)((signed int)*(_WORD *)(*(_DWORD *)((char *)v1 + 182) + 26) - 195) / v12);
        if ( v4 != v11 )
        {
          HIBYTE(gpCurPlayer->field_45) = v4;
          if ( v10 - 3 < v4 )
            v4 = v10 - 3;
          advManager::UpdateTownLocators(v1, 0, 1);
          *(_WORD *)(*(_DWORD *)((char *)v1 + 182) + 26) = v7 - v9;
          heroWindow::DrawWindow(*(heroWindow **)((char *)v1 + 154));
          v11 = v4;
        }
      }
    }
    Process1WindowsMessage();
    memcpy(&v6, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v2), 0x1Cu);
  }
  *(_WORD *)(*(_DWORD *)((char *)v1 + 182) + 22) &= 0xFFFEu;
  advManager::UpdateTownLocators(v1, 1, 1);
}

//----- (004513B0) --------------------------------------------------------
void __thiscall advManager::CastSpell(advManager *this, int spell)
{
  int v2; // edx@0
  mapCell *tile; // [sp+14h] [bp-14h]@10
  signed int v5; // [sp+18h] [bp-10h]@12
  hero *hro; // [sp+20h] [bp-8h]@2
  char v7; // [sp+24h] [bp-4h]@5

  if ( gpCurPlayer->curHeroIdx == -1 )
    hro = 0;
  else
    hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  switch ( spell )
  {
    case SPELL_SET_EARTH_GUARDIAN:
      v7 = 62;
      goto LABEL_10;
    case SPELL_SET_AIR_GUARDIAN:
      v7 = 63;
      goto LABEL_10;
    case SPELL_SET_FIRE_GUARDIAN:
      v7 = 64;
      goto LABEL_10;
    case SPELL_SET_WATER_GUARDIAN:
      v7 = 65;
      goto LABEL_10;
    case SPELL_HAUNT:
      v7 = 59;
LABEL_10:
      tile = advManager::GetCell(gpAdvManager, hro->x, hro->y);
      if ( tile->objType != 151 )
      {
        NormalDialog(
          "You must be standing on the entrance to a mine (sawmills and alchemists don't count) to cast this spell.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
        return;
      }
      gpGame->mines[(unsigned __int8)((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = v7;
      v5 = hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER);
      if ( v5 > 51 )
        LOBYTE(v5) = 51;
      gpGame->mines[(unsigned __int8)((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = 4 * v5;
      if ( spell == 60 )
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          -1);
      goto LABEL_32;
    case SPELL_VIEW_MINES:
    case SPELL_VIEW_RESOURCES:
    case SPELL_VIEW_ARTIFACTS:
    case SPELL_VIEW_TOWNS:
    case SPELL_VIEW_HEROES:
    case SPELL_VIEW_ALL:
      advManager::ViewWorld(this, v2, spell, spell == 53, spell == 53);
      goto LABEL_32;
    case SPELL_IDENTIFY:
      this->identifyCast = 1;
      NormalDialog("Enemy heroes are now fully identifiable.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      goto LABEL_32;
    case SPELL_SUMMON_BOAT:
      advManager::SummonBoat(this);
      goto LABEL_32;
    case SPELL_DIMENSION_DOOR:
    case SPELL_TOWN_GATE:
    case SPELL_TOWN_PORTAL:
      if ( hro->remainingMobility )
      {
        if ( hro->remainingMobility >= 225 )
          hro->remainingMobility -= 225;
        else
          hro->remainingMobility = 0;
        advManager::UpdateHeroLocator(this, -1, 1, 1);
        if ( spell == SPELL_DIMENSION_DOOR )
          advManager::DimensionDoor(this);
        else
          advManager::TownGate(this, spell);
LABEL_32:
        if ( spell != SPELL_DIMENSION_DOOR && spell != SPELL_TOWN_GATE )
        {
          if ( spell != SPELL_TOWN_PORTAL )
            hero::UseSpell(&gpGame->heroes[gpCurPlayer->curHeroIdx], spell);
        }
      }
      else
      {
        NormalDialog(
          "Your hero is too tired to cast this spell today.  Try again tomorrow.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      return;
    case SPELL_VISIONS:
      if ( advManager::DoVisions(this, hro) )
        goto LABEL_32;
      return;
    default:
      goto LABEL_32;
  }
}

//----- (00451750) --------------------------------------------------------
int __cdecl SaveGame()
{
  fileRequester *this; // [sp+14h] [bp-30h]@14
  char a7; // [sp+18h] [bp-2Ch]@8
  int v3; // [sp+20h] [bp-24h]@1
  int v4; // [sp+24h] [bp-20h]@19
  char a5; // [sp+28h] [bp-1Ch]@8
  int i; // [sp+38h] [bp-Ch]@1
  int v7; // [sp+3Ch] [bp-8h]@1
  baseManager *a2; // [sp+40h] [bp-4h]@15

  v3 = 0;
  v7 = 0;
  advManager::DisableButtons(gpAdvManager);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  for ( i = 0; i < 6; ++i )
  {
    if ( !gpGame->playerDead[i] )
    {
      if ( gbHumanPlayer[i] )
        ++v7;
    }
  }
  if ( gbInCampaign )
  {
    sprintf(&a7, ".GMC");
    sprintf(&a5, "*.GMC");
  }
  else if ( xIsPlayingExpansionCampaign )
  {
    sprintf(&a7, ".GXC");
    sprintf(&a5, "*.GXC");
  }
  else if ( xIsExpansionMap )
  {
    sprintf(&a7, ".GX%d", v7);
    sprintf(&a5, "*.GX%d", v7);
  }
  else
  {
    sprintf(&a7, ".GM%d", v7);
    sprintf(&a5, "*.GM%d", v7);
  }
  this = (fileRequester *)operator new(1071);
  if ( this )
    a2 = (baseManager *)fileRequester::fileRequester(this, 131, 58, 3, &a5, ".\\GAMES\\", &a7);
  else
    a2 = 0;
  if ( !a2 )
    MemError();
  v4 = executive::DoDialog(gpExec, a2);
  if ( v4 == 30722 )
  {
    v3 = 1;
    bFreshSave = 1;
    v3 = game::SaveGame(gpGame, gLastFilename, 0, 0);
    if ( v3 )
      NormalDialog("Game saved successfully.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  operator delete(a2);
  advManager::EnableButtons(gpAdvManager);
  return v3;
}
// 5235D8: using guessed type int bFreshSave;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (004519A0) --------------------------------------------------------
void __thiscall advManager::CheckCastSpell(advManager *this)
{
  int selectedSpell; // eax@2

  if ( gpCurPlayer->curHeroIdx != -1 )
  {
    advManager::MobilizeCurrHero(this, 0);
    advManager::CompleteDraw(this, 0);
    advManager::UpdateScreen(this, 0, 0);
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
    selectedSpell = game::ViewSpells(
                      gpGame,
                      &gpGame->heroes[gpCurPlayer->curHeroIdx],
                      1,
                      (int (__fastcall *)(struct tag_message *))NullHandler,
                      0);
    advManager::CastSpell(this, selectedSpell);
  }
}

//----- (00451A50) --------------------------------------------------------
signed int __thiscall DimensionDoorHandler(void *this)
{
  signed int result; // eax@36
  signed int v2; // [sp+10h] [bp-20h]@5
  int v3; // [sp+14h] [bp-1Ch]@4
  int v4; // [sp+18h] [bp-18h]@3
  void *v5; // [sp+1Ch] [bp-14h]@1
  mapCell *v6; // [sp+20h] [bp-10h]@31
  signed int v7; // [sp+24h] [bp-Ch]@3
  signed int v8; // [sp+24h] [bp-Ch]@21
  signed int v9; // [sp+28h] [bp-8h]@3
  signed int v10; // [sp+28h] [bp-8h]@21
  signed int v11; // [sp+2Ch] [bp-4h]@3

  v5 = this;
  if ( KBTickCount() > glTimers )
  {
    advManager::CompleteDraw(gpAdvManager, gpAdvManager->viewX, gpAdvManager->viewY, 0, 1);
    advManager::UpdateScreen(gpAdvManager, 0, 0);
  }
  v9 = *((_DWORD *)v5 + 4);
  v7 = *((_DWORD *)v5 + 5);
  v11 = 0;
  v4 = *(_DWORD *)v5;
  if ( v4 == 4 )
  {
    if ( !InMapArea(*((_DWORD *)v5 + 4), *((_DWORD *)v5 + 5)) )
    {
      gpWindowManager->buttonPressedCode = 0;
      mouseManager::SetPointer(gpMouseManager, 0);
      return 1;
    }
    v10 = v9 / 32;
    v8 = v7 / 32;
    if ( v10 < 0 )
      v10 = 0;
    if ( v8 < 0 )
      v8 = 0;
    if ( v10 > 14 )
      v10 = 14;
    if ( v8 > 14 )
      v8 = 14;
    if ( gpAdvManager->xOff != v10 || gpAdvManager->yOff != v8 )
    {
      gpAdvManager->xOff = v10;
      gpAdvManager->yOff = v8;
      v6 = advManager::GetCell(gpAdvManager, v10 + gpAdvManager->viewX, v8 + gpAdvManager->viewY);
      if ( v6->objType & 0x80 || v6->displayFlags & 8 )
      {
        gpWindowManager->buttonPressedCode = 0;
        mouseManager::SetPointer(gpMouseManager, 0);
      }
      else
      {
        gpWindowManager->buttonPressedCode = 1;
        mouseManager::SetPointer(gpMouseManager, 4);
      }
    }
  }
  else if ( v4 == 512 )
  {
    v3 = *((_DWORD *)v5 + 1);
    if ( v3 == 12 )
    {
      v2 = *((_DWORD *)v5 + 2);
      if ( v2 >= 10 && v2 <= 11 && !(*((_BYTE *)v5 + 13) & 2) && gpWindowManager->buttonPressedCode == 1 )
        v11 = 1;
    }
    else if ( v3 == 13 && *((_DWORD *)v5 + 2) == 30720 )
    {
      gpWindowManager->buttonPressedCode = 0;
      v11 = 1;
    }
  }
  if ( v11 )
  {
    *((_DWORD *)v5 + 2) = 10;
    *((_DWORD *)v5 + 1) = *((_DWORD *)v5 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00451D70) --------------------------------------------------------
signed int __thiscall advManager::ComboDraw(advManager *this, int a2, int a3, int a4)
{
  signed int result; // eax@2
  int v5; // edx@11
  mapCell *v7; // [sp+10h] [bp-18h]@19
  mapCell *v8; // [sp+10h] [bp-18h]@81
  signed int a4a; // [sp+14h] [bp-14h]@11
  signed int a4b; // [sp+14h] [bp-14h]@55
  signed int a4c; // [sp+14h] [bp-14h]@69
  signed int a4d; // [sp+14h] [bp-14h]@79
  signed int a4e; // [sp+14h] [bp-14h]@105
  signed int a4f; // [sp+14h] [bp-14h]@122
  signed int a4g; // [sp+14h] [bp-14h]@130
  signed int a4h; // [sp+14h] [bp-14h]@143
  signed int a4i; // [sp+14h] [bp-14h]@177
  signed int a4j; // [sp+14h] [bp-14h]@185
  signed int a4k; // [sp+14h] [bp-14h]@193
  signed int a3a; // [sp+18h] [bp-10h]@13
  signed int a3b; // [sp+18h] [bp-10h]@53
  signed int a3c; // [sp+18h] [bp-10h]@71
  signed int a3d; // [sp+18h] [bp-10h]@77
  signed int a3e; // [sp+18h] [bp-10h]@107
  signed int a3f; // [sp+18h] [bp-10h]@124
  signed int a3g; // [sp+18h] [bp-10h]@132
  signed int a3h; // [sp+18h] [bp-10h]@138
  signed int a3i; // [sp+18h] [bp-10h]@145
  signed int a3j; // [sp+18h] [bp-10h]@150
  signed int a3k; // [sp+18h] [bp-10h]@155
  signed int a3l; // [sp+18h] [bp-10h]@167
  signed int a3m; // [sp+18h] [bp-10h]@172
  signed int a3n; // [sp+18h] [bp-10h]@179
  signed int a3o; // [sp+18h] [bp-10h]@187
  signed int a3p; // [sp+18h] [bp-10h]@195
  int v36; // [sp+1Ch] [bp-Ch]@111
  int v37; // [sp+20h] [bp-8h]@111
  int v38; // [sp+24h] [bp-4h]@193

  PollSound();
  if ( !bShowIt )
    return 0;
  if ( this->field_2AE )
  {
    advManager::CompleteDraw(this, a2, a3, 0, 1);
    return 1;
  }
  if ( a4 )
  {
    giFrameCount += giFrameStep;
    if ( giFrameCount < 12 )
    {
      Process1WindowsMessage();
      if ( KBTickCount() > glTimers )
        glTimers = KBTickCount() + 120;
      PollSound();
      return 0;
    }
    giFrameCount = 0;
  }
  this->field_1DE = this->viewX;
  this->field_1E2 = this->viewY;
  memset(&bComboDraw, 0, 0x100u);
  this->field_2A2 = 0;
  for ( a4a = 0; a4a < 15; ++a4a )
  {
    for ( a3a = 0; a3a < 15; ++a3a )
    {
      if ( a2 + a3a >= 0 && a2 + a3a < MAP_WIDTH && a3 + a4a >= 0 && a3 + a4a < MAP_HEIGHT )
      {
        v7 = advManager::GetCell(this, a2 + a3a, a3 + a4a);
        if ( v7->bitfield_1_hasObject_1_isRoad_6_objTileset & 1
          || v7->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset & 1 )
          ++*((_BYTE *)&bComboDraw + 18 * a3a + a4a);
        if ( (v7->objType & 0x7F) == 40 )
          ++*((_BYTE *)&bComboDraw + 18 * a3a + a4a);
        if ( (v7->objType & 0x7F) == 1 )
          ++*((_BYTE *)&bComboDraw + 18 * a3a + a4a);
        if ( v7->objType == 152 )
        {
          ++*((_BYTE *)&bComboDraw + 18 * a3a + a4a);
          ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a - 2) + a4a);
          if ( advManager::GetCloudLookup(a2 + a3a, a3 + a4a) )
          {
            v5 = a4a;
            *((_BYTE *)&bComboDraw + 9 * (2 * a3a + 2) + a4a) += 10;
            if ( a4a >= 1 )
            {
              *((_BYTE *)&dword_524D2C + 18 * a3a + a4a + 3) += 10;
              v5 = a4a;
              *((_BYTE *)&dword_524D2C + 9 * (2 * a3a + 2) + a4a + 3) += 10;
            }
          }
          else
          {
            ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a + 2) + a4a);
            if ( a4a >= 1 )
            {
              ++*((_BYTE *)&dword_524D2C + 18 * a3a + a4a + 3);
              ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3a + 2) + a4a + 3);
            }
          }
        }
        if ( v7->objType == 170 || v7->objType == 171 )
        {
          ++*((_BYTE *)&bComboDraw + 18 * a3a + a4a);
          if ( advManager::GetCloudLookup(a2 + a3a, a3 + a4a) )
          {
            *((_BYTE *)&bComboDraw + 9 * (2 * a3a + 2) + a4a) += 10;
            *(&byte_524D31[18 * a3a] + a4a) += 10;
            *(&byte_524D31[9 * (2 * a3a + 2)] + a4a) += 10;
            v5 = a4a;
            *((_BYTE *)&bComboDraw + 9 * (2 * a3a + 4) + a4a) += 10;
            if ( a4a >= 1 )
            {
              v5 = 18 * a3a;
              *((_BYTE *)&dword_524D2C + 18 * a3a + a4a + 3) += 10;
            }
            if ( a3a >= 1 )
            {
              *((_BYTE *)&bComboDraw + 9 * (2 * a3a - 2) + a4a) += 10;
              v5 = a4a;
              *(&byte_524D31[9 * (2 * a3a - 2)] + a4a) += 10;
              if ( a3a >= 2 )
              {
                v5 = a4a;
                *((_BYTE *)&bComboDraw + 9 * (2 * a3a - 4) + a4a) += 10;
              }
              if ( a4a >= 1 )
                ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3a - 4) + a4a + 3);
            }
          }
          else
          {
            ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a + 2) + a4a);
            ++*(&byte_524D31[18 * a3a] + a4a);
            ++*(&byte_524D31[9 * (2 * a3a + 2)] + a4a);
            ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a + 4) + a4a);
            if ( a4a >= 1 )
              ++*((_BYTE *)&dword_524D2C + 18 * a3a + a4a + 3);
            if ( a3a >= 1 )
            {
              ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a - 2) + a4a);
              ++*(&byte_524D31[9 * (2 * a3a - 2)] + a4a);
              if ( a3a >= 2 )
                ++*((_BYTE *)&bComboDraw + 9 * (2 * a3a - 4) + a4a);
              if ( a4a >= 1 )
                ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3a - 4) + a4a + 3);
            }
          }
        }
      }
    }
  }
  for ( a3b = 0; a3b < 15; ++a3b )
  {
    for ( a4b = 0; a4b < 15; ++a4b )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3b + a4b) )
      {
        if ( a2 + a3b >= 0 && a2 + a3b < MAP_WIDTH && a3 + a4b >= 0 && a3 + a4b < MAP_HEIGHT )
        {
          if ( (signed int)*((_BYTE *)&bComboDraw + 18 * a3b + a4b) < 10
            && !advManager::GetCloudLookup(a2 + a3b, a3 + a4b) )
            *((_BYTE *)&bComboDraw + 18 * a3b + a4b) = 0;
        }
        else
        {
          *((_BYTE *)&bComboDraw + 18 * a3b + a4b) = 0;
        }
      }
    }
  }
  if ( this->heroMobilized )
  {
    for ( a4c = 6; a4c <= 8; ++a4c )
    {
      for ( a3c = 5; a3c <= 9; ++a3c )
        ++*((_BYTE *)&bComboDraw + 18 * a3c + a4c);
    }
  }
  if ( this->field_27A == 6 )
  {
    ++byte_524DA1;
    ++byte_524DB3;
    ++byte_524DC5;
  }
  for ( a3d = 0; a3d < 15; ++a3d )
  {
    for ( a4d = 0; a4d < 15; ++a4d )
    {
      v8 = advManager::GetCell(this, a2 + a3d, a3 + a4d);
      if ( v8->objType == 151 )
      {
        if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(v8->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType == 59 )
        {
          ++*((_BYTE *)&bComboDraw + 18 * a3d + a4d);
          ++*((_BYTE *)&bComboDraw + 9 * (2 * a3d + 2) + a4d);
          if ( a3d < 15 )
            ++*((_BYTE *)&bComboDraw + 9 * (2 * a3d + 4) + a4d);
          if ( a3d > 0 )
            ++*((_BYTE *)&bComboDraw + 9 * (2 * a3d - 2) + a4d);
          if ( a4d > 0 )
          {
            ++*((_BYTE *)&dword_524D2C + 18 * a3d + a4d + 3);
            ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d + 2) + a4d + 3);
            if ( a3d < 15 )
              ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d + 4) + a4d + 3);
            if ( a3d > 0 )
              ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d - 2) + a4d + 3);
          }
          if ( a4d > 1 )
          {
            ++*((_BYTE *)&dword_524D2C + 18 * a3d + a4d + 2);
            ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d + 2) + a4d + 2);
            if ( a3d < 15 )
              ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d + 4) + a4d + 2);
            if ( a3d > 0 )
              ++*((_BYTE *)&dword_524D2C + 9 * (2 * a3d - 2) + a4d + 2);
          }
        }
        else if ( a4d > 0 && *((_BYTE *)&dword_524D2C + 18 * a3d + a4d + 3) )
        {
          ++*((_BYTE *)&bComboDraw + 18 * a3d + a4d);
        }
      }
    }
  }
  if ( this->field_A2 && this->sizeOfSomethingMapRelated )
  {
    for ( a4e = 1; a4e < 14; ++a4e )
    {
      for ( a3e = 0; a3e < 15; ++a3e )
      {
        if ( *((_BYTE *)&bComboDraw + 18 * a3e + a4e) )
        {
          v37 = a2 + a3e;
          v36 = a3 + a4e;
          if ( a2 + a3e >= 0 )
          {
            if ( MAP_WIDTH - 1 >= v37 && v36 >= 1 && MAP_HEIGHT - 2 >= v36 )
            {
              if ( *(_WORD *)(2 * v37 + 2 * v36 * MAP_WIDTH + this->sizeOfSomethingMapRelated) )
                ++*(&byte_524D31[18 * a3e] + a4e);
              v5 = *(_WORD *)(2 * v37 + 2 * MAP_WIDTH * (v36 - 1) + this->sizeOfSomethingMapRelated);
              if ( *(_WORD *)(2 * v37 + 2 * MAP_WIDTH * (v36 - 1) + this->sizeOfSomethingMapRelated) )
                ++*((_BYTE *)&dword_524D2C + 18 * a3e + a4e + 3);
            }
          }
        }
      }
    }
  }
  gpMouseManager->couldBeShowMouse = 0;
  for ( a4f = 0; a4f < 15; ++a4f )
  {
    for ( a3f = 0; a3f < 15; ++a3f )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3f + a4f) )
        advManager::DrawCell(this, a2 + a3f, a3 + a4f, a3f, a4f, 1, 0);
    }
  }
  for ( a4g = 0; a4g < 15; ++a4g )
  {
    for ( a3g = 0; a3g < 15; ++a3g )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3g + a4g) )
        advManager::DrawCell(this, a2 + a3g, a3 + a4g, a3g, a4g, -128, 0);
    }
  }
  for ( a3h = 0; a3h < 15; ++a3h )
  {
    if ( *((_BYTE *)&bComboDraw + 18 * a3h) )
      advManager::DrawCell(this, a2 + a3h, a3, a3h, 0, 2, 0);
  }
  for ( a4h = 1; a4h < 15; ++a4h )
  {
    PollSound();
    for ( a3i = 0; a3i < 15; ++a3i )
    {
      if ( *((_BYTE *)&dword_524D2C + 18 * a3i + a4h + 3) )
        advManager::DrawCell(this, a2 + a3i, a3 + a4h - 1, a3i, a4h - 1, 8, 0);
    }
    for ( a3j = 0; a3j < 15; ++a3j )
    {
      if ( *((_BYTE *)&dword_524D2C + 18 * a3j + a4h + 3) )
        advManager::DrawCell(this, a2 + a3j, a3 + a4h - 1, a3j, a4h - 1, 4, 0);
    }
    for ( a3k = 0; a3k < 15; ++a3k )
    {
      if ( a2 + a3k != giDeferObjDrawX || a3 + a4h != giDeferObjDrawY )
      {
        if ( a2 + a3k == giDeferObjDrawX && a3 + a4h == giDeferObjDrawY + 1 )
          advManager::DrawCell(this, a2 + a3k, a3 + a4h - 1, a3k, a4h - 1, 2, 0);
        if ( *((_BYTE *)&bComboDraw + 18 * a3k + a4h) )
          advManager::DrawCell(this, a2 + a3k, a3 + a4h, a3k, a4h, 2, 0);
      }
    }
  }
  for ( a3l = 0; a3l < 15; ++a3l )
  {
    if ( byte_524D3E[18 * a3l] )
      advManager::DrawCell(this, a2 + a3l, a3 + 14, a3l, 14, 8, 0);
  }
  for ( a3m = 0; a3m < 15; ++a3m )
  {
    if ( byte_524D3E[18 * a3m] )
      advManager::DrawCell(this, a2 + a3m, a3 + 14, a3m, 14, 4, 0);
  }
  for ( a4i = 0; a4i < 15; ++a4i )
  {
    for ( a3n = 0; a3n < 15; ++a3n )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3n + a4i) )
        advManager::DrawCell(this, a2 + a3n, a3 + a4i, a3n, a4i, 64, 0);
    }
  }
  for ( a4j = 0; a4j < 15; ++a4j )
  {
    for ( a3o = 0; a3o < 15; ++a3o )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3o + a4j) )
        advManager::DrawCell(this, a2 + a3o, a3 + a4j, a3o, a4j, 32, 0);
    }
  }
  advManager::DrawAdventureBorder((int)this, v5);
  gpMouseManager->couldBeShowMouse = 1;
  PollSound();
  advManager::UpdBottomView(this, 0, 1, 1);
  giLimitUpdMinX = 15;
  giLimitUpdMinY = 15;
  giLimitUpdMaxX = 0;
  giLimitUpdMaxY = 0;
  v38 = 0;
  for ( a4k = 0; a4k < 15; ++a4k )
  {
    for ( a3p = 0; a3p < 15; ++a3p )
    {
      if ( *((_BYTE *)&bComboDraw + 18 * a3p + a4k) )
      {
        ++v38;
        if ( giLimitUpdMinX > a3p )
          giLimitUpdMinX = a3p;
        if ( a3p > giLimitUpdMaxX )
          giLimitUpdMaxX = a3p;
        if ( giLimitUpdMinY > a4k )
          giLimitUpdMinY = a4k;
        if ( giLimitUpdMaxY < a4k )
          giLimitUpdMaxY = a4k;
      }
    }
  }
  giLimitUpdMinX *= 32;
  giLimitUpdMinY *= 32;
  giLimitUpdMaxX = 32 * (giLimitUpdMaxX + 1) - 1;
  giLimitUpdMaxY = 32 * (giLimitUpdMaxY + 1) - 1;
  if ( giLimitUpdMinX < 16 )
    giLimitUpdMinX = 16;
  if ( giLimitUpdMaxX > 463 )
    giLimitUpdMaxX = 463;
  if ( giLimitUpdMinY < 16 )
    giLimitUpdMinY = 16;
  if ( giLimitUpdMaxY > 463 )
    giLimitUpdMaxY = 463;
  if ( giLimitUpdMinX <= giLimitUpdMaxX && giLimitUpdMaxY >= giLimitUpdMinY )
  {
    result = 1;
  }
  else
  {
    giLimitUpdMinX = giLimitUpdMaxX - 1;
    giLimitUpdMinY = giLimitUpdMaxY - 1;
    result = 0;
  }
  return result;
}
// 448150: using guessed type _DWORD __stdcall advManager__GetCloudLookup(_DWORD, _DWORD);
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F4BC0: using guessed type int giDeferObjDrawX;
// 4F4BC4: using guessed type int giDeferObjDrawY;
// 50F940: using guessed type int giFrameCount;
// 524C14: using guessed type int bShowIt;
// 524CB4: using guessed type int giFrameStep;
// 524D18: using guessed type int giLimitUpdMaxX;
// 524D1C: using guessed type int giLimitUpdMaxY;
// 524D2C: using guessed type int dword_524D2C;
// 524DA1: using guessed type char byte_524DA1;
// 524DB3: using guessed type char byte_524DB3;
// 524DC5: using guessed type char byte_524DC5;

//----- (00452F20) --------------------------------------------------------
signed int __thiscall advManager::ComboDraw(advManager *this, int a2)
{
  return advManager::ComboDraw(this, this->viewX, this->viewY, a2);
}

//----- (00452F60) --------------------------------------------------------
void __thiscall advManager::SetEnvironmentOrigin(advManager *this, int a2, int a3, int a4)
{
  int j; // [sp+10h] [bp-10h]@11
  int i; // [sp+14h] [bp-Ch]@2
  int k; // [sp+14h] [bp-Ch]@15
  signed int l; // [sp+14h] [bp-Ch]@20
  signed int a3a; // [sp+1Ch] [bp-4h]@13

  if ( *(_DWORD *)(gpSoundManager + 1672) )
  {
    for ( i = 0; i < 4; ++i )
    {
      if ( this->field_2C2[i][0] != -1 )
      {
        LogInt((int)"SEO a", i, -999, -999, -999, -999, -999, -999);
        if ( a4 )
        {
          LogInt((int)"SEO b", i, -999, -999, -999, -999, -999, -999);
          soundManager::StopSample(
            (soundManager *)gpSoundManager,
            *((HSAMPLE *)this->loopSamples[this->field_2C2[i][0]] + 4));
          this->field_2C2[i][0] = -1;
          this->field_2C2[i][1] = 127;
        }
        else
        {
          this->field_2C2[i][1] = 127;
        }
      }
    }
    if ( a2 != -1 && *(_DWORD *)&soundVolume )
    {
      this->field_2BE = 0;
      for ( j = 1; j <= 2; ++j )
      {
        advManager::InsertSound(this, a2, a3, 0, j);
        for ( a3a = 0; a3a < 4; ++a3a )
        {
          for ( k = 0; 2 * a3a > k; ++k )
          {
            advManager::InsertSound(this, k + a2 - a3a, a3 - a3a, a3a, j);
            advManager::InsertSound(this, a3a + a2, k + a3 - a3a, a3a, j);
            advManager::InsertSound(this, a3a + a2 - k, a3a + a3, a3a, j);
            advManager::InsertSound(this, a2 - a3a, a3a + a3 - k, a3a, j);
          }
        }
      }
      for ( l = 0; l < 4; ++l )
      {
        if ( this->field_2C2[l][0] != -1 && this->field_2C2[l][1] > 5 )
        {
          soundManager::StopSample(
            (soundManager *)gpSoundManager,
            *((HSAMPLE *)this->loopSamples[this->field_2C2[l][0]] + 4));
          this->field_2C2[l][0] = -1;
        }
        if ( this->field_2C2[l][0] != -1 && (1 << LOBYTE(this->field_2C2[l][0])) & this->field_2BE )
          soundManager::ModifySample(
            (soundManager *)gpSoundManager,
            *((HSAMPLE *)this->loopSamples[this->field_2C2[l][0]] + 4),
            100,
            dword_4EA270[this->field_2C2[l][1]]);
      }
    }
  }
}
// 4EA270: using guessed type int dword_4EA270[];
// 5240A8: using guessed type int gpSoundManager;

//----- (004532A0) --------------------------------------------------------
void __thiscall advManager::CheckLoadSample(advManager *this, int n)
{
  if ( !this->loopSamples[n] )
  {
    advManager::TrimLoopingSounds(this, 4);
    sprintf(gText, "loop%04d.82M", n);
    this->loopSamples[n] = resourceManager::GetSample(gpResourceManager, gText);
  }
}

//----- (00453310) --------------------------------------------------------
signed int __thiscall advManager::GetSoundId(advManager *this, int x, int y)
{
  signed int result; // eax@3
  int v4; // [sp+Ch] [bp-18h]@58
  mapCell *tile; // [sp+1Ch] [bp-8h]@1

  tile = &this->map->tiles[y * this->map->width] + x;
  if ( !giGroundToTerrain[tile->groundIndex] && giGroundShape[tile->groundIndex] & 0xF )
    return 20;
  if ( tile->objType & 0x80 )
  {
    switch ( tile->objType & 0x7F )
    {
      case 0xD:
        result = 25;
        break;
      case 0xF:
        result = 25;
        break;
      case 0x10:
        result = 25;
        break;
      case 0x11:
        result = 25;
        break;
      case 0x41:
        result = 25;
        break;
      case 0x3D:
        result = 24;
        break;
      case 0x5B:
        result = 23;
        break;
      case 0x3F:
        result = 22;
        break;
      case 0x1F:
        result = 18;
        break;
      case 0x4A:
        result = 18;
        break;
      case 0x4B:
        result = 18;
        break;
      case 3:
        result = 0;
        break;
      case 0x20:
        result = 1;
        break;
      case 0x27:
        result = 2;
        break;
      case 8:
        result = 10;
        break;
      case 0x28:
        result = 11;
        break;
      case 9:
        result = 12;
        break;
      case 0x52:
        result = 12;
        break;
      case 0x54:
        result = 13;
        break;
      case 0x24:
        result = 4;
        break;
      case 0x1E:
        result = 3;
        break;
      case 0x16:
        result = 9;
        break;
      case 1:
        if ( !(tile->objType & 0x80) )
          goto LABEL_66;
        result = 8;
        break;
      case 0x17:
        if ( !(tile->objType & 0x80) )
          goto LABEL_66;
        result = 15;
        break;
      case 0x40:
        if ( !(tile->objType & 0x80) )
          goto LABEL_66;
        result = 26;
        break;
      case 0x1D:
        if ( !(tile->objType & 0x80) )
          goto LABEL_66;
        result = 16;
        break;
      case 5:
        if ( !(tile->objType & 0x80) )
          goto LABEL_66;
        result = 17;
        break;
      default:
        goto LABEL_66;
    }
  }
  else
  {
    switch ( tile->objType )
    {
      case 0x51:
        return 21;
      case 0x70:
        if ( tile->objectIndex < 39 || tile->objectIndex > 44 )
          result = 6;
        else
          result = 7;
        return result;
      case 0x65:
        if ( (((unsigned __int8)tile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 58
          && (((unsigned __int8)tile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 60 )
          result = 5;
        else
          result = 27;
        return result;
      case 0x68:
        if ( (((unsigned __int8)tile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 52 )
          goto LABEL_58;
        return 13;
      default:
LABEL_58:
        v4 = ((unsigned __int8)tile->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F;
        if ( v4 == 40 )
        {
          if ( tile->objectIndex == 182 || tile->objectIndex == 183 )
            return 19;
        }
        else if ( v4 == 45 )
        {
          return 14;
        }
LABEL_66:
        result = -1;
        break;
    }
  }
  return result;
}

//----- (004537E0) --------------------------------------------------------
void __thiscall advManager::InsertSound(advManager *this, int a2, int _2C, int a3, int a4)
{
  int n; // [sp+10h] [bp-10h]@5
  signed int i; // [sp+14h] [bp-Ch]@6
  signed int j; // [sp+14h] [bp-Ch]@14
  int v9; // [sp+18h] [bp-8h]@14
  signed int v10; // [sp+1Ch] [bp-4h]@14

  if ( (signed __int64)__PAIR__(_2C, a2) >= 0 )
  {
    if ( a2 < MAP_WIDTH )
    {
      if ( MAP_HEIGHT > _2C )
      {
        n = advManager::GetSoundId(this, a2, _2C);
        if ( n != -1 )
        {
          for ( i = 0; i < 4; ++i )
          {
            if ( this->field_2C2[i][0] == n )
            {
              if ( this->field_2C2[i][1] > a3 )
              {
                this->field_2C2[i][1] = a3;
                this->field_2BE |= 1 << LOBYTE(this->field_2C2[i][0]);
              }
              return;
            }
          }
          if ( a4 != 1 )
          {
            v9 = a3;
            v10 = -1;
            for ( j = 0; j < 4; ++j )
            {
              if ( this->field_2C2[j][1] > v9 )
              {
                v9 = this->field_2C2[j][1];
                v10 = j;
              }
            }
            if ( v10 != -1 )
            {
              if ( this->field_2C2[v10][0] != -1 )
                soundManager::StopSample(
                  (soundManager *)gpSoundManager,
                  *((HSAMPLE *)this->loopSamples[this->field_2C2[v10][0]] + 4));
              this->field_2C2[v10][0] = n;
              this->field_2C2[v10][1] = a3;
              advManager::CheckLoadSample(this, n);
              *((_DWORD *)this->loopSamples[n] + 10) = dword_4EA270[a3];
              *((_DWORD *)this->loopSamples[n] + 11) = 0;
              *((_DWORD *)this->loopSamples[n] + 7) = 3;
              soundManager::MemorySample((soundManager *)gpSoundManager, (sample *)this->loopSamples[n]);
              this->field_2BE ^= 1 << LOBYTE(this->field_2C2[v10][0]);
            }
          }
        }
      }
    }
  }
}
// 4EA270: using guessed type int dword_4EA270[];
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5240A8: using guessed type int gpSoundManager;

//----- (00453A20) --------------------------------------------------------
signed int __thiscall advManager::TeleportTo(advManager *this, hero *hro, int x, int y, int a5, int a6)
{
  int v6; // ebx@18
  int v7; // eax@18
  mapCell *v10; // [sp+18h] [bp-18h]@3
  mapCell *v11; // [sp+1Ch] [bp-14h]@3
  signed int v12; // [sp+20h] [bp-10h]@5
  int v13; // [sp+24h] [bp-Ch]@1
  int v14; // [sp+2Ch] [bp-4h]@26

  v13 = bShowIt;
  if ( !a6 )
    SendMapChange(9, hro->idx, x, y, -999, 0, 0);
  v10 = advManager::GetCell(this, x, y);
  v11 = advManager::GetCell(this, hro->x, hro->y);
  if ( hro->occupiedObjType == 163 )
    gpGame->castles[hro->occupiedObjVal].visitingHeroIdx = -1;
  v12 = 0;
  if ( v11->displayFlags & 0x40 )
  {
    v11->displayFlags -= 64;
    v12 = 1;
  }
  else
  {
    game::RestoreCell(hro->x, hro->y, hro->occupiedObjType, hro->occupiedObjVal, 0, 99);
  }
  advManager::CompleteDraw(this, 0);
  if ( !gbThisNetHumanPlayer[giCurPlayer] )
    bShowIt = !*(_DWORD *)&blackoutComputer && MapExtraPosAndAdjacentsSet(hro->x, hro->y, giCurWatchPlayerBit)
           || MapExtraPosAndAdjacentsSet(x, y, giCurWatchPlayerBit);
  if ( v13 )
    advManager::HideRoute(this, 1, 1, 1);
  if ( bShowIt )
  {
    this->viewX = x - 7;
    this->viewY = y - 7;
    DelayMilli(90);
  }
  hro->x = x;
  hro->y = y;
  v6 = giVisRange[hro->secondarySkillLevel[3]];
  v7 = hero::HasArtifact(hro, 64);
  game::SetVisibility(gpGame, this->viewX + 7, this->viewY + 7, giCurPlayer, ((unsigned int)v7 >= 1) + v6);
  if ( bShowIt )
  {
    v10->displayFlags |= 0x40u;
    heroWindowManager::SaveFizzleSource(gpWindowManager, 16, 16, 448, 448);
    advManager::CompleteDraw(this, 0);
    PollSound();
    heroWindowManager::FizzleForward(gpWindowManager, 16, 16, 448, 448, -1, 0, 0);
    PollSound();
  }
  else
  {
    hro->occupiedObjType = v10->objType;
    hro->occupiedObjVal = (unsigned __int8)((unsigned __int8)(v10->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
    if ( v12 )
    {
      v10->displayFlags |= 0x40u;
    }
    else
    {
      v10->objType = -86;
      v10->field_4_1_1_isShadow_1_13_extraInfo = v10->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * hro->idx;
    }
    if ( this->field_27A == 6 )
      hro->flags |= 0x80u;
    this->field_272 = 0;
  }
  advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
  v14 = (unsigned __int8)giGroundToTerrain[v10->groundIndex];
  if ( this->currentTerrain != v14 )
  {
    this->currentTerrain = v14;
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
  }
  advManager::Reseed(0, 0);
  advManager::UpdateRadar(this, 1, 0);
  advManager::CompleteDraw(this, 0);
  return advManager::ForceNewHover(this);
}
// 5240A8: using guessed type int gpSoundManager;
// 524C14: using guessed type int bShowIt;
// 5306F0: using guessed type char giCurWatchPlayerBit;

//----- (00453E30) --------------------------------------------------------
void __thiscall advManager::DimensionDoor(advManager *this)
{
  heroWindow *dimDoorWind; // [sp+18h] [bp-18h]@1
  int y; // [sp+1Ch] [bp-14h]@7
  mapCell *targetCell; // [sp+20h] [bp-10h]@7
  int x; // [sp+24h] [bp-Ch]@7
  hero *hro; // [sp+28h] [bp-8h]@6
  heroWindow *window; // [sp+2Ch] [bp-4h]@2

  dimDoorWind = (heroWindow *)operator new(68);
  if ( dimDoorWind )
    window = heroWindow::heroWindow(dimDoorWind, 0, 0, "dimdoor.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  heroWindowManager::DoDialog(gpWindowManager, window, (int (__fastcall *)(tag_message *))DimensionDoorHandler, 0);
  operator delete(window);
  hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  if ( gpWindowManager->buttonPressedCode == 1 )
  {
    x = this->viewX + this->xOff;
    y = this->viewY + this->yOff;
    targetCell = advManager::GetCell(this, x, y);
    if ( (!(hro->flags & HERO_AT_SEA) || !giGroundToTerrain[targetCell->groundIndex])
      && (hro->flags & HERO_AT_SEA || giGroundToTerrain[targetCell->groundIndex]) )
    {
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 1);
      advManager::TeleportTo(this, hro, x, y, 0, 0);
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
    }
    else
    {
      NormalDialog("Dimension Door failed!!!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      advManager::UpdateRadar(this, 1, 0);
    }
    hero::UseSpell(&gpGame->heroes[gpCurPlayer->curHeroIdx], SPELL_DIMENSION_DOOR);
  }
  else
  {
    advManager::UpdateRadar(this, 1, 0);
  }
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00454030) --------------------------------------------------------
signed int __thiscall TownPortalHandler(void *this)
{
  signed int result; // eax@7
  signed int v2; // [sp+Ch] [bp-28h]@6
  void *v3; // [sp+14h] [bp-20h]@1
  int evt; // [sp+18h] [bp-1Ch]@7
  int v5; // [sp+1Ch] [bp-18h]@7
  int v6; // [sp+20h] [bp-14h]@7
  int v7; // [sp+30h] [bp-4h]@7

  v3 = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) && gpAdvManager->ready == 1 )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( *(_DWORD *)v3 == 512 && *((_DWORD *)v3 + 1) == 13 && (v2 = *((_DWORD *)v3 + 2), v2 >= 30721 && v2 <= 30722) )
  {
    evt = 512;
    v6 = 100;
    v5 = 55;
    heroWindow::BroadcastMessage(townPortalWin, (tag_message *)&evt);
    giTownPortalChoice = v7;
    gpWindowManager->buttonPressedCode = *((_DWORD *)v3 + 2);
    *((_DWORD *)v3 + 2) = 10;
    *((_DWORD *)v3 + 1) = *((_DWORD *)v3 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 5240A8: using guessed type int gpSoundManager;
// 524D28: using guessed type int giTownPortalChoice;

//----- (00454160) --------------------------------------------------------
void __thiscall advManager::TownGate(advManager *ecx0, int spell)
{
  int xdist; // ebx@16
  heroWindow *wind; // [sp+18h] [bp-34h]@6
  signed int smallestDist; // [sp+1Ch] [bp-30h]@1
  tag_message evt; // [sp+20h] [bp-2Ch]@9
  int i; // [sp+3Ch] [bp-10h]@9
  int targetCastle; // [sp+40h] [bp-Ch]@1
  int dist; // [sp+44h] [bp-8h]@16
  hero *hro; // [sp+48h] [bp-4h]@1

  smallestDist = 1000;
  targetCastle = -1;
  hro = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  if ( !gpCurPlayer->numCastles )
  {
    NormalDialog("No available town.  Spell Failed!!!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
    return;
  }
  if ( hro->flags & HERO_AT_SEA )
  {
    NormalDialog("Spell Failed!!!  You must be on land for this spell to work.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
    return;
  }
  if ( spell != SPELL_TOWN_PORTAL )
  {
    for ( i = 0; gpCurPlayer->numCastles > i; ++i )
    {
      xdist = abs(gpGame->castles[gpCurPlayer->castlesOwned[i]].x - hro->x);
      dist = abs(gpGame->castles[gpCurPlayer->castlesOwned[i]].y - hro->y) + xdist;
      if ( dist < smallestDist )
      {
        smallestDist = dist;
        targetCastle = i;
      }
    }
    goto LABEL_19;
  }
  wind = (heroWindow *)operator new(68);
  if ( wind )
    townPortalWin = heroWindow::heroWindow(wind, 159, 65, "townport.bin");
  else
    townPortalWin = 0;
  sprintf(gText, "{Town Portal}\n\nSelect town to port to.");
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
  evt.yCoordOrFieldID = 1;
  evt.payload = gText;
  heroWindow::BroadcastMessage(townPortalWin, &evt);
  for ( i = 0; gpCurPlayer->numCastles > i; ++i )
  {
    sprintf(gText, gpGame->castles[gpCurPlayer->castlesOwned[i]].name);
    evt.eventCode = INPUT_GUI_MESSAGE_CODE;
    evt.xCoordOrKeycode = GUI_MESSAGE_DROPLIST_ADD;
    evt.yCoordOrFieldID = 100;
    evt.payload = gText;
    heroWindow::BroadcastMessage(townPortalWin, &evt);
  }
  evt.xCoordOrKeycode = 54;
  evt.payload = 0;
  heroWindow::BroadcastMessage(townPortalWin, &evt);
  heroWindowManager::DoDialog(gpWindowManager, townPortalWin, (int (__fastcall *)(tag_message *))TownPortalHandler, 0);
  targetCastle = giTownPortalChoice;
  operator delete(townPortalWin);
  if ( gpWindowManager->buttonPressedCode != BUTTON_CANCEL )
  {
LABEL_19:
    if ( gpGame->castles[gpCurPlayer->castlesOwned[targetCastle]].visitingHeroIdx == -1 )
    {
      soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 1);
      advManager::TeleportTo(
        ecx0,
        hro,
        gpGame->castles[gpCurPlayer->castlesOwned[targetCastle]].x,
        gpGame->castles[gpCurPlayer->castlesOwned[targetCastle]].y,
        0,
        0);
      hero::UseSpell(hro, spell);
      gpGame->castles[gpCurPlayer->castlesOwned[targetCastle]].visitingHeroIdx = hro->idx;
      town::GiveSpells(&gpGame->castles[gpCurPlayer->castlesOwned[targetCastle]], 0);
      hro->occupiedObjType = 163;
      hro->occupiedObjVal = gpCurPlayer->castlesOwned[targetCastle];
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[ecx0->currentTerrain]);
    }
    else
    {
      NormalDialog("Nearest town occupied.  Spell Failed!!!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
}
// 5240A8: using guessed type int gpSoundManager;
// 524D28: using guessed type int giTownPortalChoice;

//----- (004545A0) --------------------------------------------------------
void __thiscall advManager::SummonBoat(advManager *this)
{
  int v1; // ebx@28
  char *v2; // eax@32
  int height; // [sp+10h] [bp-3Ch]@40
  int y; // [sp+14h] [bp-38h]@38
  int x; // [sp+18h] [bp-34h]@36
  int width; // [sp+1Ch] [bp-30h]@40
  int v8; // [sp+20h] [bp-2Ch]@32
  signed int j; // [sp+2Ch] [bp-20h]@16
  signed int i; // [sp+30h] [bp-1Ch]@2
  int row; // [sp+34h] [bp-18h]@5
  signed int v12; // [sp+38h] [bp-14h]@1
  int col; // [sp+3Ch] [bp-10h]@5
  char *v14; // [sp+40h] [bp-Ch]@1
  mapCell *v15; // [sp+44h] [bp-8h]@1
  signed int v16; // [sp+48h] [bp-4h]@1

  v14 = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  v16 = 0;
  v12 = 0;
  v15 = advManager::GetCell(this, this->viewX + 7, this->viewY + 7);
  if ( giGroundToTerrain[v15->groundIndex] )
  {
    for ( i = 0; i < 8; ++i )
    {
      col = this->viewX + normalDirTable[4 * i] + 7;
      row = this->viewY + byte_4F1DC1[4 * i] + 7;
      if ( col >= 0 )
      {
        if ( MAP_WIDTH > col )
        {
          if ( row >= 0 )
          {
            if ( row < MAP_HEIGHT )
            {
              v15 = advManager::GetCell(this, col, row);
              if ( v15->objectIndex == 255 )
              {
                if ( !v15->objType && !giGroundToTerrain[v15->groundIndex] )
                {
                  v16 = 1;
                  break;
                }
              }
            }
          }
        }
      }
    }
    if ( v16 )
    {
      for ( j = 0; j < 48; ++j )
      {
        if ( gpGame->boatBuilt[j] != -1 && gpGame->boats[j].field_6 == (gpCurPlayer->curHeroIdx | 0x80) )
        {
          v12 = 1;
          break;
        }
      }
      if ( !v12 )
      {
        for ( j = 0; j < 48; ++j )
        {
          if ( gpGame->boatBuilt[j] != -1 )
          {
            if ( gpGame->boats[j].field_6 & 0x80 )
            {
              if ( gpGame->boats[j].owner == giCurPlayer )
              {
                v1 = abs(gpGame->boats[j].y - *(_DWORD *)(v14 + 29));
                if ( abs(gpGame->boats[j].x - *(_DWORD *)(v14 + 25)) + v1 > 2 )
                {
                  v12 = 1;
                  break;
                }
              }
            }
          }
        }
      }
      if ( v12 )
      {
        v2 = (char *)gpGame + 8 * j;
        v8 = (int)(v2 + 24989);
        advManager::GetCell(this, v2[24990], v2[24991]);
        game::RestoreCell(*(_BYTE *)(v8 + 1), *(_BYTE *)(v8 + 2), *(_BYTE *)(v8 + 4), *(_BYTE *)(v8 + 5), 0, 5);
        if ( *(_BYTE *)(v8 + 1) >= this->viewX
          && *(_BYTE *)(v8 + 1) < this->viewX + 15
          && *(_BYTE *)(v8 + 2) >= this->viewY
          && *(_BYTE *)(v8 + 2) < this->viewY + 15 )
        {
          x = 32 * (*(_BYTE *)(v8 + 1) - this->viewX) - 48;
          if ( x < 16 )
            x = 16;
          y = 32 * (*(_BYTE *)(v8 + 2) - this->viewY) - 48;
          if ( y < 16 )
            y = 16;
          width = 112;
          height = 80;
          if ( x + 112 >= 464 )
            width = 464 - x;
          if ( y + 80 >= 464 )
            height = 464 - y;
          heroWindowManager::SaveFizzleSource(gpWindowManager, x, y, width, height);
          advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
          heroWindowManager::FizzleForward(gpWindowManager, x, y, width, height, -1, 0, 0);
        }
        *(_BYTE *)(v8 + 1) = LOBYTE(this->viewX) + normalDirTable[4 * i] + 7;
        *(_BYTE *)(v8 + 2) = LOBYTE(this->viewY) + byte_4F1DC1[4 * i] + 7;
        *(_BYTE *)(v8 + 4) = v15->objType;
        *(_BYTE *)(v8 + 5) = v15->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v15->objType = -85;
        v15->field_4_1_1_isShadow_1_13_extraInfo = 8 * j | v15->field_4_1_1_isShadow_1_13_extraInfo & 7;
        heroWindowManager::SaveFizzleSource(gpWindowManager, 154, 152, 150, 136);
        advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
        heroWindowManager::FizzleForward(gpWindowManager, 154, 152, 150, 136, -1, 0, 0);
      }
    }
  }
  advManager::UpdateScreen(this, 0, 0);
  advManager::Reseed(0, 0);
  if ( !v12 )
    NormalDialog("Summon Boat failed!!!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00454B50) --------------------------------------------------------
void __thiscall advManager::ShowRoute(void *this, int a2, int a3, int a4)
{
  mapCell *v4; // ST38_4@10
  mapCell *v5; // ST50_4@10
  signed int v6; // ST28_4@10
  void *thisa; // [sp+Ch] [bp-40h]@1
  int messageType; // [sp+10h] [bp-3Ch]@47
  int v9; // [sp+18h] [bp-34h]@10
  int i; // [sp+1Ch] [bp-30h]@8
  int row; // [sp+20h] [bp-2Ch]@8
  int col; // [sp+28h] [bp-24h]@8
  int mobility; // [sp+30h] [bp-1Ch]@8
  signed __int16 v14; // [sp+34h] [bp-18h]@12
  int v15; // [sp+38h] [bp-14h]@10
  signed int v16; // [sp+40h] [bp-Ch]@1
  char *v17; // [sp+44h] [bp-8h]@4
  int v18; // [sp+48h] [bp-4h]@6

  thisa = this;
  v16 = 0;
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    if ( gpCurPlayer->curHeroIdx == -1 )
    {
      advManager::HideRoute((advManager *)this, a2, 0, 1);
    }
    else
    {
      v17 = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
      if ( *(_DWORD *)&gpGame->heroes[gpCurPlayer->curHeroIdx].field_21 == -1 )
      {
        advManager::HideRoute((advManager *)this, a2, 1, 1);
      }
      else
      {
        v18 = searchArray::BuildPath(
                gpSearchArray,
                gpGame->heroes[gpCurPlayer->curHeroIdx].x,
                gpGame->heroes[gpCurPlayer->curHeroIdx].y,
                *(_DWORD *)&gpGame->heroes[gpCurPlayer->curHeroIdx].field_21,
                *(_DWORD *)&gpGame->heroes[gpCurPlayer->curHeroIdx].field_25,
                59999);
        if ( gpSearchArray->field_8 <= 0 || v18 <= 0 )
        {
          advManager::HideRoute((advManager *)thisa, a2, 1, 1);
        }
        else
        {
          memset(*(void **)((char *)thisa + 158), 0, 2 * MAP_HEIGHT * MAP_WIDTH);
          *(_DWORD *)((char *)thisa + 162) = 1;
          mobility = *(_DWORD *)(v17 + 53);
          col = *(_DWORD *)(v17 + 25);
          row = *(_DWORD *)(v17 + 29);
          for ( i = gpSearchArray->field_8 - 1; i >= 0; --i )
          {
            v9 = *((_BYTE *)&gpSearchArray->field_2418 + i);
            v4 = advManager::GetCell((advManager *)thisa, col, row);
            col += normalDirTable[4 * v9];
            row += byte_4F1DC1[4 * v9];
            v5 = advManager::GetCell((advManager *)thisa, col, row);
            v6 = (unsigned __int8)giGroundToTerrain[v4->groundIndex];
            v15 = CalcTerrainCost(
                    (unsigned __int8)giGroundToTerrain[v5->groundIndex],
                    v9 & 1,
                    999999999,
                    v17[116],
                    ((unsigned __int8)v4->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1,
                    ((unsigned __int8)v5->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1);
            mobility -= CalcTerrainCost(
                          v6,
                          v9 & 1,
                          mobility,
                          v17[116],
                          ((unsigned __int8)v4->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1,
                          ((unsigned __int8)v5->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1);
            if ( v9 & 1 )
            {
              switch ( v15 )
              {
                case 112:
                  v14 = 0;
                  break;
                case 150:
                  v14 = 1;
                  break;
                case 187:
                  v14 = 2;
                  break;
                case 225:
                  v14 = 3;
                  break;
                case 262:
                  v14 = 4;
                  break;
                case 300:
                  v14 = 5;
                  break;
                default:
                  v14 = 1;
                  break;
              }
            }
            else
            {
              switch ( v15 )
              {
                case 75:
                  v14 = 0;
                  break;
                case 100:
                  v14 = 1;
                  break;
                case 125:
                  v14 = 2;
                  break;
                case 150:
                  v14 = 3;
                  break;
                case 175:
                  v14 = 4;
                  break;
                case 200:
                  v14 = 5;
                  break;
                default:
                  v14 = 1;
                  break;
              }
            }
            if ( i )
              *(_WORD *)(*(_DWORD *)((char *)thisa + 158) + 2 * (col + row * MAP_WIDTH)) = *(&byte_4F2AE8[8 * *((_BYTE *)&gpSearchArray->field_2414 + i + 3)]
                                                                                           + v9)
                                                                                         + 24 * v14
                                                                                         + 2;
            else
              *(_WORD *)(*(_DWORD *)((char *)thisa + 158) + 2 * (col + row * MAP_WIDTH)) = 1;
            if ( mobility >= 0 )
              v16 = 1;
            else
              *(_WORD *)(*(_DWORD *)((char *)thisa + 158) + 2 * (col + row * MAP_WIDTH)) += 256;
          }
          if ( a4 )
          {
            if ( v16 )
              messageType = 6;
            else
              messageType = 5;
            heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, messageType, 2, 16392);
          }
        }
        if ( a2 )
        {
          advManager::CompleteDraw((advManager *)thisa, 0);
          advManager::UpdateScreen((advManager *)thisa, 0, 0);
        }
      }
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00455030) --------------------------------------------------------
void __thiscall advManager::HideRoute(advManager *this, int a2, int a3, int a4)
{
  char *v4; // eax@9

  if ( gbThisNetHumanPlayer[giCurPlayer] || giDebugLevel && giShowComputerRoute )
  {
    if ( a4 )
      heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 2, 16392);
    if ( a3 && gpCurPlayer->curHeroIdx != -1 )
    {
      v4 = (char *)gpGame + 250 * gpCurPlayer->curHeroIdx;
      *(_DWORD *)(v4 + 10213) = -1;
      *(_DWORD *)(v4 + 10217) = -1;
    }
    if ( this->field_A2 )
    {
      this->field_A2 = 0;
      if ( a2 )
      {
        advManager::CompleteDraw(this, 0);
        advManager::UpdateScreen(this, 0, 0);
      }
    }
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51D598: using guessed type int giShowComputerRoute;

//----- (00455140) --------------------------------------------------------
int __thiscall advManager::CheckDimHero(void *this)
{
  int result; // eax@1
  void *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  result = gbThisNetHumanPlayer[giCurPlayer];
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    result = gpCurPlayer->curHeroIdx;
    if ( result != -1 )
    {
      result = game::IsMobile(gpGame, gpCurPlayer->curHeroIdx);
      if ( !result )
      {
        advManager::ShowRoute(thisa, 1, 0, 0);
        advManager::UpdateHeroLocators((advManager *)thisa, 1, 1);
        result = advManager::CheckDimNextHeroBut();
      }
    }
  }
  return result;
}

//----- (004551D0) --------------------------------------------------------
int __cdecl advManager::CheckDimNextHeroBut()
{
  int messageType; // [sp+10h] [bp-4h]@3

  if ( gbThisNetHumanPlayer[giCurPlayer] && playerData::HasMobileHero(gpCurPlayer) )
    messageType = 6;
  else
    messageType = 5;
  return heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, messageType, 1, 16392);
}

//----- (00455240) --------------------------------------------------------
char __thiscall advManager::SeedTo(int this, __int64 a2)
{
  char *v2; // eax@1

  LOBYTE(v2) = gbThisNetHumanPlayer[giCurPlayer];
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    v2 = (char *)gpCurPlayer->curHeroIdx;
    if ( v2 != (char *)-1 )
    {
      v2 = (char *)&gpGame->heroes[gpCurPlayer->curHeroIdx];
      if ( giSeedingValid )
      {
        if ( !giFullySeeded )
          LOBYTE(v2) = searchArray::SeedPosition(
                         gpSearchArray,
                         gpGame->heroes[gpCurPlayer->curHeroIdx].x,
                         gpGame->heroes[gpCurPlayer->curHeroIdx].y,
                         *(_DWORD *)(this + 638),
                         59999,
                         *(_DWORD *)(this + 634) == 6,
                         0,
                         gpGame->heroes[gpCurPlayer->curHeroIdx].remainingMobility,
                         gpGame->heroes[gpCurPlayer->curHeroIdx].secondarySkillLevel[0],
                         a2,
                         1,
                         1);
      }
      else
      {
        LOBYTE(v2) = searchArray::SeedPosition(
                       gpSearchArray,
                       gpGame->heroes[gpCurPlayer->curHeroIdx].x,
                       gpGame->heroes[gpCurPlayer->curHeroIdx].y,
                       *(_DWORD *)(this + 638),
                       59999,
                       *(_DWORD *)(this + 634) == 6,
                       0,
                       gpGame->heroes[gpCurPlayer->curHeroIdx].remainingMobility,
                       gpGame->heroes[gpCurPlayer->curHeroIdx].secondarySkillLevel[0],
                       a2,
                       0,
                       1);
      }
    }
  }
  return (char)v2;
}
// 5247C0: using guessed type int giSeedingValid;
// 524808: using guessed type int giFullySeeded;

//----- (00455380) --------------------------------------------------------
signed int __thiscall advManager::ForceNewHover(void *this)
{
  signed int result; // eax@1
  void *v2; // [sp+Ch] [bp-Ch]@1
  int y; // [sp+10h] [bp-8h]@2
  int x; // [sp+14h] [bp-4h]@2

  v2 = this;
  result = gbThisNetHumanPlayer[giCurPlayer];
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    mouseManager::MouseCoords(&x, &y);
    *(_DWORD *)((char *)v2 + 486) = -1;
    result = advManager::ProcessHover(v2, x, y);
  }
  return result;
}

//----- (004553E0) --------------------------------------------------------
void __thiscall advManager::ScreenScroll(advManager *this, int a2, int a3)
{
  signed int v4; // [sp+14h] [bp-8h]@1
  signed int v5; // [sp+18h] [bp-4h]@1

  v4 = this->viewX;
  v5 = this->viewY;
  iLastScrollTime = KBTickCount();
  switch ( a2 )
  {
    case 0:
      --v5;
      break;
    case 1:
      ++v4;
      --v5;
      break;
    case 2:
      ++v4;
      break;
    case 3:
      ++v4;
      ++v5;
      break;
    case 4:
      ++v5;
      break;
    case 5:
      --v4;
      ++v5;
      break;
    case 6:
      --v4;
      break;
    case 7:
      --v4;
      --v5;
      break;
    default:
      break;
  }
  if ( a3 )
    mouseManager::SetPointer(gpMouseManager, a2 + 32);
  if ( v4 < -7 )
    v4 = -7;
  if ( MAP_WIDTH - 8 < v4 )
    v4 = MAP_WIDTH - 8;
  if ( v5 < -7 )
    v5 = -7;
  if ( MAP_HEIGHT - 8 < v5 )
    v5 = MAP_HEIGHT - 8;
  if ( this->viewX != v4 || this->viewY != v5 )
  {
    advManager::DemobilizeCurrHero(this);
    this->viewX = v4;
    this->viewY = v5;
    advManager::UpdateRadar(this, 1, 0);
    advManager::CompleteDraw(this, 0);
    advManager::UpdateScreen(this, 0, 0);
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 50EA8C: using guessed type int iLastScrollTime;

//----- (00455590) --------------------------------------------------------
void __thiscall advManager::CheckScreenScroll(void *this)
{
  void *thisa; // [sp+Ch] [bp-14h]@1
  int v2; // [sp+10h] [bp-10h]@2
  int v3; // [sp+14h] [bp-Ch]@2
  int y; // [sp+18h] [bp-8h]@2
  int x; // [sp+1Ch] [bp-4h]@2

  thisa = this;
  if ( KBTickCount() - iLastScrollTime > 70 )
  {
    iLastScrollTime = KBTickCount();
    v2 = *(_DWORD *)((char *)thisa + 470);
    v3 = *(_DWORD *)((char *)thisa + 474);
    mouseManager::MouseCoords(&x, &y);
    if ( x >= 0 && x < 640 && y >= 0 && y < 480 )
    {
      if ( x >= 16 )
      {
        if ( x <= 623 )
        {
          if ( y >= 16 )
          {
            if ( y > 464 )
              advManager::ScreenScroll((advManager *)thisa, 4, 1);
          }
          else
          {
            advManager::ScreenScroll((advManager *)thisa, 0, 1);
          }
        }
        else if ( y >= 16 )
        {
          if ( y <= 464 )
            advManager::ScreenScroll((advManager *)thisa, 2, 1);
          else
            advManager::ScreenScroll((advManager *)thisa, 3, 1);
        }
        else
        {
          advManager::ScreenScroll((advManager *)thisa, 1, 1);
        }
      }
      else if ( y >= 16 )
      {
        if ( y <= 464 )
          advManager::ScreenScroll((advManager *)thisa, 6, 1);
        else
          advManager::ScreenScroll((advManager *)thisa, 5, 1);
      }
      else
      {
        advManager::ScreenScroll((advManager *)thisa, 7, 1);
      }
    }
    if ( gpMouseManager->spriteIdx >= 32 && gpMouseManager->spriteIdx < 40 && *(_DWORD *)((char *)thisa + 470) == v2 )
    {
      if ( *(_DWORD *)((char *)thisa + 474) == v3 )
        mouseManager::SetPointer(gpMouseManager, 0);
    }
  }
}
// 50EA8C: using guessed type int iLastScrollTime;

//----- (00455750) --------------------------------------------------------
bool __cdecl advManager::MouseInScrollZone()
{
  int y; // [sp+10h] [bp-8h]@1
  int x; // [sp+14h] [bp-4h]@1

  mouseManager::MouseCoords(&x, &y);
  return x >= 0 && x < 640 && y >= 0 && y < 480 && (x < 16 || x > 623 || y < 16 || y > 464);
}

//----- (004557F0) --------------------------------------------------------
int __thiscall advManager::SetInitialMapOrigin(advManager *this)
{
  char *v1; // ST2C_4@3
  hero *v2; // ST24_4@11
  char *v3; // ST20_4@13
  playerData *v6; // [sp+18h] [bp-Ch]@8

  heroWindowManager::BroadcastMessage(gpWindowManager, INPUT_GUI_MESSAGE_CODE, 5, 2, 16392);
  this->yOff = 0;
  this->xOff = this->yOff;
  this->field_272 = 0;
  gbHeroMoving = 0;
  if ( gbThisNetHumanPlayer[giCurPlayer] && LOBYTE(gpCurPlayer->field_45) != -1 )
  {
    v1 = (char *)&gpGame->castles[LOBYTE(gpCurPlayer->field_45)];
    this->viewX = gpGame->castles[LOBYTE(gpCurPlayer->field_45)].x - 7;
    this->viewY = (unsigned __int8)v1[5] - 7;
  }
  else if ( gbThisNetHumanPlayer[giCurPlayer] && gpCurPlayer->curHeroIdx != -1 )
  {
    advManager::MobilizeCurrHero(this, 0);
  }
  else
  {
    if ( gbThisNetHumanPlayer[giCurPlayer] )
      v6 = gpCurPlayer;
    else
      v6 = &gpGame->players[giThisGamePos];
    if ( v6->numHeroes <= 0 )
    {
      if ( v6->numCastles <= 0 )
      {
        this->viewX = 0;
        this->viewY = 0;
      }
      else
      {
        v3 = (char *)&gpGame->castles[v6->castlesOwned[0]];
        this->viewX = gpGame->castles[v6->castlesOwned[0]].x - 7;
        this->viewY = (unsigned __int8)v3[5] - 7;
      }
    }
    else
    {
      v2 = &gpGame->heroes[v6->heroesOwned[0]];
      this->viewX = gpGame->heroes[v6->heroesOwned[0]].x - 7;
      this->viewY = v2->y - 7;
    }
  }
  this->currentTerrain = (unsigned __int8)giGroundToTerrain[advManager::GetCell(this, this->viewX + 7, this->viewY + 7)->groundIndex];
  soundManager::SwitchAmbientMusic(
    (soundManager *)gpSoundManager,
    (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
  advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
  advManager::Reseed(0, 0);
  return advManager::CheckDimNextHeroBut();
}
// 4F3084: using guessed type int gbHeroMoving;
// 5240A8: using guessed type int gpSoundManager;
// 524730: using guessed type int giThisGamePos;

//----- (00455AB0) --------------------------------------------------------
heroWindow *__thiscall advManager::LoadRemote(void *this)
{
  heroWindow *result; // eax@13
  void *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( gbThisNetHumanPlayer[giCurPlayer] )
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  game::LoadGame(gpGame, (char *)&gConfig + 327, 0, 1);
  if ( (gpGame->day != 1 || gpGame->week == 1 && gpGame->month == 1) && gbRemoteOn && gbThisNetHumanPlayer[giCurPlayer] )
  {
    *(_DWORD *)(gpSoundManager + 1672) = 1;
    soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 21);
    *(_DWORD *)(gpSoundManager + 1672) = 0;
    giForceSwitchMusic = KBTickCount();
  }
  if ( gpGame->playerDead[giCurPlayer] )
    ComputeAdvNetControl();
  if ( gbThisNetHumanPlayer[giCurPlayer] )
  {
    game::CancelComputerScreen();
    gbThisNetGotAdventureControl = 1;
    *(_DWORD *)(gpSoundManager + 1672) = 0;
  }
  game::DoNewTurn(gpGame);
  advManager::UpdateHeroLocators((advManager *)thisa, 1, 1);
  advManager::UpdateTownLocators(thisa, 1, 1);
  advManager::UpdateRadar((advManager *)thisa, 1, 0);
  advManager::UpdBottomView((advManager *)thisa, 1, 1, 1);
  advManager::ForceNewHover(gpAdvManager);
  SendMapChange(11, 0, 0, 0, -999, 0, 0);
  *(_DWORD *)(gpSoundManager + 1672) = 1;
  result = (heroWindow *)gpGame->_B[1];
  if ( gpGame->_B[1] && !dword_50EA80 )
  {
    dword_50EA80 = 1;
    sprintf(gText, "Someone is cheating!\n");
    result = NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  if ( giDebugLevel > 0 )
  {
    if ( !dword_50EA84 )
    {
      dword_50EA84 = 1;
      sprintf(gText, "Someone has their debug level set!\n");
      result = NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;
// 4F747C: using guessed type int giForceSwitchMusic;
// 4F7494: using guessed type int gbRemoteOn;
// 50EA80: using guessed type int dword_50EA80;
// 50EA84: using guessed type int dword_50EA84;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 5240A8: using guessed type int gpSoundManager;

//----- (00455D20) --------------------------------------------------------
int __fastcall advManager::CheckHandleNet(advManager *this, int a2)
{
  int v2; // ST24_4@8
  int v3; // eax@8
  int v5; // ecx@14
  int v6; // ecx@15
  char v8; // [sp+1Ah] [bp-Ah]@0
  int v9; // [sp+1Ch] [bp-8h]@5
  int a1; // [sp+20h] [bp-4h]@1

  a1 = (int)GetRemoteData(1, a2);
  if ( a1 && (*(_BYTE *)(a1 + 5) == 2 || *(_BYTE *)(a1 + 5) == 3) )
  {
    switch ( *(_BYTE *)(a1 + 6) )
    {
      case 1:
        v9 = *(_DWORD *)(a1 + 21);
        if ( !game::ReceiveSaveGame(*(_DWORD *)(a1 + 9), *(_DWORD *)(a1 + 13), *(_DWORD *)(a1 + 17), *(_BYTE *)a1) )
          ShutDown(0);
        if ( v9 )
        {
          LOBYTE(v2) = *(_BYTE *)a1;
          v3 = NetPosToGamePos((void *)*(_BYTE *)a1);
          *(_WORD *)((char *)&v2 + 1) = (unsigned __int8)v3;
          BYTE3(v2) = 1;
          LOBYTE(v3) = v8;
          v3 <<= 16;
          LOWORD(v3) = 257;
          ReceiveRemotePlayerExit(v2, v3);
        }
        advManager::LoadRemote(this);
        return 0;
      case 11:
        PopNetBox((const char *)(a1 + 9), (void *)*(_BYTE *)a1);
        return 0;
      case 21:
        if ( dword_4F7474 )
          return a1;
        advManager::DoNetCombat(this, a1);
        break;
      case 31:
        LogStr("Receive Remote Player Exit");
        LOBYTE(v5) = *(_BYTE *)(a1 + 15);
        v5 <<= 16;
        LOWORD(v5) = *(_WORD *)(a1 + 13);
        ReceiveRemotePlayerExit(*(_DWORD *)(a1 + 9), v5);
        return 0;
      case 33:
        LogStr("Host Reports Player Exit");
        LOBYTE(v6) = *(_BYTE *)(a1 + 15);
        v6 <<= 16;
        LOWORD(v6) = *(_WORD *)(a1 + 13);
        ReceiveHostReportsPlayerExit(*(_BYTE *)a1, 0, *(_DWORD *)(a1 + 9), v6);
        return 0;
      case 41:
        advManager::ProcessIncomingGroupMapChange(this, (const void *)(a1 + 9));
        return 0;
      default:
        return a1;
    }
  }
  return 0;
}
// 4F7474: using guessed type int dword_4F7474;

//----- (00455F30) --------------------------------------------------------
signed int __thiscall advManager::CheckHandleNetPlayerWait(void *this, int a2, int a3)
{
  int v4; // [sp+Ch] [bp-8h]@4
  void *thisa; // [sp+10h] [bp-4h]@1

  thisa = this;
  if ( *(_DWORD *)a2 == 4 )
    (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
  CheckDoMain(1, a3);
  if ( *(_DWORD *)a2 == 1 )
  {
    v4 = *(_DWORD *)(a2 + 4);
    if ( v4 == 16 )
    {
      if ( *(_BYTE *)(a2 + 12) & 0xC )
      {
        *(_DWORD *)a2 = 16384;
        *(_DWORD *)(a2 + 4) = 1;
        return 2;
      }
    }
    else if ( v4 == 60 )
    {
      PopNetBox(0, (void *)0xFFFFFFFF);
    }
  }
  advManager::UpdBottomView((advManager *)thisa, 0, 1, 1);
  return 0;
}

//----- (00456000) --------------------------------------------------------
void __thiscall advManager::TrimLoopingSounds(advManager *this, signed int a2)
{
  signed int v3; // [sp+10h] [bp-24h]@6
  signed int i; // [sp+14h] [bp-20h]@6
  signed int j; // [sp+14h] [bp-20h]@12
  signed int k; // [sp+14h] [bp-20h]@18
  signed int l; // [sp+14h] [bp-20h]@24
  char v8[28]; // [sp+18h] [bp-1Ch]@6

  if ( giHighMemBuffer > 0 )
    a2 += giHighMemBuffer / 100;
  if ( MAP_WIDTH != 144 )
    ++a2;
  if ( a2 < 28 )
  {
    v3 = 0;
    memset(v8, 0, 0x1Cu);
    for ( i = 0; i < 4; ++i )
    {
      if ( this->field_2C2[i][0] >= 0 )
      {
        if ( this->field_2C2[i][0] < 28 )
          ++v8[this->field_2C2[i][0]];
      }
    }
    for ( j = 0; j < 28; ++j )
    {
      if ( v8[j] )
        ++v3;
    }
    if ( v3 < a2 )
    {
      for ( k = 0; ; ++k )
      {
        if ( k < 28 )
        {
          if ( v8[k] )
            continue;
          if ( !this->loopSamples[k] )
            continue;
          ++v8[k];
          ++v3;
          if ( v3 < a2 )
            continue;
        }
        break;
      }
    }
    for ( l = 0; l < 28; ++l )
    {
      if ( this->loopSamples[l] && !v8[l] )
      {
        resourceManager::Dispose(gpResourceManager, (resource *)this->loopSamples[l]);
        this->loopSamples[l] = 0;
      }
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F74AC: using guessed type int giHighMemBuffer;
// 456000: using guessed type char var_1C[28];

//----- (004561E0) --------------------------------------------------------
advManager *__thiscall advManager::DisableButtons(advManager *this)
{
  advManager *result; // eax@1
  GUIMessage evt; // [sp+10h] [bp-1Ch]@2

  result = gpAdvManager;
  if ( gpAdvManager->ready == 1 )
  {
    evt.eventCode = 512;
    evt.messageType = 6;
    evt.payload = (void *)2;
    evt.fieldID = 1;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    evt.fieldID = 2;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    evt.fieldID = 3;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    evt.fieldID = 4;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    evt.fieldID = 5;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    evt.fieldID = 6;
    result = (advManager *)heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
  }
  return result;
}

//----- (004562C0) --------------------------------------------------------
advManager *__thiscall advManager::EnableButtons(advManager *this)
{
  advManager *result; // eax@1
  int evt; // [sp+10h] [bp-1Ch]@2
  int v4; // [sp+14h] [bp-18h]@2
  int v5; // [sp+18h] [bp-14h]@2
  int v6; // [sp+28h] [bp-4h]@2

  result = gpAdvManager;
  if ( gpAdvManager->ready == 1 )
  {
    evt = 512;
    v4 = 5;
    v6 = 2;
    v5 = 1;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    v5 = 2;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    v5 = 3;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    v5 = 4;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    v5 = 5;
    heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
    v5 = 6;
    result = (advManager *)heroWindow::BroadcastMessage(this->adventureScreen, (tag_message *)&evt);
  }
  return result;
}

//----- (004563A0) --------------------------------------------------------
void *__thiscall advManager::SaveAdventureBorder(int this)
{
  void *result; // eax@1
  int v2; // [sp+Ch] [bp-10h]@1
  signed int i; // [sp+10h] [bp-Ch]@2
  signed int j; // [sp+10h] [bp-Ch]@5
  signed int k; // [sp+10h] [bp-Ch]@8
  int v6; // [sp+14h] [bp-8h]@2
  signed __int8 *v7; // [sp+18h] [bp-4h]@2

  v2 = this;
  result = (void *)this;
  if ( !*(_DWORD *)(this + 186) )
  {
    *(_DWORD *)(this + 186) = BaseAlloc(0x7400u, "F:\\h2xsrc\\Source\\ADVMGR.CPP", word_50FAE8 + 4);
    v6 = *(_DWORD *)(v2 + 186);
    result = gpWindowManager->screenBuffer->contents;
    v7 = gpWindowManager->screenBuffer->contents;
    for ( i = 0; i < 16; ++i )
    {
      result = memcpy((void *)v6, v7, 0x1E0u);
      v7 += 640;
      v6 += 480;
    }
    for ( j = 16; j < 464; ++j )
    {
      memcpy((void *)v6, v7, 0x10u);
      result = memcpy((void *)(v6 + 16), v7 + 464, 0x10u);
      v7 += 640;
      v6 += 32;
    }
    for ( k = 464; k < 480; ++k )
    {
      result = memcpy((void *)v6, v7, 0x1E0u);
      v7 += 640;
      v6 += 480;
    }
  }
  return result;
}
// 50FAE8: using guessed type __int16 word_50FAE8;

//----- (004564F0) --------------------------------------------------------
void *__fastcall advManager::DrawAdventureBorder(int this, int a2)
{
  void *result; // eax@1
  signed int i; // [sp+10h] [bp-Ch]@3
  signed int j; // [sp+10h] [bp-Ch]@6
  signed int k; // [sp+10h] [bp-Ch]@9
  int v6; // [sp+14h] [bp-8h]@3
  signed __int8 *v7; // [sp+18h] [bp-4h]@3

  result = (void *)this;
  if ( *(_DWORD *)(this + 186) && !dword_4F2E80 )
  {
    v7 = gpWindowManager->screenBuffer->contents;
    result = *(void **)(this + 186);
    v6 = *(_DWORD *)(this + 186);
    for ( i = 0; i < 16; ++i )
    {
      result = memcpy(v7, (const void *)v6, 0x1E0u);
      v7 += 640;
      v6 += 480;
    }
    for ( j = 16; j < 464; ++j )
    {
      memcpy(v7, (const void *)v6, 0x10u);
      result = memcpy(v7 + 464, (const void *)(v6 + 16), 0x10u);
      v7 += 640;
      v6 += 32;
    }
    for ( k = 464; k < 480; ++k )
    {
      result = memcpy(v7, (const void *)v6, 0x1E0u);
      v7 += 640;
      v6 += 480;
    }
  }
  return result;
}
// 4F2E80: using guessed type int dword_4F2E80;

//----- (00456630) --------------------------------------------------------
signed int __thiscall advManager::FindAdjacentMonster(void *this, int a2, int _1C, int a3, int a4, int a5, int a6)
{
  void *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  dword_524CFC = a2 + 2;
  dword_524CE0 = _1C + 2;
  if ( a2 > 0 && _1C > 0 && MAP_WIDTH - 1 > a2 && MAP_HEIGHT - 1 > _1C )
  {
    for ( dword_524CF0 = a2 - 1; dword_524CFC > dword_524CF0; ++dword_524CF0 )
    {
      for ( dword_524D0C = _1C - 1; dword_524D0C < dword_524CE0; ++dword_524D0C )
      {
        if ( *(_BYTE *)(**(_DWORD **)((char *)thisa + 174)
                      + 12 * dword_524D0C * *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 8)
                      + 12 * dword_524CF0
                      + 9) == 152 )
        {
          if ( _1C <= dword_524D0C )
          {
            if ( dword_524CF0 != a5 || dword_524D0C != a6 )
              goto LABEL_53;
          }
          else if ( (advManager::GetCell((advManager *)thisa, a2, _1C)->objectIndex == 255
   || (((unsigned __int8)advManager::GetCell((advManager *)thisa, a2, _1C)->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 47
   || advManager::GetCell((advManager *)thisa, a2, _1C)->displayFlags & 0x80)
  && (dword_524CF0 != a5 || dword_524D0C != a6) )
          {
            goto LABEL_53;
          }
        }
      }
    }
    return 0;
  }
  if ( MAP_WIDTH - 1 == a2 )
    dword_524CFC = a2 + 1;
  if ( MAP_HEIGHT - 1 == _1C )
    dword_524CE0 = _1C + 1;
  if ( a2 )
    dword_524E7C = a2 - 1;
  else
    dword_524E7C = 0;
  if ( _1C )
    dword_524EBC = _1C - 1;
  else
    dword_524EBC = 0;
  dword_524CF0 = dword_524E7C;
LABEL_35:
  if ( dword_524CFC <= dword_524CF0 )
    return 0;
  for ( dword_524D0C = dword_524EBC; ; ++dword_524D0C )
  {
    if ( dword_524D0C >= dword_524CE0 )
    {
      ++dword_524CF0;
      goto LABEL_35;
    }
    if ( *(_BYTE *)(**(_DWORD **)((char *)thisa + 174)
                  + 12 * dword_524D0C * *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 8)
                  + 12 * dword_524CF0
                  + 9) != 152 )
      continue;
    if ( _1C > dword_524D0C )
      break;
    if ( dword_524CF0 != a5 || dword_524D0C != a6 )
      goto LABEL_53;
LABEL_50:
    ;
  }
  if ( advManager::GetCell((advManager *)thisa, a2, _1C)->objectIndex != 255
    && (((unsigned __int8)advManager::GetCell((advManager *)thisa, a2, _1C)->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 47
    && !(advManager::GetCell((advManager *)thisa, a2, _1C)->displayFlags & 0x80)
    || dword_524CF0 == a5 && dword_524D0C == a6 )
    goto LABEL_50;
LABEL_53:
  *(_DWORD *)a3 = dword_524CF0;
  *(_DWORD *)a4 = dword_524D0C;
  return 1;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 524CE0: using guessed type int dword_524CE0;
// 524CF0: using guessed type int dword_524CF0;
// 524CFC: using guessed type int dword_524CFC;
// 524D0C: using guessed type int dword_524D0C;
// 524E7C: using guessed type int dword_524E7C;
// 524EBC: using guessed type int dword_524EBC;

//----- (00456A10) --------------------------------------------------------
int __cdecl ComputeAdvNetControl()
{
  int result; // eax@8
  int v1; // [sp+Ch] [bp-Ch]@4
  int v2; // [sp+Ch] [bp-Ch]@10
  signed int v3; // [sp+10h] [bp-8h]@3

  if ( gbRemoteOn )
  {
    v3 = -1;
    if ( gpGame->playerDead[giCurPlayer] )
    {
      v1 = (giCurPlayer + 1) % 6;
      while ( v1 != giCurPlayer )
      {
        if ( !gpGame->playerDead[v1] && gbHumanPlayer[v1] )
        {
          result = gbThisNetHumanPlayer[v1];
          gbThisNetGotAdventureControl = gbThisNetHumanPlayer[v1];
          return result;
        }
      }
    }
    v2 = (giCurPlayer + 1) % 6;
    while ( v2 != giCurPlayer )
    {
      v2 = (v2 + 1) % 6;
      if ( !gpGame->playerDead[v2] && gbHumanPlayer[v2] )
        v3 = v2;
    }
    result = gbThisNetHumanPlayer[v3];
    gbThisNetGotAdventureControl = gbThisNetHumanPlayer[v3];
  }
  else
  {
    gbThisNetGotAdventureControl = 1;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;

//----- (00456B40) --------------------------------------------------------
signed int __fastcall MapExtraPosAndAdjacentsSet(int x, int y, unsigned __int8 a3)
{
  signed int result; // eax@2
  int j; // [sp+14h] [bp-8h]@9
  int i; // [sp+18h] [bp-4h]@3

  if ( (unsigned __int8)*(&mapRevealed[x] + y * MAP_WIDTH) & a3 )
  {
    result = 1;
  }
  else
  {
    for ( i = x - 1; x + 1 >= i; ++i )
    {
      if ( i >= 0 && i < MAP_WIDTH )
      {
        for ( j = y - 1; y + 1 >= j; ++j )
        {
          if ( j >= 0 && j < MAP_HEIGHT && (unsigned __int8)(*(&mapRevealed[i] + j * MAP_WIDTH) & a3) )
            return 1;
        }
      }
    }
    result = 0;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00456C40) --------------------------------------------------------
void __thiscall advManager::ViewPuzzle(advManager *this)
{
  __int64 v1; // qax@15
  heroWindow *thisa; // [sp+18h] [bp-60h]@4
  char v4; // [sp+1Ch] [bp-5Ch]@1
  char v5; // [sp+1Dh] [bp-5Bh]@1
  char v6; // [sp+1Eh] [bp-5Ah]@1
  char v7; // [sp+1Fh] [bp-59h]@1
  char v8; // [sp+20h] [bp-58h]@1
  char v9; // [sp+21h] [bp-57h]@1
  char v10; // [sp+22h] [bp-56h]@1
  char v11; // [sp+23h] [bp-55h]@1
  char v12; // [sp+24h] [bp-54h]@1
  char v13; // [sp+25h] [bp-53h]@1
  char v14; // [sp+26h] [bp-52h]@1
  char v15; // [sp+27h] [bp-51h]@1
  char v16; // [sp+28h] [bp-50h]@1
  char v17; // [sp+29h] [bp-4Fh]@1
  char v18; // [sp+2Ah] [bp-4Eh]@1
  char v19; // [sp+2Bh] [bp-4Dh]@1
  char v20; // [sp+2Ch] [bp-4Ch]@1
  char v21; // [sp+2Dh] [bp-4Bh]@1
  char v22; // [sp+2Eh] [bp-4Ah]@1
  char v23; // [sp+2Fh] [bp-49h]@1
  char v24; // [sp+30h] [bp-48h]@1
  char v25; // [sp+31h] [bp-47h]@1
  char v26; // [sp+32h] [bp-46h]@1
  char v27; // [sp+33h] [bp-45h]@1
  char v28; // [sp+34h] [bp-44h]@1
  char v29; // [sp+35h] [bp-43h]@1
  char v30; // [sp+36h] [bp-42h]@1
  char v31; // [sp+37h] [bp-41h]@1
  char v32; // [sp+38h] [bp-40h]@1
  char v33; // [sp+39h] [bp-3Fh]@1
  char v34; // [sp+3Ah] [bp-3Eh]@1
  char v35; // [sp+3Bh] [bp-3Dh]@1
  char v36; // [sp+3Ch] [bp-3Ch]@1
  char v37; // [sp+3Dh] [bp-3Bh]@1
  char v38; // [sp+3Eh] [bp-3Ah]@1
  char v39; // [sp+3Fh] [bp-39h]@1
  char v40; // [sp+40h] [bp-38h]@1
  char v41; // [sp+41h] [bp-37h]@1
  char v42; // [sp+42h] [bp-36h]@1
  char v43; // [sp+43h] [bp-35h]@1
  char v44; // [sp+44h] [bp-34h]@1
  char v45; // [sp+45h] [bp-33h]@1
  char v46; // [sp+46h] [bp-32h]@1
  char v47; // [sp+47h] [bp-31h]@1
  char v48; // [sp+48h] [bp-30h]@1
  char v49; // [sp+49h] [bp-2Fh]@1
  char v50; // [sp+4Ah] [bp-2Eh]@1
  char v51; // [sp+4Bh] [bp-2Dh]@1
  int i; // [sp+4Ch] [bp-2Ch]@1
  int j; // [sp+50h] [bp-28h]@20
  int v54; // [sp+54h] [bp-24h]@1
  int a3; // [sp+58h] [bp-20h]@9
  icon *v56; // [sp+5Ch] [bp-1Ch]@1
  int v57; // [sp+60h] [bp-18h]@9
  heroWindow *a2; // [sp+64h] [bp-14h]@5
  unsigned int v59; // [sp+68h] [bp-10h]@22
  unsigned int v60; // [sp+6Ch] [bp-Ch]@22
  int v61; // [sp+70h] [bp-8h]@9
  int v62; // [sp+74h] [bp-4h]@9

  game::SetupPuzzlePieces(gpGame, giCurPlayer, 0);
  v4 = 23;
  v5 = 7;
  v6 = 44;
  v7 = 5;
  v8 = 24;
  v9 = 47;
  v10 = 1;
  v11 = 39;
  v12 = 16;
  v13 = 36;
  v14 = 11;
  v15 = 45;
  v16 = 31;
  v17 = 2;
  v18 = 30;
  v19 = 38;
  v20 = 43;
  v21 = 4;
  v22 = 3;
  v23 = 14;
  v24 = 40;
  v25 = 37;
  v26 = 34;
  v27 = 0;
  v28 = 12;
  v29 = 17;
  v30 = 35;
  v31 = 42;
  v32 = 15;
  v33 = 8;
  v34 = 26;
  v35 = 41;
  v36 = 28;
  v37 = 46;
  v38 = 10;
  v39 = 22;
  v40 = 21;
  v41 = 6;
  v42 = 32;
  v43 = 18;
  v44 = 19;
  v45 = 29;
  v46 = 13;
  v47 = 27;
  v48 = 9;
  v49 = 20;
  v50 = 33;
  v51 = 25;
  v54 = 0;
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 23);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  v56 = resourceManager::GetIcon(gpResourceManager, "puzzle.icn");
  for ( i = 0; i < 48; ++i )
    icon::DrawToBuffer(v56, 0, 0, i, 0);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 16, 16, 0x1C0u, 448);
  heroWindowManager::SaveFizzleSource(gpWindowManager, 16, 16, 448, 448);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    a2 = heroWindow::heroWindow(thisa, 480, 16, "viewpuzl.bin");
  else
    a2 = 0;
  if ( !a2 )
    MemError();
  heroWindowManager::AddWindow(gpWindowManager, a2, -1, 1);
  v57 = gpGame->field_6395 - 7;
  a3 = gpGame->field_6396 - 7;
  v62 = 0;
  v61 = 0;
  v62 = (gpGame->field_6396 + gpGame->field_6395) % 3 - 1;
  v61 = (5 * gpGame->field_6396 + 2 * gpGame->field_6395) % 3 - 1;
  if ( (gpGame->field_6396 + gpGame->field_6395) % 3 == 1 )
  {
    if ( v62 <= 0 )
    {
      if ( v62 < 0 )
        --v62;
    }
    else
    {
      ++v62;
    }
  }
  else
  {
    v1 = (signed int)gpGame->field_6396 + (signed int)gpGame->field_6395;
    if ( (HIDWORD(v1) ^ ((BYTE4(v1) ^ (unsigned __int8)v1) - BYTE4(v1)) & 1) - HIDWORD(v1) == 1 )
    {
      if ( v61 <= 0 )
      {
        if ( v61 < 0 )
          --v61;
      }
      else
      {
        ++v61;
      }
    }
  }
  v57 += v62;
  a3 += v61;
  advManager::PuzzleDraw(this, v57, a3, gpGame->field_6395, gpGame->field_6396);
  for ( j = 16; j < 464; ++j )
  {
    v59 = (unsigned int)&gpWindowManager->screenBuffer->contents[640 * j + 16];
    v60 = v59 + 448;
    while ( v59 < v60 )
    {
      *(_BYTE *)v59 = gColorTableTan[*(_BYTE *)v59];
      ++v59;
    }
  }
  for ( i = 0; i < 48; ++i )
  {
    if ( !BitTest((char *)&puzzlePiecesRemoved, i) )
    {
      icon::DrawToBuffer(v56, 0, 0, (unsigned __int8)*(&v4 + i), 0);
      ++v54;
    }
  }
  if ( v54 == 48 )
    heroWindowManager::ReleaseFizzleSource(gpWindowManager);
  else
    heroWindowManager::FizzleForward(gpWindowManager, 16, 16, 448, 448, 220, 0, 0);
  heroWindowManager::DoDialog(gpWindowManager, a2, EventWindowHandler, 0);
  operator delete(a2);
  advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
  advManager::UpdateScreen(this, 0, 0);
  advManager::UpdateRadar(this, 1, 0);
  soundManager::SwitchAmbientMusic(
    (soundManager *)gpSoundManager,
    (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00457110) --------------------------------------------------------
int __thiscall advManager::PuzzleDraw(advManager *this, int a2, int a3, int a4, int a5)
{
  gbDrawingPuzzle = 1;
  advManager::CompleteDraw(this, a2, a3, 0, 0);
  gbDrawingPuzzle = 0;
  return IconToBitmap(
           (icon *)this->field_CE[17],
           gpWindowManager->screenBuffer,
           32 * (a4 - a2) - 12,
           32 * (a5 - a3),
           0,
           1,
           0,
           0,
           0x1E0u,
           480,
           0);
}
// 4F5460: using guessed type int gbDrawingPuzzle;

//----- (004571A0) --------------------------------------------------------
void __thiscall advManager::AdvPanel(void *this)
{
  int v1; // edx@8
  void *thisa; // [sp+10h] [bp-34h]@1
  heroWindow *thisb; // [sp+1Ch] [bp-28h]@1
  int v4; // [sp+20h] [bp-24h]@1
  int evt; // [sp+24h] [bp-20h]@7
  int v6; // [sp+28h] [bp-1Ch]@7
  int v7; // [sp+2Ch] [bp-18h]@7
  int v8; // [sp+3Ch] [bp-8h]@7
  int window; // [sp+40h] [bp-4h]@2

  thisa = this;
  advManager::TrimLoopingSounds((advManager *)this, 4);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  v4 = *(_DWORD *)((char *)thisa + 678);
  advManager::DemobilizeCurrHero((advManager *)thisa);
  thisb = (heroWindow *)operator new(68);
  if ( thisb )
    window = (int)heroWindow::heroWindow(thisb, 144, 40, "apanel.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  if ( gpCurPlayer->curHeroIdx == -1 )
  {
    evt = 512;
    v7 = 4;
    v6 = 6;
    v8 = 2;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
    v7 = 4;
    v6 = 5;
    v8 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))APanelHandler,
    0);
  operator delete((void *)window);
  switch ( gpWindowManager->buttonPressedCode )
  {
    case 3:
      if ( gbInCampaign )
      {
        advManager::SetEnvironmentOrigin((advManager *)thisa, -1, -1, 1);
        game::ShowCampaignInfo(gpGame, 1, 0);
        advManager::SetEnvironmentOrigin(
          (advManager *)thisa,
          *(_DWORD *)((char *)thisa + 470) + 7,
          *(_DWORD *)((char *)thisa + 474) + 7,
          1);
        advManager::RedrawAdvScreen((advManager *)thisa, 1, 0);
        soundManager::SwitchAmbientMusic(
          (soundManager *)gpSoundManager,
          (unsigned __int8)giTerrainToMusicTrack[*(_DWORD *)((char *)thisa + 166)]);
      }
      else if ( xIsPlayingExpansionCampaign )
      {
        advManager::SetEnvironmentOrigin((advManager *)thisa, -1, -1, 1);
        ExpCampaign::ShowInfo((int)&xCampaign, 1, 0);
        advManager::SetEnvironmentOrigin(
          (advManager *)thisa,
          *(_DWORD *)((char *)thisa + 470) + 7,
          *(_DWORD *)((char *)thisa + 474) + 7,
          1);
        advManager::RedrawAdvScreen((advManager *)thisa, 1, 0);
        soundManager::SwitchAmbientMusic(
          (soundManager *)gpSoundManager,
          (unsigned __int8)giTerrainToMusicTrack[*(_DWORD *)((char *)thisa + 166)]);
      }
      else
      {
        game::ShowScenInfo(gpGame);
      }
      break;
    case 4:
      advManager::ProcessSearch((advManager *)thisa, -1i64);
      break;
    case 1:
      advManager::ViewWorld((advManager *)thisa, v1, 53, 0, 0);
      break;
    case 2:
      advManager::ViewPuzzle((advManager *)thisa);
      break;
    default:
      break;
  }
  if ( v4 )
    advManager::MobilizeCurrHero((advManager *)thisa, 0);
}
// 5240A8: using guessed type int gpSoundManager;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (00457450) --------------------------------------------------------
signed int __thiscall APanelHandler(void *this)
{
  signed int result; // eax@26
  signed int v2; // [sp+Ch] [bp-18h]@18
  signed int v3; // [sp+14h] [bp-10h]@5
  void *v4; // [sp+18h] [bp-Ch]@1
  signed int v5; // [sp+1Ch] [bp-8h]@5
  signed int v6; // [sp+20h] [bp-4h]@1

  v4 = this;
  v6 = 0;
  if ( *(_DWORD *)this == 512 )
  {
    if ( *((_BYTE *)this + 13) & 2 )
    {
      if ( *((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14 )
      {
        v5 = -1;
        v3 = *((_DWORD *)this + 2);
        if ( v3 <= 30720 )
        {
          if ( v3 == 30720 )
          {
            v5 = 4;
          }
          else
          {
            switch ( v3 )
            {
              case 1:
                v5 = 0;
                break;
              case 2:
                v5 = 1;
                break;
              case 3:
                v5 = 2;
                break;
              case 4:
                v5 = 3;
                break;
              default:
                break;
            }
          }
        }
        if ( v5 >= 0 )
          NormalDialog(gEventText[v5 + 110], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      }
    }
    else if ( *((_DWORD *)this + 1) == 13 )
    {
      v2 = *((_DWORD *)this + 2);
      if ( v2 >= 1 && (v2 <= 4 || v2 == 30720) )
        v6 = 1;
    }
  }
  if ( v6 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (00457620) --------------------------------------------------------
signed int __thiscall advManager::ControlPanel(void *this)
{
  signed int result; // eax@15
  void *thisa; // [sp+10h] [bp-38h]@1
  heroWindow *thisb; // [sp+1Ch] [bp-2Ch]@1
  int v4; // [sp+20h] [bp-28h]@1
  int evt; // [sp+24h] [bp-24h]@7
  int v6; // [sp+28h] [bp-20h]@7
  int v7; // [sp+2Ch] [bp-1Ch]@7
  int v8; // [sp+3Ch] [bp-Ch]@7
  int window; // [sp+40h] [bp-8h]@2
  int v10; // [sp+44h] [bp-4h]@1

  thisa = this;
  advManager::TrimLoopingSounds((advManager *)this, 4);
  v10 = -1;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  v4 = *(_DWORD *)((char *)thisa + 678);
  advManager::DemobilizeCurrHero((advManager *)thisa);
  thisb = (heroWindow *)operator new(68);
  if ( thisb )
    window = (int)heroWindow::heroWindow(thisb, 144, 40, "cpanel.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  if ( gbRemoteOn )
  {
    evt = 512;
    v7 = 101;
    v6 = 5;
    v8 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
    v6 = 6;
    v8 = 2;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
    v7 = 102;
    v6 = 5;
    v8 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
    v6 = 6;
    v8 = 2;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))CPanelHandler,
    0);
  operator delete((void *)window);
  switch ( gpWindowManager->buttonPressedCode )
  {
    case 0x65:
    case 0x66:
    case 0x69:
      v10 = gpWindowManager->buttonPressedCode;
      break;
    case 0x6A:
      SaveGame();
      break;
    default:
      break;
  }
  if ( v4 )
    advManager::MobilizeCurrHero((advManager *)thisa, 0);
  if ( v10 == -1 )
  {
    result = 0;
  }
  else
  {
    gGameCommand = v10;
    result = 1;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 523408: using guessed type int gGameCommand;

//----- (00457810) --------------------------------------------------------
signed int __thiscall CPanelHandler(void *this)
{
  signed int result; // eax@33
  signed int v2; // [sp+Ch] [bp-E0h]@18
  signed int v3; // [sp+14h] [bp-D8h]@5
  void *v4; // [sp+18h] [bp-D4h]@1
  signed int v5; // [sp+1Ch] [bp-D0h]@5
  char msg; // [sp+20h] [bp-CCh]@19
  int v7; // [sp+E8h] [bp-4h]@1

  v4 = this;
  v7 = 0;
  if ( *(_DWORD *)this == 512 )
  {
    if ( *((_BYTE *)this + 13) & 2 )
    {
      if ( *((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14 )
      {
        v5 = -1;
        v3 = *((_DWORD *)this + 2);
        if ( v3 <= 30720 )
        {
          if ( v3 == 30720 )
          {
            v5 = 4;
          }
          else
          {
            switch ( v3 )
            {
              case 101:
                v5 = 0;
                break;
              case 102:
                v5 = 1;
                break;
              case 106:
                v5 = 2;
                break;
              case 105:
                v5 = 3;
                break;
              default:
                break;
            }
          }
        }
        if ( v5 >= 0 )
          NormalDialog(gEventText[v5 + 96], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      }
    }
    else if ( *((_DWORD *)this + 1) == 13 )
    {
      v2 = *((_DWORD *)this + 2);
      if ( v2 <= 30720 )
      {
        if ( v2 == 30720 )
        {
LABEL_26:
          v7 = 1;
        }
        else
        {
          switch ( v2 )
          {
            case 101:
              strcpy(&msg, "Are you sure you want to restart?  (Your current game will be lost)");
              goto LABEL_22;
            case 102:
              strcpy(&msg, "Are you sure you want to load a new game?  (Your current game will be lost)");
              goto LABEL_22;
            case 105:
              strcpy(&msg, "Are you sure you want to quit?");
LABEL_22:
              v7 = 1;
              if ( !bFreshSave )
              {
                NormalDialog(&msg, 2, -1, -1, -1, 0, -1, 0, -1, 0);
                if ( gpWindowManager->buttonPressedCode == 30726 )
                  v7 = 0;
              }
              break;
            case 106:
              goto LABEL_26;
            default:
              break;
          }
        }
      }
    }
  }
  if ( v7 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 5235D8: using guessed type int bFreshSave;

//----- (00457B20) --------------------------------------------------------
void __thiscall advManager::SystemOptions(void *this)
{
  void *thisa; // [sp+Ch] [bp-3Ch]@1
  heroWindow *thisb; // [sp+18h] [bp-30h]@1
  signed int i; // [sp+1Ch] [bp-2Ch]@7
  int v4; // [sp+20h] [bp-28h]@1
  int v5; // [sp+40h] [bp-8h]@1
  int v6; // [sp+44h] [bp-4h]@1

  thisa = this;
  advManager::TrimLoopingSounds((advManager *)this, 4);
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  v5 = *(_DWORD *)&walkSpeed;
  v6 = *(_DWORD *)&evilInterfaceUsage;
  v4 = *(_DWORD *)((char *)thisa + 678);
  bPrefsChanged = 0;
  advManager::DemobilizeCurrHero((advManager *)thisa);
  thisb = (heroWindow *)operator new(68);
  if ( thisb )
    cPanel = heroWindow::heroWindow(thisb, 160, 33, "spanel.bin");
  else
    cPanel = 0;
  if ( !cPanel )
    MemError();
  SetWinText(cPanel, 2);
  UpdateSystemOptions((void *)1);
  heroWindowManager::DoDialog(gpWindowManager, cPanel, (int (__fastcall *)(tag_message *))SystemOptionsHandler, 0);
  operator delete(cPanel);
  if ( *(_DWORD *)&walkSpeed != v5 )
  {
    for ( i = 0; i < 9; ++i )
      resourceManager::Dispose(gpResourceManager, *(resource **)((char *)thisa + 4 * i + 850));
    advManager::GetCursorSampleSet((advManager *)thisa, *(signed int *)&walkSpeed);
  }
  if ( bPrefsChanged )
    WritePrefs();
  if ( *(_DWORD *)&evilInterfaceUsage != v6 )
    advManager::CheckSetEvilInterface(thisa, 1, -1);
  if ( v4 )
    advManager::MobilizeCurrHero((advManager *)thisa, 0);
}
// 524D20: using guessed type int bPrefsChanged;

//----- (00457CC0) --------------------------------------------------------
void __thiscall UpdateSystemOptions(void *this)
{
  void *v1; // [sp+Ch] [bp-24h]@1
  int evt; // [sp+10h] [bp-20h]@1
  int v3; // [sp+14h] [bp-1Ch]@1
  int v4; // [sp+18h] [bp-18h]@1
  bool v5; // [sp+28h] [bp-8h]@1
  int v6; // [sp+2Ch] [bp-4h]@5

  v1 = this;
  evt = 512;
  v3 = 4;
  v4 = 10;
  v5 = *(_DWORD *)&Data != 0;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 11;
  if ( *(_DWORD *)&soundVolume )
    v5 = 3;
  else
    v5 = 2;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 12;
  v5 = *(_DWORD *)&walkSpeed + 4;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 13;
  if ( *(_DWORD *)&useCDMusic )
  {
    if ( *(_DWORD *)&useOpera )
      v6 = 2;
    else
      v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  v5 = v6 + 10;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 14;
  v5 = (*(_DWORD *)&showRoute < 1u) + 13;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 15;
  if ( *(_DWORD *)&blackoutComputer )
    v5 = 9;
  else
    v5 = *(_DWORD *)&gConfig + 4;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 16;
  v5 = *(_DWORD *)&evilInterfaceUsage + 15;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 17;
  v5 = (*(_DWORD *)&slowVideo >= 1u) + 18;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 18;
  v5 = *(&bMenu + 6) + 20;
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v3 = 3;
  v4 = 20;
  v5 = (bool)onOffText[*(_DWORD *)&Data];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 21;
  v5 = (bool)onOffText[*(_DWORD *)&soundVolume];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 22;
  v5 = (bool)walkSpeedText[*(_DWORD *)&walkSpeed];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 23;
  v5 = (bool)musicQualityText[v6];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 24;
  v5 = (bool)onOffText[*(_DWORD *)&showRoute];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 25;
  if ( *(_DWORD *)&blackoutComputer )
    v5 = (bool)"Don't Show";
  else
    v5 = (bool)walkSpeedText[*(_DWORD *)&gConfig];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 26;
  v5 = (bool)gInterfaceTypeText[*(_DWORD *)&evilInterfaceUsage];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 27;
  v5 = (bool)off_4F71D4[-(*(_DWORD *)&slowVideo < 1u)];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  v4 = 28;
  v5 = (bool)cBWMouseText[*(&bMenu + 6)];
  heroWindow::BroadcastMessage(cPanel, (tag_message *)&evt);
  if ( !v1 )
    heroWindow::DrawWindow(cPanel, 1, 0, 32767);
}
// 4F62B0: using guessed type char *onOffText[11];
// 4F62E0: using guessed type char *walkSpeedText[5];
// 4F69A8: using guessed type char *musicQualityText[3];
// 4F6F20: using guessed type char *gInterfaceTypeText[3];
// 4F6F30: using guessed type char *cBWMouseText[5];
// 4F71D4: using guessed type char *off_4F71D4[26];

//----- (00458020) --------------------------------------------------------
signed int __thiscall SystemOptionsHandler(void *this)
{
  signed int result; // eax@71
  int v2; // [sp+14h] [bp-90h]@22
  signed int v3; // [sp+18h] [bp-8Ch]@5
  void *v4; // [sp+1Ch] [bp-88h]@1
  signed int v5; // [sp+20h] [bp-84h]@5
  signed int v6; // [sp+9Ch] [bp-8h]@1
  signed int v7; // [sp+A0h] [bp-4h]@1

  v4 = this;
  v6 = 0;
  v7 = 0;
  if ( *(_DWORD *)this == 512 )
  {
    if ( *((_BYTE *)this + 13) & 2 )
    {
      if ( *((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14 )
      {
        v5 = -1;
        v3 = *((_DWORD *)this + 2);
        if ( v3 <= 30720 )
        {
          if ( v3 == 30720 )
          {
            v5 = 0;
          }
          else
          {
            switch ( v3 )
            {
              case 10:
                v5 = 1;
                break;
              case 11:
                v5 = 2;
                break;
              case 12:
                v5 = 3;
                break;
              case 13:
                v5 = 4;
                break;
              case 14:
                v5 = 5;
                break;
              case 15:
                v5 = 6;
                break;
              case 16:
                v5 = 7;
                break;
              case 17:
                v5 = 8;
                break;
              case 18:
                v5 = 9;
                break;
              default:
                break;
            }
          }
        }
        if ( v5 >= 0 )
          NormalDialog((&gSPanelHelp)[4 * v5], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      }
    }
    else
    {
      v2 = *((_DWORD *)this + 1);
      if ( v2 == 12 )
      {
        switch ( *((_DWORD *)this + 2) )
        {
          case 0xA:
            if ( *(_DWORD *)&Data || *(_DWORD *)(gpSoundManager + 1694) || *(_DWORD *)(gpSoundManager + 1698) )
            {
              *(_DWORD *)&Data = (*(_DWORD *)&Data + 1) % 11;
              soundManager::AdjustMusicVolumes(gpSoundManager);
              v6 = 1;
              bPrefsChanged = 1;
            }
            else
            {
              NormalDialog(
                "Neither MIDI nor Redbook music is currently available on this system.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            break;
          case 0xB:
            if ( *(_DWORD *)&soundVolume || *(_DWORD *)(gpSoundManager + 58) )
            {
              *(_DWORD *)&soundVolume = (*(_DWORD *)&soundVolume + 1) % 11;
              soundManager::AdjustSoundVolumes((soundManager *)gpSoundManager);
              v6 = 1;
              bPrefsChanged = 1;
            }
            else
            {
              NormalDialog("Digital sound is not currently available on this system.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
            break;
          case 0xC:
            ++*(_DWORD *)&walkSpeed;
            *(_DWORD *)&walkSpeed %= 5;
            v6 = 1;
            bPrefsChanged = 1;
            break;
          case 0xF:
            if ( *(_DWORD *)&blackoutComputer )
            {
              *(_DWORD *)&blackoutComputer = 0;
              *(_DWORD *)&gConfig = 2;
            }
            else if ( *(_DWORD *)&gConfig >= 4 )
            {
              *(_DWORD *)&blackoutComputer = 1;
            }
            else
            {
              ++*(_DWORD *)&gConfig;
            }
            v6 = 1;
            bPrefsChanged = 1;
            break;
          case 0xD:
            if ( *(_DWORD *)&useCDMusic )
            {
              if ( *(_DWORD *)&useOpera )
              {
                if ( !*(_DWORD *)(gpSoundManager + 1706) )
                  soundManager::MIDIStartup((soundManager *)gpSoundManager);
                if ( *(_DWORD *)(gpSoundManager + 1698) )
                  soundManager::SetMusicQuality(gpSoundManager, 0);
                else
                  *(_DWORD *)&useOpera = 1 - *(_DWORD *)&useOpera;
              }
              else
              {
                *(_DWORD *)&useOpera = 1;
              }
            }
            else
            {
              if ( !*(_DWORD *)(gpSoundManager + 1702) )
                soundManager::CDStartup((soundManager *)gpSoundManager);
              if ( !*(_DWORD *)(gpSoundManager + 1694) )
              {
                NormalDialog(
                  "Unable to set up CD stereo music.  Your CD player might be in use by another program, or your sound driver might not support CD stereo.",
                  1,
                  -1,
                  -1,
                  -1,
                  0,
                  -1,
                  0,
                  -1,
                  0);
                break;
              }
              soundManager::SetMusicQuality(gpSoundManager, 1);
              *(_DWORD *)&useOpera = 0;
            }
            v6 = 1;
            bPrefsChanged = 1;
            break;
          case 0xE:
            *(_DWORD *)&showRoute = 1 - *(_DWORD *)&showRoute;
            v6 = 1;
            bPrefsChanged = 1;
            break;
          case 0x10:
            *(_DWORD *)&evilInterfaceUsage = (*(_DWORD *)&evilInterfaceUsage + 1) % 3;
            v6 = 1;
            bPrefsChanged = 1;
            break;
          case 0x11:
            if ( gbLowMemory )
            {
              NormalDialog("You don't have enough memory for non-interlaced video.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
            else
            {
              *(_DWORD *)&slowVideo = *(_DWORD *)&slowVideo == 0;
              v6 = 1;
              bPrefsChanged = 1;
            }
            break;
          case 0x12:
            *(&bMenu + 6) = 1 - *(&bMenu + 6);
            v6 = 1;
            bPrefsChanged = 1;
            mouseManager::SetColorMice(gpMouseManager, *(&bMenu + 6));
            break;
          default:
            break;
        }
      }
      else if ( v2 == 13 && *((_DWORD *)this + 2) == 30720 )
      {
        v7 = 1;
      }
    }
  }
  if ( v6 )
    UpdateSystemOptions(0);
  if ( v7 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F74A8: using guessed type int gbLowMemory;
// 5240A8: using guessed type int gpSoundManager;
// 524D20: using guessed type int bPrefsChanged;

//----- (004586A0) --------------------------------------------------------
int __fastcall GetMobilityFrame(int a1)
{
  int v2; // [sp+10h] [bp-4h]@1

  v2 = 22 * a1 / 1500;
  if ( v2 < 0 )
    v2 = 0;
  if ( v2 <= 30 )
  {
    if ( v2 <= 26 )
    {
      if ( v2 > 23 )
        v2 = 23;
    }
    else
    {
      v2 = 24;
    }
  }
  else
  {
    v2 = 25;
  }
  return v2;
}

//----- (00458720) --------------------------------------------------------
int __fastcall GetManaFrame(signed int a1)
{
  int v2; // [sp+10h] [bp-4h]@1

  v2 = a1 / 5;
  if ( !(a1 / 5) && a1 >= 3 )
    v2 = 1;
  if ( v2 <= 33 )
  {
    if ( v2 <= 28 )
    {
      if ( v2 > 23 )
        v2 = 23;
    }
    else
    {
      v2 = 24;
    }
  }
  else
  {
    v2 = 25;
  }
  return v2;
}

//----- (004587A0) --------------------------------------------------------
signed int __thiscall advManager::DoVisions(void *this, hero *hro)
{
  int v2; // ebx@6
  advManager *v4; // [sp+14h] [bp-100h]@1
  int v5; // [sp+18h] [bp-FCh]@24
  int v6; // [sp+1Ch] [bp-F8h]@30
  int v7; // [sp+20h] [bp-F4h]@12
  char a2a; // [sp+24h] [bp-F0h]@21
  int v9; // [sp+ECh] [bp-28h]@1
  mapCell *v10; // [sp+F0h] [bp-24h]@5
  int row; // [sp+F4h] [bp-20h]@3
  int col; // [sp+F8h] [bp-1Ch]@1
  float v13; // [sp+FCh] [bp-18h]@12
  int creatureType; // [sp+100h] [bp-14h]@12
  int v15; // [sp+104h] [bp-10h]@1
  int v16; // [sp+108h] [bp-Ch]@12
  int v17; // [sp+10Ch] [bp-8h]@6
  int v18; // [sp+110h] [bp-4h]@1

  v4 = (advManager *)this;
  v9 = 100;
  v18 = -1;
  v15 = -1;
  for ( col = hro->x - 3; hro->x + 3 >= col; ++col )
  {
    for ( row = hro->y - 3; hro->y + 3 >= row; ++row )
    {
      v10 = advManager::GetCell(v4, col, row);
      if ( v10->objType == 152 )
      {
        v2 = abs(hro->y - row);
        v17 = abs(hro->x - col) + v2;
        if ( v17 < v9 )
        {
          v9 = v17;
          v15 = col;
          v18 = row;
        }
      }
    }
  }
  if ( v9 == 100 )
  {
    NormalDialog(
      "You must be within 3 spaces of a monster for the Visions spell to work.",
      1,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
    return 0;
  }
  v10 = advManager::GetCell(v4, v15, v18);
  creatureType = v10->objectIndex;
  v7 = ((unsigned __int8)(v10->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0;
  v16 = (unsigned __int8)((unsigned __int8)(v10->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  sprintf(gText, "{%d %s}\n\n", v16, gArmyNamesPlural[creatureType]);
  v13 = (double)philAI::FightValueOfStack(&hro->army, hro, 0, 0, 0, 0)
      / (double)(v16 * gMonsterDatabase[creatureType].fight_value);
  if ( !armyGroup::CanJoin(&hro->army, creatureType)
    || v13 <= 2.0
    || hero::HasArtifact(hro, ARTIFACT_HIDEOUS_MASK)
    || creatureType == 59
    || creatureType == 62
    || creatureType == 63
    || creatureType == 64
    || creatureType == 65 )
    goto LABEL_37;
  if ( !v7 )
  {
    if ( hro->secondarySkillLevel[4] )
    {
      if ( hro->secondarySkillLevel[4] == 3 )
      {
        v5 = v16;
      }
      else if ( hro->secondarySkillLevel[4] == 2 )
      {
        v5 = v16 / 2;
      }
      else
      {
        v5 = v16 / 4;
      }
      if ( !v5 )
        v5 = 1;
      v6 = v16 * gMonsterDatabase[creatureType].cost;
      if ( gpGame->players[hro->ownerIdx].resources[6] >= v6 )
      {
        if ( v16 == v5 )
          sprintf(&a2a, "All the creatures will join us...\n\nfor a fee of %d gold.", v6);
        else
          sprintf(&a2a, "%d of the creatures will join us...\n\nfor a fee of %d gold.", v16, v6);
        strcat(gText, &a2a);
        goto LABEL_40;
      }
      if ( v13 <= 5.0 )
        goto LABEL_39;
      goto LABEL_38;
    }
LABEL_37:
    if ( v13 <= 5.0 )
    {
LABEL_39:
      sprintf(&a2a, "I fear these creatures are in the mood for a fight.");
      strcat(gText, &a2a);
      goto LABEL_40;
    }
LABEL_38:
    sprintf(&a2a, "These weak creatures will surely flee before us.");
    strcat(gText, &a2a);
    goto LABEL_40;
  }
  sprintf(&a2a, "The creatures are willing to join us!");
  strcat(gText, &a2a);
LABEL_40:
  NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
  return 1;
}

//----- (00458C60) --------------------------------------------------------
signed int __stdcall advManager::IsCrystalBallInEffect(int a1, int a2, signed int a3)
{
  signed int i; // [sp+1Ch] [bp-Ch]@1
  char *this; // [sp+20h] [bp-8h]@3

  for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
  {
    this = (char *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]];
    if ( hero::HasArtifact((hero *)this, 91)
      && (signed int)(signed __int64)sqrt((double)((*(_DWORD *)(this + 25) - a1) * (*(_DWORD *)(this + 25) - a1)
                                                 + (*(_DWORD *)(this + 29) - a2) * (*(_DWORD *)(this + 29) - a2))) <= a3 )
      return 1;
  }
  return 0;
}

//----- (00458D40) --------------------------------------------------------
char __thiscall StopOnTrigger(int this)
{
  char result; // al@2
  int v2; // [sp+Ch] [bp-10h]@3
  int v3; // [sp+18h] [bp-4h]@1

  v3 = *(_BYTE *)(this + 9) & 0x7F;
  if ( v3 == 122 )
  {
    v2 = ((unsigned __int8)(*(_WORD *)(this + 4) >> 8) >> -5) & 0x3F;
    result = v2 >= 5 && v2 <= 6;
  }
  else
  {
    result = bStopOnTrigger[v3];
  }
  return result;
}

//----- (00458DD0) --------------------------------------------------------
signed int __thiscall ConvertSmackerPalette(void *this)
{
  signed int result; // eax@3
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 768; ++i )
  {
    result = i;
    *((_BYTE *)this + i) = (signed int)*((_BYTE *)this + i) >> 2;
  }
  return result;
}

//----- (00458E20) --------------------------------------------------------
int __fastcall DoAdvance(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@6
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = a2;
  v10 = a1;
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 104) )
    {
      if ( !a5 )
      {
        memcpy(gPalette->contents, (const void *)(a1 + 108), 0x300u);
        ConvertSmackerPalette(gPalette->contents);
        if ( a4 )
          UpdatePalette((#72 *)gPalette->contents);
      }
    }
  }
  result = SmackDoFrame(v10);
  if ( v9 )
  {
    while ( 1 )
    {
      result = SmackToBufferRect(v10, 1);
      if ( !result )
        break;
      if ( bSmackNum == 35 )
      {
        if ( *(_DWORD *)gbCampaignSideChoice == 1 )
        {
          icon::DrawToBuffer(brotherIcon, 0, 0, 0, 0);
          icon::DrawToBuffer(brotherIcon, 0, 0, 3, 0);
        }
        else
        {
          icon::DrawToBuffer(brotherIcon, 0, 0, 1, 0);
          icon::DrawToBuffer(brotherIcon, 0, 0, 2, 0);
        }
      }
      if ( bSmackNum == 67 && xLastChoice != -1 )
        icon::DrawToBuffer(backImage, 0, 0, 1, 0);
      if ( bSmackNum != 2
        || *(_DWORD *)(v10 + 884) < 0x24u
        || (font::DrawBoundedString(smallFont, congratsText, 409, 98, 134, 217, 4, 5), *(_DWORD *)(v10 + 884) != 36) )
        BlitBitmapToScreen(
          gpWindowManager->screenBuffer,
          *(_DWORD *)(v10 + 896),
          *(_DWORD *)(v10 + 900),
          *(_DWORD *)(v10 + 904),
          *(_DWORD *)(v10 + 908),
          *(_DWORD *)(v10 + 896),
          *(_DWORD *)(v10 + 900));
      else
        BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x27Fu, 479, 0, 0);
    }
  }
  if ( a3 )
    result = SmackNextFrame(v10);
  return result;
}
// 524EC0: using guessed type char bSmackNum;
// 5304C8: using guessed type int xLastChoice;
// 53983C: using guessed type int __stdcall SmackToBufferRect(_DWORD, _DWORD);
// 539840: using guessed type int __stdcall SmackNextFrame(_DWORD);
// 539850: using guessed type int __stdcall SmackDoFrame(_DWORD);

//----- (00459040) --------------------------------------------------------
void __cdecl SmackManagerMain()
{
  int v0; // eax@41
  int v1; // eax@116
  int v2; // [sp+0h] [bp-520h]@0
  int v3; // [sp+4h] [bp-51Ch]@0
  int v4; // [sp+8h] [bp-518h]@0
  bool v5; // [sp+10h] [bp-510h]@134
  int v6; // [sp+14h] [bp-50Ch]@68
  char v7; // [sp+18h] [bp-508h]@104
  tag_message a2; // [sp+34h] [bp-4ECh]@49
  int v9; // [sp+50h] [bp-4D0h]@112
  int v10; // [sp+54h] [bp-4CCh]@112
  int v11; // [sp+58h] [bp-4C8h]@112
  bool v12; // [sp+5Ch] [bp-4C4h]@106
  char v13; // [sp+60h] [bp-4C0h]@106
  int v14; // [sp+64h] [bp-4BCh]@106
  int v15; // [sp+68h] [bp-4B8h]@90
  int v16; // [sp+6Ch] [bp-4B4h]@88
  int v17; // [sp+70h] [bp-4B0h]@104
  int v18; // [sp+74h] [bp-4ACh]@118
  int v19; // [sp+8Ch] [bp-494h]@50
  int y; // [sp+90h] [bp-490h]@2
  int x; // [sp+94h] [bp-48Ch]@2
  int v22; // [sp+98h] [bp-488h]@24
  int v23; // [sp+9Ch] [bp-484h]@1
  int v24; // [sp+A0h] [bp-480h]@47
  char v25; // [sp+A8h] [bp-478h]@3
  int v26; // [sp+3ACh] [bp-174h]@1
  int v27; // [sp+3B4h] [bp-16Ch]@47
  int v28; // [sp+3B8h] [bp-168h]@47
  int v29; // [sp+3BCh] [bp-164h]@21
  char a1; // [sp+3C0h] [bp-160h]@13

  v23 = 1;
  gbLastFramePlayed = 0;
  v26 = 0;
  if ( bSmackNum == 35 )
  {
    brotherIcon = resourceManager::GetIcon(gpResourceManager, "brothers.icn");
    mouseManager::MouseCoords(&x, &y);
    *(_DWORD *)gbCampaignSideChoice = x < 320;
  }
  KBChangeMenu(hmnuDflt);
  mouseManager::HideColorPointer(gpMouseManager);
  bMainDone = 1;
  memcpy(&v25, gPalette->contents, 0x300u);
  if ( !gbNoSound && *(_DWORD *)(gpSoundManager + 58) && *(_DWORD *)&soundVolume && bSmackNum != 36 )
  {
    bSmackSound = 1;
    if ( AIL_get_preference(15u) )
    {
      SmackSoundUseMSS(*(_DWORD *)(gpSoundManager + 58));
      LogStr("SSSS 1");
    }
    else
    {
      SmackSoundUseDirectSound(*(_DWORD *)(*(_DWORD *)(gpSoundManager + 58) + 76));
      LogStr("SSSS 2");
    }
  }
  else
  {
    bSmackSound = 0;
  }
  if ( byte_4F74B8 && bSmackNum > 38 )
  {
    strcpy(&a1, "i:\\projects\\heroes\\art\\fin3d\\");
  }
  else if ( bSmackNum == 67 )
  {
    strcpy(&a1, ".\\DATA\\");
  }
  else
  {
    strcpy(&a1, "\\HEROES2\\ANIM\\");
  }
  if ( *(_DWORD *)&slowVideo )
    sprintf(gText, "%s%s.SMK", &a1, &SmackOptions[45 * bSmackNum + 18]);
  else
    sprintf(gText, "%s%s.SMK", &a1, &SmackOptions[45 * bSmackNum]);
  if ( bSmackSound )
    v29 = 1040384;
  else
    v29 = 0;
  if ( byte_50FF36[45 * bSmackNum] )
    v22 = 512;
  else
    v22 = 0;
  if ( gbLowMemory && bSmackNum == 30 && !*(_DWORD *)&slowVideo )
    v22 = 0;
  smk1 = 0;
  if ( bSmackNum != 67 )
  {
    while ( !smk1 )
    {
      smk1 = SmackOpen(gText, v29 + v22, -1);
      if ( !smk1 )
      {
        heroWindowManager::FadeScreen(gpWindowManager, 0, 128, 0);
        NormalDialog("Error reading the Heroes 2 Expansion CD.  Retry?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
        if ( gpWindowManager->buttonPressedCode == 30726 )
          ShutDown("CDROM drive error.  Exiting.");
      }
    }
    SmackToBuffer(smk1, 0, 0, 640, 480, gpWindowManager->screenBuffer->contents, 0);
  }
  if ( strlen(&SmackOptions[45 * bSmackNum + 9]) > 1 )
  {
    if ( *(_DWORD *)&slowVideo )
      sprintf(gText, "%s%s.SMK", &a1, &SmackOptions[45 * bSmackNum + 27]);
    else
      sprintf(gText, "%s%s.SMK", &a1, &SmackOptions[45 * bSmackNum + 9]);
    v0 = ((unsigned int)bSmackSound < 1) - 1;
    smk2 = SmackOpen(gText, v0 & 0xFE000, -1);
    if ( byte_50FF38[45 * bSmackNum] )
    {
      if ( !*(_DWORD *)&slowVideo && bSmackNum != 67 )
        SmackToBuffer(
          smk2,
          *(__int16 *)((char *)&word_50FF39 + 45 * bSmackNum),
          *(__int16 *)((char *)&word_50FF3B + 45 * bSmackNum),
          640,
          480,
          gpWindowManager->screenBuffer->contents,
          0);
    }
  }
  FillBitmapArea(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0);
  BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0, 0);
  if ( byte_50FF34[45 * bSmackNum] )
    heroWindowManager::FadeScreen(gpWindowManager, 1, 128, 0);
  v28 = 1;
  v27 = 0;
  v24 = 0;
  if ( bSmackNum == 35 )
  {
    Process1WindowsMessage();
    while ( inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2)->eventCode )
      v19 = 0;
  }
  while ( v28 )
  {
    if ( bSmackNum == 67 )
    {
      if ( !v27 )
      {
        mouseManager::SetPointer(gpMouseManager, "advmice.mse", 40, -999);
        mouseManager::ReallyShowPointer(gpMouseManager);
        soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
        backImage = resourceManager::GetIcon(gpResourceManager, "x_ivy.icn");
        if ( !backImage )
          MemError();
        icon::DrawToBuffer(backImage, 0, 0, 0, 0);
        icon::DrawToBuffer(backImage, 0, 0, 1, 0);
        sprintf(gText, "%s%s.SMK", &a1, "IVYPOL");
        smk2 = SmackOpen(gText, 0, -1);
        memcpy(gPalette->contents, (const void *)(smk2 + 108), 0x300u);
        SmackClose(smk2);
        smk2 = 0;
        ConvertSmackerPalette(gPalette->contents);
        UpdatePalette((#72 *)gPalette->contents);
        memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
        heroWindowManager::FadeScreen(gpWindowManager, 0, 4, 0);
        v27 = 1;
      }
    }
    else if ( !SmackWait(smk1) )
    {
      if ( bSmackNum == 3 && !v26 )
      {
        v26 = 1;
        soundManager::PlayAmbientMusic(gpSoundManager, 19, 0, -1);
      }
      if ( (!v27 || *(_DWORD *)(smk1 + 12) > 1u)
        && (bSmackNum != 2 || *(_DWORD *)(smk1 + 12) - 1 != *(_DWORD *)(smk1 + 884)) )
      {
        v6 = v27 || !byte_50FF34[45 * bSmackNum];
        DoAdvance(smk1, 1, 1, v6, 0, v2, v3, v4);
      }
      if ( *(_DWORD *)(smk1 + 884) || *(_DWORD *)(smk1 + 12) <= 1u )
      {
        if ( !v27 )
        {
          if ( bSmackNum == 35 )
          {
            mouseManager::SetPointer(gpMouseManager, "advmice.mse", 40, -999);
            mouseManager::ReallyShowPointer(gpMouseManager);
          }
          if ( byte_50FF34[45 * bSmackNum] )
          {
            memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
            heroWindowManager::FadeScreen(gpWindowManager, 0, 4, 0);
          }
          if ( bSmackNum == 36 )
            soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
          if ( bSmackNum == 72 )
            soundManager::PlayAmbientMusic(gpSoundManager, 42, 0, -1);
        }
        v27 = 1;
      }
    }
    if ( smk2 && v27 && !SmackWait(smk2) )
    {
      if ( v24 && *(_DWORD *)(smk2 + 12) - 1 == *(_DWORD *)(smk2 + 884) )
      {
        v16 = 0;
        if ( !byte_50FF38[45 * bSmackNum] || *(_DWORD *)&slowVideo )
        {
          if ( bSmackNum == 67 )
          {
            v15 = 1;
            v16 = 1;
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 1;
        }
        DoAdvance(smk2, v15, v16, 0, 1, v2, v3, v4);
        gbLastFramePlayed = 1;
        while ( SmackWait(smk2) )
          Process1WindowsMessage();
      }
      else if ( bSmackNum == 67 )
      {
        DoAdvance(smk2, 1, 1, 0, 1, v2, v3, v4);
      }
      else
      {
        DoAdvance(smk2, byte_50FF38[45 * bSmackNum], 1, 0, 1, v2, v3, v4);
      }
      if ( smk2 && *(_DWORD *)(smk2 + 884) )
        v24 = 1;
    }
    Process1WindowsMessage();
    memcpy(&v17, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v7), 0x1Cu);
    switch ( v17 )
    {
      case 4:
        if ( bSmackNum == 35 )
        {
          mouseManager::MouseCoords(&v14, (int *)&v13);
          v12 = v14 < 320;
          if ( v12 != *(_DWORD *)gbCampaignSideChoice )
          {
            *(_DWORD *)gbCampaignSideChoice = v12;
            if ( v12 == 1 )
            {
              icon::DrawToBuffer(brotherIcon, 0, 0, 0, 0);
              icon::DrawToBuffer(brotherIcon, 0, 0, 3, 0);
            }
            else
            {
              icon::DrawToBuffer(brotherIcon, 0, 0, 1, 0);
              icon::DrawToBuffer(brotherIcon, 0, 0, 2, 0);
            }
            BlitBitmapToScreen(gpWindowManager->screenBuffer, 49, 78, 0x21Au, 258, 49, 78);
          }
        }
        else if ( bSmackNum == 67 )
        {
          mouseManager::MouseCoords(&v11, &v9);
          v10 = ExpansionCampaignRect(v11, v9);
          if ( v10 != xLastChoice )
          {
            icon::DrawToBuffer(backImage, 0, 0, 0, 0);
            BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0, 0);
            xLastChoice = v10;
            if ( smk2 )
            {
              SmackClose(smk2);
              smk2 = 0;
            }
            if ( v10 != -1 )
            {
              byte_524F14 = v10 + 68;
              sprintf(gText, "%s%s.SMK", &a1, &SmackOptions[45 * (char)(v10 + 68)]);
              v1 = ((unsigned int)bSmackSound < 1) - 1;
              smk2 = SmackOpen(gText, v1 & 0xFE000, -1);
              SmackToBuffer(
                smk2,
                *(__int16 *)((char *)&word_50FF39 + 45 * byte_524F14),
                *(__int16 *)((char *)&word_50FF3B + 45 * byte_524F14),
                640,
                480,
                gpWindowManager->screenBuffer->contents,
                0);
              icon::DrawToBuffer(backImage, 0, 0, 1, 0);
            }
          }
        }
        break;
      case 1:
        if ( v18 != 62 )
          goto LABEL_119;
        break;
      case 32:
LABEL_119:
        if ( bSmackNum != 35 && bSmackNum != 67 )
          goto LABEL_121;
        break;
      case 8:
LABEL_121:
        if ( bSmackNum != 37 && (bSmackNum != 67 || xLastChoice != -1) )
          goto LABEL_145;
        break;
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
        break;
    }
    if ( bSmackNum == 2 && *(_DWORD *)(smk1 + 884) + 1 == *(_DWORD *)(smk1 + 12) && !v26 )
    {
      v26 = 1;
      soundManager::PlayAmbientMusic(gpSoundManager, 43, 0, -1);
    }
    if ( !byte_50FF37[45 * bSmackNum] )
    {
      if ( gbLastFramePlayed
        || smk2
        && (bSmackNum < 39 ? (v5 = *(_DWORD *)(smk2 + 884) >= *(_DWORD *)(smk2 + 12)) : (v5 = (unsigned int)(*(_DWORD *)(smk2 + 12) - 1) <= *(_DWORD *)(smk2 + 884)),
            v5 || !*(_DWORD *)(smk2 + 884) && v24)
        || !smk2 && (*(_DWORD *)(smk1 + 884) >= *(_DWORD *)(smk1 + 12) || !*(_DWORD *)(smk1 + 884) && v27) )
      {
        v28 = 0;
        gbPlayedThrough = 1;
      }
    }
  }
LABEL_145:
  if ( bSmackNum == 35 )
  {
    mouseManager::HideColorPointer(gpMouseManager);
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  }
  if ( byte_50FF35[45 * bSmackNum] )
  {
    memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
    heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
    FillBitmapArea(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 36);
    BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0, 0);
  }
  else if ( !gbPlayedThrough && bSmackNum != 2 )
  {
    memcpy(gpBufferPalette->contents, gPalette->contents, 0x300u);
    heroWindowManager::FadeScreen(gpWindowManager, 1, 128, 0);
    FillBitmapArea(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 36);
    BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 480, 0, 0);
  }
  if ( bTesting )
    SmackSummary(smk1, smksum);
  if ( smk1 )
    SmackClose(smk1);
  smk1 = 0;
  if ( smk2 )
    SmackClose(smk2);
  smk2 = 0;
  if ( bSmackNum != 2 )
  {
    memcpy(gPalette->contents, &v25, 0x300u);
    UpdatePalette((#72 *)gPalette->contents);
  }
  mouseManager::ShowColorPointer(gpMouseManager);
  if ( brotherIcon )
    resourceManager::Dispose(gpResourceManager, (resource *)brotherIcon);
  brotherIcon = 0;
  if ( backImage )
    resourceManager::Dispose(gpResourceManager, (resource *)backImage);
  backImage = 0;
}
// 4F74A8: using guessed type int gbLowMemory;
// 4F74B8: using guessed type char byte_4F74B8;
// 50FEDC: using guessed type int bSmackSound;
// 50FF39: using guessed type __int16 word_50FF39;
// 50FF3B: using guessed type __int16 word_50FF3B;
// 510BE8: using guessed type int bTesting;
// 510BEC: using guessed type int smk1;
// 510BF0: using guessed type int smk2;
// 523F24: using guessed type int gbNoSound;
// 5240A8: using guessed type int gpSoundManager;
// 524EC0: using guessed type char bSmackNum;
// 524EC4: using guessed type int gbPlayedThrough;
// 524F14: using guessed type char byte_524F14;
// 524F18: using guessed type char bMainDone;
// 524F1C: using guessed type int gbLastFramePlayed;
// 5304C8: using guessed type int xLastChoice;
// 539830: using guessed type int __stdcall SmackSummary(_DWORD, _DWORD);
// 539834: using guessed type int __stdcall SmackSoundUseDirectSound(_DWORD);
// 539838: using guessed type int __stdcall SmackSoundUseMSS(_DWORD);
// 539844: using guessed type int __stdcall SmackToBuffer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 539848: using guessed type int __stdcall SmackWait(_DWORD);
// 53984C: using guessed type int __stdcall SmackClose(_DWORD);
// 539854: using guessed type int __stdcall SmackOpen(_DWORD, _DWORD, _DWORD);

//----- (0045A240) --------------------------------------------------------
int __cdecl ShutDownSmacker()
{
  int result; // eax@2

  if ( smk1 )
    result = SmackClose(smk1);
  smk1 = 0;
  if ( smk2 )
    result = SmackClose(smk2);
  smk2 = 0;
  return result;
}
// 510BEC: using guessed type int smk1;
// 510BF0: using guessed type int smk2;
// 53984C: using guessed type int __stdcall SmackClose(_DWORD);

//----- (0045A2A0) --------------------------------------------------------
int __fastcall PlaySmacker(int x)
{
  int result; // eax@2
  int xa; // [sp+Ch] [bp-308h]@1
  int v3; // [sp+10h] [bp-304h]@3
  char v4; // [sp+14h] [bp-300h]@3

  xa = x;
  xLastChoice = -1;
  if ( gbNoCDRom )
  {
    result = 0;
  }
  else
  {
    gbInSmackMgr = 1;
    gbPlayedThrough = 0;
    dword_50FED8 = 1;
    memcpy(&v4, gpBufferPalette->contents, 0x300u);
    v3 = gpWindowManager->cycleColors;
    gpWindowManager->cycleColors = 0;
    if ( xa != 67 )
    {
      *(_DWORD *)(gpSoundManager + 1672) = 1;
      soundManager::PlayAmbientMusic(gpSoundManager, -1, 0, -1);
    }
    if ( *(_DWORD *)&slowVideo == 3 )
    {
      *(_DWORD *)&slowVideo = 0;
      WritePrefs();
      bSmackNum = 37;
      bTesting = 1;
      SmackManagerMain();
      bTesting = 0;
      if ( (unsigned int)(dword_524EE4 + dword_524ED0) >= 0x7D0 || (unsigned int)dword_524EE8 >= 0x514 || gbLowMemory )
      {
        *(_DWORD *)&slowVideo = 1;
        WritePrefs();
      }
      PrintSummaryInfo((int *)smksum);
    }
    bSmackNum = xa;
    SmackManagerMain();
    memcpy(gpBufferPalette->contents, &v4, 0x300u);
    gpWindowManager->cycleColors = v3;
    gbInSmackMgr = 0;
    dword_50FED8 = 0;
    result = gbPlayedThrough;
  }
  return result;
}
// 4F1CBC: using guessed type int gbNoCDRom;
// 4F3088: using guessed type int gbInSmackMgr;
// 4F74A8: using guessed type int gbLowMemory;
// 50FED8: using guessed type int dword_50FED8;
// 510BE8: using guessed type int bTesting;
// 5240A8: using guessed type int gpSoundManager;
// 524EC0: using guessed type char bSmackNum;
// 524EC4: using guessed type int gbPlayedThrough;
// 524ED0: using guessed type int dword_524ED0;
// 524EE4: using guessed type int dword_524EE4;
// 524EE8: using guessed type int dword_524EE8;
// 5304C8: using guessed type int xLastChoice;

//----- (0045A440) --------------------------------------------------------
signed int __fastcall ExpansionCampaignRect(int a1, int a2)
{
  int v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  for ( i = 0; i < 4; ++i )
  {
    if ( PointInRect(v4, v3, (int)&a1cc[4 * i]) )
      return i;
  }
  return -1;
}
// 50FEE8: using guessed type wchar_t a1cc[5];

//----- (0045A4B0) --------------------------------------------------------
char __fastcall PointInRect(int a1, int a2, int a3)
{
  char result; // al@2

  if ( *(_WORD *)a3 <= a1 )
  {
    if ( *(_WORD *)a3 + (signed int)*(_WORD *)(a3 + 4) > a1 )
    {
      if ( *(_WORD *)(a3 + 2) <= a2 )
        result = *(_WORD *)(a3 + 6) + (signed int)*(_WORD *)(a3 + 2) > a2;
      else
        result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0045A540) --------------------------------------------------------
void __fastcall PrintSummaryInfo(int *metrics)
{
  int *metricsa; // ST18_4@1

  metricsa = metrics;
  sprintf(gText, "                                              Name - %s", &SmackOptions[45 * bSmackNum]);
  LogStr(gText);
  sprintf(gText, "                                        total time - %8d", *metricsa);
  LogStr(gText);
  sprintf(gText, "MS*100 per frame (100000/MS100PerFrame=Frames/Sec) - %8d", metricsa[1]);
  LogStr(gText);
  sprintf(gText, "        Time to open and prepare for decompression - %8d", metricsa[2]);
  LogStr(gText);
  sprintf(gText, "                            Total Frames displayed - %8d", metricsa[3]);
  LogStr(gText);
  sprintf(gText, "                    Total number of skipped frames - %8d", metricsa[4]);
  LogStr(gText);
  sprintf(gText, "                         Total time spent blitting - %8d", metricsa[6]);
  LogStr(gText);
  sprintf(gText, "                          Total time spent reading - %8d", metricsa[7]);
  LogStr(gText);
  sprintf(gText, "                    Total time spent decompressing - %8d", metricsa[8]);
  LogStr(gText);
  sprintf(gText, "                     Total io speed (sbytes/second) - %8d", metricsa[10]);
  LogStr(gText);
  sprintf(gText, "                         Slowest single frame time - %8d", metricsa[11]);
  LogStr(gText);
  sprintf(gText, "                  Second slowest single frame time - %8d", metricsa[12]);
  LogStr(gText);
  sprintf(gText, "                       Slowest single frame number - %8d", metricsa[13]);
  LogStr(gText);
  sprintf(gText, "                Second slowest single frame number - %8d", metricsa[14]);
  LogStr(gText);
  sprintf(gText, "                         Average size of the frame - %8d", metricsa[15]);
  LogStr(gText);
  sprintf(gText, "                Highest amount of memory allocated - %8d", metricsa[16]);
  LogStr(gText);
}
// 524EC0: using guessed type char bSmackNum;

//----- (0045A7A0) --------------------------------------------------------
void __thiscall game::GetMap(game *this)
{
  int v1; // eax@13
  fileRequester *thisa; // [sp+20h] [bp-48h]@7
  char a1; // [sp+44h] [bp-24h]@1
  char a7; // [sp+54h] [bp-14h]@3
  baseManager *a2; // [sp+64h] [bp-4h]@8

  strcpy(&a1, gMapName);
  strcpy(gcCurMapName, byte_5110D4);
  if ( gbRemoteOn && xNetHasOldPlayers )
  {
    NormalDialog(
      "At least one player does not have the Heroes II Expansion set.  You will only be able to choose from original Heroes II games.",
      1,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
    sprintf(&a7, "*.%s", "MP2");
  }
  else if ( xIsExpansionMap )
  {
    sprintf(&a7, "*.%s", "MX2");
  }
  else
  {
    sprintf(&a7, "*.%s", "MP2");
  }
  thisa = (fileRequester *)operator new(1071);
  if ( thisa )
    a2 = (baseManager *)fileRequester::fileRequester(thisa, 212, 9, 1, &a7, ".\\MAPS\\", &a7);
  else
    a2 = 0;
  if ( !a2 )
    MemError();
  if ( executive::DoDialog(gpExec, a2) == 30722 )
  {
    operator delete(a2);
    strcpy(gMapName, gLastFilename);
    LOBYTE(v1) = stricmp(&a1, gMapName);
    if ( v1 )
    {
      strcpy(this->mapFilename, gMapName);
      game::ProcessNewMap(this, 0);
    }
  }
  else
  {
    operator delete(a2);
    strcpy(gMapName, &a1);
  }
}
// 4F7494: using guessed type int gbRemoteOn;
// 51AC64: using guessed type char xNetHasOldPlayers;

//----- (0045A980) --------------------------------------------------------
void __thiscall game::ProcessNewMap(game *this, const void *a2)
{
  int thisa; // [sp+Ch] [bp-4h]@1

  thisa = (int)this;
  this->mapFilename[20] = 0;
  this->mapFilename[21] = iLastMsgNumHumanPlayers;
  if ( this->field_6398 )
  {
    game::CleanUpNewGameWindow(this);
    game::InitNewGame((game *)thisa, a2);
    game::InitNewGameWindow(thisa);
    game::UpdateNewGameWindow(thisa);
    heroWindow::DrawWindow(*(heroWindow **)(thisa + 25496));
  }
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045AA00) --------------------------------------------------------
game *__thiscall game::InitNewGame(game *this, const void *a2)
{
  game *result; // eax@52
  int v4; // [sp+10h] [bp-18h]@1
  int v5; // [sp+14h] [bp-14h]@1
  signed int i; // [sp+1Ch] [bp-Ch]@3
  signed int j; // [sp+1Ch] [bp-Ch]@13
  signed int k; // [sp+1Ch] [bp-Ch]@18
  signed int l; // [sp+1Ch] [bp-Ch]@24
  signed int m; // [sp+1Ch] [bp-Ch]@37
  signed int n; // [sp+1Ch] [bp-Ch]@42
  int v12; // [sp+20h] [bp-8h]@1
  char v13; // [sp+24h] [bp-4h]@35

  v5 = 0;
  v12 = 0;
  v4 = 0;
  if ( this->mapFilename[20] && this->mapFilename[21] == iLastMsgNumHumanPlayers )
  {
    for ( i = 0; this->mapHeader.numPlayers > i; ++i )
    {
      if ( this->somePlayerCodeOr10IfMayBeHuman[i] == 10
        || this->somePlayerCodeOr10IfMayBeHuman[i] >= iLastMsgNumHumanPlayers )
        this->field_459[i] = this->mapHeader.playerFactions[*((_BYTE *)&this->field_44D + i)];
    }
  }
  else
  {
    this->mapFilename[21] = iLastMsgNumHumanPlayers;
    if ( a2 )
      memcpy(&this->mapHeader, a2, sizeof(this->mapHeader));
    else
      GetMapHeader(this->mapFilename, &this->mapHeader);
    for ( j = 0; j < 6; ++j )
    {
      if ( this->mapHeader.hasPlayer[j] )
        *((_BYTE *)&this->field_44D + v5++) = j;
    }
    for ( k = 0; k < 6; ++k )
    {
      if ( this->mapHeader.numPlayers > k )
      {
        this->playerHandicap[k] = 0;
        this->field_459[k] = this->mapHeader.playerFactions[*((_BYTE *)&this->field_44D + k)];
        this->somePlayerCodeOr10IfMayBeHuman[k] = -1;
        this->mapFilename[k + 13] = -1;
      }
      else
      {
        this->mapFilename[k + 13] = -1;
        this->somePlayerCodeOr10IfMayBeHuman[k] = this->mapFilename[k + 13];
        this->field_459[k] = this->somePlayerCodeOr10IfMayBeHuman[k];
        this->playerHandicap[k] = this->field_459[k];
      }
    }
    for ( l = 0; this->mapHeader.numPlayers > l; ++l )
    {
      if ( !this->mapHeader.playerMayBeHuman[*((_BYTE *)&this->field_44D + l)]
        || this->mapHeader.playerMayBeComp[*((_BYTE *)&this->field_44D + l)] )
      {
        if ( !this->mapHeader.playerMayBeHuman[*((_BYTE *)&this->field_44D + l)]
          && this->mapHeader.playerMayBeComp[*((_BYTE *)&this->field_44D + l)] )
        {
          this->somePlayerCodeOr10IfMayBeHuman[l] = 10;
          this->mapFilename[l + 13] = 0;
          ++v4;
        }
      }
      else
      {
        this->mapFilename[l + 13] = 0;
        this->somePlayerCodeOr10IfMayBeHuman[l] = v12++;
      }
    }
    v13 = v12 < iLastMsgNumHumanPlayers && this->mapHeader.numPlayers - iLastMsgNumHumanPlayers > v4;
    for ( m = 0; this->mapHeader.numPlayers > m; ++m )
    {
      if ( this->mapFilename[m + 13] == -1 )
        this->mapFilename[m + 13] = v13;
    }
    for ( n = 0; this->mapHeader.numPlayers > n; ++n )
    {
      if ( this->somePlayerCodeOr10IfMayBeHuman[n] == -1 )
      {
        if ( v12 < iLastMsgNumHumanPlayers && this->mapHeader.playerMayBeHuman[*((_BYTE *)&this->field_44D + n)] )
          this->somePlayerCodeOr10IfMayBeHuman[n] = v12++;
        else
          this->somePlayerCodeOr10IfMayBeHuman[n] = 10;
      }
    }
    this->difficulty = 1;
    this->mapFilename[20] = 1;
  }
  result = this;
  this->mapFilename[19] = -1;
  return result;
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045AEA0) --------------------------------------------------------
int __cdecl game::SetupNetPlayerNames()
{
  int result; // eax@3
  int i; // [sp+10h] [bp-4h]@2

  if ( iLastMsgNumHumanPlayers > 1 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( iLastMsgNumHumanPlayers <= i )
        break;
      if ( iMPBaseType != 2 )
        strcpy(cPlayerNames[i], (char *)&gsNetPlayerInfo + 34 * i + 4);
    }
  }
  return result;
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;

//----- (0045AF30) --------------------------------------------------------
bool __thiscall game::NewGame(game *this)
{
  int v2; // edx@22
  int v3; // eax@49
  int v4; // eax@52
  int v5; // [sp+Ch] [bp-1F0h]@24
  int v6; // [sp+10h] [bp-1ECh]@10
  heroWindow *v8; // [sp+28h] [bp-1D4h]@73
  heroWindow *v9; // [sp+2Ch] [bp-1D0h]@69
  heroWindow *v10; // [sp+30h] [bp-1CCh]@65
  heroWindow *thisa; // [sp+38h] [bp-1C4h]@31
  heroWindow *pickWindow; // [sp+40h] [bp-1BCh]@5
  char v13; // [sp+44h] [bp-1B8h]@59
  int v14; // [sp+B8h] [bp-144h]@59
  char v15; // [sp+BCh] [bp-140h]@61
  int evt; // [sp+1BCh] [bp-40h]@34
  int v17; // [sp+1C0h] [bp-3Ch]@34
  int v18; // [sp+1C4h] [bp-38h]@34
  int v19; // [sp+1D4h] [bp-28h]@34
  int v20; // [sp+1D8h] [bp-24h]@21
  int v21; // [sp+1DCh] [bp-20h]@21
  void *v22; // [sp+1E0h] [bp-1Ch]@22
  heroWindow *window; // [sp+1E4h] [bp-18h]@6
  int v24; // [sp+1E8h] [bp-14h]@54
  int i; // [sp+1ECh] [bp-10h]@17
  bool v26; // [sp+1F0h] [bp-Ch]@1
  char v27; // [sp+1F4h] [bp-8h]@36
  int v28; // [sp+1F8h] [bp-4h]@36

  v26 = 1;
  this->field_6398 = 0;
  if ( (!gbRemoteOn || !giThisNetPos) && (!gbRemoteOn || !xNetHasOldPlayers) )
  {
    pickWindow = (heroWindow *)operator new(68);
    if ( pickWindow )
      window = heroWindow::heroWindow(pickWindow, 405, 8, "x_mapmnu.bin");
    else
      window = 0;
    if ( !window )
      MemError();
    heroWindowManager::DoDialog(gpWindowManager, window, (int (__fastcall *)(tag_message *))ExpStdGameHandler, 0);
    operator delete(window);
    v6 = LOWORD(gpWindowManager->buttonPressedCode);
    switch ( v6 )
    {
      case 1:
        LOBYTE(xIsExpansionMap) = 0;
        break;
      case 2:
        LOBYTE(xIsExpansionMap) = 1;
        break;
      case 30721:
        return 0;
    }
  }
  game::SetupNetPlayerNames();
  glTimers = 0;
  for ( i = 0; i < 3; ++i )
  {
    (&cTextReceivedBuffer)[4 * i] = (char *)BaseAlloc(0x65u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 45);
    strcpy((&cTextReceivedBuffer)[4 * i], byte_5111B0);
  }
  cNGKPCore = (char *)BaseAlloc(0x69u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 48);
  cNGKPDisplay = (char *)BaseAlloc(0x69u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 49);
  strcpy(cNGKPCore, byte_5111F4);
  strcpy(cNGKPDisplay, byte_5111F8);
  NGKPcursorIndex = 0;
  NGKPBkg = resourceManager::GetIcon(gpResourceManager, "ngextra.icn");
  if ( gbWaitForRemoteReceive )
  {
    v20 = 0;
    v21 = 0;
    do
    {
      do
      {
        do
        {
          PollSound();
          v22 = GetRemoteData(1, v2);
        }
        while ( !v22 );
      }
      while ( *((_BYTE *)v22 + 5) != 2 );
      v5 = *((_BYTE *)v22 + 6);
      if ( v5 == 52 )
      {
        memset(&this->mapHeader, 0, 0x1A4u);
        memcpy(&this->mapHeader, (char *)v22 + 9, 0x74u);
        v20 = 1;
      }
      else if ( v5 == 55 )
      {
        memcpy(&gsNetPlayerInfo, (char *)v22 + 9, 0xCCu);
        game::SetupNetPlayerNames();
        v21 = 1;
      }
    }
    while ( !v21 || !v20 );
    thisa = (heroWindow *)operator new(68);
    if ( thisa )
      this->field_6398 = (int)heroWindow::heroWindow(thisa, 190, 4, "ngmp.bin");
    else
      this->field_6398 = 0;
    game::InitNewGame(this, &this->mapHeader);
    game::InitNewGameWindow((int)this);
    game::UpdateNewGameWindow((int)this);
    evt = 512;
    v18 = 54;
    v17 = 5;
    v19 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    v17 = 6;
    v19 = 2;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    v18 = 30722;
    v17 = 5;
    v19 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    v17 = 6;
    v19 = 2;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    v18 = 30721;
    v17 = 5;
    v19 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    v17 = 6;
    v19 = 2;
    heroWindow::BroadcastMessage((heroWindow *)this->field_6398, (tag_message *)&evt);
    gbNewGameDialogOver = 0;
    heroWindowManager::DoDialog(
      gpWindowManager,
      (heroWindow *)this->field_6398,
      (int (__fastcall *)(tag_message *))NewGameHandler,
      0);
    operator delete((void *)this->field_6398);
    v26 = gpWindowManager->buttonPressedCode != 30721;
  }
  else
  {
    while ( 1 )
    {
      v27 = 0;
      v28 = FindLastToken(this->mapFilename, 46);
      if ( v28 )
      {
        if ( StrEqNoCase((int *)v28, (int *)".MX2") && xIsExpansionMap )
          v27 = 1;
        if ( StrEqNoCase((int *)v28, (int *)".MP2") && !xIsExpansionMap )
          v27 = 1;
      }
      if ( !v27 )
      {
        if ( xIsExpansionMap )
          strcpy(gpGame->mapFilename, "arrax.mx2");
        else
          strcpy(gpGame->mapFilename, "brokena.mp2");
        this->mapFilename[20] = 0;
        this->mapFilename[21] = iLastMsgNumHumanPlayers;
      }
      if ( iLastMsgNumHumanPlayers > 3 )
      {
        LOBYTE(v3) = stricmp(gpGame->mapFilename, "brokena.mp2");
        if ( !v3 )
          strcpy(gpGame->mapFilename, "slugfest.mp2");
      }
      if ( iLastMsgNumHumanPlayers > 1 )
      {
        LOBYTE(v4) = stricmp(gpGame->mapFilename, "arrax.mx2");
        if ( !v4 )
          strcpy(gpGame->mapFilename, "fullhse.mx2");
      }
      strcpy(gMapName, this->mapFilename);
      v24 = GetMapHeader(this->mapFilename, &this->mapHeader);
      if ( v24 )
      {
        if ( this->mapHeader.minHumans <= iLastMsgNumHumanPlayers
          && this->mapHeader.maxHumans >= iLastMsgNumHumanPlayers )
          break;
      }
      game::GetMap(gpGame);
    }
    if ( gbRemoteOn )
    {
      memcpy(&v13, &gpGame->mapHeader, 0x74u);
      v14 = TransmitRemoteData(&v13, 127, 0x74u, 52, 1, 1, -1);
      if ( !v14 )
        ShutDown(0);
      memcpy(&v15, &gsNetPlayerInfo, 0xCCu);
      v14 = TransmitRemoteData(&v15, 127, 0xCCu, 55, 1, 1, -1);
      if ( !v14 )
        ShutDown(0);
    }
    game::LoadGame(this, "origdata.bin", 1, 0);
    if ( iLastMsgNumHumanPlayers <= 1 )
    {
      v8 = (heroWindow *)operator new(68);
      if ( v8 )
        this->field_6398 = (int)heroWindow::heroWindow(v8, 190, 33, "ngsp.bin");
      else
        this->field_6398 = 0;
    }
    else if ( iMPBaseType == 2 )
    {
      v10 = (heroWindow *)operator new(68);
      if ( v10 )
        this->field_6398 = (int)heroWindow::heroWindow(v10, 190, 4, "nghs.bin");
      else
        this->field_6398 = 0;
    }
    else
    {
      v9 = (heroWindow *)operator new(68);
      if ( v9 )
        this->field_6398 = (int)heroWindow::heroWindow(v9, 190, 4, "ngmp.bin");
      else
        this->field_6398 = 0;
    }
    if ( !this->field_6398 )
      MemError();
    SetWinText((heroWindow *)this->field_6398, 7);
    game::InitNewGame(this, 0);
    game::InitNewGameWindow((int)this);
    game::UpdateNewGameWindow((int)this);
    gbNewGameShadowHidden = 0;
    gbNewGameDialogOver = 0;
    heroWindowManager::DoDialog(
      gpWindowManager,
      (heroWindow *)this->field_6398,
      (int (__fastcall *)(tag_message *))NewGameHandler,
      0);
    operator delete((void *)this->field_6398);
    if ( gpWindowManager->buttonPressedCode == 30721 )
    {
      v26 = 0;
    }
    else
    {
      this->numPlayers = this->mapHeader.numPlayers;
      game::NewMap(this, gMapName);
    }
  }
  for ( i = 0; i < 3; ++i )
    BaseFree((&cTextReceivedBuffer)[4 * i], (int)"F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 286);
  BaseFree(cNGKPCore, (int)"F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 288);
  BaseFree(cNGKPDisplay, (int)"F:\\h2xsrc\\Source\\Newgame.cpp", word_51117C + 289);
  resourceManager::Dispose(gpResourceManager, (resource *)NGKPBkg);
  return v26;
}
// 4F7494: using guessed type int gbRemoteOn;
// 5110CC: using guessed type int gbNewGameDialogOver;
// 51117C: using guessed type __int16 word_51117C;
// 51AC64: using guessed type char xNetHasOldPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523F08: using guessed type int gbWaitForRemoteReceive;
// 524778: using guessed type int iMPBaseType;
// 524F24: using guessed type int gbNewGameShadowHidden;

//----- (0045BA00) --------------------------------------------------------
void __thiscall game::CleanUpNewGameWindow(void *this)
{
  void *v1; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  v1 = this;
  for ( i = 0; i < 6; ++i )
  {
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 6);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 18);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 12);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 24);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 30);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 36);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 78);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 42);
    heroWindow::RemoveAndDeleteWidget(*((heroWindow **)v1 + 6374), i + 48);
  }
}

//----- (0045BB00) --------------------------------------------------------
int __thiscall game::InitNewGameWindow(int this)
{
  signed int v1; // ST74_4@1
  signed int v2; // ecx@1
  int result; // eax@5
  int v4; // [sp+Ch] [bp-54h]@1
  iconWidget *v5; // [sp+10h] [bp-50h]@58
  textWidget *v6; // [sp+14h] [bp-4Ch]@53
  iconWidget *v7; // [sp+18h] [bp-48h]@42
  textWidget *thisa; // [sp+1Ch] [bp-44h]@34
  iconWidget *v9; // [sp+20h] [bp-40h]@28
  iconWidget *v10; // [sp+24h] [bp-3Ch]@23
  iconWidget *v11; // [sp+28h] [bp-38h]@18
  iconWidget *v12; // [sp+2Ch] [bp-34h]@12
  iconWidget *v13; // [sp+30h] [bp-30h]@7
  char *content; // [sp+34h] [bp-2Ch]@34
  char *contenta; // [sp+34h] [bp-2Ch]@47
  signed __int16 v16; // [sp+38h] [bp-28h]@40
  signed int v17; // [sp+3Ch] [bp-24h]@49
  signed __int16 v18; // [sp+40h] [bp-20h]@1
  int v19; // [sp+44h] [bp-1Ch]@1
  widget *guiObj; // [sp+48h] [bp-18h]@8
  widget *guiObja; // [sp+48h] [bp-18h]@13
  widget *guiObjb; // [sp+48h] [bp-18h]@19
  widget *guiObjc; // [sp+48h] [bp-18h]@24
  widget *guiObjd; // [sp+48h] [bp-18h]@29
  widget *guiObje; // [sp+48h] [bp-18h]@43
  widget *guiObjf; // [sp+48h] [bp-18h]@59
  signed int i; // [sp+50h] [bp-10h]@4
  int v28; // [sp+54h] [bp-Ch]@1
  widget *v29; // [sp+58h] [bp-8h]@35
  widget *v30; // [sp+58h] [bp-8h]@54

  v4 = this;
  v1 = 372 - 62 * *(_BYTE *)(this + 707);
  v2 = *(_BYTE *)(this + 707) + 1;
  v28 = v1 / v2 + 24;
  v19 = v1 / v2 + 62;
  v18 = 0;
  if ( iLastMsgNumHumanPlayers > 1 && iMPBaseType != 2 )
    v18 = -14;
  for ( i = 0; ; ++i )
  {
    result = v4;
    if ( *(_BYTE *)(v4 + 707) <= i )
      break;
    if ( iLastMsgNumHumanPlayers > 1 )
    {
      v13 = (iconWidget *)operator new(45);
      if ( v13 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v13,
                             (_WORD)v28 + i * (_WORD)v19 + 13,
                             v18 + 343,
                             64,
                             28,
                             "ngextra.icn",
                             59,
                             0,
                             i + 42,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObj, -1);
      v12 = (iconWidget *)operator new(45);
      if ( v12 )
        guiObja = (widget *)iconWidget::iconWidget(
                              v12,
                              (_WORD)v28 + i * (_WORD)v19 + 16,
                              v18 + 340,
                              62,
                              26,
                              "ngextra.icn",
                              0,
                              0,
                              i + 48,
                              16,
                              1);
      else
        guiObja = 0;
      if ( !guiObja )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObja, -1);
    }
    v11 = (iconWidget *)operator new(45);
    if ( v11 )
      guiObjb = (widget *)iconWidget::iconWidget(
                            v11,
                            (_WORD)v28 + i * (_WORD)v19 + 11,
                            197,
                            68,
                            iLastMsgNumHumanPlayers <= 1 ? 47 : 64,
                            "ngextra.icn",
                            iLastMsgNumHumanPlayers <= 1 ? 79 : 60,
                            0,
                            i + 6,
                            16,
                            1);
    else
      guiObjb = 0;
    if ( !guiObjb )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObjb, -1);
    v10 = (iconWidget *)operator new(45);
    if ( v10 )
      guiObjc = (widget *)iconWidget::iconWidget(
                            v10,
                            (_WORD)v28 + i * (_WORD)v19 + 13,
                            191,
                            68,
                            iLastMsgNumHumanPlayers <= 1 ? 51 : 64,
                            "ngextra.icn",
                            iLastMsgNumHumanPlayers <= 1 ? 80 : 63,
                            0,
                            i + 18,
                            16,
                            1);
    else
      guiObjc = 0;
    if ( !guiObjc )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObjc, -1);
    v9 = (iconWidget *)operator new(45);
    if ( v9 )
      guiObjd = (widget *)iconWidget::iconWidget(
                            v9,
                            (_WORD)v28 + i * (_WORD)v19 + 16,
                            194,
                            62,
                            58,
                            "ngextra.icn",
                            iLastMsgNumHumanPlayers <= 1 ? 3 : 27,
                            0,
                            i + 12,
                            16,
                            1);
    else
      guiObjd = 0;
    if ( !guiObjd )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObjd, -1);
    if ( iLastMsgNumHumanPlayers > 1 )
    {
      content = (char *)BaseAlloc(2u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_511304 + 80);
      sprintf(content, L" ");
      thisa = (textWidget *)operator new(43);
      if ( thisa )
        v29 = (widget *)textWidget::textWidget(
                          thisa,
                          (_WORD)v28 + i * (_WORD)v19 + 19,
                          240,
                          56,
                          9,
                          content,
                          "smalfont.fnt",
                          1,
                          i + 24,
                          512,
                          1);
      else
        v29 = 0;
      if ( !v29 )
        MemError();
      heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), v29, -1);
    }
    v16 = 0;
    if ( iLastMsgNumHumanPlayers == 1 )
      v16 = -14;
    v7 = (iconWidget *)operator new(45);
    if ( v7 )
      guiObje = (widget *)iconWidget::iconWidget(
                            v7,
                            (_WORD)v28 + i * (_WORD)v19 + 11,
                            v16 + v18 + 277,
                            64,
                            47,
                            "ngextra.icn",
                            61,
                            0,
                            i + 30,
                            16,
                            1);
    else
      guiObje = 0;
    if ( !guiObje )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObje, -1);
    contenta = (char *)BaseAlloc(2u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_511304 + 112);
    sprintf(contenta, L"A");
    if ( (signed int)*(_BYTE *)(v4 + 707) < 5 )
    {
      v17 = 26;
    }
    else if ( (signed int)*(_BYTE *)(v4 + 707) < 6 )
    {
      v17 = 16;
    }
    else
    {
      v17 = 0;
    }
    v6 = (textWidget *)operator new(43);
    if ( v6 )
      v30 = (widget *)textWidget::textWidget(
                        v6,
                        (_WORD)v28 + i * (_WORD)v19 + 15 - v17 / 2,
                        v16 + v18 + 322,
                        v17 + 64,
                        12,
                        contenta,
                        "smalfont.fnt",
                        1,
                        i + 78,
                        512,
                        1);
    else
      v30 = 0;
    if ( !v30 )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), v30, -1);
    v5 = (iconWidget *)operator new(45);
    if ( v5 )
      guiObjf = (widget *)iconWidget::iconWidget(
                            v5,
                            (_WORD)v28 + i * (_WORD)v19 + 16,
                            v16 + v18 + 274,
                            62,
                            45,
                            "ngextra.icn",
                            51,
                            0,
                            i + 36,
                            16,
                            1);
    else
      guiObjf = 0;
    if ( !guiObjf )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v4 + 25496), guiObjf, -1);
  }
  return result;
}
// 511304: using guessed type __int16 word_511304;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;

//----- (0045C180) --------------------------------------------------------
void __thiscall game::UpdateNewGameWindow(int this)
{
  __int16 v1; // ax@41
  int thisa; // [sp+Ch] [bp-2Ch]@1
  int evt; // [sp+10h] [bp-28h]@1
  int v4; // [sp+14h] [bp-24h]@1
  int v5; // [sp+18h] [bp-20h]@1
  int v6; // [sp+28h] [bp-10h]@1
  int i; // [sp+2Ch] [bp-Ch]@1
  bool v8; // [sp+34h] [bp-4h]@21

  thisa = this;
  strcpy(gText, (char *)(this + 739));
  evt = 512;
  v4 = 3;
  v5 = 64;
  v6 = (int)gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
  v4 = 6;
  v6 = 4;
  for ( i = 0; i < 5; ++i )
  {
    v5 = i + 67;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
  }
  v4 = 5;
  v5 = *(_BYTE *)(thisa + 1125) + 67;
  heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
  if ( iLastMsgNumHumanPlayers > 1 )
  {
    for ( i = 0; i < 3; ++i )
    {
      sprintf(gText, (&cTextReceivedBuffer)[4 * i]);
      v4 = 3;
      v5 = i + 74;
      v6 = (int)gText;
      heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    }
  }
  for ( i = 0; *(_BYTE *)(thisa + 707) > i; ++i )
  {
    if ( *(_BYTE *)(i + thisa + 1119) == 10 )
    {
      sprintf(gText, byte_5113C4);
    }
    else if ( strlen(cPlayerNames[*(_BYTE *)(i + thisa + 1119)]) )
    {
      sprintf(gText, cPlayerNames[*(_BYTE *)(i + thisa + 1119)]);
    }
    else
    {
      sprintf(gText, "Player %d", *(_BYTE *)(i + thisa + 1119) + 1);
    }
    v4 = 3;
    v5 = i + 24;
    v6 = (int)gText;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    if ( *(_BYTE *)(thisa + 1145) == i )
      v4 = 5;
    else
      v4 = 6;
    v5 = i + 18;
    v6 = 4;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    v8 = !*(_BYTE *)(i + thisa + 1139) && (iLastMsgNumHumanPlayers <= 1 || *(_BYTE *)(i + thisa + 1119) == 10);
    v4 = 4;
    v5 = i + 12;
    if ( *(_BYTE *)(i + thisa + 1119) == 10 )
      v6 = ((unsigned int)v8 < 1 ? 3 : 15) + *(_BYTE *)(i + thisa + 1101);
    else
      v6 = ((unsigned int)v8 < 1 ? 9 : 21) + *(_BYTE *)(i + thisa + 1101);
    if ( iLastMsgNumHumanPlayers > 1 )
      v6 += 24;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    if ( v8 )
      v4 = 6;
    else
      v4 = 5;
    v6 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    v4 = 4;
    v5 = i + 48;
    if ( *(_BYTE *)(i + thisa + 1119) == 10 )
      v6 = 78;
    else
      v6 = *(_BYTE *)(i + thisa + 1107);
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    if ( *(_BYTE *)(i + thisa + 1119) == 10 )
      v4 = 6;
    else
      v4 = 5;
    v6 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    v8 = *(_BYTE *)(*(_BYTE *)(i + thisa + 1101) + thisa + 719) != 7;
    v4 = 5;
    v6 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    v4 = 4;
    v5 = i + 36;
    v6 = ((unsigned int)v8 < 1 ? 51 : 70) + *(_BYTE *)(i + thisa + 1113);
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    sprintf(gText, gAlignmentNames[*(_BYTE *)(i + thisa + 1113)]);
    v4 = 3;
    v5 = i + 78;
    v6 = (int)gText;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
    if ( v8 )
      v4 = 6;
    else
      v4 = 5;
    v6 = 2;
    heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
  }
  v1 = game::CalcDifficultyRating((game *)thisa);
  gpGame->gameDifficulty = v1;
  v4 = 3;
  v5 = 66;
  sprintf(gText, "%s %d%%", "Rating", gpGame->gameDifficulty);
  v6 = (int)gText;
  heroWindow::BroadcastMessage(*(heroWindow **)(thisa + 25496), (tag_message *)&evt);
  game::DrawNGKPDisplayString(0);
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045C720) --------------------------------------------------------
signed int __fastcall NewGameHandler(void *this, game *a2)
{
  signed int result; // eax@8
  unsigned int v3; // eax@30
  int v4; // [sp+10h] [bp-3B4h]@74
  int v5; // [sp+14h] [bp-3B0h]@73
  int v6; // [sp+1Ch] [bp-3A8h]@1
  char v7; // [sp+20h] [bp-3A4h]@146
  char v8; // [sp+5Ch] [bp-368h]@146
  char v9; // [sp+14Ch] [bp-278h]@136
  int v10; // [sp+1C0h] [bp-204h]@135
  int v11; // [sp+1C4h] [bp-200h]@135
  int v12; // [sp+1C8h] [bp-1FCh]@135
  int v13; // [sp+1D8h] [bp-1ECh]@135
  int v14; // [sp+1DCh] [bp-1E8h]@36
  int v15; // [sp+1E0h] [bp-1E4h]@15
  char a2a; // [sp+1E4h] [bp-1E0h]@12
  int v17; // [sp+388h] [bp-3Ch]@13
  void *v18; // [sp+38Ch] [bp-38h]@4
  int evt; // [sp+390h] [bp-34h]@2
  int v20; // [sp+394h] [bp-30h]@2
  int v21; // [sp+398h] [bp-2Ch]@2
  int v22; // [sp+3A8h] [bp-1Ch]@2
  int v23; // [sp+3ACh] [bp-18h]@1
  int v24; // [sp+3B0h] [bp-14h]@106
  int j; // [sp+3B4h] [bp-10h]@103
  int i; // [sp+3B8h] [bp-Ch]@16
  int v27; // [sp+3BCh] [bp-8h]@30
  int v28; // [sp+3C0h] [bp-4h]@1

  v6 = (int)this;
  v23 = 0;
  v28 = 0;
  if ( !gbNewGameShadowHidden )
  {
    gbNewGameShadowHidden = 1;
    evt = 512;
    v20 = 6;
    v21 = 73;
    v22 = 6;
    heroWindow::BroadcastMessage((heroWindow *)gpGame->field_6398, (tag_message *)&evt);
  }
  if ( !*(_DWORD *)v6 )
  {
    v18 = GetRemoteData(1, (int)a2);
    if ( v18 && (*((_BYTE *)v18 + 5) == 2 || *((_BYTE *)v18 + 5) == 3) )
    {
      switch ( *((_BYTE *)v18 + 6) )
      {
        case 53:
          gpWindowManager->buttonPressedCode = *(_DWORD *)(v6 + 8);
          gpWindowManager->buttonPressedCode = 30722;
          *(_DWORD *)v6 = 512;
          *(_DWORD *)(v6 + 8) = 10;
          *(_DWORD *)(v6 + 4) = *(_DWORD *)(v6 + 8);
          return 2;
        case 54:
          NormalDialog("The host has canceled the game.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          ShutDown(0);
          break;
        case 51:
          if ( !strcmp((int)((char *)v18 + 9), (int)gpGame->mapHeader.name) )
          {
            memcpy(&gpGame->field_44D, (char *)v18 + 69, 0x41u);
            v23 = 1;
          }
          break;
        case 52:
          memset(&a2a, 0, 0x1A4u);
          memcpy(&a2a, (char *)v18 + 9, 0x74u);
          game::ProcessNewMap(gpGame, &a2a);
          break;
        case 11:
          v23 = 1;
          v17 = *(_BYTE *)v18;
          if ( v17 < 0 )
            v15 = 0;
          else
            sprintf(gText, "%s:  %s", (char *)&gsNetPlayerInfo + 34 * v17 + 4, (char *)v18 + 9);
          gText[100] = 0;
          for ( i = 0; i < 2; ++i )
            strcpy((&cTextReceivedBuffer)[4 * i], (&dword_524F2C)[4 * i]);
          strcpy(dword_524F30, gText);
          break;
        default:
          break;
      }
    }
    if ( KBTickCount() > glTimers )
    {
      game::NGKPSetupDisplayString(cNGKPCore, NGKPcursorIndex);
      game::DrawNGKPDisplayString(1);
    }
  }
  if ( *(_DWORD *)v6 == 1 )
  {
    if ( iLastMsgNumHumanPlayers > 1 )
    {
      if ( iMPBaseType != 2 )
      {
        if ( game::ProcessNGKeyPress(v6) )
        {
          v23 = 1;
          for ( i = 0; i < 2; ++i )
            strcpy((&cTextReceivedBuffer)[4 * i], (&dword_524F2C)[4 * i]);
          strcpy(dword_524F30, cNGKPCore);
          strcpy(cNGKPCore, byte_51140C);
          strcpy(cNGKPDisplay, byte_511410);
          NGKPcursorIndex = 0;
          v3 = strlen(dword_524F30);
          v27 = TransmitRemoteData(dword_524F30, 127, v3 + 1, 11, 1, 1, -1);
          if ( !v27 )
            ShutDown(0);
        }
      }
    }
  }
  if ( *(_DWORD *)v6 != 512 )
    goto LABEL_142;
  if ( *(_BYTE *)(v6 + 13) & 2 )
  {
    if ( *(_DWORD *)(v6 + 4) == 12 || *(_DWORD *)(v6 + 4) == 14 )
    {
      v14 = -1;
      if ( *(_DWORD *)(v6 + 8) >= 1 && *(_DWORD *)(v6 + 8) <= 5
        || *(_DWORD *)(v6 + 8) >= 67 && *(_DWORD *)(v6 + 8) <= 71 )
        v14 = 0;
      if ( *(_DWORD *)(v6 + 8) >= 48 && *(_DWORD *)(v6 + 8) <= 53
        || *(_DWORD *)(v6 + 8) >= 42 && *(_DWORD *)(v6 + 8) <= 47 )
        v14 = 1;
      if ( *(_DWORD *)(v6 + 8) >= 12 && *(_DWORD *)(v6 + 8) <= 17
        || *(_DWORD *)(v6 + 8) >= 6 && *(_DWORD *)(v6 + 8) <= 11
        || *(_DWORD *)(v6 + 8) >= 18 && *(_DWORD *)(v6 + 8) <= 24
        || *(_DWORD *)(v6 + 8) >= 24 && *(_DWORD *)(v6 + 8) <= 30 )
        v14 = 2;
      if ( *(_DWORD *)(v6 + 8) >= 36 && *(_DWORD *)(v6 + 8) <= 41
        || *(_DWORD *)(v6 + 8) >= 30 && *(_DWORD *)(v6 + 8) <= 35 )
        v14 = 3;
      if ( *(_DWORD *)(v6 + 8) == 54 || *(_DWORD *)(v6 + 8) == 72 || *(_DWORD *)(v6 + 8) == 64 )
        v14 = 4;
      if ( *(_DWORD *)(v6 + 8) == 66 )
        v14 = 5;
      if ( *(_DWORD *)(v6 + 8) == 30722 )
        v14 = 6;
      if ( *(_DWORD *)(v6 + 8) == 30721 )
        v14 = 7;
      if ( v14 != -1 )
        NormalDialog((&gNewGameHelp)[4 * v14], 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    goto LABEL_142;
  }
  v5 = *(_DWORD *)(v6 + 4);
  if ( v5 == 12 )
  {
    switch ( *(_DWORD *)(v6 + 8) )
    {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        i = *(_DWORD *)(v6 + 8) - 1;
        goto LABEL_88;
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
        i = *(_DWORD *)(v6 + 8) - 67;
LABEL_88:
        gpGame->difficulty = i;
        v28 = 1;
        v23 = 1;
        goto LABEL_142;
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
        i = *(_DWORD *)(v6 + 8) - 48;
        goto LABEL_91;
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2D:
      case 0x2E:
      case 0x2F:
        i = *(_DWORD *)(v6 + 8) - 42;
LABEL_91:
        v28 = 1;
        v23 = 1;
        if ( gpGame->somePlayerCodeOr10IfMayBeHuman[i] != 10 )
          gpGame->playerHandicap[i] = (gpGame->playerHandicap[i] + 1) % 3;
        goto LABEL_142;
      case 6:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
        i = *(_DWORD *)(v6 + 8) - 6;
        goto LABEL_98;
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
        i = *(_DWORD *)(v6 + 8) - 12;
        goto LABEL_98;
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
        i = *(_DWORD *)(v6 + 8) - 18;
        goto LABEL_98;
      case 0x18:
      case 0x19:
      case 0x1A:
      case 0x1B:
      case 0x1C:
      case 0x1D:
        i = *(_DWORD *)(v6 + 8) - 24;
LABEL_98:
        v28 = 1;
        v23 = 1;
        if ( gpGame->mapFilename[i + 13]
          || iLastMsgNumHumanPlayers > 1 && gpGame->somePlayerCodeOr10IfMayBeHuman[i] != 10 )
        {
          if ( iLastMsgNumHumanPlayers == 1 )
          {
            if ( gpGame->somePlayerCodeOr10IfMayBeHuman[i] == 10 )
            {
              for ( j = 0; gpGame->mapHeader.numPlayers > j; ++j )
              {
                if ( gpGame->somePlayerCodeOr10IfMayBeHuman[j] != 10 )
                {
                  v24 = gpGame->somePlayerCodeOr10IfMayBeHuman[j];
                  gpGame->somePlayerCodeOr10IfMayBeHuman[j] = gpGame->somePlayerCodeOr10IfMayBeHuman[i];
                  gpGame->somePlayerCodeOr10IfMayBeHuman[i] = v24;
                  j = 999;
                }
              }
            }
          }
          else if ( gpGame->mapFilename[19] == -1 )
          {
            gpGame->mapFilename[19] = i;
          }
          else if ( gpGame->mapFilename[19] != i
  && (gpGame->somePlayerCodeOr10IfMayBeHuman[i] != 10
   || gpGame->somePlayerCodeOr10IfMayBeHuman[gpGame->mapFilename[19]] != 10) )
          {
            if ( gpGame->mapFilename[i + 13] && gpGame->mapFilename[gpGame->mapFilename[19] + 13]
              || gpGame->somePlayerCodeOr10IfMayBeHuman[i] != 10
              && gpGame->somePlayerCodeOr10IfMayBeHuman[gpGame->mapFilename[19]] != 10 )
            {
              j = gpGame->somePlayerCodeOr10IfMayBeHuman[i];
              gpGame->somePlayerCodeOr10IfMayBeHuman[i] = gpGame->somePlayerCodeOr10IfMayBeHuman[gpGame->mapFilename[19]];
              gpGame->somePlayerCodeOr10IfMayBeHuman[gpGame->mapFilename[19]] = j;
            }
            else
            {
              NormalDialog("The two positions selected can not be swapped.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
            }
            gpGame->mapFilename[19] = -1;
          }
          else
          {
            gpGame->mapFilename[19] = -1;
          }
        }
        goto LABEL_142;
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
        i = *(_DWORD *)(v6 + 8) - 36;
        goto LABEL_125;
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
        i = *(_DWORD *)(v6 + 8) - 30;
LABEL_125:
        if ( gpGame->mapHeader.playerFactions[*((_BYTE *)&gpGame->field_44D + i)] == 7 )
        {
          if ( gpGame->field_459[i] == 7 )
          {
            gpGame->field_459[i] = 0;
          }
          else if ( gpGame->field_459[i] == 5 )
          {
            gpGame->field_459[i] = 7;
          }
          else
          {
            ++gpGame->field_459[i];
          }
          v28 = 1;
          v23 = 1;
        }
        break;
      case 0x40:
      case 0x48:
        goto LABEL_133;
      default:
        goto LABEL_142;
    }
    goto LABEL_142;
  }
  if ( v5 != 13 )
  {
LABEL_142:
    if ( v23 )
    {
      game::UpdateNewGameWindow((int)gpGame);
      heroWindow::DrawWindow((heroWindow *)gpGame->field_6398);
    }
    if ( v28 && gbRemoteOn )
    {
      memcpy(&v7, gpGame->mapHeader.name, 0x3Cu);
      memcpy(&v8, &gpGame->field_44D, 0x41u);
      v27 = TransmitRemoteData(&v7, 127, 0x7Du, 51, 1, 1, -1);
      if ( !v27 )
        ShutDown(0);
    }
    return 1;
  }
  v4 = *(_DWORD *)(v6 + 8);
  if ( v4 == 54 )
  {
LABEL_133:
    if ( !gbRemoteOn || !giThisNetPos )
    {
      v10 = 512;
      v11 = 6;
      v12 = 30721;
      v13 = 2;
      heroWindow::BroadcastMessage((heroWindow *)gpGame->field_6398, (tag_message *)&v10);
      game::GetMap(gpGame);
      v10 = 512;
      v11 = 5;
      v12 = 30721;
      v13 = 2;
      heroWindow::BroadcastMessage((heroWindow *)gpGame->field_6398, (tag_message *)&v10);
      if ( gbRemoteOn )
      {
        memcpy(&v9, &gpGame->mapHeader, 0x74u);
        v27 = TransmitRemoteData(&v9, 127, 0x74u, 52, 1, 1, -1);
      }
    }
    goto LABEL_142;
  }
  if ( v4 == 30721 )
  {
    if ( gbRemoteOn )
    {
      v27 = TransmitRemoteData(0, 127, 0, 54, 1, 1, -1);
      ShutDown(0);
    }
    gpWindowManager->buttonPressedCode = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(v6 + 8) = 10;
    *(_DWORD *)(v6 + 4) = *(_DWORD *)(v6 + 8);
    gbNewGameDialogOver = 1;
    result = 2;
  }
  else
  {
    if ( v4 != 30722 )
      goto LABEL_142;
    if ( gbRemoteOn )
      v27 = TransmitRemoteData(0, 127, 0, 53, 1, 1, -1);
    gpWindowManager->buttonPressedCode = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(v6 + 8) = 10;
    *(_DWORD *)(v6 + 4) = *(_DWORD *)(v6 + 8);
    gbNewGameDialogOver = 1;
    result = 2;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 5110CC: using guessed type int gbNewGameDialogOver;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;
// 524F24: using guessed type int gbNewGameShadowHidden;

//----- (0045D660) --------------------------------------------------------
signed int __stdcall game::ProcessNGKeyPress(int a1)
{
  signed int result; // eax@3
  char a2; // [sp+20h] [bp-70h]@24
  char v3; // [sp+8Ch] [bp-4h]@24
  int evt; // [sp+98h] [bp+8h]@24

  if ( iLastMsgNumHumanPlayers != 1 && iMPBaseType != 2 )
  {
    switch ( *(_DWORD *)(a1 + 4) )
    {
      case 1:
        if ( gbAllowTextEntryEscape )
          strcpy(cNGKPCore, byte_511444);
        goto LABEL_46;
      case 0x53:
        if ( strlen(cNGKPCore) > NGKPcursorIndex )
        {
          strcpy(gText, &cNGKPCore[NGKPcursorIndex + 1]);
          strcpy(&cNGKPCore[NGKPcursorIndex], gText);
        }
        goto LABEL_46;
      case 0x4B:
        if ( NGKPcursorIndex > 0 )
          --NGKPcursorIndex;
        goto LABEL_46;
      case 0x4D:
        if ( strlen(cNGKPCore) > NGKPcursorIndex )
          ++NGKPcursorIndex;
        goto LABEL_46;
      default:
        inputManager::AsciiConvert(gpInputManager, (tag_message *)a1);
        if ( *(_DWORD *)(a1 + 4) == 10 )
        {
          result = 1;
        }
        else
        {
          if ( *(_DWORD *)(a1 + 4) == 127 )
          {
            if ( NGKPcursorIndex > 0 )
            {
              strcpy(gText, &cNGKPCore[NGKPcursorIndex]);
              strcpy(&cNGKPCore[NGKPcursorIndex-- - 1], gText);
            }
          }
          else if ( strlen(cNGKPCore) + 1 < 0x64 && *(_DWORD *)(a1 + 4) )
          {
            strcpy(&a2, cNGKPCore);
            v3 = 0;
            if ( *(_DWORD *)(evt + 4) < 256 )
            {
              v3 = *(_BYTE *)(a1 + 4);
              if ( v3 == 123 || v3 == 125 )
                v3 = 0;
            }
            else
            {
              switch ( *(_BYTE *)(a1 + 5) )
              {
                case 0x52:
                  v3 = 48;
                  break;
                case 0x4F:
                  v3 = 49;
                  break;
                case 0x50:
                  v3 = 50;
                  break;
                case 0x51:
                  v3 = 51;
                  break;
                case 0x4B:
                  v3 = 52;
                  break;
                case 0x4C:
                  v3 = 53;
                  break;
                case 0x4D:
                  v3 = 54;
                  break;
                case 0x47:
                  v3 = 55;
                  break;
                case 0x48:
                  v3 = 56;
                  break;
                case 0x49:
                  v3 = 57;
                  break;
                default:
                  break;
              }
            }
            if ( v3 )
            {
              strcpy(gText, cNGKPCore);
              gText[NGKPcursorIndex] = v3;
              gText[NGKPcursorIndex + 1] = 0;
              strcat(gText, &cNGKPCore[NGKPcursorIndex]);
              strcpy(cNGKPCore, gText);
              ++NGKPcursorIndex;
              game::NGKPSetupDisplayString(cNGKPCore, NGKPcursorIndex);
              if ( font::LineLength(smallFont, cNGKPDisplay, 348) > 1 )
              {
                strcpy(cNGKPCore, &a2);
                --NGKPcursorIndex;
              }
            }
          }
LABEL_46:
          game::DrawNGKPDisplayString(1);
          result = 0;
        }
        break;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F199C: using guessed type int gbAllowTextEntryEscape;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;

//----- (0045DA80) --------------------------------------------------------
void __stdcall game::NGKPSetupDisplayString(const char *a1, unsigned __int16 a2)
{
  if ( iLastMsgNumHumanPlayers != 1 && iMPBaseType != 2 )
  {
    if ( KBTickCount() > glTimers )
    {
      NGKPcursorFlashOn = 1 - NGKPcursorFlashOn;
      glTimers = KBTickCount() + 360;
    }
    if ( (signed int)a2 > 0 )
      strncpy(cNGKPDisplay, a1, a2);
    if ( NGKPcursorFlashOn )
      cNGKPDisplay[a2] = 31;
    else
      cNGKPDisplay[a2] = 95;
    if ( strlen((char *)a1) <= a2 )
      cNGKPDisplay[a2 + 1] = 0;
    else
      strcpy(&cNGKPDisplay[a2 + 1], (char *)&a1[a2]);
  }
}
// 5110D0: using guessed type int NGKPcursorFlashOn;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;

//----- (0045DBA0) --------------------------------------------------------
void __stdcall game::DrawNGKPDisplayString(int a1)
{
  if ( !gbNewGameDialogOver && iLastMsgNumHumanPlayers != 1 && iMPBaseType != 2 )
  {
    icon::DrawToBuffer(NGKPBkg, 244, 406, 81, 0);
    font::DrawBoundedString(smallFont, cNGKPDisplay, 244, 406, 348, 12, 2, 0);
    if ( a1 )
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 244, 406, 0x15Cu, 12);
  }
}
// 5110CC: using guessed type int gbNewGameDialogOver;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524778: using guessed type int iMPBaseType;

//----- (0045DC50) --------------------------------------------------------
BOOL __thiscall game::ShowScenInfo(void *this)
{
  signed int v1; // eax@6
  void *v3; // [sp+Ch] [bp-84h]@1
  iconWidget *v4; // [sp+18h] [bp-78h]@59
  textWidget *v5; // [sp+1Ch] [bp-74h]@54
  iconWidget *v6; // [sp+20h] [bp-70h]@43
  textWidget *v7; // [sp+24h] [bp-6Ch]@37
  iconWidget *v8; // [sp+28h] [bp-68h]@31
  iconWidget *v9; // [sp+2Ch] [bp-64h]@26
  iconWidget *v10; // [sp+30h] [bp-60h]@20
  iconWidget *thisa; // [sp+34h] [bp-5Ch]@15
  heroWindow *v12; // [sp+38h] [bp-58h]@1
  char *content; // [sp+3Ch] [bp-54h]@37
  char *contenta; // [sp+3Ch] [bp-54h]@48
  signed int v15; // [sp+44h] [bp-4Ch]@50
  int evt; // [sp+48h] [bp-48h]@6
  int v17; // [sp+4Ch] [bp-44h]@6
  int v18; // [sp+50h] [bp-40h]@6
  char *v19; // [sp+60h] [bp-30h]@6
  int v20; // [sp+64h] [bp-2Ch]@12
  int v21; // [sp+68h] [bp-28h]@12
  widget *guiObj; // [sp+6Ch] [bp-24h]@12
  int v23; // [sp+70h] [bp-20h]@12
  int i; // [sp+74h] [bp-1Ch]@12
  int v25; // [sp+78h] [bp-18h]@6
  int v26; // [sp+7Ch] [bp-14h]@12
  textWidget *v27; // [sp+80h] [bp-10h]@12
  int v28; // [sp+84h] [bp-Ch]@12
  bool v29; // [sp+88h] [bp-8h]@78
  heroWindow *a2; // [sp+8Ch] [bp-4h]@2

  v3 = this;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  v12 = (heroWindow *)operator new(68);
  if ( v12 )
    a2 = heroWindow::heroWindow(v12, 90, 4, "sceninfo.bin");
  else
    a2 = 0;
  if ( !a2 )
    MemError();
  SetWinText(a2, 23);
  evt = 512;
  v17 = 3;
  v18 = 64;
  v19 = (char *)v3 + 739;
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  v18 = 200;
  v19 = cDifficulty[*((_BYTE *)v3 + 685)];
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  v18 = 201;
  v19 = cDifficulty[*((_BYTE *)v3 + 1125)];
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  v1 = game::CalcDifficultyRating((game *)v3);
  sprintf(gText, "%d", v1);
  strcat(gText, L"%");
  v18 = 202;
  v19 = gText;
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  v25 = 0;
  switch ( *((_BYTE *)v3 + 687) )
  {
    case 0x48:
      v25 = 1;
      break;
    case 0x6C:
      v25 = 2;
      break;
    case 0x90:
      v25 = 3;
      break;
  }
  v18 = 203;
  v19 = cMapSize[v25];
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  v18 = 204;
  v19 = (char *)v3 + 799;
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  game::GetVictoryConditionText((game *)v3, gText);
  v18 = 205;
  v19 = gText;
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  game::GetLossConditionText((game *)v3, gText);
  v18 = 206;
  v19 = gText;
  heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  guiObj = 0;
  v27 = 0;
  v23 = 372 - 62 * *((_BYTE *)v3 + 707);
  v28 = v23 / (*((_BYTE *)v3 + 707) + 1);
  v26 = v28 + 24;
  v21 = v28 + 62;
  v20 = 0;
  for ( i = 0; *((_BYTE *)v3 + 707) > i; ++i )
  {
    if ( iLastMsgNumHumanPlayers > 1 )
    {
      thisa = (iconWidget *)operator new(45);
      if ( thisa )
        guiObj = (widget *)iconWidget::iconWidget(
                             thisa,
                             (_WORD)v26 + i * (_WORD)v21 + 13,
                             v20 + 309,
                             64,
                             28,
                             "ngextra.icn",
                             59,
                             0,
                             i + 42,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(a2, guiObj, -1);
      v10 = (iconWidget *)operator new(45);
      if ( v10 )
        guiObj = (widget *)iconWidget::iconWidget(
                             v10,
                             (_WORD)v26 + i * (_WORD)v21 + 16,
                             v20 + 306,
                             62,
                             26,
                             "ngextra.icn",
                             0,
                             0,
                             i + 48,
                             16,
                             1);
      else
        guiObj = 0;
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(a2, guiObj, -1);
    }
    v9 = (iconWidget *)operator new(45);
    if ( v9 )
      guiObj = (widget *)iconWidget::iconWidget(
                           v9,
                           (_WORD)v26 + i * (_WORD)v21 + 11,
                           163,
                           68,
                           iLastMsgNumHumanPlayers <= 1 ? 47 : 64,
                           "ngextra.icn",
                           iLastMsgNumHumanPlayers <= 1 ? 79 : 60,
                           0,
                           i + 6,
                           16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(a2, guiObj, -1);
    v8 = (iconWidget *)operator new(45);
    if ( v8 )
      guiObj = (widget *)iconWidget::iconWidget(
                           v8,
                           (_WORD)v26 + i * (_WORD)v21 + 16,
                           160,
                           62,
                           58,
                           "ngextra.icn",
                           iLastMsgNumHumanPlayers <= 1 ? 3 : 27,
                           0,
                           i + 12,
                           16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(a2, guiObj, -1);
    if ( iLastMsgNumHumanPlayers > 1 )
    {
      content = (char *)BaseAlloc(2u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_511448 + 114);
      sprintf(content, L" ");
      v7 = (textWidget *)operator new(43);
      if ( v7 )
        v27 = textWidget::textWidget(
                v7,
                (_WORD)v26 + i * (_WORD)v21 + 19,
                206,
                56,
                9,
                content,
                "smalfont.fnt",
                1,
                i + 24,
                512,
                1);
      else
        v27 = 0;
      if ( !v27 )
        MemError();
      heroWindow::AddWidget(a2, (widget *)v27, -1);
    }
    v6 = (iconWidget *)operator new(45);
    if ( v6 )
      guiObj = (widget *)iconWidget::iconWidget(
                           v6,
                           (_WORD)v26 + i * (_WORD)v21 + 11,
                           v20 + 243,
                           64,
                           47,
                           "ngextra.icn",
                           61,
                           0,
                           i + 30,
                           16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(a2, guiObj, -1);
    contenta = (char *)BaseAlloc(2u, "F:\\h2xsrc\\Source\\Newgame.cpp", word_511448 + 146);
    sprintf(contenta, L"A");
    if ( (signed int)*((_BYTE *)v3 + 707) < 5 )
    {
      v15 = 26;
    }
    else if ( (signed int)*((_BYTE *)v3 + 707) < 6 )
    {
      v15 = 16;
    }
    else
    {
      v15 = 0;
    }
    v5 = (textWidget *)operator new(43);
    if ( v5 )
      v27 = textWidget::textWidget(
              v5,
              (_WORD)v26 + i * (_WORD)v21 + 15 - v15 / 2,
              v20 + 288,
              v15 + 64,
              12,
              contenta,
              "smalfont.fnt",
              1,
              i + 78,
              512,
              1);
    else
      v27 = 0;
    if ( !v27 )
      MemError();
    heroWindow::AddWidget(a2, (widget *)v27, -1);
    v4 = (iconWidget *)operator new(45);
    if ( v4 )
      guiObj = (widget *)iconWidget::iconWidget(
                           v4,
                           (_WORD)v26 + i * (_WORD)v21 + 16,
                           v20 + 240,
                           62,
                           45,
                           "ngextra.icn",
                           51,
                           0,
                           i + 36,
                           16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(a2, guiObj, -1);
  }
  for ( i = 0; *((_BYTE *)v3 + 707) > i; ++i )
  {
    if ( *((_BYTE *)v3 + i + 1119) == 10 )
    {
      sprintf(gText, byte_511520);
    }
    else if ( strlen(cPlayerNames[*((_BYTE *)v3 + i + 1119)]) )
    {
      sprintf(gText, cPlayerNames[*((_BYTE *)v3 + i + 1119)]);
    }
    else
    {
      sprintf(gText, "Player %d", *((_BYTE *)v3 + i + 1119) + 1);
    }
    v17 = 3;
    v18 = i + 24;
    v19 = gText;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    if ( *((_BYTE *)v3 + 1145) == i )
      v17 = 5;
    else
      v17 = 6;
    v18 = i + 18;
    v19 = (char *)4;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    v29 = !*((_BYTE *)v3 + i + 1139) && (iLastMsgNumHumanPlayers <= 1 || *((_BYTE *)v3 + i + 1119) == 10);
    v17 = 4;
    v18 = i + 12;
    if ( *((_BYTE *)v3 + i + 1119) == 10 )
      v19 = (char *)(((unsigned int)v29 < 1 ? 3 : 15) + *((_BYTE *)v3 + i + 1101));
    else
      v19 = (char *)(((unsigned int)v29 < 1 ? 9 : 21) + *((_BYTE *)v3 + i + 1101));
    if ( iLastMsgNumHumanPlayers > 1 )
      v19 += 24;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    if ( v29 )
      v17 = 6;
    else
      v17 = 5;
    v19 = (char *)2;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    v17 = 4;
    v18 = i + 48;
    if ( *((_BYTE *)v3 + i + 1119) == 10 )
      v19 = (char *)78;
    else
      v19 = (char *)*((_BYTE *)v3 + i + 1107);
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    if ( *((_BYTE *)v3 + i + 1119) == 10 )
      v17 = 6;
    else
      v17 = 5;
    v19 = (char *)2;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    v17 = 4;
    v18 = i + 36;
    v19 = (char *)(((unsigned int)v29 < 1 ? 51 : 70) + *((_BYTE *)v3 + i + 1113));
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
    sprintf(gText, gAlignmentNames[*((_BYTE *)v3 + i + 1113)]);
    v17 = 3;
    v18 = i + 78;
    v19 = gText;
    heroWindow::BroadcastMessage(a2, (tag_message *)&evt);
  }
  heroWindowManager::DoDialog(gpWindowManager, a2, EventWindowHandler, 0);
  return operator delete(a2);
}
// 4F6918: using guessed type char *cMapSize[9];
// 4F6928: using guessed type char *cDifficulty[5];
// 511448: using guessed type __int16 word_511448;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045E7D0) --------------------------------------------------------
char *__thiscall game::GetLossConditionText(game *this, char *a2)
{
  char *result; // eax@2
  signed int v3; // ST28_4@3
  int v4; // [sp+Ch] [bp-20h]@2

  if ( this->mapHeader.field_22 )
  {
    result = (char *)this;
    v4 = this->mapHeader.field_22;
    switch ( v4 )
    {
      case 1:
        v3 = game::GetTownId(this, *(_WORD *)&this->mapHeader.field_23, LOWORD(this->mapHeader.field_2E));
        result = (char *)sprintf(
                           a2,
                           "Lose the %s '%s'.",
                           &aCastle[("town" - "castle") & (((this->castles[v3].buildingsBuiltFlags & 0x40) != 0) - 1)],
                           this->castles[v3].name);
        break;
      case 2:
        result = (char *)sprintf(a2, "Lose the hero '%s'.", this->heroes[*(_WORD *)&this->mapHeader.field_23].name);
        break;
      case 3:
        result = (char *)sprintf(
                           a2,
                           "Fail to win by the end of month %d, week %d, day %d.",
                           (*(_WORD *)&gpGame->mapHeader.field_23 - 1) / 28 + 1,
                           (*(_WORD *)&gpGame->mapHeader.field_23
                          - 28 * ((*(_WORD *)&gpGame->mapHeader.field_23 - 1) / 28)
                          - 1)
                         / 7
                         + 1,
                           (*(_WORD *)&gpGame->mapHeader.field_23 - 1) % 7 + 1);
        break;
    }
  }
  else
  {
    result = (char *)sprintf(a2, "Lose all your heroes, towns and castles.");
  }
  return result;
}

//----- (0045E9A0) --------------------------------------------------------
void __thiscall game::GetVictoryConditionText(game *thisa, char *buf)
{
  signed int townId; // ST24_4@3
  char side2Desc[100]; // [sp+1Ch] [bp-D4h]@10
  char side1Desc[100]; // [sp+80h] [bp-70h]@10
  town *twn; // [sp+E4h] [bp-Ch]@3
  bool v7; // [sp+E8h] [bp-8h]@10

  if ( thisa->mapHeader.winConditionType )
  {
    switch ( thisa->mapHeader.winConditionType )
    {
      case WIN_CONDITION_CAPTURE_CASTLE:
        townId = game::GetTownId(thisa, thisa->mapHeader.winConditionArgument, thisa->mapHeader.field_2C);
        twn = &thisa->castles[townId];
        sprintf(
          buf,
          "Capture the %s '%s'",
          &aCastle_0[("town" - "castle") & (((thisa->castles[townId].buildingsBuiltFlags & 0x40) != 0) - 1)],
          thisa->castles[townId].name);
        break;
      case WIN_CONDITION_DEFEAT_HERO:
        sprintf(buf, "Defeat the hero '%s'", thisa->heroes[thisa->mapHeader.winConditionArgument].name);
        break;
      case WIN_CONDITION_FIND_ARTIFACT:
        if ( thisa->mapHeader.winConditionArgument )
          sprintf(buf, "Find the %s", dword_4F55F4[thisa->mapHeader.winConditionArgument]);
        else
          sprintf(buf, "Find the ultimate artifact");
        break;
      case WIN_CONDITION_ACCUMULATE_GOLD:
        sprintf(buf, "Accumulate %d gold", 1000 * thisa->mapHeader.winConditionArgument);
        break;
      case WIN_CONDITION_DEFEAT_COLOR:
        v7 = game::GetSideDesc(thisa, side1Desc, 0, thisa->mapHeader.winConditionArgument - 1);
        game::GetSideDesc(thisa, side2Desc, thisa->mapHeader.winConditionArgument, thisa->mapHeader.numPlayers - 1);
        if ( v7 )
          sprintf(buf, "%s must defeat %s", side1Desc, side2Desc);
        else
          sprintf(buf, "%s must defeat %s", side2Desc, side1Desc);
        break;
      default:
        break;
    }
    if ( thisa->mapHeader.winConditionType != WIN_CONDITION_DEFEAT_COLOR && thisa->mapHeader.allowDefeatAllVictory )
      strcat(buf, ", or you may win by defeating all enemy heroes and capturing all enemy towns and castles.");
    else
      strcat(buf, L".");
  }
  else
  {
    strcpy(buf, "Defeat all enemy heroes and capture all enemy towns and castles.");
  }
}

//----- (0045ECA0) --------------------------------------------------------
bool __thiscall game::GetSideDesc(game *this, char *a1, int sideStart, int sideEnd)
{
  char a2a; // [sp+14h] [bp-7Ch]@18
  int numOnSide; // [sp+78h] [bp-18h]@10
  int i; // [sp+7Ch] [bp-14h]@1
  bool containsMe; // [sp+80h] [bp-10h]@8
  int v10; // [sp+84h] [bp-Ch]@10
  int myPlayerNum; // [sp+88h] [bp-8h]@1
  int v12; // [sp+8Ch] [bp-4h]@15

  myPlayerNum = -1;
  for ( i = 0; this->mapHeader.numPlayers > i; ++i )
  {
    if ( this->somePlayerCodeOr10IfMayBeHuman[i] == giThisGamePos )
      myPlayerNum = i;
  }
  containsMe = myPlayerNum >= sideStart && myPlayerNum <= sideEnd;
  numOnSide = sideEnd - sideStart + 1;
  v10 = sideEnd - sideStart + 1 - ((unsigned int)containsMe >= 1);
  if ( containsMe )
  {
    if ( v10 )
    {
      if ( v10 <= 1 )
        sprintf(a1, "You and your ally ");
      else
        sprintf(a1, "You and your allies ");
      v12 = 0;
      for ( i = sideStart; i <= sideEnd; ++i )
      {
        if ( myPlayerNum != i )
        {
          ++v12;
          sprintf(&a2a, (&gColors)[4 * *((_BYTE *)&this->field_44D + i)]);
          a2a -= 32;
          strcat(a1, &a2a);
          if ( v10 - 1 <= v12 )
          {
            if ( v10 > v12 )
              strcat(a1, " and ");
          }
          else
          {
            strcat(a1, ", ");
          }
        }
      }
    }
    else
    {
      sprintf(a1, "You");
    }
  }
  else
  {
    if ( numOnSide <= 1 )
      strcpy(a1, "the enemy - ");
    else
      strcpy(a1, "the enemy alliance of ");
    v12 = 0;
    for ( i = sideStart; i <= sideEnd; ++i )
    {
      ++v12;
      sprintf(&a2a, (&gColors)[4 * *((_BYTE *)&this->field_44D + i)]);
      a2a -= 32;
      strcat(a1, &a2a);
      if ( v10 - 1 <= v12 )
      {
        if ( v10 > v12 )
          strcat(a1, " and ");
      }
      else
      {
        strcat(a1, ", ");
      }
    }
  }
  return containsMe;
}
// 524730: using guessed type int giThisGamePos;

//----- (0045EF50) --------------------------------------------------------
__int16 __cdecl wsnet_init()
{
  int v0; // eax@4
  int v1; // eax@6
  int v2; // eax@8
  int v3; // eax@10
  int v4; // eax@12
  char *v5; // eax@13
  int v6; // ST1C_4@15
  char *v7; // eax@15
  char *v8; // eax@16
  int v9; // ST1C_4@21
  int v10; // ST18_4@21
  char *v11; // eax@21
  int v12; // ST1C_4@23
  char *v13; // eax@23
  char v15; // [sp+Ch] [bp-128h]@24
  char v16; // [sp+Dh] [bp-127h]@26
  char v17; // [sp+Eh] [bp-126h]@24
  char name; // [sp+28h] [bp-10Ch]@11
  struct hostent *v19; // [sp+128h] [bp-Ch]@13
  int i; // [sp+12Ch] [bp-8h]@24
  u_long argp; // [sp+130h] [bp-4h]@9

  if ( *(&bMenu + 7 * giCurExe + 5) )
  {
    sprintf(
      gText,
      "About to initiate TCP/IP connection.  Heroes II will now drop from full screen mode to windowed mode, so that any Windows 95 generated dialog boxes can be seen.\n\nWhen the connection is successfully made, you can return to full screen mode by pressing 'F4'.");
    NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
    SetFullScreenStatus(0);
  }
  gbRemoteOn = 1;
  ppDPRcvBuffer = BaseAlloc(0x320u, "F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511798 + 10);
  piDPRcvBufferSize = BaseAlloc(0x320u, "F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511798 + 11);
  memset(ppDPRcvBuffer, 0, 0x320u);
  memset(piDPRcvBufferSize, 0, 0x320u);
  wVer = 257;
  iRc = thunk_WSAStartup(0x101u, &wsadata);
  if ( iRc )
  {
    v0 = thunk_WSAGetLastError();
    sprintf(cWSTextBuffer, "Error During WSAStartup(): %d", v0);
    ShutDown(cWSTextBuffer);
  }
  sd_dg = thunk_socket(2, 2, 0);
  if ( sd_dg == -1 )
  {
    v1 = thunk_WSAGetLastError();
    sprintf(cWSTextBuffer, "Error During socket(): %d", v1);
    ShutDown(cWSTextBuffer);
  }
  gbRemoteOn = 1;
  saddr_loc.sa_family = 2;
  word_5250E2 = thunk_htons(0x7D0u);
  dword_5250E4 = thunk_htonl(0);
  iRc = thunk_bind(sd_dg, &saddr_loc, 16);
  if ( iRc == -1 )
  {
    v2 = thunk_WSAGetLastError();
    sprintf(cWSTextBuffer, "Error During bind(): %d", v2);
    ShutDown(cWSTextBuffer);
  }
  argp = 1;
  iRc = thunk_ioctlsocket(sd_dg, -2147195266, &argp);
  if ( iRc == -1 )
  {
    v3 = thunk_WSAGetLastError();
    sprintf(cWSTextBuffer, "Error During ioctlsocket(): %d", v3);
    ShutDown(cWSTextBuffer);
  }
  iRc = thunk_gethostname(&name, 255);
  if ( iRc == -1 )
  {
    v4 = thunk_WSAGetLastError();
    sprintf(cWSTextBuffer, "Error During gethostname(): %d", v4);
    ShutDown(cWSTextBuffer);
  }
  v19 = thunk_gethostbyname(&name);
  gIn_addrIP = (struct in_addr)**(_DWORD **)v19->h_addr_list;
  v5 = thunk_inet_ntoa(gIn_addrIP);
  sprintf(cWSTextBuffer, "%s", v5);
  *((_DWORD *)&giNetPosToDCOPos + giThisNetPos) = thunk_inet_addr(cWSTextBuffer);
  if ( (unsigned __int8)GameMode == 1 )
  {
    giWaitType = 11;
    if ( giTCPHostStatus == -1 )
    {
      v8 = thunk_inet_ntoa(gIn_addrIP);
      sprintf(cWSTextBuffer, "Hosting game at %s\n\nWaiting On Guest(s).\n\n  Press 'CANCEL' to abort.", v8);
      NormalDialog(cWSTextBuffer, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    else
    {
      v6 = giTCPNumPlayers - 1;
      v7 = thunk_inet_ntoa(gIn_addrIP);
      sprintf(
        cWSTextBuffer,
        "Hosting game at %s.\n\nYou have %d guest(s) out of an expected total of %d guest(s) now logged in.  Click 'CANCEL' to move on without waiting for additional guests.",
        v7,
        0,
        v6);
      NormalDialog(cWSTextBuffer, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    if ( !gbFunctionComplete )
      ShutDown(0);
    iWSLastMsgNumHumanPlayers = iLastMsgNumHumanPlayers;
    giWaitType = 12;
    if ( giTCPHostStatus == -1 )
    {
      v12 = iLastMsgNumHumanPlayers - 1;
      v13 = thunk_inet_ntoa(gIn_addrIP);
      sprintf(
        cWSTextBuffer,
        "Hosting game at %s.\n\nYou have %d guest(s) now logged in.  Click 'OK' to move on, or wait for additional guests.",
        v13,
        v12);
      NormalDialog(cWSTextBuffer, 5, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    else if ( giTCPNumPlayers > 2 )
    {
      v9 = giTCPNumPlayers - 1;
      v10 = iLastMsgNumHumanPlayers - 1;
      v11 = thunk_inet_ntoa(gIn_addrIP);
      sprintf(
        cWSTextBuffer,
        "Hosting game at %s.\n\nYou have %d guest(s) out of an expected total of %d guest(s) now logged in.  Click 'CANCEL' to move on without waiting for additional guests.",
        v11,
        v10,
        v9);
      NormalDialog(cWSTextBuffer, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    gbRemoteGameOpen = 0;
    v15 = iLastMsgNumHumanPlayers;
    memcpy(&v17, &giNetPosToDCOPos, 0x18u);
    for ( i = 1; iLastMsgNumHumanPlayers > i; ++i )
    {
      v16 = i;
      wsSendMessage(*((_DWORD *)&giNetPosToDCOPos + i), 3, 0x1Au, &v15);
    }
  }
  else
  {
    while ( 1 )
    {
      if ( giTCPHostStatus != -1 && strlen(gcTCPAddress) )
      {
        strcpy(cWSTextBuffer, gcTCPAddress);
        strcpy(gcTCPAddress, byte_511B78);
      }
      else
      {
        GetDataEntry("Enter the host IP address.\n(i.e. 220.415.119.223)", (int)cWSTextBuffer, 20, 0, 0, 1);
      }
      *(_DWORD *)&giNetPosToDCOPos = thunk_inet_addr(cWSTextBuffer);
      if ( *(_DWORD *)&giNetPosToDCOPos != -1 )
        break;
      NormalDialog("Error in IP Address, please try again.", 5, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    giWaitType = 13;
    sprintf(cWSTextBuffer, "Searching for host.");
    NormalDialog(cWSTextBuffer, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( !gbFunctionComplete )
      ShutDown(0);
  }
  return 0;
}
// 4F2E88: using guessed type int giCurExe;
// 4F7494: using guessed type int gbRemoteOn;
// 511788: using guessed type int iWSLastMsgNumHumanPlayers;
// 511798: using guessed type __int16 word_511798;
// 51257C: using guessed type char GameMode;
// 523018: using guessed type int gbFunctionComplete;
// 52340C: using guessed type int giTCPHostStatus;
// 523410: using guessed type int giTCPNumPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524750: using guessed type int giWaitType;
// 524A6C: using guessed type int gbRemoteGameOpen;
// 524F40: using guessed type int iRc;
// 5250E2: using guessed type __int16 word_5250E2;
// 5250E4: using guessed type int dword_5250E4;

//----- (0045F510) --------------------------------------------------------
void __cdecl wsnet_term()
{
  if ( sd_dg != -1 )
    thunk_closesocket(sd_dg);
  if ( ppDPRcvBuffer )
    BaseFree(ppDPRcvBuffer, (int)"F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511BEC + 7);
  ppDPRcvBuffer = 0;
  if ( piDPRcvBufferSize )
    BaseFree(piDPRcvBufferSize, (int)"F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511BEC + 11);
  piDPRcvBufferSize = 0;
  thunk_WSACleanup();
  bHostFound = 0;
  sd_dg = -1;
  iWSLastMsgNumHumanPlayers = 1;
  iWSAttempts = 0;
  iWSNextTickCount = 0;
  iWSWaitForHostStatus = 0;
  _cfltcvt_init();
}
// 511780: using guessed type int bHostFound;
// 511788: using guessed type int iWSLastMsgNumHumanPlayers;
// 51178C: using guessed type int iWSAttempts;
// 511790: using guessed type int iWSNextTickCount;
// 511794: using guessed type int iWSWaitForHostStatus;
// 511BEC: using guessed type __int16 word_511BEC;

//----- (0045F5F0) --------------------------------------------------------
void __fastcall wsSendMessage(int a1, char a2, unsigned __int16 a3, const void *a4)
{
  char v4; // ST2C_1@1
  int v5; // eax@13
  int v6; // [sp+10h] [bp-24h]@1
  struct sockaddr to; // [sp+1Ch] [bp-18h]@3
  int i; // [sp+2Ch] [bp-8h]@4
  char *buf; // [sp+30h] [bp-4h]@1

  v4 = a2;
  v6 = a1;
  buf = (char *)BaseAlloc(a3 + 1, "F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511C30 + 2);
  *buf = v4;
  if ( a3 )
    memcpy(buf + 1, a4, a3);
  to.sa_family = 2;
  *(_WORD *)&to.sa_data[0] = thunk_htons(0x7D0u);
  if ( v6 )
  {
    *(_DWORD *)&to.sa_data[2] = v6;
    iRc = thunk_sendto(sd_dg, buf, a3 + 1, 0, &to, 16);
    if ( iRc == -1 )
    {
      v5 = thunk_WSAGetLastError();
      sprintf(cWSTextBuffer, "Error During sendto(): %d", v5);
      NormalDialog(cWSTextBuffer, 5, -1, -1, -1, 0, -1, 0, -1, 0);
      return;
    }
  }
  else
  {
    for ( i = 0; i < iLastMsgNumHumanPlayers; ++i )
    {
      if ( i != giThisNetPos )
      {
        while ( 1 )
        {
          *(_DWORD *)&to.sa_data[2] = *((_DWORD *)&giNetPosToDCOPos + i);
          iRc = thunk_sendto(sd_dg, buf, a3 + 1, 0, &to, 16);
          if ( iRc != -1 )
            break;
          thunk_WSAGetLastError();
          DelayMilli(300);
        }
      }
    }
  }
  BaseFree(buf, (int)"F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511C30 + 57);
}
// 511C30: using guessed type __int16 word_511C30;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524F40: using guessed type int iRc;

//----- (0045F7F0) --------------------------------------------------------
int __fastcall wsnet_snd(int a1, unsigned __int16 a2, const void *a3)
{
  unsigned __int16 v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+10h] [bp-8h]@1

  v4 = a2;
  v5 = a1;
  wsProcessMessages();
  if ( v5 == 127 )
    wsSendMessage(0, 1, v4, a3);
  else
    wsSendMessage(*((_DWORD *)&giNetPosToDCOPos + v5), 1, v4, a3);
  return 0;
}

//----- (0045F860) --------------------------------------------------------
__int16 __stdcall wsnet_rcv(void *a1)
{
  __int16 result; // ax@2
  int v2; // ST20_4@3

  wsProcessMessages();
  if ( iDPRcvBufferTail == iDPRcvBufferHead )
  {
    result = 0;
  }
  else
  {
    v2 = *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferTail);
    memcpy(a1, *((const void **)ppDPRcvBuffer + iDPRcvBufferTail), *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferTail));
    BaseFree(*((void **)ppDPRcvBuffer + iDPRcvBufferTail), (int)"F:\\h2xsrc\\Source\\Wsnetwin.cpp", word_511CBC + 9);
    iDPRcvBufferTail = (iDPRcvBufferTail + 1) % 200;
    result = v2;
  }
  return result;
}
// 4ED2E0: using guessed type int iDPRcvBufferHead;
// 4ED2E4: using guessed type int iDPRcvBufferTail;
// 511CBC: using guessed type __int16 word_511CBC;

//----- (0045F910) --------------------------------------------------------
int __cdecl wsProcessMessages()
{
  int result; // eax@2
  int fromlen; // [sp+Ch] [bp-18h]@1
  struct sockaddr from; // [sp+10h] [bp-14h]@2
  int len; // [sp+20h] [bp-4h]@2

  fromlen = 16;
  while ( 1 )
  {
    len = 256;
    result = thunk_recvfrom(sd_dg, rcvBufIn, 256, 0, &from, &fromlen);
    iRc = result;
    if ( result == -1 )
    {
      result = thunk_WSAGetLastError();
      iRc = result;
      if ( result == 10035 )
        break;
    }
    if ( !iRc )
      break;
    if ( *(_DWORD *)&from.sa_data[2] != *((_DWORD *)&giNetPosToDCOPos + giThisNetPos) )
      wsEvaluateMessage(iRc, *(int *)&from.sa_data[2]);
  }
  return result;
}
// 524F40: using guessed type int iRc;

//----- (0045F9C0) --------------------------------------------------------
void __fastcall wsEvaluateMessage(int a1, int a2)
{
  int v2; // [sp+14h] [bp-28h]@1
  int evt; // [sp+18h] [bp-24h]@18
  int v4; // [sp+1Ch] [bp-20h]@18
  int v5; // [sp+20h] [bp-1Ch]@18
  int v6; // [sp+30h] [bp-Ch]@18
  char *v7; // [sp+34h] [bp-8h]@1
  int i; // [sp+38h] [bp-4h]@5

  v2 = a1;
  v7 = &rcvBufIn[1];
  switch ( rcvBufIn[0] )
  {
    case 1:
      *((_DWORD *)ppDPRcvBuffer + iDPRcvBufferHead) = BaseAlloc(
                                                        a1 - 1,
                                                        "F:\\h2xsrc\\Source\\Wsnetwin.cpp",
                                                        word_511CE0 + 10);
      memcpy(*((void **)ppDPRcvBuffer + iDPRcvBufferHead), &rcvBufIn[1], v2 - 1);
      *((_DWORD *)piDPRcvBufferSize + iDPRcvBufferHead) = v2;
      iDPRcvBufferHead = (iDPRcvBufferHead + 1) % 200;
      break;
    case 2:
      if ( (unsigned __int8)GameMode == 1 )
      {
        if ( gbRemoteGameOpen )
        {
          for ( i = 1; i < iLastMsgNumHumanPlayers; ++i )
          {
            if ( *((_DWORD *)&giNetPosToDCOPos + i) == a2 || (char *)&gsNetPlayerInfo + 34 * i == v7 )
            {
              wsSendMessage(*((_DWORD *)&giNetPosToDCOPos + i), 4, 0, 0);
              return;
            }
          }
          *((_DWORD *)&giNetPosToDCOPos + iLastMsgNumHumanPlayers) = a2;
          LogInt((int)"Got HereIAm from ", a2, -999, -999, -999, -999, -999, -999);
          memcpy((char *)&gsNetPlayerInfo + 34 * iLastMsgNumHumanPlayers, v7, 0x22u);
          if ( !byte_526CFC[34 * iLastMsgNumHumanPlayers] )
            xNetHasOldPlayers = 1;
          wsSendMessage(*((_DWORD *)&giNetPosToDCOPos + iLastMsgNumHumanPlayers++), 4, 0, 0);
        }
        else
        {
          wsSendMessage(a2, 5, 0, 0);
        }
      }
      break;
    case 3:
      iLastMsgNumHumanPlayers = *v7;
      giThisNetPos = v7[1];
      LogInt((int)"WSMSGSTARTUP", giThisNetPos, a2, -999, -999, -999, -999, -999);
      memcpy(&giNetPosToDCOPos, v7 + 2, 0x18u);
      bStartUpInfoReceived = 1;
      break;
    case 5:
      sprintf(cWSTextBuffer, "The Host already has a game in progress and is not accepting new players.");
      NormalDialog(cWSTextBuffer, 1, -1, -1, -1, 0, -1, 0, -1, 0);
      ShutDown(0);
      break;
    case 4:
      sprintf(cWSTextBuffer, "Waiting for other remote player to set up game.");
      evt = 512;
      v4 = 3;
      v5 = 1;
      v6 = (int)cWSTextBuffer;
      heroWindow::BroadcastMessage(pNormalDialogWindow, (tag_message *)&evt);
      heroWindow::DrawWindow(pNormalDialogWindow);
      bHostFound = 1;
      break;
    default:
      sprintf(cWSTextBuffer, "Unknown message: %d\n", rcvBufIn[0]);
      if ( giDebugLevel > 0 )
      {
        sprintf(gText, cWSTextBuffer);
        NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
      }
      LogStr(cWSTextBuffer);
      break;
  }
}
// 4ED2E0: using guessed type int iDPRcvBufferHead;
// 4ED2F0: using guessed type int bStartUpInfoReceived;
// 4F21F0: using guessed type int giDebugLevel;
// 511780: using guessed type int bHostFound;
// 511CE0: using guessed type __int16 word_511CE0;
// 51257C: using guessed type char GameMode;
// 51AC64: using guessed type char xNetHasOldPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524A6C: using guessed type int gbRemoteGameOpen;

//----- (0045FD40) --------------------------------------------------------
bool __cdecl wsWaitForFirstGuest()
{
  wsProcessMessages();
  return iLastMsgNumHumanPlayers > 1;
}
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045FD70) --------------------------------------------------------
signed int __cdecl wsWaitForExtraGuests()
{
  int v1; // ST0C_4@5
  char *v2; // eax@5
  int evt; // [sp+Ch] [bp-1Ch]@5
  int v4; // [sp+10h] [bp-18h]@5
  int v5; // [sp+14h] [bp-14h]@5
  int v6; // [sp+24h] [bp-4h]@5

  wsProcessMessages();
  if ( iLastMsgNumHumanPlayers != iWSLastMsgNumHumanPlayers )
  {
    if ( giTCPHostStatus != -1 && giTCPNumPlayers <= iLastMsgNumHumanPlayers )
      return 1;
    iWSLastMsgNumHumanPlayers = iLastMsgNumHumanPlayers;
    v1 = iLastMsgNumHumanPlayers - 1;
    v2 = thunk_inet_ntoa(gIn_addrIP);
    sprintf(
      cWSTextBuffer,
      "Hosting game at %s.\n\nYou have %d guest(s) now logged in.  Click 'OK' to move on, or wait for additional guests.",
      v2,
      v1);
    evt = 512;
    v4 = 3;
    v5 = 1;
    v6 = (int)cWSTextBuffer;
    heroWindow::BroadcastMessage(pNormalDialogWindow, (tag_message *)&evt);
    heroWindow::DrawWindow(pNormalDialogWindow);
  }
  return 0;
}
// 511788: using guessed type int iWSLastMsgNumHumanPlayers;
// 52340C: using guessed type int giTCPHostStatus;
// 523410: using guessed type int giTCPNumPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (0045FE30) --------------------------------------------------------
signed int __cdecl wsWaitForHost()
{
  if ( iWSWaitForHostStatus )
  {
    if ( iWSWaitForHostStatus == 1 )
    {
      wsProcessMessages();
      if ( bStartUpInfoReceived )
        return 1;
    }
  }
  else
  {
    if ( KBTickCount() < iWSNextTickCount )
      return 0;
    wsProcessMessages();
    if ( bHostFound )
    {
      ++iWSWaitForHostStatus;
      return 0;
    }
    wsSendMessage(0, 2, 0x22u, &gsThisNetPlayerInfo);
    iWSNextTickCount = KBTickCount() + 3000;
    ++iWSAttempts;
    if ( iWSAttempts > 15 )
    {
      sprintf(cWSTextBuffer, "The Host is not responding.  Keep waiting?");
      NormalDialog(cWSTextBuffer, 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode != 30725 )
        ShutDown(0);
      iWSAttempts = 0;
    }
  }
  return 0;
}
// 4ED2F0: using guessed type int bStartUpInfoReceived;
// 511780: using guessed type int bHostFound;
// 51178C: using guessed type int iWSAttempts;
// 511790: using guessed type int iWSNextTickCount;
// 511794: using guessed type int iWSWaitForHostStatus;

//----- (0045FF60) --------------------------------------------------------
void __thiscall game::SetupDynamicStuff(void *this, int a2, int a3, int a4)
{
  float v4; // STF8_4@4
  int v5; // ST24_4@31
  unsigned int v6; // eax@31
  __int16 v7; // ax@71
  __int16 v8; // ax@83
  __int16 v9; // ax@141
  __int16 v10; // ax@146
  char v11; // al@152
  char v12; // al@191
  void *v13; // [sp+18h] [bp-DCh]@1
  signed int v14; // [sp+1Ch] [bp-D8h]@81
  int v15; // [sp+20h] [bp-D4h]@69
  unsigned __int8 v16; // [sp+24h] [bp-D0h]@61
  iconWidget *v17; // [sp+28h] [bp-CCh]@204
  iconWidget *v18; // [sp+2Ch] [bp-C8h]@199
  textWidget *v19; // [sp+30h] [bp-C4h]@191
  iconWidget *v20; // [sp+34h] [bp-C0h]@186
  iconWidget *v21; // [sp+38h] [bp-BCh]@181
  textWidget *v22; // [sp+3Ch] [bp-B8h]@173
  iconWidget *v23; // [sp+40h] [bp-B4h]@168
  iconWidget *v24; // [sp+44h] [bp-B0h]@158
  textWidget *v25; // [sp+48h] [bp-ACh]@152
  iconWidget *v26; // [sp+4Ch] [bp-A8h]@145
  iconWidget *v27; // [sp+50h] [bp-A4h]@140
  iconWidget *v28; // [sp+54h] [bp-A0h]@135
  iconWidget *v29; // [sp+58h] [bp-9Ch]@130
  textWidget *v30; // [sp+5Ch] [bp-98h]@124
  iconWidget *v31; // [sp+60h] [bp-94h]@119
  textWidget *v32; // [sp+64h] [bp-90h]@97
  iconWidget *v33; // [sp+68h] [bp-8Ch]@92
  iconWidget *v34; // [sp+6Ch] [bp-88h]@79
  iconWidget *v35; // [sp+70h] [bp-84h]@67
  iconWidget *v36; // [sp+74h] [bp-80h]@59
  iconWidget *v37; // [sp+78h] [bp-7Ch]@54
  iconWidget *v38; // [sp+7Ch] [bp-78h]@42
  iconWidget *v39; // [sp+80h] [bp-74h]@36
  textWidget *v40; // [sp+84h] [bp-70h]@31
  iconWidget *v41; // [sp+88h] [bp-6Ch]@25
  int v42; // [sp+90h] [bp-64h]@17
  int v43; // [sp+98h] [bp-5Ch]@13
  signed int v44; // [sp+9Ch] [bp-58h]@180
  int thisa; // [sp+A0h] [bp-54h]@130
  int v46; // [sp+A4h] [bp-50h]@181
  int v47; // [sp+A4h] [bp-50h]@199
  __int16 v48; // [sp+A8h] [bp-4Ch]@164
  __int16 v49; // [sp+ACh] [bp-48h]@181
  int v50; // [sp+ACh] [bp-48h]@199
  signed int v51; // [sp+B0h] [bp-44h]@196
  signed int v52; // [sp+B4h] [bp-40h]@77
  __int16 imgIdx; // [sp+B8h] [bp-3Ch]@34
  int v54; // [sp+BCh] [bp-38h]@31
  int v55; // [sp+C0h] [bp-34h]@48
  signed int v56; // [sp+C4h] [bp-30h]@48
  __int16 v57; // [sp+C8h] [bp-2Ch]@88
  __int16 v58; // [sp+C8h] [bp-2Ch]@102
  signed int v59; // [sp+CCh] [bp-28h]@105
  char *content; // [sp+DCh] [bp-18h]@31
  char *contenta; // [sp+DCh] [bp-18h]@97
  char *contentb; // [sp+DCh] [bp-18h]@124
  char *contentc; // [sp+DCh] [bp-18h]@152
  char *contentd; // [sp+DCh] [bp-18h]@173
  char *contente; // [sp+DCh] [bp-18h]@191
  signed int i; // [sp+E0h] [bp-14h]@8
  signed int j; // [sp+E0h] [bp-14h]@22
  int v68; // [sp+E4h] [bp-10h]@41
  int v69; // [sp+E4h] [bp-10h]@59
  int v70; // [sp+E4h] [bp-10h]@67
  int v71; // [sp+E4h] [bp-10h]@75
  int v72; // [sp+E4h] [bp-10h]@150
  int v73; // [sp+E4h] [bp-10h]@186
  int v74; // [sp+E4h] [bp-10h]@204
  signed int skill; // [sp+E8h] [bp-Ch]@10
  signed int skilla; // [sp+E8h] [bp-Ch]@88
  signed int skillb; // [sp+E8h] [bp-Ch]@102
  PRIMARY_SKILL skillc; // [sp+E8h] [bp-Ch]@150
  signed int skilld; // [sp+E8h] [bp-Ch]@156
  signed int skille; // [sp+E8h] [bp-Ch]@164
  int skillf; // [sp+E8h] [bp-Ch]@178
  signed int skillg; // [sp+E8h] [bp-Ch]@196
  int v83; // [sp+ECh] [bp-8h]@24
  signed int v84; // [sp+ECh] [bp-8h]@34
  int v85; // [sp+F0h] [bp-4h]@24

  v13 = this;
  if ( a3 )
  {
    if ( giOverviewItems[giOverviewType] > 4 )
    {
      v4 = 303.0 / (double)(giOverviewItems[giOverviewType] - 4);
      OVScrollKnob->offsetY = (signed __int64)((double)giOverviewTop[giOverviewType] * v4 + 18.0 + 0.4);
    }
    else
    {
      OVScrollKnob->offsetY = 169;
    }
  }
  if ( a4 || giOverviewType != iLastDynamicType || giOverviewTop[iLastDynamicType] != iLastDynamicTop )
  {
    for ( i = 0; i < 4; ++i )
    {
      for ( skill = 0; skill < 70; ++skill )
      {
        if ( *((_DWORD *)textWidgetDynamic + 70 * i + skill) )
        {
          heroWindow::RemoveWidget(overWin, *((widget **)textWidgetDynamic + 70 * i + skill));
          v43 = *((_DWORD *)textWidgetDynamic + 70 * i + skill);
          if ( v43 )
            (*(void (__thiscall **)(int))(*(_DWORD *)v43 + 4))(v43);
          *((_DWORD *)textWidgetDynamic + 70 * i + skill) = 0;
        }
        if ( *((_DWORD *)iconWidgetDynamic + 70 * i + skill) )
        {
          heroWindow::RemoveWidget(overWin, *((widget **)iconWidgetDynamic + 70 * i + skill));
          v42 = *((_DWORD *)iconWidgetDynamic + 70 * i + skill);
          if ( v42 )
            (*(void (__thiscall **)(int))(*(_DWORD *)v42 + 4))(v42);
          *((_DWORD *)iconWidgetDynamic + 70 * i + skill) = 0;
        }
      }
    }
    for ( j = 0; j < 4; ++j )
    {
      v83 = 0;
      v85 = 200 * j + 200;
      if ( j + giOverviewTop[giOverviewType] >= giOverviewItems[giOverviewType] )
        break;
      v41 = (iconWidget *)operator new(45);
      if ( v41 )
        *((_DWORD *)iconWidgetDynamic + 70 * j) = iconWidget::iconWidget(
                                                    v41,
                                                    30,
                                                    86 * j + 17,
                                                    594,
                                                    82,
                                                    "overview.icn",
                                                    giOverviewType + 10,
                                                    0,
                                                    200 * j + 202,
                                                    16,
                                                    1);
      else
        *((_DWORD *)iconWidgetDynamic + 70 * j) = 0;
      if ( !*((_DWORD *)iconWidgetDynamic + 70 * j) )
        MemError();
      heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j), -1);
      if ( giOverviewType == 1 )
      {
        v54 = (int)((char *)v13 + 100 * *(&gpCurPlayer->castlesOwned[j] + giOverviewTop[giOverviewType]) + 2899);
        v5 = word_511E74 + 79;
        v6 = strlen((char *)v13 + 100 * *(&gpCurPlayer->castlesOwned[j] + giOverviewTop[giOverviewType]) + 2986);
        content = (char *)BaseAlloc(v6 + 1, "F:\\h2xsrc\\Source\\Overview.cpp", v5);
        strcpy(content, (char *)(v54 + 87));
        v40 = (textWidget *)operator new(43);
        if ( v40 )
          *((_DWORD *)textWidgetDynamic + 70 * j) = textWidget::textWidget(
                                                      v40,
                                                      35,
                                                      86 * j + 80,
                                                      132,
                                                      10,
                                                      content,
                                                      "smalfont.fnt",
                                                      1,
                                                      200 * j + 203,
                                                      512,
                                                      1);
        else
          *((_DWORD *)textWidgetDynamic + 70 * j) = 0;
        heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j), -1);
        v84 = 1;
        imgIdx = *(_BYTE *)(v54 + 3);
        if ( !(*(_BYTE *)(v54 + 24) & 0x40) )
          imgIdx += 6;
        v39 = (iconWidget *)operator new(45);
        if ( v39 )
          *((_DWORD *)iconWidgetDynamic + 70 * j + 1) = iconWidget::iconWidget(
                                                          v39,
                                                          47,
                                                          86 * j + 36,
                                                          46,
                                                          22,
                                                          "minitown.icn",
                                                          imgIdx,
                                                          0,
                                                          200 * j + 204,
                                                          16,
                                                          1);
        else
          *((_DWORD *)iconWidgetDynamic + 70 * j + 1) = 0;
        if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 1) )
          MemError();
        heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 1), -1);
        v68 = 2;
        if ( BitTest(gpGame->field_27BB, *(_BYTE *)v54) )
        {
          v38 = (iconWidget *)operator new(45);
          if ( v38 )
            *((_DWORD *)iconWidgetDynamic + 70 * j + 2) = iconWidget::iconWidget(
                                                            v38,
                                                            42,
                                                            86 * j + 31,
                                                            0,
                                                            0,
                                                            "locators.icn",
                                                            24,
                                                            0,
                                                            200 * j + 244,
                                                            16,
                                                            1);
          else
            *((_DWORD *)iconWidgetDynamic + 70 * j + 2) = 0;
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 2) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 2), -1);
          v68 = 3;
        }
        v56 = 0;
        v55 = 0;
        if ( *(_BYTE *)(v54 + 23) == -1 )
        {
          if ( *(_BYTE *)(v54 + 25) & 0x80 )
            v56 = 1;
        }
        else
        {
          v55 = (int)((char *)v13 + 250 * *(_BYTE *)(v54 + 23) + 10180);
        }
        if ( v55 || v56 )
        {
          v37 = (iconWidget *)operator new(45);
          if ( v37 )
            *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = iconWidget::iconWidget(
                                                              v37,
                                                              112,
                                                              86 * j + 36,
                                                              46,
                                                              22,
                                                              "portxtra.icn",
                                                              0,
                                                              0,
                                                              200 * j + 239,
                                                              16,
                                                              1);
          else
            *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = 0;
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v68) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v68), -1);
          v69 = v68 + 1;
          v36 = (iconWidget *)operator new(45);
          if ( v36 )
          {
            if ( v56 )
              v16 = *(_BYTE *)(v54 + 3);
            else
              v16 = *(_BYTE *)(v55 + 24);
            *((_DWORD *)iconWidgetDynamic + 70 * j + v69) = iconWidget::iconWidget(
                                                              v36,
                                                              107,
                                                              86 * j + 31,
                                                              51,
                                                              27,
                                                              &aMinicapt_icn[("miniport.icn" - "minicapt.icn") & ((v56 != 0) - 1)],
                                                              v16,
                                                              0,
                                                              200 * j + 240,
                                                              16,
                                                              1);
          }
          else
          {
            *((_DWORD *)iconWidgetDynamic + 70 * j + v69) = 0;
          }
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v69) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v69), -1);
          v70 = v69 + 1;
          v35 = (iconWidget *)operator new(45);
          if ( v35 )
          {
            if ( v56 )
              v15 = 0;
            else
              v15 = *(_DWORD *)(v55 + 53);
            v7 = GetMobilityFrame(v15);
            *((_DWORD *)iconWidgetDynamic + 70 * j + v70) = iconWidget::iconWidget(
                                                              v35,
                                                              112,
                                                              86 * j + 36,
                                                              0,
                                                              0,
                                                              "mobility.icn",
                                                              v7,
                                                              0,
                                                              200 * j + 243,
                                                              16,
                                                              1);
          }
          else
          {
            *((_DWORD *)iconWidgetDynamic + 70 * j + v70) = 0;
          }
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v70) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v70), -1);
          v71 = v70 + 1;
          if ( *(_BYTE *)(v54 + 3) != 1 && *(_BYTE *)(v54 + 3) )
            v52 = 20;
          else
            v52 = 10;
          v34 = (iconWidget *)operator new(45);
          if ( v34 )
          {
            if ( v56 )
              v14 = v52;
            else
              v14 = *(_WORD *)v55;
            v8 = GetManaFrame(v14);
            *((_DWORD *)iconWidgetDynamic + 70 * j + v71) = iconWidget::iconWidget(
                                                              v34,
                                                              151,
                                                              86 * j + 36,
                                                              0,
                                                              0,
                                                              "mana.icn",
                                                              v8,
                                                              0,
                                                              200 * j + 241,
                                                              16,
                                                              1);
          }
          else
          {
            *((_DWORD *)iconWidgetDynamic + 70 * j + v71) = 0;
          }
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v71) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v71), -1);
          v68 = v71 + 1;
        }
        v57 = 0;
        for ( skilla = 0; skilla < 5; ++skilla )
        {
          if ( *(_BYTE *)(skilla + v54 + 8) != -1 && (signed int)*(_WORD *)(v54 + 2 * skilla + 13) > 0 )
          {
            v33 = (iconWidget *)operator new(45);
            if ( v33 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = iconWidget::iconWidget(
                                                                v33,
                                                                41 * v57 + 173,
                                                                86 * j + 35,
                                                                42,
                                                                40,
                                                                "mons32.icn",
                                                                *(_BYTE *)(skilla + v54 + 8),
                                                                0,
                                                                skilla + (_WORD)v85 + 5,
                                                                17,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v68) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v68++), -1);
            contenta = (char *)BaseAlloc(6u, "F:\\h2xsrc\\Source\\Overview.cpp", word_511E74 + 238);
            sprintf(contenta, "%d", *(_WORD *)(v54 + 2 * skilla + 13));
            v32 = (textWidget *)operator new(43);
            if ( v32 )
              *((_DWORD *)textWidgetDynamic + 70 * j + v84) = textWidget::textWidget(
                                                                v32,
                                                                41 * v57 + 173,
                                                                86 * j + 81,
                                                                40,
                                                                12,
                                                                contenta,
                                                                "smalfont.fnt",
                                                                1,
                                                                skilla + (_WORD)v85 + 10,
                                                                512,
                                                                1);
            else
              *((_DWORD *)textWidgetDynamic + 70 * j + v84) = 0;
            heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j + v84++), -1);
            ++v57;
          }
        }
        v58 = 0;
        for ( skillb = 0; skillb < 12; ++skillb )
        {
          switch ( skillb )
          {
            case 0:
              v59 = 0;
              break;
            case 1:
              v59 = 1;
              break;
            case 2:
              v59 = 6;
              break;
            case 3:
              v59 = 2;
              break;
            case 4:
              v59 = 7;
              break;
            case 5:
              v59 = 3;
              break;
            case 6:
              v59 = 8;
              break;
            case 7:
              v59 = 4;
              break;
            case 8:
              v59 = 9;
              break;
            case 9:
              v59 = 5;
              break;
            case 10:
              v59 = 10;
              break;
            default:
              v59 = 11;
              break;
          }
          if ( (1 << (v59 + 19)) & *(_DWORD *)(v54 + 24) )
          {
            v31 = (iconWidget *)operator new(45);
            if ( v31 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = iconWidget::iconWidget(
                                                                v31,
                                                                41 * v58 + 378,
                                                                86 * j + 35,
                                                                42,
                                                                40,
                                                                "mons32.icn",
                                                                gDwellingType[*(_BYTE *)(v54 + 3)][v59],
                                                                0,
                                                                v85 + (_WORD)v59 + 15,
                                                                17,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v68) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v68) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v68++), -1);
            contentb = (char *)BaseAlloc(6u, "F:\\h2xsrc\\Source\\Overview.cpp", word_511E74 + 298);
            sprintf(contentb, "%d", *(_WORD *)(v54 + 2 * v59 + 30));
            v30 = (textWidget *)operator new(43);
            if ( v30 )
              *((_DWORD *)textWidgetDynamic + 70 * j + v84) = textWidget::textWidget(
                                                                v30,
                                                                41 * v58 + 378,
                                                                86 * j + 81,
                                                                40,
                                                                12,
                                                                contentb,
                                                                "smalfont.fnt",
                                                                1,
                                                                v85 + (_WORD)v59 + 27,
                                                                512,
                                                                1);
            else
              *((_DWORD *)textWidgetDynamic + 70 * j + v84) = 0;
            heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j + v84++), -1);
            ++v58;
          }
        }
      }
      else
      {
        thisa = (int)((char *)v13 + 250 * *(&gpCurPlayer->heroesOwned[j] + giOverviewTop[giOverviewType]) + 10180);
        v29 = (iconWidget *)operator new(45);
        if ( v29 )
          *((_DWORD *)iconWidgetDynamic + 70 * j + 1) = iconWidget::iconWidget(
                                                          v29,
                                                          35,
                                                          86 * j + 21,
                                                          46,
                                                          22,
                                                          "portxtra.icn",
                                                          0,
                                                          0,
                                                          200 * j + 300,
                                                          16,
                                                          1);
        else
          *((_DWORD *)iconWidgetDynamic + 70 * j + 1) = 0;
        if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 1) )
          MemError();
        heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 1), -1);
        v28 = (iconWidget *)operator new(45);
        if ( v28 )
          *((_DWORD *)iconWidgetDynamic + 70 * j + 2) = iconWidget::iconWidget(
                                                          v28,
                                                          30,
                                                          86 * j + 16,
                                                          51,
                                                          27,
                                                          "miniport.icn",
                                                          *(_BYTE *)(thisa + 24),
                                                          0,
                                                          200 * j + 301,
                                                          16,
                                                          1);
        else
          *((_DWORD *)iconWidgetDynamic + 70 * j + 2) = 0;
        if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 2) )
          MemError();
        heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 2), -1);
        v27 = (iconWidget *)operator new(45);
        if ( v27 )
        {
          v9 = GetMobilityFrame(*(_DWORD *)(thisa + 53));
          *((_DWORD *)iconWidgetDynamic + 70 * j + 3) = iconWidget::iconWidget(
                                                          v27,
                                                          35,
                                                          86 * j + 21,
                                                          0,
                                                          0,
                                                          "mobility.icn",
                                                          v9,
                                                          0,
                                                          200 * j + 303,
                                                          16,
                                                          1);
        }
        else
        {
          *((_DWORD *)iconWidgetDynamic + 70 * j + 3) = 0;
        }
        if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 3) )
          MemError();
        heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 3), -1);
        v26 = (iconWidget *)operator new(45);
        if ( v26 )
        {
          v10 = GetManaFrame(*(_WORD *)thisa);
          *((_DWORD *)iconWidgetDynamic + 70 * j + 4) = iconWidget::iconWidget(
                                                          v26,
                                                          74,
                                                          86 * j + 21,
                                                          0,
                                                          0,
                                                          "mana.icn",
                                                          v10,
                                                          0,
                                                          200 * j + 241,
                                                          16,
                                                          1);
        }
        else
        {
          *((_DWORD *)iconWidgetDynamic + 70 * j + 4) = 0;
        }
        if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + 4) )
          MemError();
        heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + 4), -1);
        v72 = 5;
        for ( skillc = 0; (signed int)skillc < 4; ++skillc )
        {
          contentc = (char *)BaseAlloc(4u, "F:\\h2xsrc\\Source\\Overview.cpp", word_511E74 + 386);
          v11 = hero::Stats((hero *)thisa, skillc);
          sprintf(contentc, "%d", v11);
          v25 = (textWidget *)operator new(43);
          if ( v25 )
            *((_DWORD *)textWidgetDynamic + 70 * j + v83) = textWidget::textWidget(
                                                              v25,
                                                              35 * skillc + 105,
                                                              86 * j + 39,
                                                              14,
                                                              8,
                                                              contentc,
                                                              "smalfont.fnt",
                                                              1,
                                                              skillc + (_WORD)v85 + 142,
                                                              512,
                                                              2);
          else
            *((_DWORD *)textWidgetDynamic + 70 * j + v83) = 0;
          heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j + v83++), -1);
        }
        for ( skilld = 0; skilld < 4; ++skilld )
        {
          v24 = (iconWidget *)operator new(45);
          if ( v24 )
            *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = iconWidget::iconWidget(
                                                              v24,
                                                              35 * skilld + 87,
                                                              86 * j + 17,
                                                              35,
                                                              30,
                                                              "overview.icn",
                                                              15,
                                                              0,
                                                              skilld + (_WORD)v85 + 170,
                                                              16,
                                                              1);
          else
            *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = 0;
          if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v72) )
            MemError();
          heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v72++), -1);
        }
        v48 = 0;
        for ( skille = 0; skille < 5; ++skille )
        {
          if ( *(_BYTE *)(skille + thisa + 101) != -1 && (signed int)*(_WORD *)(thisa + 2 * skille + 106) > 0 )
          {
            v23 = (iconWidget *)operator new(45);
            if ( v23 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = iconWidget::iconWidget(
                                                                v23,
                                                                40 * v48 + 30,
                                                                86 * j + 47,
                                                                42,
                                                                40,
                                                                "mons32.icn",
                                                                *(_BYTE *)(skille + thisa + 101),
                                                                0,
                                                                skille + (_WORD)v85 + 104,
                                                                17,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v72) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v72++), -1);
            contentd = (char *)BaseAlloc(6u, "F:\\h2xsrc\\Source\\Overview.cpp", word_511E74 + 445);
            sprintf(contentd, "%d", *(_WORD *)(thisa + 2 * skille + 106));
            v22 = (textWidget *)operator new(43);
            if ( v22 )
              *((_DWORD *)textWidgetDynamic + 70 * j + v83) = textWidget::textWidget(
                                                                v22,
                                                                40 * v48 + 30,
                                                                86 * j + 87,
                                                                40,
                                                                12,
                                                                contentd,
                                                                "smalfont.fnt",
                                                                1,
                                                                skille + (_WORD)v85 + 109,
                                                                512,
                                                                1);
            else
              *((_DWORD *)textWidgetDynamic + 70 * j + v83) = 0;
            heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j + v83++), -1);
            ++v48;
          }
        }
        for ( skillf = 0; skillf < 8; ++skillf )
        {
          v44 = hero::GetNthSS((hero *)thisa, skillf);
          if ( v44 != -1 )
          {
            v46 = skillf / 4;
            v49 = (unsigned __int8)((char)skillf % -4);
            v21 = (iconWidget *)operator new(45);
            if ( v21 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = iconWidget::iconWidget(
                                                                v21,
                                                                35 * v49 + 233,
                                                                86 * j + 42 * v46 + 20,
                                                                34,
                                                                34,
                                                                "overview.icn",
                                                                12,
                                                                0,
                                                                skillf + (_WORD)v85 + 154,
                                                                16,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v72) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v72), -1);
            v73 = v72 + 1;
            v20 = (iconWidget *)operator new(45);
            if ( v20 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v73) = iconWidget::iconWidget(
                                                                v20,
                                                                35 * v49 + 234,
                                                                86 * j + 42 * v46 + 21,
                                                                32,
                                                                32,
                                                                "miniss.icn",
                                                                v44,
                                                                0,
                                                                skillf + (_WORD)v85 + 146,
                                                                16,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v73) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v73) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v73), -1);
            v72 = v73 + 1;
            contente = (char *)BaseAlloc(2u, "F:\\h2xsrc\\Source\\Overview.cpp", word_511E74 + 507);
            v12 = hero::GetSSLevel((hero *)thisa, (SECONDARY_SKILL)v44);
            sprintf(contente, "%d", v12);
            v19 = (textWidget *)operator new(43);
            if ( v19 )
              *((_DWORD *)textWidgetDynamic + 70 * j + v83) = textWidget::textWidget(
                                                                v19,
                                                                35 * v49 + 255,
                                                                86 * j + 42 * v46 + 45,
                                                                8,
                                                                8,
                                                                contente,
                                                                "smalfont.fnt",
                                                                1,
                                                                skillf + (_WORD)v85 + 162,
                                                                512,
                                                                2);
            else
              *((_DWORD *)textWidgetDynamic + 70 * j + v83) = 0;
            heroWindow::AddWidget(overWin, *((widget **)textWidgetDynamic + 70 * j + v83++), -1);
          }
        }
        v51 = 0;
        for ( skillg = 0; skillg < 14; ++skillg )
        {
          if ( *(_BYTE *)(skillg + thisa + 213) != -1 )
          {
            v47 = v51 / 7;
            v50 = v51 % 7;
            v18 = (iconWidget *)operator new(45);
            if ( v18 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = iconWidget::iconWidget(
                                                                v18,
                                                                35 * v50 + 378,
                                                                86 * j + 42 * v47 + 20,
                                                                34,
                                                                34,
                                                                "overview.icn",
                                                                12,
                                                                0,
                                                                skillg + (_WORD)v85 + 128,
                                                                16,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v72) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v72) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v72), -1);
            v74 = v72 + 1;
            v17 = (iconWidget *)operator new(45);
            if ( v17 )
              *((_DWORD *)iconWidgetDynamic + 70 * j + v74) = iconWidget::iconWidget(
                                                                v17,
                                                                35 * v50 + 379,
                                                                86 * j + 42 * v47 + 21,
                                                                32,
                                                                32,
                                                                "artfx.icn",
                                                                *(_BYTE *)(skillg + thisa + 213),
                                                                0,
                                                                skillg + (_WORD)v85 + 114,
                                                                16,
                                                                1);
            else
              *((_DWORD *)iconWidgetDynamic + 70 * j + v74) = 0;
            if ( !*((_DWORD *)iconWidgetDynamic + 70 * j + v74) )
              MemError();
            heroWindow::AddWidget(overWin, *((widget **)iconWidgetDynamic + 70 * j + v74), -1);
            v72 = v74 + 1;
            ++v51;
          }
        }
      }
    }
    if ( a2 )
    {
      heroWindow::DrawWindow(overWin, 0, 110, 999);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 30, 16, 0x262u, 341);
    }
  }
}
// 511E64: using guessed type int giOverviewType;
// 511E68: using guessed type int giOverviewTop[];
// 511E74: using guessed type __int16 word_511E74;
// 525208: using guessed type int giOverviewItems[];
// 525210: using guessed type int iLastDynamicTop;
// 525214: using guessed type int iLastDynamicType;

//----- (00462190) --------------------------------------------------------
void __thiscall game::SetupNewOverviewType(void *this, int a2, int a3)
{
  int v3; // ST24_4@20
  unsigned int v4; // eax@20
  void *v5; // [sp+Ch] [bp-50h]@1
  char v6; // [sp+10h] [bp-4Ch]@2
  textWidget *thisa; // [sp+14h] [bp-48h]@20
  int v8; // [sp+1Ch] [bp-40h]@14
  int a4; // [sp+20h] [bp-3Ch]@11
  __int16 v10; // [sp+24h] [bp-38h]@11
  __int16 v11; // [sp+26h] [bp-36h]@11
  __int16 v12; // [sp+28h] [bp-34h]@11
  __int16 v13; // [sp+2Ah] [bp-32h]@11
  char *content; // [sp+2Ch] [bp-30h]@20
  int evt; // [sp+30h] [bp-2Ch]@8
  int v16; // [sp+34h] [bp-28h]@8
  int v17; // [sp+38h] [bp-24h]@8
  bool v18; // [sp+48h] [bp-14h]@8
  int a2a; // [sp+4Ch] [bp-10h]@11
  __int16 v20; // [sp+50h] [bp-Ch]@11
  __int16 v21; // [sp+52h] [bp-Ah]@11
  __int16 v22; // [sp+54h] [bp-8h]@11
  __int16 v23; // [sp+56h] [bp-6h]@11
  int i; // [sp+58h] [bp-4h]@11

  v5 = this;
  giOverviewType = a2;
  if ( a2 )
    v6 = gpCurPlayer->numCastles;
  else
    v6 = gpCurPlayer->numHeroes;
  iOverviewItems = v6;
  if ( giOverviewTop[giOverviewType] > v6 - 4 )
    giOverviewTop[giOverviewType] = iOverviewItems - 4;
  if ( giOverviewTop[giOverviewType] < 0 )
    giOverviewTop[giOverviewType] = 0;
  evt = 512;
  v16 = 4;
  v17 = 102;
  v18 = giOverviewType + 6;
  heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  v16 = 4;
  v17 = 100;
  v18 = giOverviewType == 0;
  heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  v16 = 4;
  v17 = 101;
  if ( giOverviewType == 1 )
    v18 = 3;
  else
    v18 = 2;
  heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  a2a = 15204387;
  v20 = 377;
  v21 = 35;
  v22 = 177;
  v23 = 379;
  a4 = 9306306;
  v10 = 241;
  v11 = 140;
  v12 = 199;
  v13 = 239;
  for ( i = 0; i < 3; ++i )
  {
    if ( textWidgetTitle[i] )
    {
      heroWindow::RemoveWidget(overWin, (widget *)textWidgetTitle[i]);
      v8 = textWidgetTitle[i];
      if ( v8 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
      textWidgetTitle[i] = 0;
    }
  }
  for ( i = 0; i < 3; ++i )
  {
    v3 = word_5120D0 + 42;
    v4 = strlen((&cOverviewText)[4 * (i + 3 * giOverviewType)]);
    content = (char *)BaseAlloc(v4 + 1, "F:\\h2xsrc\\Source\\Overview.cpp", v3);
    strcpy(content, (&cOverviewText)[4 * (i + 3 * giOverviewType)]);
    thisa = (textWidget *)operator new(43);
    if ( thisa )
      textWidgetTitle[i] = (int)textWidget::textWidget(
                                  thisa,
                                  *(int *)((char *)&a2a + 6 * giOverviewType + 2 * i),
                                  3,
                                  *(int *)((char *)&a4 + 6 * giOverviewType + 2 * i),
                                  12,
                                  content,
                                  "smalfont.fnt",
                                  1,
                                  i + 110,
                                  512,
                                  1);
    else
      textWidgetTitle[i] = 0;
    heroWindow::AddWidget(overWin, (widget *)textWidgetTitle[i], -1);
  }
  game::SetupDynamicStuff(v5, 0, 1, 0);
  if ( a3 )
    heroWindow::DrawWindow(overWin, a3, 100, 999);
}
// 462190: too many cbuild loops
// 511E64: using guessed type int giOverviewType;
// 511E68: using guessed type int giOverviewTop[];
// 5120D0: using guessed type __int16 word_5120D0;
// 525218: using guessed type int textWidgetTitle[];
// 525224: using guessed type int iOverviewItems;

//----- (004624F0) --------------------------------------------------------
int __cdecl game::SetupResources()
{
  int result; // eax@3
  int evt; // [sp+10h] [bp-20h]@1
  int v2; // [sp+14h] [bp-1Ch]@3
  int v3; // [sp+18h] [bp-18h]@3
  char *v4; // [sp+28h] [bp-8h]@3
  int i; // [sp+2Ch] [bp-4h]@1

  evt = 512;
  for ( i = 0; i < 7; ++i )
  {
    v2 = 3;
    v4 = gText;
    sprintf(gText, "%d", gpCurPlayer->resources[i]);
    v3 = i + 30;
    result = heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  }
  return result;
}

//----- (00462580) --------------------------------------------------------
void __thiscall game::Overview(void *this)
{
  int v1; // eax@24
  int v2; // eax@36
  void *v3; // [sp+Ch] [bp-44h]@1
  iconWidget *v4; // [sp+18h] [bp-38h]@15
  heroWindow *thisa; // [sp+1Ch] [bp-34h]@10
  int evt; // [sp+20h] [bp-30h]@1
  int v7; // [sp+24h] [bp-2Ch]@30
  int v8; // [sp+28h] [bp-28h]@30
  char *v9; // [sp+38h] [bp-18h]@30
  int j; // [sp+3Ch] [bp-14h]@4
  int i; // [sp+40h] [bp-10h]@1
  char v12[8]; // [sp+44h] [bp-Ch]@20
  int v13; // [sp+4Ch] [bp-4h]@20

  v3 = this;
  giOverviewReturnAction = -1;
  giOverviewReturnActionExtra = -1;
  evt = 512;
  advManager::TrimLoopingSounds(gpAdvManager, 4);
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  for ( i = 0; i < 3; ++i )
    textWidgetTitle[i] = 0;
  textWidgetDynamic = BaseAlloc(0x2BC0u, "F:\\h2xsrc\\Source\\Overview.cpp", word_512108 + 17);
  iconWidgetDynamic = BaseAlloc(0x2BC0u, "F:\\h2xsrc\\Source\\Overview.cpp", word_512108 + 18);
  for ( j = 0; j < 4; ++j )
  {
    for ( i = 0; i < 70; ++i )
    {
      *((_DWORD *)textWidgetDynamic + 70 * j + i) = 0;
      *((_DWORD *)iconWidgetDynamic + 70 * j + i) = 0;
    }
  }
  iLastDynamicType = -1;
  iLastDynamicTop = -1;
  giOverviewItems[0] = gpCurPlayer->numHeroes;
  dword_52520C = gpCurPlayer->numCastles;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  resourceManager::GetBackdrop(gpResourceManager, "overback.icn", gpWindowManager->screenBuffer, 1);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    overWin = heroWindow::heroWindow(thisa, 0, 0, "overwind.bin");
  else
    overWin = 0;
  if ( !overWin )
    MemError();
  SetWinText(overWin, 9);
  v4 = (iconWidget *)operator new(45);
  if ( v4 )
    OVScrollKnob = (widget *)iconWidget::iconWidget(v4, 629, 18, 8, 17, "scrollcn.icn", 4, 0, 111, 16, 1);
  else
    OVScrollKnob = 0;
  if ( !OVScrollKnob )
    MemError();
  heroWindow::AddWidget(overWin, OVScrollKnob, -1);
  game::SetupResources();
  memset(v12, 0, 7u);
  v13 = 0;
  for ( i = 0; i < 144; ++i )
  {
    if ( *((_BYTE *)v3 + i + 24742) == giCurPlayer )
    {
      if ( (signed int)*((_BYTE *)v3 + 7 * i + 23736) > 6 )
      {
        if ( *((_BYTE *)v3 + 7 * i + 23736) == 100 )
          ++v13;
      }
      else
      {
        v1 = *((_BYTE *)v3 + 7 * i + 23736);
        ++v12[v1];
      }
    }
  }
  for ( i = 0; i < 7; ++i )
  {
    v7 = 3;
    v9 = gText;
    sprintf(gText, "%d", v12[i]);
    v8 = i + 20;
    heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  }
  for ( i = 4; i > 0; --i )
  {
    if ( v13 < i )
    {
      v7 = 6;
      v8 = i + 49;
      v9 = (char *)4;
      heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
    }
  }
  game::SetupResources();
  v7 = 3;
  v8 = 40;
  v9 = gText;
  v2 = game::ComputeDailyGold((game *)v3, giCurPlayer);
  sprintf(gText, "%d", v2);
  heroWindow::BroadcastMessage(overWin, (tag_message *)&evt);
  game::SetupNewOverviewType(v3, giOverviewType, 0);
  heroWindowManager::DoDialog(gpWindowManager, overWin, (int (__fastcall *)(tag_message *))OverviewHandler, 1);
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  operator delete(overWin);
  overWin = 0;
  BaseFree(textWidgetDynamic, (int)"F:\\h2xsrc\\Source\\Overview.cpp", word_512108 + 104);
  BaseFree(iconWidgetDynamic, (int)"F:\\h2xsrc\\Source\\Overview.cpp", word_512108 + 105);
  textWidgetDynamic = 0;
  iconWidgetDynamic = 0;
}
// 511E64: using guessed type int giOverviewType;
// 512108: using guessed type __int16 word_512108;
// 524238: using guessed type int giOverviewReturnAction;
// 525208: using guessed type int giOverviewItems[];
// 52520C: using guessed type int dword_52520C;
// 525210: using guessed type int iLastDynamicTop;
// 525214: using guessed type int iLastDynamicType;
// 525218: using guessed type int textWidgetTitle[];
// 462580: using guessed type char var_C[8];

//----- (00462A50) --------------------------------------------------------
void __thiscall game::DoKnob(void *this)
{
  void *v1; // [sp+1Ch] [bp-D0h]@1
  char v2; // [sp+20h] [bp-CCh]@21
  char v3; // [sp+3Ch] [bp-B0h]@20
  char v4; // [sp+58h] [bp-94h]@17
  tag_message a2; // [sp+74h] [bp-78h]@2
  int v6; // [sp+90h] [bp-5Ch]@18
  int v7; // [sp+94h] [bp-58h]@20
  int v8; // [sp+B0h] [bp-3Ch]@10
  float v9; // [sp+B4h] [bp-38h]@2
  int y; // [sp+B8h] [bp-34h]@2
  int v11; // [sp+BCh] [bp-30h]@2
  int v12; // [sp+C4h] [bp-28h]@6
  int x; // [sp+D8h] [bp-14h]@2
  float v14; // [sp+DCh] [bp-10h]@2
  int v15; // [sp+E0h] [bp-Ch]@2
  double v16; // [sp+E4h] [bp-8h]@2

  v1 = this;
  if ( giOverviewItems[giOverviewType] > 4 )
  {
    v14 = 304.0;
    v9 = 18.0;
    v15 = giOverviewTop[giOverviewType];
    v16 = 304.0 / (double)(giOverviewItems[giOverviewType] - 3);
    mouseManager::MouseCoords(&x, &y);
    inputManager::Flush(gpInputManager);
    memcpy(&v11, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
    while ( v11 != 16 && v11 != 64 )
    {
      if ( v11 == 4 )
      {
        if ( (double)v12 < v9 )
          v12 = (signed __int64)v9;
        if ( (double)v12 > v9 + v14 - 1.0 )
          v12 = (signed __int64)(v9 + v14 - 1.0);
        (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
        OVScrollKnob->offsetY = v12 - 9;
        v8 = (signed __int64)(((double)OVScrollKnob->offsetY - v9) / v16);
        if ( v15 == v8 )
        {
          heroWindow::DrawWindow(overWin, 1, 0, 32767);
        }
        else
        {
          if ( giOverviewItems[giOverviewType] - 4 < v8 )
            v8 = giOverviewItems[giOverviewType] - 4;
          if ( v8 < 0 )
            v8 = 0;
          giOverviewTop[giOverviewType] = v8;
          OVScrollKnob->offsetY = v12 - 9;
          game::SetupDynamicStuff(v1, 1, 0, 0);
          v15 = v8;
        }
      }
      Process1WindowsMessage();
      memcpy(&v11, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v4), 0x1Cu);
      if ( v11 == 4 )
      {
        v6 = 1;
        while ( v6 )
        {
          memcpy(&v7, inputManager::PeekEvent(gpInputManager, &v3), 0x1Cu);
          if ( v7 == 4 )
            memcpy(&v11, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v2), 0x1Cu);
          else
            v6 = 0;
        }
      }
    }
    OVScrollKnob->flags &= 0xFFFEu;
    game::SetupDynamicStuff(v1, 0, 1, 0);
    heroWindow::DrawWindow(overWin, 0, 110, 111);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 627, 17, 0xBu, 322);
  }
}
// 511E64: using guessed type int giOverviewType;
// 511E68: using guessed type int giOverviewTop[];
// 525208: using guessed type int giOverviewItems[];

//----- (00462D50) --------------------------------------------------------
signed int __thiscall OverviewHandler(void *this)
{
  signed int result; // eax@52
  int v2; // [sp+18h] [bp-20h]@2
  void *v3; // [sp+1Ch] [bp-1Ch]@1
  signed int v4; // [sp+30h] [bp-8h]@1
  unsigned int v5; // [sp+34h] [bp-4h]@1

  v3 = this;
  v4 = 0;
  v5 = 0;
  if ( *(_DWORD *)this != 512 )
    goto LABEL_40;
  v2 = *((_DWORD *)this + 1);
  if ( v2 == 12 )
    goto LABEL_4;
  if ( v2 != 13 )
  {
    if ( v2 != 14 )
      goto LABEL_40;
    v5 = 1;
LABEL_4:
    if ( *((_BYTE *)this + 13) & 2 )
      v5 = 1;
    switch ( *((_DWORD *)this + 2) )
    {
      case 0x6F:
        if ( !v5 )
          game::DoKnob(gpGame);
        break;
      case 0x6E:
        if ( !v5 && giOverviewItems[giOverviewType] > 4 )
        {
          giOverviewTop[giOverviewType] = 100
                                        * (*((_DWORD *)this + 5) - 27)
                                        / 32100
                                        / (giOverviewItems[giOverviewType] - 3);
          if ( giOverviewTop[giOverviewType] + 3 >= giOverviewItems[giOverviewType] )
            giOverviewTop[giOverviewType] = giOverviewItems[giOverviewType] - 4;
          if ( giOverviewTop[giOverviewType] < 0 )
            giOverviewTop[giOverviewType] = 0;
          game::SetupDynamicStuff(gpGame, 1, 1, 0);
        }
        break;
      case 0x64:
        if ( !v5 )
          goto LABEL_17;
        break;
      case 0x65:
        if ( !v5 )
          goto LABEL_21;
        break;
      default:
        v4 = game::ProcessIconSelect(gpGame, *((_DWORD *)this + 2), v5);
        break;
    }
    goto LABEL_40;
  }
  switch ( *((_DWORD *)this + 2) )
  {
    case 0x23:
LABEL_17:
      if ( giOverviewType )
        game::SetupNewOverviewType(gpGame, 0, 1);
      break;
    case 0x14:
LABEL_21:
      if ( giOverviewType != 1 )
        game::SetupNewOverviewType(gpGame, 1, 1);
      break;
    case 0xA:
      if ( giOverviewTop[giOverviewType] > 0 )
      {
        --giOverviewTop[giOverviewType];
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
      }
      break;
    case 0xB:
      if ( giOverviewItems[giOverviewType] - 4 > giOverviewTop[giOverviewType] )
      {
        ++giOverviewTop[giOverviewType];
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
      }
      break;
    case 0xE:
      gpWindowManager->buttonPressedCode = *((_DWORD *)this + 2);
      v4 = 1;
      break;
    default:
      break;
  }
LABEL_40:
  if ( *(_DWORD *)v3 == 1 )
  {
    switch ( *((_DWORD *)v3 + 1) )
    {
      case 0x49:
        giOverviewTop[giOverviewType] -= 4;
        if ( giOverviewTop[giOverviewType] < 0 )
          giOverviewTop[giOverviewType] = 0;
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
        break;
      case 0x51:
        giOverviewTop[giOverviewType] += 4;
        if ( giOverviewItems[giOverviewType] - 4 < giOverviewTop[giOverviewType] )
          giOverviewTop[giOverviewType] = giOverviewItems[giOverviewType] - 4;
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
        break;
      case 0x47:
        giOverviewTop[giOverviewType] = 0;
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
        break;
      case 0x4F:
        giOverviewTop[giOverviewType] = giOverviewItems[giOverviewType] - 4;
        game::SetupDynamicStuff(gpGame, 1, 1, 0);
        break;
      default:
        break;
    }
  }
  if ( v4 == 1 )
  {
    *((_DWORD *)v3 + 2) = 10;
    *((_DWORD *)v3 + 1) = *((_DWORD *)v3 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 511E64: using guessed type int giOverviewType;
// 511E68: using guessed type int giOverviewTop[];
// 525208: using guessed type int giOverviewItems[];

//----- (00463250) --------------------------------------------------------
signed int __thiscall game::ProcessIconSelect(void *this, signed int a2, unsigned int a3)
{
  int v4; // eax@14
  int v5; // ST5C_4@18
  void *v6; // [sp+Ch] [bp-24h]@1
  recruitUnit *thisa; // [sp+18h] [bp-18h]@48
  baseManager *a2a; // [sp+1Ch] [bp-14h]@49
  int v9; // [sp+20h] [bp-10h]@3
  char *hro; // [sp+24h] [bp-Ch]@6
  int castle; // [sp+28h] [bp-8h]@28
  int a1; // [sp+2Ch] [bp-4h]@21
  int a1a; // [sp+2Ch] [bp-4h]@46
  int v14; // [sp+38h] [bp+8h]@5

  v6 = this;
  if ( a2 >= 200 && a2 <= 999 )
  {
    v9 = (a2 - 200) / 200;
    if ( v9 + giOverviewTop[giOverviewType] > giOverviewItems[giOverviewType] )
      return 0;
    v14 = (a2 - 200) % 200;
    if ( !giOverviewType )
    {
      hro = (char *)this + 250 * *(&gpCurPlayer->heroesOwned[v9] + giOverviewTop[giOverviewType]) + 10180;
      if ( v14 >= 100 && v14 <= 103 )
      {
        giOverviewReturnAction = 1;
        giOverviewReturnActionExtra = *(&gpCurPlayer->heroesOwned[v9] + giOverviewTop[giOverviewType]);
        return 1;
      }
      if ( v14 >= 109 && v14 <= 113 )
        v14 -= 5;
      if ( v14 >= 104 )
      {
        if ( v14 <= 108 )
        {
          v4 = armyGroup::GetNumArmies((armyGroup *)((char *)this
                                                   + 250
                                                   * *(&gpCurPlayer->heroesOwned[v9] + giOverviewTop[giOverviewType])
                                                   + 10281));
          game::ViewArmy(
            gpGame,
            119,
            20,
            (CREATURES)hro[v14 - 3],
            *(_WORD *)&hro[2 * (v14 - 104) + 106],
            0,
            v4 == 1,
            1u,
            a3,
            (hero *)hro,
            0,
            (armyGroup *)(hro + 101),
            v14 - 104);
          if ( !a3 )
            game::SetupDynamicStuff(v6, 1, 1, 1);
        }
      }
      if ( v14 >= 146 && v14 <= 153 )
      {
        v5 = hero::GetNthSS((hero *)hro, v14 - 146);
        hero::DoSSLevelDialog((hero *)hro, v5, a3);
      }
      if ( v14 >= 114 && v14 <= 127 )
      {
        a1 = hro[v14 + 99];
        if ( a1 == 81 )
          game::ViewSpells(gpGame, (hero *)hro, 2, (int (__fastcall *)(struct tag_message *))ViewSpecialHandler, 1);
        else
          hero::ViewArtifact(a1, a3, hro[v14 + 122]);
      }
      if ( v14 >= 170 && v14 <= 173 )
        NormalDialog(gStatDesc[v14 - 170], a3 < 1 ? 1 : 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
    if ( giOverviewType == 1 )
    {
      castle = (int)((char *)v6 + 100 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]) + 2899);
      if ( v14 == 4 )
      {
        giOverviewReturnAction = 2;
        giOverviewReturnActionExtra = *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]);
        return 1;
      }
      if ( v14 >= 39
        && v14 <= 43
        && *((_BYTE *)v6 + 100 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]) + 2922) != -1 )
      {
        giOverviewReturnAction = 1;
        giOverviewReturnActionExtra = *(_BYTE *)(castle + 23);
        return 1;
      }
      if ( v14 >= 10 && v14 <= 14 )
        v14 -= 5;
      if ( v14 >= 5 )
      {
        if ( v14 <= 9 )
        {
          game::ViewArmy(
            gpGame,
            119,
            20,
            (CREATURES)*((_BYTE *)v6
                       + 100 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType])
                       + v14
                       + 2902),
            *((_WORD *)v6 + 50 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]) + v14 - 5 + 1456),
            (int)((char *)v6 + 100 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]) + 2899),
            0,
            1u,
            a3,
            0,
            0,
            (armyGroup *)((char *)v6 + 100 * *(&gpCurPlayer->castlesOwned[v9] + giOverviewTop[giOverviewType]) + 2907),
            v14 - 5);
          if ( !a3 )
            game::SetupDynamicStuff(v6, 1, 1, 1);
        }
      }
      if ( v14 >= 27 && v14 <= 38 )
        v14 -= 12;
      if ( v14 >= 15 && v14 <= 26 )
      {
        a1a = v14 - 15;
        if ( a3 )
        {
          QuickViewRecruit((town *)castle, a1a);
        }
        else
        {
          thisa = (recruitUnit *)operator new(126);
          if ( thisa )
            a2a = (baseManager *)recruitUnit::recruitUnit(thisa, castle, a1a, 0);
          else
            a2a = 0;
          if ( !a2a )
            MemError();
          executive::DoDialog(gpExec, a2a);
          operator delete(a2a);
          resourceManager::GetBackdrop(gpResourceManager, "overback.icn", gpWindowManager->screenBuffer, 1);
          game::SetupResources();
          game::SetupDynamicStuff(v6, 0, 1, 1);
          heroWindow::DrawWindow(overWin);
        }
      }
    }
  }
  return 0;
}
// 511E64: using guessed type int giOverviewType;
// 511E68: using guessed type int giOverviewTop[];
// 524238: using guessed type int giOverviewReturnAction;
// 525208: using guessed type int giOverviewItems[];

//----- (00463740) --------------------------------------------------------
int __cdecl DoArenaDialog()
{
  __int16 imgIdx; // [sp+10h] [bp-80h]@10
  textWidget *v2; // [sp+18h] [bp-78h]@16
  iconWidget *v3; // [sp+1Ch] [bp-74h]@8
  heroWindow *this; // [sp+20h] [bp-70h]@1
  int evt; // [sp+30h] [bp-60h]@6
  int v6; // [sp+34h] [bp-5Ch]@6
  int v7; // [sp+38h] [bp-58h]@6
  char *v8; // [sp+48h] [bp-48h]@6
  int xOff; // [sp+4Ch] [bp-44h]@1
  int v10; // [sp+50h] [bp-40h]@1
  int v11; // [sp+5Ch] [bp-34h]@1
  int i; // [sp+64h] [bp-2Ch]@6
  int v13; // [sp+68h] [bp-28h]@6
  int v14; // [sp+6Ch] [bp-24h]@6
  int v15; // [sp+70h] [bp-20h]@1
  char filnam; // [sp+74h] [bp-1Ch]@1
  int guiObj[3]; // [sp+84h] [bp-Ch]@17

  v15 = 5;
  v11 = 306;
  v10 = 405;
  xOff = 159;
  choice = 0;
  sprintf(&filnam, "evntwin%d.bin", 5);
  this = (heroWindow *)operator new(68);
  if ( this )
    arenaWinPtr = heroWindow::heroWindow(this, xOff, 28, &filnam);
  else
    arenaWinPtr = 0;
  if ( !arenaWinPtr )
    MemError();
  strcpy(
    gText,
    "You enter the arena and face a pack of vicious lions.  You handily defeat them, to the wild cheers of the crowd.  Impressed by your skill, the aged trainer of gladiators agrees to train you in a skill of your choice.");
  v13 = font::LineLength(bigFont, gText, 244);
  v14 = 16 * v13;
  evt = 512;
  v6 = 3;
  v7 = 1;
  v8 = gText;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  for ( i = 0; i < 3; ++i )
  {
    v3 = (iconWidget *)operator new(45);
    if ( v3 )
    {
      if ( choice == i )
        imgIdx = i + 4;
      else
        imgIdx = i;
      skillWidget[i] = (int)iconWidget::iconWidget(
                              v3,
                              60 * i + 84,
                              244,
                              39,
                              34,
                              "xprimary.icn",
                              imgIdx,
                              0,
                              i + 100,
                              16,
                              1);
    }
    else
    {
      skillWidget[i] = 0;
    }
    if ( !skillWidget[i] )
      MemError();
    v2 = (textWidget *)operator new(43);
    if ( v2 )
      guiObj[i] = (int)textWidget::textWidget(
                         v2,
                         60 * i + 79,
                         282,
                         49,
                         24,
                         gStatNames[i],
                         "smalfont.fnt",
                         1,
                         -1,
                         512,
                         1);
    else
      guiObj[i] = 0;
    if ( !guiObj[i] )
      MemError();
    heroWindow::AddWidget(arenaWinPtr, (widget *)skillWidget[i], -1);
    heroWindow::AddWidget(arenaWinPtr, (widget *)guiObj[i], -1);
  }
  evt = 512;
  v6 = 6;
  v8 = (char *)6;
  v7 = 30727;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  v7 = 30728;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  v7 = 30721;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  v7 = 30725;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  v7 = 30726;
  heroWindow::BroadcastMessage(arenaWinPtr, (tag_message *)&evt);
  heroWindowManager::DoDialog(gpWindowManager, arenaWinPtr, (int (__fastcall *)(tag_message *))ArenaWindowHandler, 0);
  operator delete(arenaWinPtr);
  return choice;
}
// 525230: using guessed type int skillWidget[];
// 52523C: using guessed type int choice;
// 463740: using guessed type int guiObj[3];

//----- (00463AA0) --------------------------------------------------------
signed int __thiscall ArenaWindowHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-38h]@21
  signed int v3; // [sp+10h] [bp-34h]@16
  int v4; // [sp+14h] [bp-30h]@14
  void *v5; // [sp+18h] [bp-2Ch]@1

  v5 = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) && gpAdvManager->ready == 1 )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( giDialogTimeout && KBTickCount() > giDialogTimeout )
  {
    *(_DWORD *)v5 = 512;
    gpWindowManager->buttonPressedCode = *((_DWORD *)v5 + 2);
    *((_DWORD *)v5 + 2) = 10;
    *((_DWORD *)v5 + 1) = *((_DWORD *)v5 + 2);
    giDialogTimeout = 0;
    return 2;
  }
  if ( *(_DWORD *)v5 == 1 )
  {
    if ( *((_DWORD *)v5 + 1) == 15 )
    {
      ++choice;
      if ( choice >= 3 )
        choice = 0;
      UpdateArenaIcons();
    }
    return 1;
  }
  if ( *(_DWORD *)v5 == 512 )
  {
    v4 = *((_DWORD *)v5 + 1);
    if ( v4 == 12 )
      goto LABEL_15;
    if ( v4 != 13 )
    {
      if ( v4 != 14 )
        return 1;
LABEL_15:
      if ( *((_BYTE *)v5 + 13) & 2 )
      {
        v3 = *((_DWORD *)v5 + 2);
        if ( v3 >= 100 && v3 <= 102 )
        {
          choice = *((_DWORD *)v5 + 2) - 100;
          NormalDialog(gStatDesc[choice], 4, -1, -1, -1, 0, -1, 0, -1, 0);
        }
      }
      return 1;
    }
    v2 = *((_DWORD *)v5 + 2);
    if ( v2 >= 100 )
    {
      if ( v2 <= 102 )
      {
        choice = *((_DWORD *)v5 + 2) - 100;
        UpdateArenaIcons();
      }
      else if ( v2 == 30722 )
      {
        gpWindowManager->buttonPressedCode = *((_DWORD *)v5 + 2);
        *((_DWORD *)v5 + 2) = 10;
        *((_DWORD *)v5 + 1) = *((_DWORD *)v5 + 2);
        giDialogTimeout = 0;
        return 2;
      }
    }
  }
  return 1;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 5240A8: using guessed type int gpSoundManager;
// 52523C: using guessed type int choice;

//----- (00463D00) --------------------------------------------------------
void __cdecl UpdateArenaIcons()
{
  __int16 imgIdx; // [sp+Ch] [bp-14h]@7
  iconWidget *this; // [sp+10h] [bp-10h]@5
  int v2; // [sp+18h] [bp-8h]@3
  signed int i; // [sp+1Ch] [bp-4h]@1

  for ( i = 0; i < 3; ++i )
  {
    heroWindow::RemoveWidget(arenaWinPtr, (widget *)skillWidget[i]);
    v2 = skillWidget[i];
    if ( v2 )
      (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 4))(v2);
    skillWidget[i] = 0;
    this = (iconWidget *)operator new(45);
    if ( this )
    {
      if ( choice == i )
        imgIdx = i + 4;
      else
        imgIdx = i;
      skillWidget[i] = (int)iconWidget::iconWidget(
                              this,
                              60 * i + 84,
                              244,
                              39,
                              34,
                              "xprimary.icn",
                              imgIdx,
                              0,
                              i + 100,
                              16,
                              1);
    }
    else
    {
      skillWidget[i] = 0;
    }
    if ( !skillWidget[i] )
      MemError();
    heroWindow::AddWidget(arenaWinPtr, (widget *)skillWidget[i], -1);
  }
  heroWindow::DrawWindow(arenaWinPtr, 1, 100, 102);
}
// 525230: using guessed type int skillWidget[];
// 52523C: using guessed type int choice;

//----- (00463E60) --------------------------------------------------------
void __thiscall ModemSetup(void *this)
{
  void *v1; // [sp+10h] [bp-D8h]@1
  char msg; // [sp+14h] [bp-D4h]@21
  int i; // [sp+7Ch] [bp-6Ch]@2
  char v4; // [sp+80h] [bp-68h]@5

  v1 = this;
  LogStr("MS1");
  gbRemoteOn = 1;
  dword_5252AC = 0;
  inque = 0;
  dword_52636C = 0;
  outque = 0;
  iBaudBits = 115200 / *((_DWORD *)&modemBaudRate + gbDirectConnect);
  com_init(*((_DWORD *)&modemComPort + gbDirectConnect), 4u, 0);
  LogStr("MS2");
  if ( !gbDirectConnect )
  {
    for ( i = 0; i < 2; ++i )
    {
      if ( *((_DWORD *)&modemComPort + gbDirectConnect) < 1 )
        sprintf(&v4, "ATZ");
      else
        sprintf(&v4, (const char *)&gConfig + 174);
      PollSound();
      ModemCommand(&v4);
      DelayMilli(200);
      ModemCommand((const char *)L"\r");
      DelayMilli(100);
      PollSound();
    }
  }
  LogStr("MS3");
  if ( v1 == (void *)3 )
  {
    if ( !gbDirectConnect && Dial() )
    {
      RemoteCleanup();
      GameMode = 0;
    }
  }
  else
  {
    if ( v1 != (void *)4 )
      return;
    if ( !gbDirectConnect && Wait() )
    {
      RemoteCleanup();
      GameMode = 0;
    }
  }
  if ( gbDirectConnect )
  {
    LogStr("MS4");
    WFDCStage = 0;
    giWaitType = 7;
    strcpy(&msg, "Waiting for other computer to log in to direct connection.\n\nPress 'CANCEL' to abort.");
    NormalDialog(&msg, 6, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( !gbFunctionComplete )
      ShutDown(0);
    LogStr("MS5");
  }
  else
  {
    Connect();
  }
}
// 4F7478: using guessed type int gbDirectConnect;
// 4F7494: using guessed type int gbRemoteOn;
// 5122FC: using guessed type int iBaudBits;
// 512318: using guessed type wchar_t asc_512318[2];
// 51257C: using guessed type char GameMode;
// 523018: using guessed type int gbFunctionComplete;
// 524750: using guessed type int giWaitType;
// 5252A8: using guessed type int inque;
// 5252AC: using guessed type int dword_5252AC;
// 526314: using guessed type int WFDCStage;
// 526368: using guessed type int outque;
// 52636C: using guessed type int dword_52636C;

//----- (004640B0) --------------------------------------------------------
bool __cdecl Dial()
{
  char v1; // [sp+Ch] [bp-28h]@1

  iLastDialPos = 0;
  sprintf(&v1, "ATDT%s", &numbuf);
  sprintf(gText, "%s %s", "Dialing...", &numbuf);
  GUIModemCommand(gText, &v1);
  sprintf(gText, "%s %s", "Dialing...", &numbuf);
  return GUIModemResponse(gText, "CONNECT") != 0;
}
// 525298: using guessed type int iLastDialPos;

//----- (00464150) --------------------------------------------------------
bool __cdecl Wait()
{
  GUIModemResponse("Waiting for ring...", "RING");
  GUIModemCommand("Initializing modem...", "ATA");
  return GUIModemResponse("Establishing connection...", "CONNECT") != 0;
}

//----- (004641B0) --------------------------------------------------------
void __fastcall GUIModemCommand(const char *a1, const char *a2)
{
  char *v2; // ST30_4@1

  v2 = (char *)a1;
  iLastActionTime = 0;
  iModemCommandPos = 0;
  giWaitType = 5;
  strcpy(cModemCommand, (char *)a2);
  NormalDialog(v2, 6, -1, -1, -1, 0, -1, 0, -1, 0);
  if ( !gbFunctionComplete )
    ShutDown(0);
}
// 523018: using guessed type int gbFunctionComplete;
// 524750: using guessed type int giWaitType;
// 526308: using guessed type int iModemCommandPos;
// 52630C: using guessed type int iLastActionTime;

//----- (00464230) --------------------------------------------------------
char __cdecl GUIModemCommandExec()
{
  char result; // al@2

  if ( KBTickCount() >= iLastActionTime + 250 )
  {
    iLastActionTime = KBTickCount();
    if ( iModemCommandPos >= (signed int)strlen(cModemCommand) )
    {
      write_buffer(L"\r", 1);
      result = 1;
    }
    else
    {
      write_buffer(&cModemCommand[iModemCommandPos++], 1);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 512414: using guessed type wchar_t asc_512414[2];
// 526308: using guessed type int iModemCommandPos;
// 52630C: using guessed type int iLastActionTime;

//----- (004642D0) --------------------------------------------------------
signed int __thiscall ModemCommand(const char *this)
{
  const char *a1; // [sp+Ch] [bp-D4h]@1
  unsigned int v3; // [sp+D8h] [bp-8h]@1
  signed int i; // [sp+DCh] [bp-4h]@1

  a1 = this;
  v3 = strlen((char *)this);
  for ( i = 0; (signed int)v3 > i; ++i )
  {
    write_buffer(&a1[i], 1);
    DelayMilli(100);
  }
  return write_buffer(L"\r", 1);
}
// 512418: using guessed type wchar_t asc_512418[2];

//----- (00464350) --------------------------------------------------------
char __fastcall GUIModemResponse(const char *a1, const char *a2)
{
  char *v2; // ST2C_4@1
  char *v3; // ST30_4@1

  v2 = (char *)a2;
  v3 = (char *)a1;
  memset(&GUIMRresponse, 0, 0x50u);
  GUIMRrespptr = 0;
  strcpy(GUIMRresp, v2);
  giWaitType = 6;
  NormalDialog(v3, 6, -1, -1, -1, 0, -1, 0, -1, 0);
  if ( !gbFunctionComplete )
    ShutDown(0);
  return 0;
}
// 523018: using guessed type int gbFunctionComplete;
// 524750: using guessed type int giWaitType;
// 526300: using guessed type int GUIMRrespptr;

//----- (004643E0) --------------------------------------------------------
char __cdecl GUIModemResponseExec()
{
  char result; // al@2
  signed int v1; // eax@11

  GUIMRc = read_byte();
  if ( GUIMRc == -1 )
  {
    result = 0;
  }
  else if ( GUIMRc != 10 && GUIMRrespptr != 79 )
  {
    if ( GUIMRc >= 32 )
      *((_BYTE *)&GUIMRresponse + GUIMRrespptr++) = GUIMRc;
    result = 0;
  }
  else
  {
    *((_BYTE *)&GUIMRresponse + GUIMRrespptr) = 0;
    if ( GUIMRrespptr > 17 )
      byte_526329 = 0;
    v1 = strlen(GUIMRresp);
    if ( !strncmp((int)&GUIMRresponse, (int)GUIMRresp, v1) )
    {
      result = 1;
    }
    else
    {
      GUIMRrespptr = 0;
      result = 0;
    }
  }
  return result;
}
// 526300: using guessed type int GUIMRrespptr;
// 526310: using guessed type int GUIMRc;
// 526329: using guessed type char byte_526329;

//----- (004644D0) --------------------------------------------------------
signed int __fastcall write_buffer(const void *a1, int a2)
{
  signed int result; // eax@2

  if ( a2 + dword_52636C + 16 <= 2048 )
  {
    com_snd(0, a2, a1, 0);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 52636C: using guessed type int dword_52636C;

//----- (00464520) --------------------------------------------------------
signed int __cdecl read_byte()
{
  signed int result; // eax@2
  unsigned __int8 Buffer; // [sp+10h] [bp-4h]@1

  if ( com_rcv(0, 1u, &Buffer) == 1 )
    result = Buffer;
  else
    result = -1;
  return result;
}

//----- (00464570) --------------------------------------------------------
int __cdecl _atoflt(_CRT_FLOAT *Result, char *Str)
{
  int v2; // ecx@0
  int result; // eax@1
  int v4; // [sp+Ch] [bp-4h]@1

  v4 = v2;
  LOWORD(result) = com_snd(0, 1u, &v4, 0);
  return result;
}

//----- (004645A0) --------------------------------------------------------
char __cdecl Connect()
{
  signed int v0; // eax@9
  int v1; // eax@12
  char a1; // [sp+10h] [bp-18h]@9
  unsigned int v4; // [sp+24h] [bp-4h]@1

  v4 = KBTickCount() % 0xF4240u;
  sprintf(idstr, "%06d", v4);
  oldsec = -1;
  remotestage = 0;
  localstage = 0;
  do
  {
    if ( ReadPacket() )
    {
      packet[packetlen] = 0;
      if ( packetlen != 10 || strncmp((int)packet, (int)"ID", 2) )
        continue;
      if ( !strncmp((int)&packet[2], (int)idstr, 6) )
      {
        sprintf(gText, "Duplicate ID Strings!\nSorry Please Try Again\n");
        GOut(gText);
        RemoteCleanup();
      }
      strncpy(remoteidstr, &packet[2], 6u);
      remotestage = byte_526DD1 - 48;
      localstage = byte_526DD1 - 48 + 1;
      oldsec = -1;
    }
    stime = KBTickCount();
    if ( stime / 1000 != oldsec / 1000 )
    {
      oldsec = stime;
      sprintf(&a1, "ID%s_%i", idstr, localstage);
      v0 = strlen(&a1);
      WriteModemPacket((int)&a1, v0);
    }
    PollSound();
  }
  while ( localstage < 2 );
  do
    v1 = ReadPacket();
  while ( (_BYTE)v1 );
  return v1;
}
// 512308: using guessed type int packetlen;
// 525290: using guessed type int localstage;
// 525294: using guessed type int oldsec;
// 52529C: using guessed type int stime;
// 526304: using guessed type int remotestage;
// 526DD1: using guessed type char byte_526DD1;

//----- (00464760) --------------------------------------------------------
signed int __cdecl WaitForDirectConnect()
{
  unsigned int v0; // ST20_4@2
  signed int v2; // eax@12
  char a1; // [sp+14h] [bp-14h]@12

  if ( WFDCStage )
  {
    if ( WFDCStage == 1 )
    {
      if ( ReadPacket() )
      {
        packet[packetlen] = 0;
        if ( packetlen != 10 )
          return 0;
        if ( strncmp((int)packet, (int)"ID", 2) )
          return 0;
        if ( !strncmp((int)&packet[2], (int)idstr, 6) )
        {
          sprintf(gText, "Duplicate ID Strings!\nSorry Please Try Again\n");
          GOut(gText);
          RemoteCleanup();
        }
        strncpy(remoteidstr, &packet[2], 6u);
        remotestage = byte_526DD1 - 48;
        localstage = byte_526DD1 - 48 + 1;
        oldsec = -1;
      }
      stime = KBTickCount();
      if ( stime / 1000 != oldsec / 1000 )
      {
        oldsec = stime;
        sprintf(&a1, "ID%s_%i", idstr, localstage);
        v2 = strlen(&a1);
        WriteModemPacket((int)&a1, v2);
      }
      if ( localstage >= 2 )
        ++WFDCStage;
    }
    else if ( WFDCStage == 2 && !ReadPacket() )
    {
      return 1;
    }
  }
  else
  {
    v0 = KBTickCount() % 0xF4240u;
    sprintf(idstr, "%06d", v0);
    oldsec = -1;
    remotestage = 0;
    localstage = 0;
    ++WFDCStage;
  }
  return 0;
}
// 512308: using guessed type int packetlen;
// 525290: using guessed type int localstage;
// 525294: using guessed type int oldsec;
// 52529C: using guessed type int stime;
// 526304: using guessed type int remotestage;
// 526314: using guessed type int WFDCStage;
// 526DD1: using guessed type char byte_526DD1;

//----- (00464980) --------------------------------------------------------
char __cdecl ReadPacket()
{
  signed int v1; // [sp+Ch] [bp-4h]@5

  if ( dword_5252AC > 4092 )
  {
    LogStr("OverFlow1");
    dword_5252AC = 0;
    newpacket = 1;
  }
LABEL_3:
  if ( newpacket )
  {
    packetlen = 0;
    newpacket = 0;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v1 = read_byte();
      if ( v1 < 0 )
        return 0;
      if ( inescape )
        break;
      if ( v1 != 112 )
        goto LABEL_15;
      inescape = 1;
    }
    inescape = 0;
    if ( v1 == 1 )
      break;
    if ( !v1 )
    {
      newpacket = 1;
      goto LABEL_3;
    }
LABEL_15:
    if ( packetlen >= 256 )
    {
      newpacket = 1;
      LogStr("OverFlow2");
      goto LABEL_3;
    }
    packet[packetlen++] = v1;
  }
  newpacket = 1;
  return 1;
}
// 512300: using guessed type int inescape;
// 512304: using guessed type int newpacket;
// 512308: using guessed type int packetlen;
// 5252AC: using guessed type int dword_5252AC;

//----- (00464AB0) --------------------------------------------------------
void __fastcall WriteModemPacket(int a1, signed int a2)
{
  signed int v2; // ST14_4@4
  signed int v3; // [sp+Ch] [bp-230h]@1
  int v4; // [sp+10h] [bp-22Ch]@1
  char v5[516]; // [sp+18h] [bp-224h]@3
  int v6; // [sp+21Ch] [bp-20h]@1

  v3 = a2;
  v4 = a1;
  v6 = 0;
  if ( a2 <= 256 )
  {
    v5[v6++] = 112;
    for ( v5[v6++] = 0; ; v5[v6++] = *(_BYTE *)v4++ )
    {
      v2 = v3--;
      if ( !v2 )
        break;
      if ( *(_BYTE *)v4 == 112 )
        v5[v6++] = 112;
    }
    v5[v6++] = 112;
    v5[v6++] = 1;
    while ( !write_buffer(v5, v6) )
      ForcePollSound();
  }
  else
  {
    LogStr("TOO LONG");
  }
}
// 464AB0: using guessed type char var_224[516];

//----- (00464BB0) --------------------------------------------------------
searchArray *__thiscall searchArray::searchArray(searchArray *this)
{
  this->field_2414 = 0;
  this->field_4 = 0;
  return this;
}

//----- (00464BC0) --------------------------------------------------------
void __thiscall searchArray::_searchArray(searchArray *this)
{
  searchArray *thisa; // esi@1
  void *v2; // ecx@1

  thisa = this;
  v2 = this->field_2414;
  if ( v2 )
    BaseFree(v2, (int)"F:\\h2xsrc\\Source\\FINDPATH.CPP", word_5124EC + 1);
  thisa->field_2414 = 0;
}
// 5124EC: using guessed type __int16 word_5124EC;

//----- (00464BF0) --------------------------------------------------------
void __thiscall searchArray::Init(searchArray *this)
{
  searchArray *thisa; // esi@1
  void *v2; // ecx@1

  thisa = this;
  v2 = this->field_2414;
  if ( v2 )
    BaseFree(v2, (int)"F:\\h2xsrc\\Source\\FINDPATH.CPP", word_5124EC + 1);
  thisa->field_2414 = 0;
  thisa->field_2414 = (PathfindingInfo *)BaseAlloc(
                                           9 * MAP_HEIGHT * MAP_WIDTH,
                                           "F:\\h2xsrc\\Source\\FINDPATH.CPP",
                                           word_5124C8 + 2);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5124C8: using guessed type __int16 word_5124C8;
// 5124EC: using guessed type __int16 word_5124EC;

//----- (00464C50) --------------------------------------------------------
void __thiscall searchArray::Close(searchArray *this)
{
  searchArray *thisa; // esi@1
  void *v2; // ecx@1

  thisa = this;
  v2 = this->field_2414;
  if ( v2 )
    BaseFree(v2, (int)"F:\\h2xsrc\\Source\\FINDPATH.CPP", word_5124EC + 1);
  thisa->field_2414 = 0;
}
// 5124EC: using guessed type __int16 word_5124EC;

//----- (00464C80) --------------------------------------------------------
int __thiscall searchArray::Clear(searchArray *this)
{
  int result; // eax@1

  result = 0;
  memset(this->mainDataStructure, 0, sizeof(this->mainDataStructure));
  memset(this->field_2414, 0, 9 * MAP_HEIGHT * MAP_WIDTH);
  this->field_8 = 0;
  this->field_0 = 0;
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (00464CC0) --------------------------------------------------------
// This is an odd but simple metric, best described by the source code. Its unit circle is an octogon.
int __stdcall searchArray::QuickDistance(int x1, int y1, int x2, int y2)
{
  signed int xDist; // esi@1
  signed int yDist; // eax@1
  int result; // eax@2

  xDist = abs(x1 - x2);
  yDist = abs(y1 - y2);
  if ( xDist < yDist )
    result = yDist + xDist / 2;
  else
    result = xDist + yDist / 2;
  return result;
}

//----- (00464D00) --------------------------------------------------------
int __fastcall CalcTerrainCost(signed int terrain, char a2, int mobility, int pathfinding, int fromRoad, int toRoad)
{
  int v6; // eax@1
  int result; // eax@2
  int v8; // edi@2

  v6 = 2 * (pathfinding + 4 * terrain);
  if ( giTerrainCost[0][v6 + 1] <= mobility )
  {
    v8 = fromRoad;
    goto LABEL_8;
  }
  result = giTerrainCost[0][v6];
  v8 = fromRoad;
  if ( result <= mobility )
    goto LABEL_5;
  if ( !fromRoad )
    return *(&giTerrainCost[0][2 * (pathfinding + 4 * terrain)] + (a2 & 1));
  if ( giTerrainCost[18][2 * pathfinding] > mobility )
  {
LABEL_8:
    if ( v8 && toRoad )
      terrain = 9;
    return *(&giTerrainCost[0][2 * (pathfinding + 4 * terrain)] + (a2 & 1));
  }
LABEL_5:
  if ( fromRoad )
    result = giTerrainCost[18][2 * pathfinding];
  return result;
}

//----- (00464D80) --------------------------------------------------------
char __thiscall searchArray::PushPoint(searchArray *this, int a2, int a3, int a4, signed int a5, signed int a6, char a7, int a8, char a9, char a10, int a11, char a12, char a13)
{
  int v13; // eax@1
  searchArray *thisa; // edi@1
  PathfindingInfo *v15; // eax@8
  char v16; // al@8
  int v17; // eax@14
  char *v18; // eax@14
  char v19; // cl@22
  void *v20; // ecx@24
  int v21; // edx@24

  LOBYTE(v13) = a6;
  thisa = this;
  if ( a6 >= a5 || a6 <= 0 )
  {
    if ( a2 >= 0 )
    {
      LOBYTE(v13) = MAP_WIDTH - 1;
      if ( MAP_WIDTH - 1 >= a2 )
      {
        LOBYTE(v13) = a3;
        if ( a3 >= 0 )
        {
          LOBYTE(v13) = MAP_HEIGHT - 1;
          if ( MAP_HEIGHT - 1 >= a3 )
          {
            v13 = this->field_0;
            if ( this->field_0 < 0x400u )
            {
              dword_526B94 = 0;
              dword_526B98 = v13;
              v15 = &this->field_2414[a2 + a3 * MAP_WIDTH];
              dword_526B78 = (int)v15;
              v16 = v15->field_4;
              if ( !(v16 & 1)
                || ((LOBYTE(v13) = v13 & 4, (_BYTE)v13) || !a8)
                && (*(_WORD *)(dword_526B78 + 2) > a5 || (_BYTE)v13 && (LOBYTE(v13) = a8, !a8)) )
              {
                while ( 1 )
                {
                  v17 = (dword_526B98 + dword_526B94) >> 1;
                  dword_526B90 = v17;
                  v18 = (char *)&this->mainDataStructure[v17];
                  Src = v18;
                  if ( dword_526B94 >= dword_526B98 )
                    break;
                  if ( *((_WORD *)v18 + 1) <= a5 )
                    dword_526B98 = dword_526B90;
                  else
                    dword_526B94 = dword_526B90 + 1;
                }
                if ( this->field_0 > (unsigned int)dword_526B90 )
                  memmove(
                    (void *)(this->field_0 - dword_526B90),
                    (int)Src,
                    (char *)Src + 9,
                    Src,
                    9 * (this->field_0 - dword_526B90));
                ++thisa->field_0;
                if ( a5 <= giCurTempMobility || a11 )
                {
                  *((_BYTE *)Src + 4) ^= (*((_BYTE *)Src + 4) ^ 8 * a11) & 8;
                  *((_BYTE *)Src + 7) = a12;
                  v19 = a4;
                  *((_BYTE *)Src + 8) = a13;
                }
                else
                {
                  *((_BYTE *)Src + 4) |= 8u;
                  v19 = a4;
                  *((_BYTE *)Src + 7) = a2 - normalDirTable[4 * a4];
                  *((_BYTE *)Src + 8) = a3 - byte_4F1DC1[4 * a4];
                }
                *(_BYTE *)Src = a2;
                *((_BYTE *)Src + 1) = a3;
                *((_BYTE *)Src + 4) = 16 * v19 ^ (16 * v19 ^ *((_BYTE *)Src + 4)) & 0xF;
                *((_WORD *)Src + 1) = a5;
                *((_BYTE *)Src + 4) ^= (*((_BYTE *)Src + 4) ^ 2 * a7) & 2;
                *((_BYTE *)Src + 4) ^= (*((_BYTE *)Src + 4) ^ 4 * a8) & 4;
                *((_BYTE *)Src + 5) = a9;
                *((_BYTE *)Src + 6) = a10;
                *((_BYTE *)Src + 4) |= 1u;
                v20 = Src;
                v21 = dword_526B78;
                v13 = *(_DWORD *)Src;
                *(_DWORD *)dword_526B78 = *(_DWORD *)Src;
                *(_DWORD *)(v21 + 4) = *((_DWORD *)v20 + 1);
                *(_BYTE *)(v21 + 8) = *((_BYTE *)v20 + 8);
              }
            }
          }
        }
      }
    }
  }
  return v13;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 524760: using guessed type int giCurTempMobility;
// 526B78: using guessed type int dword_526B78;
// 526B90: using guessed type int dword_526B90;
// 526B94: using guessed type int dword_526B94;
// 526B98: using guessed type int dword_526B98;

//----- (00464FF0) --------------------------------------------------------
signed int __thiscall searchArray::TestPossibleDirections(searchArray *this, __int64 a2, int a3, int a4, int a5, int a6)
{
  searchArray *v6; // ebp@1
  mapCell *v7; // eax@1
  int v8; // ecx@2
  signed int result; // eax@2
  char v10; // al@19
  char v11; // al@24
  char v12; // al@43

  *(_DWORD *)a4 = 0;
  v6 = this;
  *(_DWORD *)(a4 + 4) = 0;
  v7 = advManager::GetCell(gpAdvManager, a2, SHIDWORD(a2));
  dword_526B8C = 0;
  dword_526B9C = (int)v7;
  do
  {
    v8 = a2 + normalDirTable[4 * dword_526B8C];
    result = HIDWORD(a2) + byte_4F1DC1[4 * dword_526B8C];
    dword_526B88 = v8;
    ::a3 = result;
    if ( v8 < 0
      || (result = v8, MAP_WIDTH <= v8)
      || (result = ::a3, ::a3 < 0)
      || (result = MAP_HEIGHT, ::a3 >= MAP_HEIGHT)
      || (result = (signed int)advManager::GetCell(gpAdvManager, dword_526B88, ::a3),
          dword_526B80 = result,
          *(_BYTE *)(result + 8) & 8)
      || gbHumanPlayer[giCurPlayer]
      && (result = dword_526B88 + ::a3 * MAP_WIDTH,
          !((unsigned __int8)mapRevealed[result] & (unsigned __int8)giCurPlayerBit)) )
    {
LABEL_49:
      dword_526C18 = -1;
      goto LABEL_50;
    }
    if ( *(_BYTE *)(dword_526B80 + 9) & 0x80 )
    {
      if ( a5 )
      {
        *(_BYTE *)(dword_526B8C + a4) = 1;
      }
      else
      {
        result = dword_526B88;
        if ( *(_DWORD *)&v6->_1[0] != dword_526B88 )
          goto LABEL_49;
        result = ::a3;
        if ( *(_DWORD *)&v6->_1[4] != ::a3 )
          goto LABEL_49;
      }
    }
    dword_526C18 = (unsigned __int8)giGroundToTerrain[*(_WORD *)dword_526B80];
    if ( dword_526C18 )
    {
      if ( a6 )
      {
        result = dword_526B80;
        if ( *(_BYTE *)(dword_526B80 + 9) != 28 )
          goto LABEL_49;
      }
    }
    else
    {
      result = dword_526B80;
      if ( a6 )
      {
        if ( *(_BYTE *)(dword_526B80 + 9) == -85 )
          goto LABEL_49;
        if ( !giGroundToTerrain[*(_WORD *)dword_526B9C] )
        {
          v10 = normalDirTable[4 * dword_526B8C];
          if ( v10 )
          {
            if ( byte_4F1DC1[4 * dword_526B8C] )
            {
              result = (signed int)advManager::GetCell(gpAdvManager, a2 + v10, SHIDWORD(a2));
              if ( giGroundToTerrain[*(_WORD *)result] )
                goto LABEL_49;
              result = (signed int)advManager::GetCell(gpAdvManager, a2, HIDWORD(a2) + byte_4F1DC1[4 * dword_526B8C]);
              if ( giGroundToTerrain[*(_WORD *)result] )
                goto LABEL_49;
            }
          }
        }
      }
      else
      {
        v11 = *(_BYTE *)(dword_526B80 + 9);
        if ( v11 != -86 && v11 != -85 && v11 != -96 )
          goto LABEL_49;
      }
    }
    result = 1 << dword_526B8C;
    if ( (1 << dword_526B8C) & 0x83 )
    {
      if ( *(_BYTE *)(dword_526B9C + 3) != -1 )
      {
        if ( (*(_BYTE *)(dword_526B9C + 2) & 0xFC) != -68 )
        {
          result = dword_526B9C;
          if ( !(*(_BYTE *)(dword_526B9C + 8) & 0x80) )
            goto LABEL_49;
        }
      }
      result = dword_526B80;
      if ( *(_BYTE *)(dword_526B80 + 7) != -1 )
      {
        result = (signed int)advManager::GetCell(gpAdvManager, dword_526B88, ::a3 + 1);
        if ( *(_BYTE *)(result + 3) != -1 )
        {
          if ( (*(_BYTE *)(result + 2) & 0xFC) != -68 && !(*(_BYTE *)(result + 8) & 0x80) )
            goto LABEL_49;
        }
      }
    }
    else if ( result & 0x38 )
    {
      if ( *(_BYTE *)(dword_526B80 + 3) != -1 )
      {
        if ( (*(_BYTE *)(dword_526B80 + 2) & 0xFC) != -68 )
        {
          result = dword_526B80;
          if ( !(*(_BYTE *)(dword_526B80 + 8) & 0x80) )
          {
            v12 = *(_BYTE *)(dword_526B80 + 9);
            if ( !(v12 & 0x80) )
              goto LABEL_49;
            dword_526B84 = v12 & 0x7F;
            if ( !StopOnTrigger(dword_526B80) )
              goto LABEL_49;
          }
        }
      }
      result = dword_526B9C;
      if ( *(_BYTE *)(dword_526B9C + 7) != -1 )
      {
        result = (signed int)advManager::GetCell(gpAdvManager, a2, HIDWORD(a2) + 1);
        if ( *(_BYTE *)(result + 3) != -1 )
        {
          if ( (*(_BYTE *)(result + 2) & 0xFC) != -68 && !(*(_BYTE *)(result + 8) & 0x80) )
            goto LABEL_49;
        }
      }
    }
LABEL_50:
    LOBYTE(result) = dword_526C18;
    *(_BYTE *)(dword_526B8C++ + a3) = dword_526C18;
  }
  while ( dword_526B8C < 8 );
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 526B80: using guessed type int dword_526B80;
// 526B84: using guessed type int dword_526B84;
// 526B8C: using guessed type int dword_526B8C;
// 526B9C: using guessed type int dword_526B9C;
// 526C18: using guessed type int dword_526C18;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (00465370) --------------------------------------------------------
signed int __stdcall searchArray::SeedCombatPosition(army *stack)
{
  signed int v1; // eax@1
  int v2; // ebp@4
  signed int v3; // edi@4
  signed int v4; // edi@9
  int v5; // ebp@9
  int i; // edi@13
  int v7; // ecx@14
  char *v8; // ebx@14
  int v9; // ebp@14
  int v10; // ebx@20
  signed int result; // eax@25

  v1 = 0;
  do
  {
    v1 += 98;
    gpCombatManager->field_49F[v1 + 84] = 0;
  }
  while ( v1 < 11466 );
  if ( *(_DWORD *)&stack->creature.creature_flags & FLYER )
  {
    v2 = 0;
    v3 = 0;
    do
    {
      if ( army::CanFit(stack, v2, 0, 0) )
        gpCombatManager->combatGrid[v3].field_41 = 1;
      ++v3;
      ++v2;
    }
    while ( v3 < 117 );
  }
  else
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if ( army::ValidPath(stack, v5, 1) )
        gpCombatManager->combatGrid[v4].field_41 = 1;
      ++v4;
      ++v5;
    }
    while ( v4 < 117 );
  }
  for ( i = 0; gpCombatManager->numCreatures[-stack->owningSide + 1] > i; ++i )
  {
    v7 = i + -21 * stack->owningSide;
    v8 = (char *)&gpCombatManager->creatures[1][v7];
    stack->targetOwner = gpCombatManager->creatures[1][v7].owningSide;
    stack->targetStackIdx = *(_DWORD *)(v8 + 234);
    v9 = *(_DWORD *)(v8 + 122);
    if ( stack->creature.shots <= 0 || army::GetAttackMask(stack, stack->occupiedHex, 1, -1) != 255 )
    {
      if ( army::ValidPath(stack, v9, 1) == 1 )
        gpCombatManager->combatGrid[v9].field_41 = 1;
    }
    else
    {
      gpCombatManager->combatGrid[v9].field_41 = 1;
    }
    if ( *((_DWORD *)v8 + 52) & 1 )
    {
      if ( (v10 = army::GetAdjacentCellIndex((army *)v8, v9, (unsigned int)(*(_DWORD *)(v8 + 134) - 1) < 1 ? 1 : 4),
            stack->creature.shots > 0)
        && army::GetAttackMask(stack, stack->occupiedHex, 1, -1) == 255
        || army::ValidPath(stack, v10, 1) == 1 )
        gpCombatManager->combatGrid[v10].field_41 = 1;
    }
  }
  result = -1;
  stack->targetStackIdx = -1;
  stack->targetOwner = -1;
  return result;
}

//----- (00465560) --------------------------------------------------------
int __thiscall searchArray::FindCombatPath(searchArray *this, int sourceHex, int targHex, army *stack, int a5, int twoHexer)
{
  searchArray *thisa; // esi@1
  int othHex; // edx@2
  army *stacka; // ebp@2
  signed int deltaX; // ecx@3
  signed int row; // edi@4
  int moatHex; // ecx@5
  int v12; // eax@16
  int v13; // eax@22
  signed int v14; // edi@22
  char *v15; // ebx@23
  char *v16; // ecx@23
  __int64 v17; // qax@23
  __int64 v18; // qax@23
  signed int v19; // ecx@23
  int v20; // ebx@24
  int v21; // eax@27
  signed int v22; // ebx@30
  int v23; // eax@32
  int v24; // ecx@32
  signed int v25; // ecx@38
  int result; // eax@45
  signed int v27; // esi@47
  char v28; // dl@48
  int v29; // ebx@48
  int v30; // edx@52
  int v31; // eax@52
  int v32; // eax@53
  int v33; // [sp+10h] [bp-30h]@16
  char *v34; // [sp+18h] [bp-28h]@21
  signed int v35; // [sp+1Ch] [bp-24h]@23
  int availNeighborBmask; // [sp+1Ch] [bp-24h]@30
  int othTargetHex; // [sp+20h] [bp-20h]@2
  int othTargetHexa; // [sp+20h] [bp-20h]@22
  signed int minSomething; // [sp+2Ch] [bp-14h]@16
  int a4; // [sp+30h] [bp-10h]@18
  char v41[12]; // [sp+34h] [bp-Ch]@5

  thisa = this;
  memset(bIsMoatSlowed, 0, 116u);
  bIsMoatSlowed[116] = 0;
  if ( gpCombatManager->hasMoat )
  {
    othHex = -1;
    stacka = stack;
    othTargetHex = -1;
    if ( *(_DWORD *)&stack->creature.creature_flags & TWO_HEXER )
    {
      deltaX = (unsigned int)(stack->facingRight - 1) < 1 ? 1 : -1;
      othHex = deltaX + stack->occupiedHex;
      othTargetHex = deltaX + targHex;
    }
    row = 0;
    do
    {
      moatHex = moatCell[row];
      v41[row] = gpCombatManager->combatGrid[moatHex].isBlocked;
      if ( (row != 4 || gpCombatManager->drawBridgePosition == 4)
        && (targHex != moatHex && othTargetHex != moatHex || twoHexer)
        && stack->occupiedHex != moatHex
        && othHex != moatHex )
        bIsMoatSlowed[moatHex] = 1;
      ++row;
    }
    while ( row < 9 );
  }
  else
  {
    stacka = stack;
  }
  minSomething = 640;
  v33 = -1;
  v12 = targHex;
  if ( !a5 )
    v12 = -1;
  a4 = v12;
  memset(thisa->mainDataStructure, 0, sizeof(thisa->mainDataStructure));
  memset(thisa->field_2414, 0, 9 * MAP_HEIGHT * MAP_WIDTH);
  thisa->field_0 = 0;
  thisa->field_8 = 0;
  if ( !ValidHex(sourceHex) || !ValidHex(targHex) || !stacka )
  {
LABEL_45:
    result = 0;
    goto LABEL_46;
  }
  v34 = (char *)&thisa->field_2418;
  searchArray::PushCombatPoint(thisa, sourceHex, stacka->facingRight < 1u ? 4 : 1, 0, stacka->creature.speed);
  if ( !thisa->field_0 )
    goto LABEL_43;
  while ( 1 )
  {
    v13 = thisa->field_0 - 1;
    thisa->field_0 = v13;
    HIWORD(v14) = 0;
    othTargetHexa = *(_DWORD *)&thisa->mainDataStructure[v13].field_0;
    LOWORD(v14) = *(_DWORD *)&thisa->mainDataStructure[v13].field_0 >> 16;
    if ( stacka->creature.speed < v14 )
      goto LABEL_36;
    v15 = (char *)gpCombatManager + 98 * (unsigned __int8)othTargetHexa;
    v16 = (char *)gpCombatManager + 98 * targHex;
    v17 = (signed int)*((_WORD *)v15 + 650) - (signed int)*((_WORD *)v16 + 650);
    v35 = (HIDWORD(v17) ^ v17) - HIDWORD(v17);
    v18 = (signed int)*((_WORD *)v15 + 651) - (signed int)*((_WORD *)v16 + 651);
    v19 = (HIDWORD(v18) ^ v18) - HIDWORD(v18);
    v20 = v35 < v19 ? v19 + v35 / 2 : v19 / 2 + v35;
    if ( stacka->targetOwner != -1 )
    {
      v21 = army::GetAttackMask(stacka, (unsigned __int8)othTargetHexa, 0, a4);
      if ( v21 != 255 )
        break;
    }
    if ( v20 < minSomething )
    {
      minSomething = v20;
      v33 = (unsigned __int8)othTargetHexa;
      if ( !v20 )
        goto LABEL_43;
    }
    v22 = 0;
    availNeighborBmask = army::GetMoveMask(stacka, (unsigned __int8)othTargetHexa);
    do
    {
      if ( !((1 << v22) & availNeighborBmask) )
      {
        v23 = army::GetAdjacentCellIndex(stacka, (unsigned __int8)othTargetHexa, v22);
        v24 = 0;
        if ( bIsMoatSlowed[v23] )
          v24 = stacka->speed + 2;
        searchArray::PushCombatPoint(thisa, v23, v22, v14 + v24 + 1, stacka->creature.speed);
      }
      ++v22;
    }
    while ( v22 < 8 );
LABEL_36:
    if ( !thisa->field_0 )
      goto LABEL_43;
  }
  v25 = 0;
  while ( (1 << v25) & v21 )
  {
    ++v25;
    if ( v25 >= 8 )
      goto LABEL_43;
  }
  v34 = (char *)&thisa->field_2418 + 1;
  LOBYTE(thisa->field_2418) = v25;
  v33 = (unsigned __int8)othTargetHexa;
  ++thisa->field_8;
LABEL_43:
  if ( stacka->targetOwner == -1 )
  {
    if ( v33 == targHex )
      goto LABEL_51;
    goto LABEL_45;
  }
  if ( !thisa->field_8 )
    goto LABEL_45;
LABEL_51:
  while ( v33 != sourceHex )
  {
    v30 = (int)&thisa->field_2414[v33];
    ++v34;
    *(v34 - 1) = *(_BYTE *)(v30 + 4) >> 4;
    v31 = thisa->field_8 + 1;
    thisa->field_8 = v31;
    if ( v31 >= 256 )
      break;
    v32 = OppositeDirection((unsigned __int8)(*(_BYTE *)(v30 + 4) >> 4));
    v33 = army::GetAdjacentCellIndex(stacka, v33, v32);
  }
  result = thisa->field_8;
LABEL_46:
  if ( gpCombatManager->hasMoat )
  {
    v27 = 0;
    do
    {
      v28 = v41[v27];
      v29 = moatCell[v27++];
      gpCombatManager->combatGrid[v29].isBlocked = v28;
    }
    while ( v27 < 9 );
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 465560: using guessed type char var_C[12];

//----- (00465970) --------------------------------------------------------
void __thiscall searchArray::PushCombatPoint(searchArray *this, int sourceHex, char neighborIdx, signed int a4, signed int speed)
{
  searchArray *thisa; // edi@1
  int hi; // ebx@2
  int low; // ecx@2
  PathfindingInfo *v8; // ebp@4
  int mid; // eax@7
  PathfindingInfo *goalPInfo; // esi@7
  int v11; // ecx@13
  int v12; // eax@13
  char v13; // cl@15
  char v14; // al@15

  thisa = this;
  if ( ValidHex(sourceHex) )
  {
    hi = thisa->field_0;
    low = 0;
    if ( speed <= 0 || speed >= a4 )
    {
      v8 = &thisa->field_2414[sourceHex];
      if ( !(v8->field_4 & 1) || v8->field_2 > a4 )
      {
        if ( thisa->field_0 < 0x400u )
        {
          while ( 1 )
          {
            mid = (low + hi) / 2;
            goalPInfo = &thisa->mainDataStructure[mid];
            if ( hi <= low )
              break;
            if ( thisa->mainDataStructure[mid].field_2 <= a4 )
              hi = (low + hi) / 2;
            else
              low = mid + 1;
          }
          if ( (unsigned int)mid < thisa->field_0 )
            memmove(
              (void *)(thisa->field_0 - mid),
              (int)&thisa->mainDataStructure[mid + 1],
              &thisa->mainDataStructure[mid + 1],
              &thisa->mainDataStructure[mid],
              9 * (thisa->field_0 - mid));
          v11 = thisa->field_4;
          v12 = thisa->field_0 + 1;
          thisa->field_0 = v12;
          if ( v11 < (unsigned int)v12 )
            thisa->field_4 = v12;
          v13 = 16 * neighborIdx;
          goalPInfo->field_0 = sourceHex;
          goalPInfo->field_1 = 0;
          goalPInfo->field_4 = v13 ^ (v13 ^ goalPInfo->field_4) & 0xF;
          goalPInfo->field_2 = a4;
          v14 = v8->field_4 | 1;
          v8->field_4 = v14;
          v8->field_4 = v13 ^ (v14 ^ v13) & 0xF;
          v8->field_2 = a4;
        }
      }
    }
  }
}

//----- (00465A70) --------------------------------------------------------
signed int __thiscall combatManager::DoSpellAI(combatManager *this, int i, int a3)
{
  signed int result; // eax@2
  combatManager *thisa; // [sp+10h] [bp-20h]@1
  int potCasts; // [sp+14h] [bp-1Ch]@30
  Spell bestSpell; // [sp+18h] [bp-18h]@1
  int value; // [sp+1Ch] [bp-14h]@30
  Spell j; // [sp+20h] [bp-10h]@3
  int targetForBestSpell; // [sp+24h] [bp-Ch]@1
  int target; // [sp+28h] [bp-8h]@30
  int maxValue; // [sp+2Ch] [bp-4h]@1

  thisa = this;
  maxValue = 0;
  bestSpell = -1;
  targetForBestSpell = -1;
  if ( this->heroes[i] )
  {
    for ( j = 0; (signed int)j < 2; ++j )
    {
      if ( thisa->heroes[j] && hero::HasArtifact(thisa->heroes[j], 98) )
        return 0;
    }
    for ( j = 0; j < NUM_SPELLS; ++j )
    {
      if ( hero::HasSpell(thisa->heroes[i], j)
        && gsSpellInfo[j].attributes & ATTR_COMBAT_SPELL
        && GetManaCost(j, thisa->heroes[i]) <= thisa->heroes[i]->spellpoints
        && (!a3
         || j == SPELL_FIREBALL
         || j == SPELL_FIREBLAST
         || j == SPELL_LIGHTNING_BOLT
         || j == SPELL_CHAIN_LIGHTNING
         || j == SPELL_HOLY_WORD
         || j == SPELL_HOLY_SHOUT
         || j == SPELL_MAGIC_ARROW
         || j == SPELL_ARMAGEDDON
         || j == SPELL_ELEMENTAL_STORM
         || j == SPELL_METEOR_SHOWER
         || j == SPELL_COLD_RAY
         || j == SPELL_COLD_RING
         || j == SPELL_DEATH_RIPPLE
         || j == SPELL_DEATH_WAVE) )
      {
        combatManager::DetermineEffectOfSpell(thisa, j, &value, &target);
        potCasts = thisa->heroes[i]->spellpoints / GetManaCost(j, thisa->heroes[i]);
        if ( potCasts > 10 )
          potCasts = 10;
        value = (signed __int64)((double)value * gfSpellCastableCombatMod[potCasts]);
        if ( value > maxValue )
        {
          maxValue = value;
          bestSpell = j;
          targetForBestSpell = target;
        }
      }
    }
    if ( maxValue <= 0 )
    {
      result = 0;
    }
    else
    {
      giNextAction = 1;
      giNextActionExtra = bestSpell;
      giNextActionGridIndex = targetForBestSpell;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00465CF0) --------------------------------------------------------
void __thiscall combatManager::DetermineEffectOfSpell(combatManager *this, Spell spell, int *value, int *target)
{
  int durationBenefitIdx; // eax@27
  int v5; // ST94_4@53
  double v6; // st7@54
  int v7; // ecx@54
  int v8; // ST88_4@61
  double v9; // st7@62
  int v10; // ecx@62
  int v11; // ST7C_4@69
  double v12; // st7@70
  int v13; // ecx@70
  int v14; // ST70_4@77
  double v15; // st7@78
  int v16; // ecx@78
  int v17; // ST64_4@85
  double v18; // st7@86
  int v19; // ecx@86
  int v20; // eax@93
  double v21; // st7@94
  int v22; // ecx@94
  int v23; // ST4C_4@102
  int v24; // ST48_4@106
  int v25; // ST3C_4@116
  int v26; // ST30_4@126
  int v27; // ST2C_4@129
  int v28; // ST24_4@139
  int v29; // ST20_4@143
  int v30; // ST1C_4@147
  combatManager *thisa; // [sp+9Ch] [bp-44h]@1
  signed int v32; // [sp+A0h] [bp-40h]@151
  int v33; // [sp+A4h] [bp-3Ch]@102
  int duration; // [sp+A8h] [bp-38h]@23
  int val; // [sp+ACh] [bp-34h]@21
  int incapacitated; // [sp+B0h] [bp-30h]@21
  int targetSide; // [sp+B4h] [bp-2Ch]@1
  float durBenefit; // [sp+B8h] [bp-28h]@1
  int v39; // [sp+BCh] [bp-24h]@1
  int underMyControl; // [sp+C0h] [bp-20h]@21
  army *potTarg; // [sp+C4h] [bp-1Ch]@1
  AI_SPELL_TYPES aiSpellType; // [sp+C8h] [bp-18h]@2
  int i; // [sp+D0h] [bp-10h]@151
  int targetHex; // [sp+D4h] [bp-Ch]@1
  bool targSpentTurn; // [sp+D8h] [bp-8h]@1
  int hex; // [sp+DCh] [bp-4h]@1

  thisa = this;
  targetHex = 0;
  targetSide = 0;
  hex = 1;
  durBenefit = 1.0;
  targSpentTurn = 1;
  v39 = 0;
  potTarg = 0;
  *value = 0;
  switch ( spell )
  {
    case SPELL_MASS_CURE:
    case SPELL_HOLY_WORD:
    case SPELL_HOLY_SHOUT:
    case SPELL_MASS_DISPEL:
    case SPELL_ARMAGEDDON:
    case SPELL_ELEMENTAL_STORM:
    case SPELL_DEATH_RIPPLE:
    case SPELL_DEATH_WAVE:
    case SPELL_SUMMON_EARTH_ELEMENTAL:
    case SPELL_SUMMON_AIR_ELEMENTAL:
    case SPELL_SUMMON_FIRE_ELEMENTAL:
    case SPELL_SUMMON_WATER_ELEMENTAL:
    case SPELL_EARTHQUAKE:
      aiSpellType = AI_BATTLEFIELD_AFFECTING_SPELL;
      goto LABEL_12;
    case SPELL_FIREBALL:
    case SPELL_FIREBLAST:
    case SPELL_METEOR_SHOWER:
    case SPELL_COLD_RING:
      aiSpellType = AI_BALL_SPALL;
      goto LABEL_12;
    case SPELL_MASS_HASTE:
    case SPELL_MASS_BLESS:
    case SPELL_MASS_SHIELD:
      aiSpellType = AI_MASS_BUFF_SPELL;
      targetSide = this->currentActionSide;
      goto LABEL_12;
    case SPELL_MASS_SLOW:
    case SPELL_MASS_CURSE:
      aiSpellType = AI_MASS_DEBUFF_SPELL;
      targetSide = 1 - this->currentActionSide;
      goto LABEL_12;
    case SPELL_DISPEL_MAGIC:
      aiSpellType = AI_DISPEL_SPELL;
      targetSide = 2;
      goto LABEL_12;
    case SPELL_TELEPORT:
    case SPELL_CURE:
    case SPELL_HASTE:
    case SPELL_BLESS:
    case SPELL_STONESKIN:
    case SPELL_STEELSKIN:
    case SPELL_ANTI_MAGIC:
    case SPELL_DRAGON_SLAYER:
    case SPELL_BLOOD_LUST:
    case SPELL_MIRROR_IMAGE:
    case SPELL_SHIELD:
      aiSpellType = AI_TARGET_BUFF_SPELL;
      targetSide = this->currentActionSide;
      goto LABEL_12;
    case SPELL_RESURRECT:
    case SPELL_RESURRECT_TRUE:
    case SPELL_ANIMATE_DEAD:
      aiSpellType = AI_RESURRECT_SPELL;
      targetSide = this->currentActionSide;
      goto LABEL_12;
    case SPELL_LIGHTNING_BOLT:
    case SPELL_CHAIN_LIGHTNING:
    case SPELL_SLOW:
    case SPELL_BLIND:
    case SPELL_CURSE:
    case SPELL_MAGIC_ARROW:
    case SPELL_BERZERKER:
    case SPELL_PARALYZE:
    case SPELL_HYPNOTIZE:
    case SPELL_COLD_RAY:
    case SPELL_DISRUPTING_RAY:
      aiSpellType = AI_TARGET_DAMAGE_OR_DEBUFF_SPELL;
      targetSide = 1 - this->currentActionSide;
LABEL_12:
      if ( aiSpellType == AI_RESURRECT_SPELL )
        targetHex = combatManager::FirstResurrectable(this, 1, &hex, spell);
      if ( aiSpellType == AI_TARGET_BUFF_SPELL
        || aiSpellType == AI_TARGET_DAMAGE_OR_DEBUFF_SPELL
        || aiSpellType == AI_MASS_DEBUFF_SPELL
        || aiSpellType == AI_MASS_BUFF_SPELL
        || aiSpellType == AI_DISPEL_SPELL )
        targetHex = combatManager::FirstArmy(thisa, 1, targetSide, &hex);
      while ( 2 )
      {
        if ( !targetHex )
        {
          incapacitated = 0;
          underMyControl = 0;
          val = 0;
          if ( thisa->combatGrid[hex].stackIdx < 0 || thisa->combatGrid[hex].unitOwner < 0 )
          {
            potTarg = 0;
          }
          else
          {
            potTarg = &thisa->creatures[thisa->combatGrid[hex].unitOwner][thisa->combatGrid[hex].stackIdx];
            giCurrSpellGroup = thisa->combatGrid[hex].unitOwner;
            targSpentTurn = (potTarg->creature.creature_flags & MAYBE_NOT_LOST_TURN) != 0;
            duration = thisa->heroSpellpowers[thisa->currentActionSide];
            if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 42) )
              duration += 2;
            if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 66) )
              duration += 10;
            durationBenefitIdx = duration - targSpentTurn;
            if ( duration - targSpentTurn >= 10 )
              durationBenefitIdx = 10;
            durBenefit = durationBenefit[durationBenefitIdx];
            if ( potTarg->effectStrengths[7] || potTarg->effectStrengths[5] )
              underMyControl = 1;
            if ( potTarg->effectStrengths[2] || potTarg->effectStrengths[6] || potTarg->effectStrengths[11] )
              incapacitated = 1;
          }
          switch ( spell )
          {
            case SPELL_CURE:
              combatManager::EffectSpellCure(thisa, &val, thisa->currentActionSide, hex, 1);
              goto LABEL_171;
            case SPELL_MASS_CURE:
              combatManager::EffectSpellCure(thisa, &val, thisa->currentActionSide, -1, 1);
              goto LABEL_171;
            case SPELL_DISPEL_MAGIC:
              combatManager::EffectSpellCure(thisa, &val, potTarg->owningSide, potTarg->stackIdx, 0);
              goto LABEL_171;
            case SPELL_MASS_DISPEL:
              combatManager::EffectSpellCure(thisa, &val, 2, -1, 0);
              goto LABEL_171;
            case SPELL_RESURRECT:
            case SPELL_RESURRECT_TRUE:
            case SPELL_ANIMATE_DEAD:
              if ( !underMyControl )
                combatManager::EffectSpellResurrect(thisa, &val, hex, spell);
              goto LABEL_171;
            case SPELL_MIRROR_IMAGE:
            case SPELL_SUMMON_EARTH_ELEMENTAL:
            case SPELL_SUMMON_AIR_ELEMENTAL:
            case SPELL_SUMMON_FIRE_ELEMENTAL:
            case SPELL_SUMMON_WATER_ELEMENTAL:
              val = combatManager::EffectSpellCreateCreature(thisa, hex, spell);
              goto LABEL_171;
            case SPELL_FIREBALL:
            case SPELL_FIREBLAST:
            case SPELL_LIGHTNING_BOLT:
            case SPELL_CHAIN_LIGHTNING:
            case SPELL_HOLY_WORD:
            case SPELL_HOLY_SHOUT:
            case SPELL_MAGIC_ARROW:
            case SPELL_ARMAGEDDON:
            case SPELL_ELEMENTAL_STORM:
            case SPELL_METEOR_SHOWER:
            case SPELL_COLD_RAY:
            case SPELL_COLD_RING:
            case SPELL_DISRUPTING_RAY:
            case SPELL_DEATH_RIPPLE:
            case SPELL_DEATH_WAVE:
              if ( !underMyControl )
              {
                combatManager::EffectSpellDamage(thisa, &val, spell, hex);
                if ( incapacitated )
                  val = (signed __int64)((double)val * 0.5);
              }
              goto LABEL_171;
            case SPELL_HASTE:
            case SPELL_MASS_HASTE:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[0] )
                  {
                    v5 = combatManager::RawEffectSpellInfluence(thisa, potTarg, 0);
                    val = (signed __int64)((double)v5 * durBenefit);
                    if ( potTarg->effectStrengths[1] )
                    {
                      v6 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_SLOW);
                      v7 = targSpentTurn + potTarg->effectStrengths[1];
                      if ( v7 >= 10 )
                        v7 = 10;
                      val = (signed __int64)((double)val - v6 * heuristicModifierForDuration[v7]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_BERZERKER:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[5] )
                  {
                    v8 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BERSERKER);
                    val = (signed __int64)((double)v8 * durBenefit);
                    if ( potTarg->effectStrengths[7] )
                    {
                      v9 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_HYPNOTIZE);
                      v10 = targSpentTurn + potTarg->effectStrengths[7];
                      if ( v10 >= 10 )
                        v10 = 10;
                      val = (signed __int64)((double)val - v9 * heuristicModifierForDuration[v10]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_HYPNOTIZE:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[7] )
                  {
                    v11 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_HYPNOTIZE);
                    val = (signed __int64)((double)v11 * durBenefit);
                    if ( potTarg->effectStrengths[5] )
                    {
                      v12 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BERSERKER);
                      v13 = targSpentTurn + potTarg->effectStrengths[5];
                      if ( v13 >= 10 )
                        v13 = 10;
                      val = (signed __int64)((double)val - v12 * heuristicModifierForDuration[v13]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_SLOW:
            case SPELL_MASS_SLOW:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[1] )
                  {
                    v14 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_SLOW);
                    val = (signed __int64)((double)v14 * durBenefit);
                    if ( potTarg->effectStrengths[0] )
                    {
                      v15 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, 0);
                      v16 = targSpentTurn + potTarg->effectStrengths[0];
                      if ( v16 >= 10 )
                        v16 = 10;
                      val = (signed __int64)((double)val - v15 * heuristicModifierForDuration[v16]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_BLESS:
            case SPELL_MASS_BLESS:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[3] )
                  {
                    v17 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BLESS);
                    val = (signed __int64)((double)v17 * durBenefit);
                    if ( potTarg->effectStrengths[4] )
                    {
                      v18 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_CURSE);
                      v19 = targSpentTurn + potTarg->effectStrengths[4];
                      if ( v19 >= 10 )
                        v19 = 10;
                      val = (signed __int64)((double)val - v18 * heuristicModifierForDuration[v19]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_CURSE:
            case SPELL_MASS_CURSE:
              if ( !incapacitated )
              {
                if ( !underMyControl )
                {
                  if ( !potTarg->effectStrengths[4] )
                  {
                    v20 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_CURSE);
                    val = (signed __int64)((double)-v20 * durBenefit);
                    if ( potTarg->effectStrengths[3] )
                    {
                      v21 = (double)combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BLESS);
                      v22 = targSpentTurn + potTarg->effectStrengths[3];
                      if ( v22 >= 10 )
                        v22 = 10;
                      val = (signed __int64)((double)val - v21 * heuristicModifierForDuration[v22]);
                    }
                  }
                }
              }
              goto LABEL_171;
            case SPELL_ANTI_MAGIC:
              if ( !potTarg->effectStrengths[12] )
              {
                if ( spell != 22 || thisa->heroes[1 - thisa->currentActionSide] )
                {
                  v23 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_ANTI_MAGIC);
                  val = (signed __int64)((double)v23 * durBenefit);
                  combatManager::EffectSpellCure(thisa, &v33, potTarg->owningSide, potTarg->stackIdx, 0);
                  val += v33;
                }
                else
                {
                  val = 0;
                }
              }
              goto LABEL_171;
            case SPELL_STONESKIN:
              if ( !underMyControl && !potTarg->effectStrengths[13] && !potTarg->effectStrengths[14] )
              {
                v24 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_STONESKIN);
                val = (signed __int64)((double)v24 * durBenefit);
                if ( thisa->castles[1] && !potTarg->owningSide && potTarg->creature.creature_flags & SHOOTER )
                  val = (signed __int64)((double)val * 1.5);
                if ( incapacitated )
                  val = (signed __int64)((double)val * 0.5);
              }
              goto LABEL_171;
            case SPELL_STEELSKIN:
              if ( !underMyControl && !potTarg->effectStrengths[13] && !potTarg->effectStrengths[14] )
              {
                v25 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_STEELSKIN);
                val = (signed __int64)((double)v25 * durBenefit);
                if ( thisa->castles[1] && !potTarg->owningSide && potTarg->creature.creature_flags & 4 )
                  val = (signed __int64)((double)val * 1.5);
                if ( incapacitated )
                  val = (signed __int64)((double)val * 0.5);
              }
              goto LABEL_171;
            case SPELL_BLOOD_LUST:
              if ( !incapacitated && !underMyControl && !potTarg->effectStrengths[9] )
              {
                v26 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BLOOD_LUST);
                val = (signed __int64)((double)v26 * durBenefit);
              }
              goto LABEL_171;
            case SPELL_SHIELD:
            case SPELL_MASS_SHIELD:
              if ( !underMyControl && !potTarg->effectStrengths[10] )
              {
                v27 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_SHIELD);
                val = (signed __int64)((double)v27 * durBenefit);
                if ( thisa->castles[1] && !potTarg->owningSide && potTarg->creature.creature_flags & 4 )
                  val *= 2;
                if ( incapacitated )
                  val = (signed __int64)((double)val * 0.5);
              }
              goto LABEL_171;
            case SPELL_BLIND:
              if ( !incapacitated && !underMyControl && !potTarg->effectStrengths[2] )
              {
                v28 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_BLIND);
                val = (signed __int64)((double)v28 * durBenefit);
              }
              goto LABEL_171;
            case SPELL_PARALYZE:
              if ( !incapacitated && !underMyControl && !potTarg->effectStrengths[6] )
              {
                v29 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_PARALYZE);
                val = (signed __int64)((double)v29 * durBenefit);
              }
              goto LABEL_171;
            case SPELL_DRAGON_SLAYER:
              if ( !incapacitated && !underMyControl && !potTarg->effectStrengths[8] )
              {
                v30 = combatManager::RawEffectSpellInfluence(thisa, potTarg, EFFECT_DRAGON_SLAYER);
                val = (signed __int64)((double)v30 * durBenefit);
              }
              goto LABEL_171;
            case SPELL_TELEPORT:
              val = 0;
              goto LABEL_171;
            case SPELL_EARTHQUAKE:
              if ( thisa->currentActionSide || !thisa->isCastleBattle )
              {
                val = 0;
              }
              else
              {
                v32 = 0;
                for ( i = 0; i < 4; ++i )
                {
                  if ( thisa->wallStatus[i] == 2 || thisa->wallStatus[i] == 6 )
                    ++v32;
                }
                if ( v32 )
                {
                  if ( v32 >= 4 )
                    val = 0;
                  else
                    val = 100 * (4 - v32);
                }
                else
                {
                  val = 29999;
                }
              }
LABEL_171:
              switch ( aiSpellType )
              {
                case AI_MASS_BUFF_SPELL:
                case AI_MASS_DEBUFF_SPELL:
                  v39 += val;
                  break;
                case AI_BATTLEFIELD_AFFECTING_SPELL:
                case AI_BALL_SPALL:
                case AI_TARGET_BUFF_SPELL:
                case AI_TARGET_DAMAGE_OR_DEBUFF_SPELL:
                case AI_RESURRECT_SPELL:
                case AI_DISPEL_SPELL:
                  v39 = val;
                  break;
                default:
                  break;
              }
              if ( aiSpellType == AI_MASS_BUFF_SPELL || aiSpellType == AI_MASS_DEBUFF_SPELL || *value < v39 )
              {
                *value = v39;
                *target = hex;
              }
              switch ( aiSpellType )
              {
                case AI_BATTLEFIELD_AFFECTING_SPELL:
                  targetHex = 1;
                  break;
                case AI_MASS_BUFF_SPELL:
                case AI_MASS_DEBUFF_SPELL:
                case AI_TARGET_BUFF_SPELL:
                case AI_TARGET_DAMAGE_OR_DEBUFF_SPELL:
                case AI_DISPEL_SPELL:
                  targetHex = combatManager::FirstArmy(thisa, hex + 1, targetSide, &hex);
                  break;
                case AI_RESURRECT_SPELL:
                  targetHex = combatManager::FirstResurrectable(thisa, hex + 1, &hex, spell);
                  break;
                case AI_BALL_SPALL:
                  combatManager::NextPos(&hex);
                  if ( hex > 43 )
                    targetHex = 1;
                  break;
                default:
                  continue;
              }
              continue;
            default:
              *value = 0;
              break;
          }
        }
        break;
      }
      break;
    default:
      *value = 0;
      break;
  }
}
// 526C20: using guessed type int giCurrSpellGroup;

//----- (00466E50) --------------------------------------------------------
int __thiscall combatManager::EffectSpellCreateCreature(combatManager *this, int hex, Spell spell)
{
  signed __int64 v3; // qax@12
  combatManager *thisa; // [sp+1Ch] [bp-18h]@1
  float durationModifier; // [sp+20h] [bp-14h]@22
  float chance; // [sp+24h] [bp-10h]@1
  int v8; // [sp+28h] [bp-Ch]@20
  int creature; // [sp+2Ch] [bp-8h]@14

  thisa = this;
  chance = 1.0;
  if ( (spell == SPELL_SUMMON_EARTH_ELEMENTAL
     || spell == SPELL_SUMMON_AIR_ELEMENTAL
     || spell == SPELL_SUMMON_FIRE_ELEMENTAL
     || spell == SPELL_SUMMON_WATER_ELEMENTAL)
    && this->heroes[this->currentActionSide] )
    hero::HasArtifact(this->heroes[this->currentActionSide], 53);
  if ( spell != SPELL_SUMMON_EARTH_ELEMENTAL
    && spell != SPELL_SUMMON_AIR_ELEMENTAL
    && spell != SPELL_SUMMON_FIRE_ELEMENTAL
    && spell != SPELL_SUMMON_WATER_ELEMENTAL
    || combatManager::SpaceForElementalExists(thisa) )
  {
    switch ( spell )
    {
      case SPELL_SUMMON_EARTH_ELEMENTAL:
        creature = CREATURE_EARTH_ELEMENTAL;
        break;
      case SPELL_SUMMON_AIR_ELEMENTAL:
        creature = CREATURE_AIR_ELEMENTAL;
        break;
      case SPELL_SUMMON_FIRE_ELEMENTAL:
        creature = CREATURE_FIRE_ELEMENTAL;
        break;
      case SPELL_SUMMON_WATER_ELEMENTAL:
        creature = CREATURE_WATER_ELEMENTAL;
        break;
      default:
        chance = army::SpellCastWorkChance(
                   &thisa->creatures[thisa->combatGrid[hex].unitOwner][thisa->combatGrid[hex].stackIdx],
                   SPELL_MIRROR_IMAGE);
        creature = thisa->creatures[thisa->combatGrid[hex].unitOwner][thisa->combatGrid[hex].stackIdx].creatureIdx;
        break;
    }
    v8 = creature * gMonsterDatabase[creature].fight_value;
    if ( spell == SPELL_MIRROR_IMAGE )
    {
      if ( thisa->heroSpellpowers[thisa->currentActionSide] == 1 )
      {
        durationModifier = 0.16;
      }
      else if ( thisa->heroSpellpowers[thisa->currentActionSide] == 2 )
      {
        durationModifier = 0.2;
      }
      else
      {
        durationModifier = 0.22;
      }
      v8 = (signed __int64)((double)v8 * durationModifier);
      if ( gMonsterDatabase[creature].creature_flags & SHOOTER )
        v8 = (signed __int64)((double)v8 * 1.4);
    }
    v3 = (signed __int64)((double)v8 * chance);
  }
  else
  {
    LODWORD(v3) = 0;
  }
  return v3;
}

//----- (004671A0) --------------------------------------------------------
int __thiscall combatManager::RawEffectSpellInfluence(combatManager *this, army *stack, STACK_MODIFYING_EFFECT eff)
{
  __int16 v3; // fps@1
  unsigned __int8 v4; // c0@1
  unsigned __int8 v5; // c3@1
  int result; // eax@2
  __int16 v7; // fps@24
  unsigned __int8 v8; // c0@24
  unsigned __int8 v9; // c3@24
  float v10; // STA0_4@31
  __int16 v11; // fps@62
  unsigned __int8 v12; // c0@62
  unsigned __int8 v13; // c3@62
  combatManager *thisa; // [sp+64h] [bp-58h]@1
  float v15; // [sp+68h] [bp-54h]@30
  signed int numDragons; // [sp+70h] [bp-4Ch]@42
  signed int numShooters; // [sp+78h] [bp-44h]@55
  signed int v18; // [sp+7Ch] [bp-40h]@42
  signed int v19; // [sp+80h] [bp-3Ch]@28
  int v19a; // [sp+80h] [bp-3Ch]@67
  int speedWithEffect; // [sp+88h] [bp-34h]@4
  float chance; // [sp+90h] [bp-2Ch]@1
  int i; // [sp+9Ch] [bp-20h]@42
  int j; // [sp+9Ch] [bp-20h]@55
  int fightValue; // [sp+A0h] [bp-1Ch]@3
  int hexXCoord; // [sp+A4h] [bp-18h]@14
  float avgDamage; // [sp+A8h] [bp-14h]@29
  float currentTurnsToOtherSide; // [sp+ACh] [bp-10h]@22
  float v29; // [sp+B0h] [bp-Ch]@52
  float v30; // [sp+B0h] [bp-Ch]@60
  int distFromOptimalColumn; // [sp+B4h] [bp-8h]@15
  int adjustedDistFromOtherSide; // [sp+B4h] [bp-8h]@19
  float turnsToOtherSideAfterCast; // [sp+B8h] [bp-4h]@24

  thisa = this;
  UNDEF(v3);
  chance = army::SpellCastWorkChance(stack, (Spell)giSpellInfluenceToSpell[eff]);
  if ( v4 | v5 )
  {
    result = 0;
  }
  else
  {
    fightValue = stack->quantity * stack->creature.fight_value;
    switch ( eff )
    {
      case EFFECT_SLOW:
        speedWithEffect = (stack->creature.speed + 1) >> 1;
        goto LABEL_7;
      case EFFECT_HASTE:
        speedWithEffect = stack->creature.speed + 2;
        if ( stack->creature.creature_flags & FLYER )
        {
          result = 0;
        }
        else
        {
LABEL_7:
          if ( thisa->isCastleBattle && stack->owningSide == 1 )
          {
            result = 0;
          }
          else if ( stack->creature.creature_flags & SHOOTER )
          {
            result = 0;
          }
          else if ( army::GetAttackMask(stack, stack->occupiedHex, 1, -1) == 255 )
          {
            hexXCoord = stack->occupiedHex % 13;
            if ( thisa->currentActionSide )
              distFromOptimalColumn = 10 - hexXCoord;
            else
              distFromOptimalColumn = hexXCoord - 2;
            if ( distFromOptimalColumn < 0 )
              distFromOptimalColumn = 0;
            adjustedDistFromOtherSide = distFromOptimalColumn + 2;
            if ( thisa->isCastleBattle )
              adjustedDistFromOtherSide += 3;
            if ( stack->creature.creature_flags & FLYER )
              currentTurnsToOtherSide = 1.0;
            else
              currentTurnsToOtherSide = (double)adjustedDistFromOtherSide / (double)stack->creature.speed;
            UNDEF(v7);
            turnsToOtherSideAfterCast = (double)adjustedDistFromOtherSide / (double)speedWithEffect;
            if ( !(v8 | v9) )
              turnsToOtherSideAfterCast = 7.0;
            if ( currentTurnsToOtherSide > 7.0 )
              currentTurnsToOtherSide = 7.0;
            v19 = (signed __int64)((currentTurnsToOtherSide - turnsToOtherSideAfterCast) / 10.0 * (double)fightValue);
LABEL_67:
            v19a = (signed __int64)((double)v19 * chance);
            if ( stack->effectStrengths[5] || stack->effectStrengths[7] )
            {
              if ( eff != EFFECT_ANTI_MAGIC )
                v19a = 0;
            }
            result = v19a;
          }
          else
          {
            result = 0;
          }
        }
        break;
      case EFFECT_BLESS:
      case EFFECT_CURSE:
        avgDamage = ((double)stack->creature.min_damage + (double)stack->creature.max_damage) * 0.5;
        if ( eff == EFFECT_BLESS )
        {
          v15 = ((double)stack->creature.max_damage - avgDamage) / avgDamage * (double)fightValue * 0.45;
        }
        else
        {
          v10 = ((double)stack->creature.max_damage - avgDamage) / avgDamage * (double)fightValue * 0.45;
          v15 = -v10;
        }
        v19 = (signed __int64)v15;
        goto LABEL_67;
      case EFFECT_BLIND:
        v19 = (signed __int64)((double)fightValue * 0.40000001);
        goto LABEL_67;
      case EFFECT_BERSERKER:
        v19 = (signed __int64)((double)fightValue * 0.55000001);
        goto LABEL_67;
      case EFFECT_PARALYZE:
        v19 = (signed __int64)((double)fightValue * 0.5);
        goto LABEL_67;
      case EFFECT_HYPNOTIZE:
        v19 = (signed __int64)((double)fightValue * 0.64999998);
        goto LABEL_67;
      case EFFECT_BLOOD_LUST:
        v19 = (signed __int64)((double)fightValue * 0.14);
        goto LABEL_67;
      case EFFECT_PETRIFY:
        v19 = (signed __int64)((double)fightValue * 0.25);
        goto LABEL_67;
      case EFFECT_STONESKIN:
        v19 = (signed __int64)((double)fightValue * 0.16);
        goto LABEL_67;
      case EFFECT_STEELSKIN:
        v19 = (signed __int64)((double)fightValue * 0.28);
        goto LABEL_67;
      case EFFECT_ANTI_MAGIC:
        v19 = (signed __int64)((double)fightValue * 0.2);
        goto LABEL_67;
      case EFFECT_DRAGON_SLAYER:
        v18 = 0;
        numDragons = 0;
        for ( i = 0; thisa->numCreatures[1 - stack->owningSide] > i; ++i )
        {
          if ( thisa->creatures[stack->owningSide][i].creatureIdx == CREATURE_GREEN_DRAGON
            || thisa->creatures[stack->owningSide][i].creatureIdx == CREATURE_RED_DRAGON
            || thisa->creatures[stack->owningSide][i].creatureIdx == CREATURE_BLACK_DRAGON
            || thisa->creatures[stack->owningSide][i].creatureIdx == CREATURE_BONE_DRAGON )
          {
            ++numDragons;
            if ( army::OtherArmyAdjacent(
                   stack,
                   thisa->creatures[stack->owningSide][i].owningSide,
                   thisa->creatures[stack->owningSide][i].stackIdx) )
              v18 = 1;
          }
        }
        if ( v18 )
          v29 = 1.0;
        else
          v29 = (double)(numDragons / thisa->numCreatures[1 - stack->owningSide]);
        v19 = (signed __int64)(0.28 * v29);
        goto LABEL_67;
      case EFFECT_SHIELD:
        numShooters = 0;
        for ( j = 0; thisa->numCreatures[1 - stack->owningSide] > j; ++j )
        {
          if ( thisa->creatures[stack->owningSide][j].creature.creature_flags & SHOOTER )
            ++numShooters;
        }
        v30 = (double)(numShooters / thisa->numCreatures[1 - stack->owningSide]);
        if ( !stack->owningSide )
        {
          if ( thisa->isCastleBattle )
          {
            UNDEF(v11);
            v30 = v30 + 0.3;
            if ( !(v12 | v13) )
              v30 = 1.0;
          }
        }
        v19 = (signed __int64)(0.44999999 * v30);
        goto LABEL_67;
      default:
        v19 = 0;
        goto LABEL_67;
    }
  }
  return result;
}
/* Orphan comments:
if(turnsToOtherSideAfterCast > 7.0)
*/

//----- (00467880) --------------------------------------------------------
int __cdecl combatManager::ClearEffects()
{
  int result; // eax@5
  signed int i; // [sp+10h] [bp-8h]@1
  spellpower_offset j; // [sp+14h] [bp-4h]@3

  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; j < MAX_STACKS; ++j )
    {
      result = 20 * i;
      gArmyEffected[i][j] = 0;
    }
  }
  return result;
}

//----- (004678F0) --------------------------------------------------------
void __stdcall combatManager::NextPos(int *hexIdx)
{
  if ( (*hexIdx + 2) % 13 )
    ++*hexIdx;
  else
    *hexIdx += 3;
}

//----- (00467930) --------------------------------------------------------
signed int __thiscall combatManager::FirstArmy(combatManager *this, int startHex, int side, int *resultHex)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  while ( startHex <= 115 )
  {
    if ( thisa->combatGrid[startHex].unitOwner == side || side == 2 && thisa->combatGrid[startHex].unitOwner >= 0 )
    {
      *resultHex = startHex;
      return 0;
    }
    combatManager::NextPos(&startHex);
  }
  *resultHex = -1;
  return 1;
}

//----- (004679E0) --------------------------------------------------------
signed int __thiscall combatManager::FirstResurrectable(combatManager *this, int startHex, int *resultHex, Spell spell)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  while ( startHex <= 115 )
  {
    if ( combatManager::FindResurrectArmyIndex(thisa, thisa->currentActionSide, spell, startHex) != -1 )
    {
      *resultHex = startHex;
      return 0;
    }
    combatManager::NextPos(&startHex);
  }
  *resultHex = -1;
  return 1;
}

//----- (00467A60) --------------------------------------------------------
void __thiscall combatManager::EffectSpellCure(combatManager *this, int *val, int side, int hex, int isCure)
{
  double v5; // st7@24
  int v6; // edx@24
  double v7; // st7@27
  int v8; // edx@27
  double v9; // st7@30
  int v10; // edx@30
  combatManager *thisa; // [sp+38h] [bp-30h]@1
  int dam; // [sp+40h] [bp-28h]@14
  int curSide; // [sp+44h] [bp-24h]@2
  STACK_MODIFYING_EFFECT eff; // [sp+48h] [bp-20h]@19
  army *stack; // [sp+4Ch] [bp-1Ch]@13
  signed int i; // [sp+50h] [bp-18h]@5
  signed int removingPosEffectVal; // [sp+58h] [bp-10h]@5
  signed int done; // [sp+5Ch] [bp-Ch]@1
  int removingNegEffectVal; // [sp+60h] [bp-8h]@5
  bool lostTurn; // [sp+64h] [bp-4h]@17

  thisa = this;
  *val = 0;
  done = 0;
  if ( side == 2 )
    curSide = this->currentActionSide;
  else
    curSide = side;
  while ( !done )
  {
    removingPosEffectVal = 0;
    removingNegEffectVal = 0;
    for ( i = 0; i < 20; ++i )
    {
      if ( (hex == -1 || i == hex)
        && thisa->creatures[curSide][i].creatureIdx >= 0
        && thisa->creatures[curSide][i].quantity > 0 )
      {
        stack = &thisa->creatures[curSide][i];
        if ( isCure == 1 )
        {
          dam = 5 * thisa->heroSpellpowers[thisa->currentActionSide];
          if ( thisa->creatures[curSide][i].damage < dam )
            dam = thisa->creatures[curSide][i].damage;
          removingPosEffectVal = (signed __int64)((double)gMonsterDatabase[thisa->creatures[curSide][i].creatureIdx].fight_value
                                                * (double)dam
                                                * 0.75
                                                / (double)thisa->creatures[curSide][i].creature.hp
                                                + (double)removingPosEffectVal);
        }
        lostTurn = (thisa->creatures[curSide][i].creature.creature_flags & MAYBE_NOT_LOST_TURN) != 0;
        if ( HIBYTE(thisa->creatures[curSide][i].creature.creature_flags) & ATTR_MIRROR_IMAGE )
        {
          removingNegEffectVal = thisa->creatures[curSide][i].quantity
                               * gMonsterDatabase[thisa->creatures[curSide][i].creatureIdx].fight_value;
        }
        else
        {
          for ( eff = 0; (signed int)eff < 15; ++eff )
          {
            if ( stack->effectStrengths[eff] )
            {
              switch ( eff )
              {
                case EFFECT_HASTE:
                case EFFECT_BLESS:
                case EFFECT_DRAGON_SLAYER:
                case EFFECT_BLOOD_LUST:
                case EFFECT_SHIELD:
                case EFFECT_STONESKIN:
                case EFFECT_STEELSKIN:
                  v5 = (double)combatManager::RawEffectSpellInfluence(thisa, stack, eff);
                  v6 = lostTurn + stack->effectStrengths[eff];
                  if ( v6 >= 10 )
                    v6 = 10;
                  removingPosEffectVal = (signed __int64)(v5 * heuristicModifierForDuration[v6]
                                                        + (double)removingPosEffectVal);
                  break;
                case EFFECT_SLOW:
                case EFFECT_CURSE:
                  v7 = (double)combatManager::RawEffectSpellInfluence(thisa, stack, eff);
                  v8 = lostTurn + stack->effectStrengths[eff];
                  if ( v8 >= 10 )
                    v8 = 10;
                  removingNegEffectVal = (signed __int64)(v7 * heuristicModifierForDuration[v8]
                                                        + (double)removingNegEffectVal);
                  break;
                case EFFECT_BLIND:
                case EFFECT_BERSERKER:
                case EFFECT_PARALYZE:
                case EFFECT_HYPNOTIZE:
                case EFFECT_PETRIFY:
                  v9 = (double)combatManager::RawEffectSpellInfluence(thisa, stack, eff);
                  v10 = lostTurn + stack->effectStrengths[eff];
                  if ( v10 >= 10 )
                    v10 = 10;
                  removingNegEffectVal = (signed __int64)((double)removingNegEffectVal
                                                        - v9 * heuristicModifierForDuration[v10]);
                  break;
                case EFFECT_ANTI_MAGIC:
                  continue;
              }
            }
          }
        }
      }
    }
    if ( isCure == 1 )
      removingPosEffectVal = 0;
    if ( thisa->currentActionSide == curSide )
      *val += -removingNegEffectVal - removingPosEffectVal;
    else
      *val += removingNegEffectVal + removingPosEffectVal;
    if ( side != 2 || thisa->currentActionSide != curSide )
      done = 1;
    else
      curSide = 1 - thisa->currentActionSide;
  }
}

//----- (00467ED0) --------------------------------------------------------
signed __int64 __thiscall combatManager::EffectSpellResurrect(combatManager *this, int *val, int hexIdx, Spell spell)
{
  signed __int64 result; // qax@6
  combatManager *thisa; // [sp+14h] [bp-18h]@1
  army *v6; // [sp+18h] [bp-14h]@4
  signed int hpRestored; // [sp+20h] [bp-Ch]@1
  signed int v8; // [sp+24h] [bp-8h]@4
  int creaturesRaised; // [sp+28h] [bp-4h]@4

  thisa = this;
  hpRestored = 50 * this->heroSpellpowers[this->currentActionSide];
  if ( this->heroes[this->currentActionSide] && hero::HasArtifact(this->heroes[this->currentActionSide], 52) )
    hpRestored *= 2;
  v8 = combatManager::FindResurrectArmyIndex(thisa, thisa->currentActionSide, spell, hexIdx);
  v6 = &thisa->creatures[thisa->currentActionSide][v8];
  creaturesRaised = hpRestored / thisa->creatures[thisa->currentActionSide][v8].creature.hp;
  if ( creaturesRaised + thisa->creatures[thisa->currentActionSide][v8].quantity > thisa->creatures[thisa->currentActionSide][v8].initialQuantity )
    creaturesRaised = thisa->creatures[thisa->currentActionSide][v8].initialQuantity
                    - thisa->creatures[thisa->currentActionSide][v8].quantity;
  *val = creaturesRaised * gMonsterDatabase[thisa->creatures[thisa->currentActionSide][v8].creatureIdx].fight_value;
  result = (signed __int64)(army::SpellCastWorkChance(v6, spell) * (double)*val);
  *val = result;
  if ( spell == SPELL_RESURRECT )
  {
    result = (signed __int64)((double)*val * 0.85);
    *val = result;
  }
  return result;
}

//----- (00468050) --------------------------------------------------------
int __thiscall combatManager::EffectSpellDamage(combatManager *this, int *val, Spell spell, int hexIdx)
{
  __int16 v4; // fps@73
  unsigned __int8 v5; // c0@73
  unsigned __int8 v6; // c3@73
  int unitOwner; // eax@110
  int v8; // ecx@111
  __int64 v9; // qax@112
  __int64 v10; // qax@112
  signed __int64 v11; // qax@125
  combatManager *thisa; // [sp+50h] [bp-54h]@1
  int v14; // [sp+54h] [bp-50h]@114
  int creatIdx; // [sp+58h] [bp-4Ch]@74
  int remDam; // [sp+5Ch] [bp-48h]@107
  int stacksKilled[2]; // [sp+60h] [bp-44h]@22
  float chance; // [sp+68h] [bp-3Ch]@73
  int v19; // [sp+6Ch] [bp-38h]@18
  int damage; // [sp+70h] [bp-34h]@74
  army *stack; // [sp+74h] [bp-30h]@19
  int damMult; // [sp+78h] [bp-2Ch]@2
  int i; // [sp+7Ch] [bp-28h]@20
  int neighborIdx; // [sp+80h] [bp-24h]@18
  int kills; // [sp+84h] [bp-20h]@18
  int dam; // [sp+88h] [bp-1Ch]@18
  bool done; // [sp+8Ch] [bp-18h]@18
  int fightValueKilled[2]; // [sp+90h] [bp-14h]@22
  int curHex; // [sp+98h] [bp-Ch]@18
  int v30[2]; // [sp+9Ch] [bp-8h]@22

  thisa = this;
  switch ( spell )
  {
    case SPELL_ARMAGEDDON:
      damMult = 50;
      break;
    case SPELL_HOLY_WORD:
      damMult = 10;
      break;
    case SPELL_HOLY_SHOUT:
      damMult = 20;
      break;
    case SPELL_DEATH_RIPPLE:
      damMult = 5;
      break;
    case SPELL_DEATH_WAVE:
      damMult = 10;
      break;
    case SPELL_ELEMENTAL_STORM:
      damMult = 25;
      break;
    case SPELL_FIREBALL:
      damMult = 10;
      break;
    case SPELL_FIREBLAST:
      damMult = 10;
      break;
    case SPELL_METEOR_SHOWER:
      damMult = 25;
      break;
    case SPELL_LIGHTNING_BOLT:
      damMult = 25;
      break;
    case SPELL_MAGIC_ARROW:
      damMult = 10;
      break;
    case SPELL_CHAIN_LIGHTNING:
      damMult = 40;
      break;
    case SPELL_COLD_RAY:
      damMult = 20;
      break;
    case SPELL_COLD_RING:
      damMult = 10;
      break;
    default:
      damMult = 0;
      break;
  }
  dam = damMult * this->heroSpellpowers[this->currentActionSide];
  curHex = 0;
  neighborIdx = 0;
  done = 0;
  kills = 0;
  v19 = 0;
  if ( this->combatGrid[hexIdx].stackIdx >= 0 )
    stack = &this->creatures[this->combatGrid[hexIdx].unitOwner][this->combatGrid[hexIdx].stackIdx];
  for ( i = 0; i < 2; ++i )
  {
    stacksKilled[i] = 0;
    fightValueKilled[i] = 0;
    v30[i] = 0;
  }
  combatManager::ClearEffects();
  while ( !done )
  {
    switch ( spell )
    {
      case SPELL_HOLY_WORD:
      case SPELL_HOLY_SHOUT:
      case SPELL_ARMAGEDDON:
      case SPELL_ELEMENTAL_STORM:
      case SPELL_DEATH_RIPPLE:
      case SPELL_DEATH_WAVE:
        combatManager::NextPos(&curHex);
        done = curHex >= 116;
        break;
      case SPELL_COLD_RING:
        if ( !neighborIdx )
          neighborIdx = 1;
        goto LABEL_29;
      case SPELL_FIREBALL:
      case SPELL_FIREBLAST:
      case SPELL_METEOR_SHOWER:
LABEL_29:
        if ( (neighborIdx < 7 || spell == SPELL_FIREBLAST) && neighborIdx < 19 )
        {
          if ( !neighborIdx )
            curHex = hexIdx;
          if ( neighborIdx > 0 && neighborIdx <= 6 )
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, neighborIdx - 1);
          if ( neighborIdx > 6 && neighborIdx <= 12 )
          {
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, neighborIdx - 7);
            curHex = GetAdjacentCellIndexNoArmy(curHex, neighborIdx - 7);
          }
          if ( neighborIdx == 13 )
            curHex = hexIdx - 26;
          if ( neighborIdx == 14 )
            curHex = hexIdx + 26;
          if ( neighborIdx == 15 )
          {
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, 1);
            curHex = GetAdjacentCellIndexNoArmy(curHex, 0);
          }
          if ( neighborIdx == 16 )
          {
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, 1);
            curHex = GetAdjacentCellIndexNoArmy(curHex, 2);
          }
          if ( neighborIdx == 17 )
          {
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, 4);
            curHex = GetAdjacentCellIndexNoArmy(curHex, 5);
          }
          if ( neighborIdx == 18 )
          {
            curHex = GetAdjacentCellIndexNoArmy(hexIdx, 4);
            curHex = GetAdjacentCellIndexNoArmy(curHex, 3);
          }
          ++neighborIdx;
        }
        else
        {
          done = 1;
        }
        break;
      case SPELL_LIGHTNING_BOLT:
      case SPELL_MAGIC_ARROW:
      case SPELL_COLD_RAY:
      case SPELL_DISRUPTING_RAY:
        if ( curHex == hexIdx )
          done = 1;
        else
          curHex = hexIdx;
        break;
      case SPELL_CHAIN_LIGHTNING:
        if ( curHex )
        {
          dam >>= 1;
          curHex = combatManager::GetNextChainLightningTarget(
                     thisa,
                     &thisa->creatures[thisa->combatGrid[curHex].unitOwner][thisa->combatGrid[curHex].stackIdx],
                     0);
        }
        else
        {
          curHex = hexIdx;
        }
        ++neighborIdx;
        if ( neighborIdx > 4 || curHex == -1 )
          done = 1;
        break;
      case SPELL_TELEPORT:
      case SPELL_CURE:
      case SPELL_MASS_CURE:
      case SPELL_RESURRECT:
      case SPELL_RESURRECT_TRUE:
      case SPELL_HASTE:
      case SPELL_MASS_HASTE:
      case SPELL_SLOW:
      case SPELL_MASS_SLOW:
      case SPELL_BLIND:
      case SPELL_BLESS:
      case SPELL_MASS_BLESS:
      case SPELL_STONESKIN:
      case SPELL_STEELSKIN:
      case SPELL_CURSE:
      case SPELL_MASS_CURSE:
      case SPELL_ANTI_MAGIC:
      case SPELL_DISPEL_MAGIC:
      case SPELL_MASS_DISPEL:
      case SPELL_BERZERKER:
      case SPELL_PARALYZE:
      case SPELL_HYPNOTIZE:
        break;
    }
    if ( !done )
    {
      if ( curHex >= 0 )
      {
        if ( curHex < 116 )
        {
          if ( thisa->combatGrid[curHex].stackIdx >= 0 )
          {
            if ( thisa->combatGrid[curHex].unitOwner >= 0 )
            {
              stack = &thisa->creatures[thisa->combatGrid[curHex].unitOwner][thisa->combatGrid[curHex].stackIdx];
              if ( !gArmyEffected[thisa->combatGrid[curHex].unitOwner][thisa->combatGrid[curHex].stackIdx] )
              {
                gArmyEffected[thisa->combatGrid[curHex].unitOwner][thisa->combatGrid[curHex].stackIdx] = 1;
                UNDEF(v4);
                chance = army::SpellCastWorkChance(stack, spell);
                if ( !(v5 | v6) )
                {
                  damage = (signed __int64)((double)dam * chance);
                  creatIdx = stack->creatureIdx;
                  switch ( spell )
                  {
                    case SPELL_ARMAGEDDON:
                      if ( creatIdx == CREATURE_IRON_GOLEM || creatIdx == CREATURE_STEEL_GOLEM )
                        damage = (signed __int64)((double)damage * 0.5);
                      break;
                    case SPELL_FIREBALL:
                    case SPELL_FIREBLAST:
                      if ( creatIdx == CREATURE_IRON_GOLEM || creatIdx == CREATURE_STEEL_GOLEM )
                        damage = (signed __int64)((double)damage * 0.5);
                      if ( creatIdx == CREATURE_WATER_ELEMENTAL )
                        damage *= 2;
                      break;
                    case SPELL_METEOR_SHOWER:
                      if ( creatIdx == CREATURE_IRON_GOLEM || creatIdx == CREATURE_STEEL_GOLEM )
                        damage = (signed __int64)((double)damage * 0.5);
                      if ( creatIdx == CREATURE_EARTH_ELEMENTAL )
                        damage *= 2;
                      break;
                    case SPELL_LIGHTNING_BOLT:
                    case SPELL_CHAIN_LIGHTNING:
                    case SPELL_ELEMENTAL_STORM:
                      if ( creatIdx == CREATURE_IRON_GOLEM || creatIdx == CREATURE_STEEL_GOLEM )
                        damage = (signed __int64)((double)damage * 0.5);
                      if ( creatIdx == CREATURE_AIR_ELEMENTAL )
                        damage *= 2;
                      break;
                    case SPELL_COLD_RAY:
                    case SPELL_COLD_RING:
                      if ( creatIdx == CREATURE_IRON_GOLEM || creatIdx == CREATURE_STEEL_GOLEM )
                        damage = (signed __int64)((double)damage * 0.5);
                      if ( creatIdx == CREATURE_FIRE_ELEMENTAL )
                        damage *= 2;
                      break;
                    default:
                      break;
                  }
                  combatManager::ModifyDamageForArtifacts(
                    &damage,
                    spell,
                    thisa->heroes[thisa->currentActionSide],
                    thisa->heroes[stack->owningSide]);
                  if ( HIBYTE(stack->creature.creature_flags) & ATTR_MIRROR_IMAGE && damage )
                    damage = 999999;
                  kills = damage / stack->creature.hp;
                  remDam = damage % stack->creature.hp;
                  if ( remDam + stack->damage >= stack->creature.hp )
                  {
                    ++kills;
                    remDam -= stack->creature.hp - stack->damage;
                  }
                  if ( stack->quantity <= kills )
                  {
                    kills = stack->quantity;
                    remDam = 0;
                    unitOwner = thisa->combatGrid[curHex].unitOwner;
                    ++stacksKilled[unitOwner];
                  }
                  fightValueKilled[thisa->combatGrid[curHex].unitOwner] = (signed __int64)(((double)remDam * 0.75
                                                                                          + (double)(kills * stack->creature.hp))
                                                                                         * (double)gMonsterDatabase[stack->creatureIdx].fight_value
                                                                                         / (double)stack->creature.hp
                                                                                         + (double)fightValueKilled[thisa->combatGrid[curHex].unitOwner]);
                  v8 = thisa->combatGrid[curHex].unitOwner;
                  v30[v8] += kills
                           * stack->creature.hp
                           * gMonsterDatabase[stack->creatureIdx].fight_value
                           / stack->creature.hp;
                  if ( HIBYTE(stack->creature.creature_flags) & 1 )
                  {
                    v9 = v30[thisa->combatGrid[curHex].unitOwner];
                    v30[thisa->combatGrid[curHex].unitOwner] = ((signed int)v9 - HIDWORD(v9)) >> 1;
                    v10 = fightValueKilled[thisa->combatGrid[curHex].unitOwner];
                    fightValueKilled[thisa->combatGrid[curHex].unitOwner] = ((signed int)v10 - HIDWORD(v10)) >> 1;
                  }
                  if ( spell == 34 )
                  {
                    v14 = stack->creature.defense - 3;
                    if ( v14 < 1 )
                      v14 = 1;
                    v19 = (signed __int64)((double)((stack->quantity - kills)
                                                  * ((signed int)stack->creature.defense - v14)
                                                  * gMonsterDatabase[stack->creatureIdx].fight_value)
                                         * 0.05
                                         + (double)v19);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( thisa->numCreatures[0] > stacksKilled[0] && thisa->numCreatures[1] > stacksKilled[1] )
  {
    *val = v19 + fightValueKilled[1 - thisa->currentActionSide] - fightValueKilled[thisa->currentActionSide];
  }
  else if ( v30[thisa->currentActionSide] > 0 )
  {
    *val = v19 + v30[1 - thisa->currentActionSide] - v30[thisa->currentActionSide];
  }
  else
  {
    *val = v19 + 100000000 - gsSpellInfo[spell].appearingChance;
  }
  LODWORD(v11) = thisa;
  if ( !thisa->currentActionSide )
  {
    LODWORD(v11) = thisa;
    if ( thisa->isCastleBattle )
    {
      v11 = (signed __int64)((double)*val * 1.25);
      *val = v11;
    }
  }
  return v11;
}
// 468050: using guessed type int fightValueKilled[2];
// 468050: using guessed type int var_8[2];

//----- (00468D10) --------------------------------------------------------
int __thiscall searchArray::BuildPath(searchArray *this, int a2, int a3, int a4, int a5, signed int a6)
{
  char *v6; // eax@1
  int v7; // esi@1
  int i; // edi@1
  PathfindingInfo *v9; // ebx@4
  int v10; // edx@7
  int v11; // edx@8

  v6 = (char *)&this->field_2418;
  this->field_8 = 0;
  v7 = a4;
  for ( i = a5; a2 != v7 || a3 != i; i += byte_4F1DC1[4 * v11] )
  {
    v9 = &this->field_2414[v7 + i * MAP_WIDTH];
    if ( v9->field_0 != v7 && v9->field_1 != i )
      return 0;
    if ( v9->field_2 <= a6 )
    {
      ++v6;
      *(v6 - 1) = (unsigned __int8)v9->field_4 >> 4;
      v10 = this->field_8 + 1;
      this->field_8 = v10;
      if ( v10 >= 256 )
      {
        this->field_8 = 0;
        return this->field_8;
      }
    }
    v11 = (((unsigned __int8)v9->field_4 >> 4) + 4) & 7;
    v7 += normalDirTable[4 * v11];
  }
  return this->field_8;
}
// 4F0A00: using guessed type int MAP_WIDTH;

//----- (00468DD0) --------------------------------------------------------
char __thiscall searchArray::SeedPosition(searchArray *this, int a2, int a3, int a4, signed int a5, int a6, int a7, int a8, int a9, __int64 a10, int a11, int a12)
{
  searchArray *thisa; // esi@1
  int v13; // eax@4
  char v14; // al@13
  PathfindingInfo *v15; // edx@17
  signed int v16; // ebp@20
  int v17; // eax@23
  char *v18; // eax@23
  int v19; // edx@23
  int v20; // eax@32
  int v21; // eax@39
  __int64 v22; // ST18_8@55
  int v23; // ecx@55
  int v24; // ecx@57
  int v25; // ecx@57
  char v26; // al@60
  char v27; // ST2C_1@66
  char v28; // ST28_1@66
  int v29; // ST24_4@66
  char v30; // ST20_1@66
  char v31; // ST1C_1@66
  int v32; // ST18_4@66
  char v33; // ST14_1@66
  mapCell *v34; // eax@66
  int v35; // eax@66
  int v36; // ST2C_4@69
  mapCell *v37; // eax@69
  int v38; // eax@69
  int v39; // eax@80
  int v40; // ecx@90
  signed int v41; // eax@92
  int v42; // edx@92
  int v43; // eax@92

  thisa = this;
  if ( !a11 )
  {
    giFullySeeded = 0;
    giCurTempMobility = a8;
    searchArray::Clear(this);
    *(_DWORD *)&thisa->_1[4] = -1;
    *(_DWORD *)&thisa->_1[0] = -1;
    dword_526C80 = 0;
  }
  giSeedingValid = 1;
  if ( (signed int)a10 < 0 )
  {
    dword_526C28 = 0;
  }
  else
  {
    v13 = a10 + HIDWORD(a10) * MAP_WIDTH;
    if ( !((unsigned __int8)giCurPlayerBit & (unsigned __int8)mapRevealed[v13]) )
      return v13;
    v13 = (int)advManager::GetCell(gpAdvManager, a10, SHIDWORD(a10));
    dword_526C70 = v13;
    if ( *(_BYTE *)(v13 + 8) & 8 )
      return v13;
    if ( !giGroundToTerrain[*(_WORD *)v13] )
    {
      LOBYTE(v13) = dword_526C70;
      if ( a6 )
      {
        if ( *(_BYTE *)(dword_526C70 + 9) == -85 )
          return v13;
      }
      else
      {
        LOBYTE(v13) = *(_BYTE *)(dword_526C70 + 9);
        if ( (_BYTE)v13 != -86 && (_BYTE)v13 != -85 && (_BYTE)v13 != -96 )
          return v13;
      }
    }
    dword_526C28 = 1;
    v14 = *(_BYTE *)(dword_526C70 + 2);
    dword_526CA8 = 999999;
    dword_526C44 = (unsigned __int8)(v14 & 2) >> 1;
  }
  if ( dword_526C28 )
  {
    if ( !a11 )
      goto LABEL_20;
    v15 = &thisa->field_2414[a10 + HIDWORD(a10) * MAP_WIDTH];
    *(_DWORD *)&byte_526C58 = *(_DWORD *)&v15->field_0;
    *((_DWORD *)&byte_526C58 + 1) = *(_DWORD *)&v15->field_4;
    *(&byte_526C58 + 8) = BYTE3(v15->field_5);
    if ( byte_526C5C & 1 )
    {
      LOBYTE(v13) = dword_526C80 + 75;
      if ( dword_526C80 + 75 >= (unsigned __int16)word_526C5A )
        return v13;
    }
  }
  if ( a11 )
  {
    v16 = a5;
    goto LABEL_22;
  }
LABEL_20:
  v16 = a5;
  searchArray::PushPoint(thisa, a2, a3, a4, 0, a5, 0, 0, 0, 0, 0, 0, 0);
LABEL_22:
  dword_526CB4 = (int)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  while ( thisa->field_0 )
  {
    v17 = thisa->field_0 - 1;
    thisa->field_0 = v17;
    v18 = (char *)thisa + 9 * v17;
    v19 = *((_DWORD *)v18 + 5);
    v18 += 20;
    *(_DWORD *)&byte_526C58 = v19;
    *((_DWORD *)&byte_526C58 + 1) = *((_DWORD *)v18 + 1);
    *(&byte_526C58 + 8) = v18[8];
    if ( dword_526C28 && dword_526CA8 < 999999 && (unsigned __int16)word_526C5A + 75 >= dword_526CA8 )
    {
      v13 = (unsigned __int16)word_526C5A;
      dword_526C80 = (unsigned __int16)word_526C5A;
      ++thisa->field_0;
      return v13;
    }
    if ( (unsigned __int16)word_526C5A <= v16 || v16 <= 0 )
    {
      if ( byte_526C5C & 4 )
      {
        dword_526C2C = 1;
        *(_DWORD *)dword_526C94 = (unsigned __int8)byte_526C5D;
        *(_DWORD *)dword_526CAC = (unsigned __int8)byte_526C5E;
      }
      else
      {
        dword_526C2C = 0;
      }
      if ( byte_526C5C & 2 )
      {
        v20 = advManager::GetCell(gpAdvManager, (unsigned __int8)byte_526C58, (unsigned __int8)byte_526C59)->objType & 0x7F;
        dword_526C90 = v20;
        if ( v20 == 24 || v20 == 42 || v20 == 43 )
        {
          if ( !a7 )
            goto LABEL_72;
          if ( byte_526C5C & 4 )
            goto LABEL_72;
          *(_DWORD *)dword_526C94 = (unsigned __int8)byte_526C58;
          *(_DWORD *)dword_526CAC = (unsigned __int8)byte_526C59;
          dword_526C2C = 1;
          if ( dword_526C90 == 42 )
          {
            if ( gpGame->relatedToHeroForHireStatus[advManager::GetCell(
                                                      gpAdvManager,
                                                      (unsigned __int8)byte_526C58,
                                                      (unsigned __int8)byte_526C59)->field_4_1_1_isShadow_1_13_extraInfo >> 3] == giCurPlayer )
              goto LABEL_72;
          }
        }
        else
        {
          if ( v20 == 36 )
            goto LABEL_72;
          if ( v20 == 39 )
            goto LABEL_72;
          if ( !a7 )
            goto LABEL_72;
          if ( byte_526C5C & 4 )
            goto LABEL_72;
          v21 = (int)advManager::GetCell(gpAdvManager, (unsigned __int8)byte_526C58, (unsigned __int8)byte_526C59);
          if ( StopOnTrigger(v21) )
            goto LABEL_72;
        }
      }
      if ( a6 )
      {
        dword_526C90 = advManager::GetCell(gpAdvManager, (unsigned __int8)byte_526C58, (unsigned __int8)byte_526C59)->objType;
        if ( dword_526C90 != 28 )
          goto LABEL_55;
      }
      else
      {
        if ( !(*(&mapRevealed[(unsigned __int8)byte_526C59 * MAP_WIDTH] + (unsigned __int8)byte_526C58) & 0x80)
          || a2 == (unsigned __int8)byte_526C58 && a3 == (unsigned __int8)byte_526C59 )
          goto LABEL_55;
        if ( a7 && !(byte_526C5C & 4) )
        {
          if ( advManager::FindAdjacentMonster(
                 gpAdvManager,
                 (unsigned __int8)byte_526C58,
                 (unsigned __int8)byte_526C59,
                 (int)dword_526C94,
                 (int)dword_526CAC,
                 -1,
                 -1) )
            dword_526C2C = 1;
LABEL_55:
          HIDWORD(v22) = (unsigned __int8)byte_526C59;
          LODWORD(v22) = (unsigned __int8)byte_526C58;
          searchArray::TestPossibleDirections(thisa, v22, (int)byte_526C30, (int)byte_526C78, 1, a6);
          dword_526CB0 = (unsigned __int8)giGroundToTerrain[advManager::GetCell(
                                                              gpAdvManager,
                                                              (unsigned __int8)byte_526C58,
                                                              (unsigned __int8)byte_526C59)->groundIndex];
          v23 = (unsigned __int8)(advManager::GetCell(
                                    gpAdvManager,
                                    (unsigned __int8)byte_526C58,
                                    (unsigned __int8)byte_526C59)->bitfield_1_hasObject_1_isRoad_6_objTileset & 2) >> 1;
          dword_526C9C = 0;
          dword_526C4C = v23;
          dword_526C3C = giCurTempMobility - (unsigned __int16)word_526C5A;
          do
          {
            if ( byte_526C30[dword_526C9C] != -1 )
            {
              v24 = byte_4F1DC1[4 * dword_526C9C];
              dword_526C38 = (unsigned __int8)byte_526C58 + normalDirTable[4 * dword_526C9C];
              dword_526C6C = (unsigned __int8)byte_526C59 + v24;
              v25 = dword_526C38 + dword_526C6C * MAP_WIDTH;
              dword_526CA4 = (int)&thisa->field_2414[v25];
              if ( !a7
                || byte_526C5C & 4
                || !(mapRevealed[v25] & 0x80)
                || (v26 = *(_BYTE *)(dword_526CA4 + 4), !(v26 & 1))
                || !(v26 & 4)
                || *(_WORD *)(dword_526CA4 + 2) >= (unsigned __int16)word_526C5A + 300
                || !advManager::FindAdjacentMonster(
                      gpAdvManager,
                      dword_526C38,
                      dword_526C6C,
                      (int)dword_526C94,
                      (int)dword_526CAC,
                      -1,
                      -1)
                || *(_BYTE *)(dword_526CA4 + 5) != *(_DWORD *)dword_526C94
                || *(_BYTE *)(dword_526CA4 + 6) != *(_DWORD *)dword_526CAC )
              {
                v27 = byte_526C60;
                v28 = byte_526C5F;
                v29 = (unsigned __int8)(byte_526C5C & 8) >> 3;
                v30 = dword_526CAC[0];
                v31 = dword_526C94[0];
                v32 = dword_526C2C;
                v33 = byte_526C78[dword_526C9C];
                v34 = advManager::GetCell(gpAdvManager, dword_526C38, dword_526C6C);
                v35 = CalcTerrainCost(
                        dword_526CB0,
                        dword_526C9C,
                        dword_526C3C,
                        a9,
                        dword_526C4C,
                        (unsigned __int8)(v34->bitfield_1_hasObject_1_isRoad_6_objTileset & 2) >> 1);
                searchArray::PushPoint(
                  thisa,
                  dword_526C38,
                  dword_526C6C,
                  dword_526C9C,
                  (unsigned __int16)word_526C5A + v35,
                  v16,
                  v33,
                  v32,
                  v31,
                  v30,
                  v29,
                  v28,
                  v27);
                if ( dword_526C28 )
                {
                  if ( __PAIR__(dword_526C6C, dword_526C38) == a10 )
                  {
                    if ( !(byte_526C5C & 4) )
                    {
                      v36 = dword_526C44;
                      v37 = advManager::GetCell(gpAdvManager, dword_526C38, dword_526C6C);
                      dword_526C98 = CalcTerrainCost(
                                       byte_526C30[dword_526C9C],
                                       dword_526C9C,
                                       giCurTempMobility - (unsigned __int16)word_526C5A,
                                       a9,
                                       (unsigned __int8)(v37->bitfield_1_hasObject_1_isRoad_6_objTileset & 2) >> 1,
                                       v36);
                      v38 = dword_526C98 + (unsigned __int16)word_526C5A;
                      if ( dword_526CA8 > v38 )
                        dword_526CA8 = dword_526C98 + (unsigned __int16)word_526C5A;
                    }
                  }
                }
              }
            }
            ++dword_526C9C;
          }
          while ( dword_526C9C < 8 );
          goto LABEL_72;
        }
      }
    }
LABEL_72:
    ++dword_526CA0;
  }
  LOBYTE(v13) = a12;
  if ( a12 )
  {
    dword_526C8C = 0;
    LOBYTE(v13) = MAP_WIDTH;
    if ( MAP_WIDTH > 0 )
    {
      do
      {
        for ( dword_526C64 = 0; MAP_WIDTH > dword_526C64; ++dword_526C64 )
        {
          if ( (advManager::GetCell(gpAdvManager, dword_526C8C, dword_526C64)->objType & 0x7F) == 24 )
          {
            dword_526C70 = (int)advManager::GetCell(gpAdvManager, dword_526C8C, dword_526C64);
            dword_526C9C = 0;
            do
            {
              v39 = byte_4F1DC1[4 * dword_526C9C];
              dword_526C50 = dword_526C8C + normalDirTable[4 * dword_526C9C];
              dword_526C88 = dword_526C64 + v39;
              if ( dword_526C50 >= 0 && dword_526C50 < MAP_WIDTH && dword_526C88 >= 0 && MAP_HEIGHT > dword_526C88 )
              {
                dword_526C84 = (int)advManager::GetCell(gpAdvManager, dword_526C50, dword_526C88);
                dword_526C68 = 1;
                if ( (1 << dword_526C9C) & 0x38
                  && *(_BYTE *)(dword_526C84 + 3) != -1
                  && (*(_BYTE *)(dword_526C84 + 2) & 0xFC) != -68
                  && !(*(_BYTE *)(dword_526C84 + 8) & 0x80) )
                  dword_526C68 = 0;
                if ( dword_526C68 )
                {
                  v40 = dword_526C50 + dword_526C88 * MAP_WIDTH;
                  if ( thisa->field_2414[v40].field_4 & 1 )
                  {
                    if ( !(*(_BYTE *)(dword_526C84 + 9) & 0x80) )
                    {
                      v41 = (unsigned __int8)giGroundToTerrain[*(_WORD *)dword_526C84];
                      HIWORD(v42) = 0;
                      dword_526CB0 = v41;
                      LOWORD(v42) = thisa->field_2414[v40].field_2;
                      dword_526C48 = v42;
                      v43 = CalcTerrainCost(
                              v41,
                              dword_526C9C,
                              giCurTempMobility - v42,
                              a9,
                              (unsigned __int8)(*(_BYTE *)(dword_526C84 + 2) & 2) >> 1,
                              (unsigned __int8)(*(_BYTE *)(dword_526C70 + 2) & 2) >> 1);
                      searchArray::PushPoint(
                        thisa,
                        dword_526C8C,
                        dword_526C64,
                        ((_BYTE)dword_526C9C + 4) & 7,
                        v43 + dword_526C48,
                        v16,
                        1,
                        0,
                        -1,
                        -1,
                        0,
                        -1,
                        -1);
                    }
                  }
                }
              }
              ++dword_526C9C;
            }
            while ( dword_526C9C < 8 );
          }
        }
        v13 = dword_526C8C + 1;
        dword_526C8C = v13;
      }
      while ( MAP_WIDTH > v13 );
    }
  }
  giFullySeeded = 1;
  return v13;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 524760: using guessed type int giCurTempMobility;
// 5247C0: using guessed type int giSeedingValid;
// 524808: using guessed type int giFullySeeded;
// 526C28: using guessed type int dword_526C28;
// 526C48: using guessed type int dword_526C48;
// 526C58: using guessed type char byte_526C58;
// 526C59: using guessed type char byte_526C59;
// 526C5A: using guessed type __int16 word_526C5A;
// 526C5C: using guessed type char byte_526C5C;
// 526C5D: using guessed type char byte_526C5D;
// 526C5E: using guessed type char byte_526C5E;
// 526C5F: using guessed type char byte_526C5F;
// 526C60: using guessed type char byte_526C60;
// 526C68: using guessed type int dword_526C68;
// 526C70: using guessed type int dword_526C70;
// 526C80: using guessed type int dword_526C80;
// 526C84: using guessed type int dword_526C84;
// 526C90: using guessed type int dword_526C90;
// 526C98: using guessed type int dword_526C98;
// 526CA0: using guessed type int dword_526CA0;
// 526CA4: using guessed type int dword_526CA4;
// 526CA8: using guessed type int dword_526CA8;
// 526CB4: using guessed type int dword_526CB4;
// 532C5C: using guessed type char giCurPlayerBit;

//----- (004697B0) --------------------------------------------------------
town *__thiscall town::town(town *this)
{
  armyGroup::armyGroup(&this->garrison);
  this->factionID = 0;
  this->idx = 0;
  this->ownerIdx = 0;
  this->x = 0;
  this->y = 0;
  this->visitingHeroIdx = -1;
  this->buildingsBuiltFlags = 32;
  this->mageGuildLevel = 0;
  this->field_1D = 0;
  return this;
}

//----- (00469820) --------------------------------------------------------
int __thiscall town::HasGarrison(town *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    if ( this->garrison.creatureTypes[i] != -1 )
      return 1;
  }
  return 0;
}

//----- (00469880) --------------------------------------------------------
void __thiscall town::GiveSpells(town *this, hero *captain)
{
  char v2; // al@12
  signed int j; // [sp+10h] [bp-Ch]@10
  int i; // [sp+14h] [bp-8h]@8
  hero *hro; // [sp+18h] [bp-4h]@4

  if ( captain || this->visitingHeroIdx != -1 )
  {
    if ( captain )
      hro = captain;
    else
      hro = &gpGame->heroes[this->visitingHeroIdx];
    if ( hero::HasArtifact(hro, ARTIFACT_MAGIC_BOOK) && this->buildingsBuiltFlags & 1 )
    {
      for ( i = 0; hro->secondarySkillLevel[7] + 2 > i; ++i )
      {
        for ( j = 0; this->numSpellsOfLevel[i] > j; ++j )
        {
          v2 = hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
          hero::AddSpell(hro, this->mageGuildSpells[i][j], v2);
        }
      }
    }
  }
}

//----- (004699A0) --------------------------------------------------------
void __thiscall town::XformToCastle(town *this)
{
  game::ConvertObject(gpGame, this->x - 5, this->y - 3, this->x + 2, this->y + 1, 35, 16, 255, 35, 0, 35, 35);
  game::ConvertObject(gpGame, this->x - 5, this->y - 3, this->x + 2, this->y + 1, 37, 16, 255, 37, 0, 35, 35);
}

//----- (00469A50) --------------------------------------------------------
void __thiscall town::View(town *this, int a2)
{
  town *thisa; // [sp+Ch] [bp-8h]@1

  thisa = this;
  bEnteringTown = 1;
  if ( giHighMemBuffer + 1300 <= 2900 )
  {
    if ( giHighMemBuffer + 1300 > 800 )
      gAdvDisposeLevel = 1;
  }
  else
  {
    gAdvDisposeLevel = 2;
  }
  gpTownManager->castle = this;
  if ( !a2 )
    heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  executive::CallManager(gpExec, (baseManager *)gpTownManager);
  if ( thisa->visitingHeroIdx != -1 )
    advManager::SetHeroContext(gpAdvManager, thisa->visitingHeroIdx, 0);
  gAdvDisposeLevel = 0;
  bEnteringTown = 0;
}
// 4F7490: using guessed type int gAdvDisposeLevel;
// 4F74AC: using guessed type int giHighMemBuffer;
// 51256C: using guessed type int bEnteringTown;

//----- (00469B30) --------------------------------------------------------
town *__thiscall town::Deallocate(town *this)
{
  town *result; // eax@15
  signed int v2; // [sp+10h] [bp-Ch]@1
  signed int i; // [sp+14h] [bp-8h]@1
  int j; // [sp+14h] [bp-8h]@6
  char *v5; // [sp+18h] [bp-4h]@1

  v5 = (char *)&gpGame->players[this->ownerIdx];
  v2 = -1;
  for ( i = 0; gpGame->players[this->ownerIdx].numCastles > i; ++i )
  {
    if ( v5[i + 71] == this->idx )
      v2 = i;
  }
  for ( j = v2; v5[68] - 1 > j; ++j )
    v5[j + 71] = v5[j + 72];
  v5[v5[68] + 70] = -1;
  if ( this->idx == v5[69] )
    v5[69] = -1;
  --v5[68];
  if ( v5[68] >= 5 )
  {
    if ( v5[70] + 5 > v5[68] )
      v5[70] = v5[68] - 5;
  }
  else
  {
    v5[70] = 0;
  }
  gpGame->field_2773[this->idx] = -1;
  result = this;
  this->ownerIdx = -1;
  return result;
}

//----- (00469C80) --------------------------------------------------------
void __thiscall town::BuildBuilding(town *this, signed int buildingCode)
{
  town *thisa; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@9

  thisa = this;
  if ( !buildingCode )
  {
    ++this->mageGuildLevel;
    this->mageGuildSpells[4][this->mageGuildLevel + 3] = gSpellLimits[this->mageGuildLevel - 1];
    if ( this->factionID == FACTION_WIZARD && BYTE1(this->buildingsBuiltFlags) & 0x20 )
      ++this->mageGuildSpells[4][this->mageGuildLevel + 3];
    if ( this->visitingHeroIdx != -1 )
      town::GiveSpells(this, 0);
  }
  if ( buildingCode == BUILDING_SPECIAL )
  {
    if ( thisa->factionID == FACTION_WIZARD )
    {
      for ( i = 0; thisa->mageGuildLevel > i; ++i )
        ++thisa->numSpellsOfLevel[i];
      if ( thisa->visitingHeroIdx != -1 )
        town::GiveSpells(thisa, 0);
    }
  }
  thisa->buildingsBuiltFlags |= 1 << buildingCode;
  if ( buildingCode == BUILDING_UPGRADE_1 )
    thisa->buildingsBuiltFlags &= 0xFFEFFFFFu;
  if ( buildingCode == BUILDING_UPGRADE_2 )
    thisa->buildingsBuiltFlags &= 0xFFDFFFFFu;
  if ( buildingCode == BUILDING_UPGRADE_3 )
    thisa->buildingsBuiltFlags &= 0xFFBFFFFFu;
  if ( buildingCode == BUILDING_UPGRADE_4 )
    thisa->buildingsBuiltFlags &= 0xFF7FFFFFu;
  if ( buildingCode == BUILDING_UPGRADE_5 )
    thisa->buildingsBuiltFlags &= 0xFEFFFFFFu;
  if ( buildingCode == BUILDING_UPGRADE_5B )
    thisa->buildingsBuiltFlags &= 0xDEFFFFFFu;
  if ( buildingCode >= 19 && buildingCode <= 24 )
    *(_WORD *)&thisa[-1].name[2 * buildingCode + 5] = gMonsterDatabase[LOBYTE((&gTownObjNames[3 * thisa->factionID + 27])[buildingCode + 1])].growth;
  if ( buildingCode >= 25 && buildingCode <= 29 )
    *(_WORD *)&thisa[-1].name[2 * buildingCode + 5] = *(_WORD *)&thisa[-1].numSpellsOfLevel[2 * buildingCode + 2];
  if ( buildingCode == 30 )
    thisa->numCreaturesInDwelling[11] = thisa->numCreaturesInDwelling[10];
  if ( buildingCode == BUILDING_CASTLE )
  {
    thisa->buildingsBuiltFlags &= 0xFFFFFFDFu;
    town::XformToCastle(thisa);
  }
  town::GiveSpells(thisa, 0);
  BitSet(gpGame->field_27BB, thisa->idx);
}
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (00469EC0) --------------------------------------------------------
bool __thiscall town::CanBuildDock(town *this)
{
  return this->buildDockRelated != 255;
}

//----- (00469F00) --------------------------------------------------------
void __thiscall town::CalcNumLevelArchers(town *this, int *numArchers, int *attack)
{
  signed int i; // [sp+10h] [bp-4h]@1
  signed int j; // [sp+10h] [bp-4h]@6

  *attack = this->mageGuildLevel;
  *numArchers = 0;
  for ( i = 19; i <= 30; ++i )
  {
    if ( (1 << i) & this->buildingsBuiltFlags )
      ++*numArchers;
  }
  for ( j = 0; j <= 15; ++j )
  {
    if ( (1 << j) & this->buildingsBuiltFlags )
      ++*numArchers;
  }
}

//----- (00469FA0) --------------------------------------------------------
bool __thiscall combatManager::AICheckRetreat(int ecx0)
{
  bool result; // eax@2
  int v2; // esi@16
  __int16 v3; // fps@62
  unsigned __int8 v4; // c0@62
  unsigned __int8 v5; // c3@62
  int v6; // [sp+2Ch] [bp-148h]@1
  signed int v7; // [sp+34h] [bp-140h]@21
  signed int i; // [sp+38h] [bp-13Ch]@13
  int v9; // [sp+40h] [bp-134h]@43
  float v10; // [sp+44h] [bp-130h]@62
  signed int j; // [sp+48h] [bp-12Ch]@18
  signed int k; // [sp+48h] [bp-12Ch]@21
  signed int l; // [sp+48h] [bp-12Ch]@36
  char v14; // [sp+4Ch] [bp-128h]@13
  hero *hro; // [sp+5Ch] [bp-118h]@16
  armyGroup *armyGrp; // [sp+60h] [bp-114h]@16
  int v17[2]; // [sp+64h] [bp-110h]@35
  int v18[2]; // [sp+6Ch] [bp-108h]@33
  float v19; // [sp+74h] [bp-100h]@46
  hero this; // [sp+78h] [bp-FCh]@13

  v6 = ecx0;
  if ( *(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12927) )
  {
    result = 0;
  }
  else if ( *(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12935) )
  {
    if ( *(_BYTE *)(*(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12935) + 231) )
    {
      result = 0;
    }
    else if ( gpGame->mapHeader.winConditionType != 2
  || *(_BYTE *)(*(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12935) + 2) != gpGame->mapHeader.winConditionArgument )
    {
      if ( gpGame->players[*(_BYTE *)(*(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12935) + 3)].numCastles
        || gpGame->players[*(_BYTE *)(*(_DWORD *)(ecx0 + 4 * *(_DWORD *)(ecx0 + 62127) + 12935) + 3)].numHeroes != 1 )
      {
        hero::hero(&this);
        armyGroup::armyGroup((armyGroup *)&v14);
        for ( i = 0; i < 2; ++i )
        {
          if ( *(_DWORD *)(v6 + 4 * i + 12935) )
          {
            v2 = *(_DWORD *)(v6 + 4 * i + 12935);
            memcpy(&this, (const void *)v2, 0xF8u);
            *(_WORD *)&this.scrollSpell[12] = *(_WORD *)(v2 + 248);
            hro = &this;
            armyGrp = &this.army;
          }
          else
          {
            armyGrp = (armyGroup *)&v14;
            hro = 0;
          }
          for ( j = 0; j < 5; ++j )
          {
            armyGrp->creatureTypes[j] = -1;
            armyGrp->quantities[j] = 0;
          }
          v7 = 0;
          for ( k = 0; k < 20; ++k )
          {
            if ( *(_DWORD *)(1154 * k + 24234 * i + v6 + 13765) >= 0
              && *(_DWORD *)(1154 * k + 24234 * i + v6 + 13797) > 0 )
            {
              armyGrp->creatureTypes[v7] = *(_BYTE *)(1154 * k + 24234 * i + v6 + 13765);
              if ( *(_BYTE *)(1154 * k + 24234 * i + v6 + 13855) & 0x80 )
                armyGrp->quantities[v7] = *(_DWORD *)(1154 * k + 24234 * i + v6 + 13797);
              else
                armyGrp->quantities[v7] = (signed __int64)((double)*(signed int *)(1154 * k + 24234 * i + v6 + 13797)
                                                         * 1.2);
              ++v7;
            }
            if ( v7 >= 5 )
              k = 999;
          }
          v18[i] = philAI::FightValueOfStack(armyGrp, hro, 1, 0, 0, 0);
          if ( *(_DWORD *)(v6 + 4 * i + 12927) )
            v18[i] = (signed __int64)((double)v18[i] * 1.1);
          v17[i] = 0;
          if ( hro )
          {
            for ( l = 0; l < 14; ++l )
            {
              if ( hro->artifacts[l] >= 0 && hro->artifacts[l] < 37 )
                v17[i] += gArtifactBaseRV[hro->artifacts[l]];
            }
          }
        }
        v18[1 - *(_DWORD *)(v6 + 62127)] = (signed __int64)((double)v18[1 - *(_DWORD *)(v6 + 62127)] * 1.1);
        v9 = v17[*(_DWORD *)(v6 + 62127)];
        if ( v17[*(_DWORD *)(v6 + 62127)] >= 1000
          || *(_DWORD *)(*(_DWORD *)(v6 + 4 * *(_DWORD *)(v6 + 62127) + 12935) + 57) >= 2000 )
        {
          v19 = 0.16;
          if ( v9 <= 10000 )
          {
            if ( v9 <= 5000 )
            {
              if ( v9 > 0 )
                v19 = v19 + 0.04;
            }
            else
            {
              v19 = v19 + 0.05;
            }
          }
          else
          {
            v19 = v19 + 0.06;
          }
          if ( v18[*(_DWORD *)(v6 + 62127)] <= 40000 )
          {
            if ( v18[*(_DWORD *)(v6 + 62127)] <= 30000 )
            {
              if ( v18[*(_DWORD *)(v6 + 62127)] <= 15000 )
              {
                if ( v18[*(_DWORD *)(v6 + 62127)] <= 5000 )
                {
                  if ( v18[*(_DWORD *)(v6 + 62127)] > 2500 )
                    v19 = v19 - 0.02;
                }
                else
                {
                  v19 = v19 - 0.04;
                }
              }
              else
              {
                v19 = v19 - 0.06;
              }
            }
            else
            {
              v19 = v19 - 0.08;
            }
          }
          else
          {
            v19 = v19 - (double)(v18[*(_DWORD *)(v6 + 62127)] / 20000);
          }
          v19 = v19 - (double)(4 - (signed int)gpGame->difficulty) * 0.015;
          UNDEF(v3);
          v10 = (double)(*(_DWORD *)(*(_DWORD *)(v6 + 4 * *(_DWORD *)(v6 + 62127) + 12935) + 57) / 200000);
          if ( !(v4 | v5) )
            v10 = 0.029999999;
          v19 = v19 + v10;
          if ( !*(_DWORD *)(v6 + 62127) )
            v19 = v19 - 0.06;
          if ( v19 > 0.16 )
            v19 = 0.16;
          result = (double)v18[*(_DWORD *)(v6 + 62127)] / (double)(v18[0] + v18[1]) < v19;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 469FA0: using guessed type int var_110[2];

//----- (0046A8E0) --------------------------------------------------------
void __thiscall combatManager::DoCompAI(combatManager *this, int side)
{
  combatManager *thisa; // [sp+20h] [bp-A0h]@1
  signed int v3; // [sp+24h] [bp-9Ch]@110
  char *v4; // [sp+28h] [bp-98h]@95
  int a1; // [sp+2Ch] [bp-94h]@95
  char v6; // [sp+30h] [bp-90h]@92
  char v7; // [sp+31h] [bp-8Fh]@92
  char v8; // [sp+32h] [bp-8Eh]@92
  char v9; // [sp+33h] [bp-8Dh]@92
  char v10; // [sp+34h] [bp-8Ch]@92
  char v11; // [sp+35h] [bp-8Bh]@92
  char v12; // [sp+36h] [bp-8Ah]@92
  char v13; // [sp+37h] [bp-89h]@92
  char v14; // [sp+38h] [bp-88h]@92
  int v15; // [sp+3Ch] [bp-84h]@92
  bool v16; // [sp+40h] [bp-80h]@15
  int v17; // [sp+44h] [bp-7Ch]@8
  int v18; // [sp+48h] [bp-78h]@12
  int attack; // [sp+4Ch] [bp-74h]@8
  town *v20; // [sp+50h] [bp-70h]@8
  int numArchers; // [sp+54h] [bp-6Ch]@8
  int a4[2]; // [sp+58h] [bp-68h]@1
  int v23[2]; // [sp+60h] [bp-60h]@1
  int v24; // [sp+68h] [bp-58h]@1
  int v25; // [sp+6Ch] [bp-54h]@1
  army *stack; // [sp+74h] [bp-4Ch]@1
  int v27[2]; // [sp+78h] [bp-48h]@1
  signed int hexIdx; // [sp+80h] [bp-40h]@108
  int v29[2]; // [sp+84h] [bp-3Ch]@1
  int v30; // [sp+8Ch] [bp-34h]@1
  int v31; // [sp+90h] [bp-30h]@1
  int v32; // [sp+94h] [bp-2Ch]@1
  int v33; // [sp+98h] [bp-28h]@1
  int v34; // [sp+9Ch] [bp-24h]@1
  int v35[2]; // [sp+A0h] [bp-20h]@1
  int v36; // [sp+A8h] [bp-18h]@41
  int a3; // [sp+ACh] [bp-14h]@1
  int v38[2]; // [sp+B0h] [bp-10h]@1
  int stackBmask[2]; // [sp+B8h] [bp-8h]@1

  thisa = this;
  this->field_F2B7 = 0;
  stack = &thisa->creatures[thisa->activeStackOwner][this->activeStack];
  v34 = 0;
  a3 = 1 - this->currentActionSide;
  a4[this->currentActionSide] = combatManager::GetMirrorImageMask(this, this->currentActionSide);
  a4[a3] = combatManager::GetMirrorImageMask(thisa, a3);
  v23[thisa->currentActionSide] = combatManager::GetShooterMask(thisa, thisa->currentActionSide);
  v23[a3] = combatManager::GetShooterMask(thisa, a3);
  v38[thisa->currentActionSide] = combatManager::GetFlyerMask(thisa, thisa->currentActionSide);
  v38[a3] = combatManager::GetFlyerMask(thisa, a3);
  stackBmask[thisa->currentActionSide] = combatManager::GetWalkerMask(thisa, thisa->currentActionSide);
  stackBmask[a3] = combatManager::GetWalkerMask(thisa, a3);
  v27[thisa->currentActionSide] = combatManager::GetOutOfItMask(thisa, thisa->currentActionSide);
  v27[a3] = combatManager::GetOutOfItMask(thisa, a3);
  v35[thisa->currentActionSide] = combatManager::GetTraitorMask(thisa, thisa->currentActionSide);
  v35[a3] = combatManager::GetTraitorMask(thisa, a3);
  v29[thisa->currentActionSide] = combatManager::GetStrength(
                                    thisa,
                                    thisa->currentActionSide,
                                    v23[thisa->currentActionSide]);
  v29[a3] = combatManager::GetStrength(thisa, a3, v23[a3]);
  v25 = combatManager::GetStrength(
          thisa,
          thisa->currentActionSide,
          v35[thisa->currentActionSide] | v27[thisa->currentActionSide] | stackBmask[thisa->currentActionSide] | v38[thisa->currentActionSide] | v23[thisa->currentActionSide]);
  v24 = (v25 + 4) / 5;
  v32 = 0;
  v31 = 0;
  v33 = combatManager::GetStrength(thisa, thisa->currentActionSide, v23[thisa->currentActionSide]);
  v30 = combatManager::GetStrength(thisa, a3, v23[a3]);
  if ( thisa->isCastleBattle )
  {
    if ( !thisa->heroes[0]->secondarySkillLevel[1] && !hero::HasArtifact(thisa->heroes[0], 63) )
    {
      if ( thisa->currentActionSide )
        v30 /= 2;
      else
        v33 /= 2;
    }
    if ( !thisa->ballistaDestroyed )
    {
      v20 = thisa->castles[1];
      town::CalcNumLevelArchers(thisa->castles[1], &numArchers, &attack);
      v17 = 0;
      if ( thisa->turretStatus[0] == 1 )
        v17 += numArchers / 2;
      if ( thisa->turretStatus[3] == 1 )
        v17 += numArchers / 2;
      numArchers += v17;
      v18 = (signed __int64)(((double)attack * 0.1 + 1.0) * (double)(300 * numArchers));
      v16 = !thisa->heroes[0] || !hero::HasArtifact(thisa->heroes[0], 63) && !thisa->heroes[0]->secondarySkillLevel[1];
      if ( thisa->currentActionSide == 1 )
        v33 += v18;
      else
        v30 += v18;
    }
  }
  if ( thisa->heroes[thisa->currentActionSide] )
    v33 = (signed __int64)((double)v33 * gfSSArcheryMod[thisa->heroes[thisa->currentActionSide]->secondarySkillLevel[1]]);
  if ( thisa->heroes[1 - thisa->currentActionSide] )
    v30 = (signed __int64)((double)v30
                         * gfSSArcheryMod[thisa->heroes[1 - thisa->currentActionSide]->secondarySkillLevel[1]]);
  if ( (v25 + 4) / 5 < v33 )
    v32 = 1;
  if ( v33 < v30 )
    v31 = 1;
  if ( stack->creature.creature_flags & 4 )
  {
    if ( stack->creature.shots <= 0 )
      v34 = 3;
    else
      v34 = 1;
  }
  else if ( stack->creature.creature_flags & 2 )
  {
    v34 = 2;
  }
  else
  {
    v34 = 3;
  }
  if ( v34 == 1 )
  {
    if ( combatManager::AttemptAdjacentAttack(thisa, (int)stack) )
      goto LABEL_104;
    if ( stack->creatureIdx != 54 && stack->creatureIdx != 55 )
    {
      v36 = combatManager::GetBestArmy(thisa, a3, a4[a3]);
      if ( v36 == -1 )
      {
        v36 = combatManager::GetBestArmy(thisa, a3, v23[a3]);
        if ( v36 == -1 )
        {
          v36 = combatManager::GetBestArmy(thisa, a3, v38[a3]);
          if ( v36 == -1 )
          {
            if ( stackBmask[a3] && (v36 = combatManager::GetClosestArmy(thisa, stack, a3, stackBmask[a3]), v36 != -1) )
            {
              giNextAction = 2;
              giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
            }
            else
            {
              v36 = combatManager::GetBestArmy(thisa, a3, v27[a3]);
              if ( v36 == -1 )
              {
                v36 = combatManager::GetBestArmy(thisa, a3, v35[a3]);
                if ( v36 == -1 )
                  goto LABEL_103;
                giNextAction = 2;
                giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
              }
              else
              {
                giNextAction = 2;
                giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
              }
            }
          }
          else
          {
            giNextAction = 2;
            giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
          }
        }
        else
        {
          giNextAction = 2;
          giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
        }
      }
      else
      {
        giNextAction = 2;
        giNextActionGridIndex = thisa->creatures[a3][v36].occupiedHex;
      }
    }
    else
    {
      combatManager::DoLichShot(thisa, (int)stack);
    }
  }
  else if ( v34 == 2 )
  {
    if ( !v32 || v31 )
    {
      if ( !combatManager::AttemptAttack(thisa, (int)stack, a3, a4[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v23[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v38[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, stackBmask[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v27[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v35[a3]) )
        goto LABEL_103;
    }
    else if ( !combatManager::AttemptAttack(thisa, (int)stack, a3, a4[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v23[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v38[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, stackBmask[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v27[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v35[a3]) )
    {
      goto LABEL_103;
    }
  }
  else
  {
    if ( v34 != 3 )
    {
LABEL_103:
      giNextAction = 3;
      goto LABEL_104;
    }
    if ( !v32 || v31 )
    {
      if ( !combatManager::AttemptAttack(thisa, (int)stack, a3, a4[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v23[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v38[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, stackBmask[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v27[a3])
        && !combatManager::AttemptAttack(thisa, (int)stack, a3, v35[a3])
        && !combatManager::WalkTowardArmy(thisa, stack, a3, v23[a3])
        && !combatManager::WalkTowardArmy(thisa, stack, a3, stackBmask[a3])
        && !combatManager::WalkTowardArmy(thisa, stack, a3, v38[a3])
        && !combatManager::WalkTowardArmy(thisa, stack, a3, v27[a3])
        && !combatManager::WalkTowardArmy(thisa, stack, a3, v35[a3]) )
      {
        v6 = 8;
        v7 = 21;
        v8 = 33;
        v9 = 46;
        v10 = 58;
        v11 = 72;
        v12 = 85;
        v13 = 99;
        v14 = 112;
        v15 = stack->occupiedHex / 13;
        if ( thisa->currentActionSide )
          goto LABEL_103;
        if ( !thisa->isCastleBattle )
          goto LABEL_103;
        if ( (unsigned __int8)*(&v6 + v15) <= stack->occupiedHex )
          goto LABEL_103;
        a1 = (unsigned __int8)*(&v6 + v15);
        v4 = (char *)&gpCombatManager->combatGrid[a1];
        if ( !ValidHex((unsigned __int8)*(&v6 + v15)) || v4[16] != -1 || v4[14] )
          goto LABEL_103;
        giNextAction = 2;
        giNextActionGridIndex = a1;
      }
    }
    else if ( !combatManager::AttemptAttack(thisa, (int)stack, a3, a4[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v23[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v38[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, stackBmask[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v27[a3])
  && !combatManager::AttemptAttack(thisa, (int)stack, a3, v35[a3])
  && !combatManager::WalkTowardArmyFront(thisa, (int)stack, thisa->currentActionSide, v23[thisa->currentActionSide]) )
    {
      giNextAction = 3;
    }
  }
LABEL_104:
  if ( giNextAction == 2
    && giNextActionGridIndex > 0
    && giNextActionGridIndex < 117
    && gpCombatManager->combatGrid[giNextActionGridIndex].unitOwner == -1 )
  {
    for ( hexIdx = 0; hexIdx < 6; ++hexIdx )
    {
      v3 = army::GetAdjacentCellIndex(stack, giNextActionGridIndex, hexIdx);
      if ( v3 > 0 && v3 < 117 && gpCombatManager->combatGrid[v3].unitOwner == 1 - thisa->currentActionSide )
      {
        giNextActionGridIndex = v3;
        return;
      }
    }
  }
}
// 46A8E0: using guessed type int a4[2];
// 46A8E0: using guessed type int var_60[2];
// 46A8E0: using guessed type int var_10[2];
// 46A8E0: using guessed type int stackBmask[2];
// 46A8E0: using guessed type int var_48[2];
// 46A8E0: using guessed type int var_20[2];
// 46A8E0: using guessed type int var_3C[2];

//----- (0046BB80) --------------------------------------------------------
double __stdcall combatManager::GetModLichDamage(int a1, float a2)
{
  int v2; // ecx@1
  __int16 v3; // fps@1
  float v4; // ST1C_4@2
  char v5; // c0@1
  float v7; // [sp+18h] [bp-8h]@1

  v7 = a2;
  HIWORD(v2) = 0;
  UNDEF(v3);
  if ( v5 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 194);
    v4 = (double)(*(_DWORD *)(a1 + 150) * v2 - *(_DWORD *)(a1 + 162));
    v7 = v4;
  }
  if ( *(_BYTE *)(a1 + 208) & 4 )
    v7 = v7 * 1.3;
  if ( *(_BYTE *)(a1 + 208) & 2 )
    v7 = v7 * 1.3;
  return (double)(*(_WORD *)(a1 + 194) + 100) * v7 / 100.0;
}

//----- (0046BC40) --------------------------------------------------------
int __thiscall combatManager::DoLichShot(void *this, int a2)
{
  int result; // eax@3
  void *v3; // [sp+10h] [bp-54h]@1
  int hexIdx; // [sp+14h] [bp-50h]@8
  char v5[40]; // [sp+18h] [bp-4Ch]@4
  int v6; // [sp+40h] [bp-24h]@4
  float v7; // [sp+44h] [bp-20h]@15
  int i; // [sp+48h] [bp-1Ch]@1
  int v9; // [sp+4Ch] [bp-18h]@1
  float v10; // [sp+50h] [bp-14h]@1
  int v11; // [sp+54h] [bp-10h]@10
  float v12; // [sp+58h] [bp-Ch]@1
  signed int neighborIdx; // [sp+5Ch] [bp-8h]@8
  float v14; // [sp+60h] [bp-4h]@4

  v3 = this;
  v9 = -1;
  v10 = -99999.0;
  v12 = (double)(9 * *(_DWORD *)(a2 + 150));
  for ( i = 0; ; ++i )
  {
    result = 1 - *(_DWORD *)((char *)v3 + 62127);
    if ( *(_DWORD *)((char *)v3 + 4 * result + 13639) <= i )
      break;
    memset(v5, 0, 0x28u);
    v14 = 0.0;
    v6 = (int)((char *)v3 + 24234 * (1 - *(_DWORD *)((char *)v3 + 62127)) + 1154 * i + 13647);
    if ( v6 && !(*(_BYTE *)(v6 + 208) & 0x10) && *(_DWORD *)(v6 + 150) > 0 )
    {
      v14 = combatManager::GetModLichDamage(v6, v12);
      *(&v5[20 * *(_DWORD *)(v6 + 230)] + *(_DWORD *)(v6 + 234)) = 1;
      hexIdx = *(_DWORD *)(v6 + 122);
      for ( neighborIdx = 0; neighborIdx < 6; ++neighborIdx )
      {
        v11 = GetAdjacentCellIndexNoArmy(hexIdx, neighborIdx);
        if ( v11 >= 0
          && v11 < 117
          && *((_BYTE *)v3 + 98 * v11 + 1316) != -1
          && *((_BYTE *)v3 + 98 * v11 + 1317) != -1
          && !*(&v5[20 * *((_BYTE *)v3 + 98 * v11 + 1316)] + *((_BYTE *)v3 + 98 * v11 + 1317)) )
        {
          v7 = combatManager::GetModLichDamage(
                 (int)((char *)v3
                     + 24234 * *((_BYTE *)v3 + 98 * v11 + 1316)
                     + 1154 * *((_BYTE *)v3 + 98 * v11 + 1317)
                     + 13647),
                 v12);
          *(&v5[20 * *((_BYTE *)v3 + 98 * v11 + 1316)] + *((_BYTE *)v3 + 98 * v11 + 1317)) = 1;
          if ( *((_BYTE *)v3 + 98 * v11 + 1316) == *(_DWORD *)((char *)v3 + 62127) )
            v14 = v14 - v7;
          else
            v14 = v7 + v14;
        }
      }
      if ( v9 == -1 || v14 > (double)v10 )
      {
        v10 = v14;
        v9 = i;
        giNextAction = 2;
        giNextActionGridIndex = hexIdx;
      }
    }
  }
  return result;
}
// 46BC40: using guessed type char var_4C[40];

//----- (0046BF70) --------------------------------------------------------
int __thiscall combatManager::GetShooterMask(void *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)this + 4 * a2 + 13639) > i; ++i )
  {
    if ( (char *)this + 24234 * a2 + 1154 * i != (void *)-13647
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 0x10)
      && *((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 4
      && (signed int)*((_BYTE *)this + 24234 * a2 + 1154 * i + 13849) > 0
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13915)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13919)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13924)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13918) )
    {
      if ( !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13920) )
        v5 |= v3;
    }
    v3 *= 2;
  }
  return v5;
}

//----- (0046C0B0) --------------------------------------------------------
int __thiscall combatManager::GetMirrorImageMask(combatManager *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; this->numCreatures[a2] > i; ++i )
  {
    if ( (combatManager *)((char *)this + 24234 * a2 + 1154 * i) != (combatManager *)-13647
      && !(this->creatures[a2][i].creature.creature_flags & 0x10) )
    {
      if ( HIBYTE(this->creatures[a2][i].creature.creature_flags) & 1 )
        v5 |= v3;
    }
    v3 *= 2;
  }
  return v5;
}

//----- (0046C170) --------------------------------------------------------
int __thiscall combatManager::GetFlyerMask(void *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)this + 4 * a2 + 13639) > i; ++i )
  {
    if ( (char *)this + 24234 * a2 + 1154 * i != (void *)-13647
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 0x10)
      && *((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 2
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13915)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13919)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13924)
      && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13918) )
    {
      if ( !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13920) )
        v5 |= v3;
    }
    v3 *= 2;
  }
  return v5;
}

//----- (0046C290) --------------------------------------------------------
int __thiscall combatManager::GetAllMask(combatManager *this, int side)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; this->numCreatures[side] > i; ++i )
  {
    if ( (combatManager *)((char *)this + 24234 * side + 1154 * i) != (combatManager *)-13647// &this[side][i] != 0. Likely meant to be this[side][i] != 0.
      && !(this->creatures[side][i].creature.creature_flags & DEAD) )
    {
      if ( this->creatures[side][i].quantity > 0 )
        v5 |= v3;
    }
    v3 *= 2;
  }
  return v5;
}

//----- (0046C350) --------------------------------------------------------
int __thiscall combatManager::GetWalkerMask(void *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)this + 4 * a2 + 13639) > i; ++i )
  {
    if ( (char *)this + 24234 * a2 + 1154 * i != (void *)-13647
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 0x10)
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 2)
      && (!(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 4)
       || (signed int)*((_BYTE *)this + 24234 * a2 + 1154 * i + 13849) <= 0) )
    {
      if ( !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13915)
        && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13919)
        && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13924)
        && !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13918) )
      {
        if ( !*((_BYTE *)this + 24234 * a2 + 1154 * i + 13920) )
          v5 |= v3;
      }
    }
    v3 *= 2;
  }
  return v5;
}

//----- (0046C4A0) --------------------------------------------------------
int __thiscall combatManager::GetOutOfItMask(void *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)this + 4 * a2 + 13639) > i; ++i )
  {
    if ( (char *)this + 24234 * a2 + 1154 * i != (void *)-13647
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 0x10)
      && (*((_BYTE *)this + 24234 * a2 + 1154 * i + 13915)
       || *((_BYTE *)this + 24234 * a2 + 1154 * i + 13919)
       || *((_BYTE *)this + 24234 * a2 + 1154 * i + 13924)) )
      v5 |= v3;
    v3 *= 2;
  }
  return v5;
}

//----- (0046C590) --------------------------------------------------------
int __thiscall combatManager::GetTraitorMask(void *this, int a2)
{
  signed int v3; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  v3 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)this + 4 * a2 + 13639) > i; ++i )
  {
    if ( (char *)this + 24234 * a2 + 1154 * i != (void *)-13647
      && !(*((_BYTE *)this + 24234 * a2 + 1154 * i + 13855) & 0x10)
      && (*((_BYTE *)this + 24234 * a2 + 1154 * i + 13918) || *((_BYTE *)this + 24234 * a2 + 1154 * i + 13920)) )
      v5 |= v3;
    v3 *= 2;
  }
  return v5;
}

//----- (0046C670) --------------------------------------------------------
signed int __thiscall combatManager::GetBestArmy(void *this, int a2, int a3)
{
  void *v4; // [sp+Ch] [bp-18h]@1
  signed int v5; // [sp+10h] [bp-14h]@1
  signed int i; // [sp+14h] [bp-10h]@1
  signed int v7; // [sp+18h] [bp-Ch]@1
  unsigned __int32 v8; // [sp+1Ch] [bp-8h]@4
  unsigned __int32 v9; // [sp+20h] [bp-4h]@1

  v4 = this;
  v5 = 1;
  v9 = 0;
  v7 = -1;
  for ( i = 0; *(_DWORD *)((char *)v4 + 4 * a2 + 13639) > i; ++i )
  {
    if ( v5 & a3 )
    {
      v8 = army::Strength((army *)((char *)v4 + 24234 * a2 + 1154 * i + 13647));
      if ( *((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13915)
        || *((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13919)
        || *((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13924)
        || *((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13918)
        || *((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13920) )
        v8 >>= 1;
      if ( v9 < v8 )
      {
        v7 = i;
        v9 = v8;
      }
    }
    v5 *= 2;
  }
  return v7;
}

//----- (0046C870) --------------------------------------------------------
signed int __thiscall combatManager::GetWorstArmy(void *this, int a2, int a3)
{
  void *v4; // [sp+Ch] [bp-18h]@1
  signed int v5; // [sp+10h] [bp-14h]@1
  signed int i; // [sp+14h] [bp-10h]@1
  signed int v7; // [sp+18h] [bp-Ch]@1
  unsigned __int32 v8; // [sp+1Ch] [bp-8h]@4
  signed int v9; // [sp+20h] [bp-4h]@1

  v4 = this;
  v5 = 1;
  v9 = 999999999;
  v7 = -1;
  for ( i = 0; *(_DWORD *)((char *)v4 + 4 * a2 + 13639) > i; ++i )
  {
    if ( v5 & a3 )
    {
      v8 = army::Strength((army *)((char *)v4 + 24234 * a2 + 1154 * i + 13647));
      if ( v9 > v8 )
      {
        v7 = i;
        v9 = v8;
      }
    }
    v5 *= 2;
  }
  return v7;
}

//----- (0046C940) --------------------------------------------------------
signed int __thiscall combatManager::GetClosestArmy(combatManager *this, army *stack, int side, int stackBmask)
{
  int dist; // eax@4
  int hp; // edx@4
  combatManager *thisa; // [sp+Ch] [bp-1Ch]@1
  signed int t; // [sp+14h] [bp-14h]@1
  int i; // [sp+18h] [bp-10h]@1
  signed int bestIdx; // [sp+1Ch] [bp-Ch]@1
  int lowestScore; // [sp+20h] [bp-8h]@1

  thisa = this;
  t = 1;
  lowestScore = 9999999;
  bestIdx = -1;
  for ( i = 0; thisa->numCreatures[side] > i; ++i )
  {
    if ( t & stackBmask )
    {
      dist = searchArray::QuickDistance(
               thisa->combatGrid[stack->occupiedHex].centerX,
               thisa->combatGrid[stack->occupiedHex].occupyingCreatureBottomY,
               thisa->combatGrid[thisa->creatures[side][i].occupiedHex].centerX,
               thisa->combatGrid[thisa->creatures[side][i].occupiedHex].occupyingCreatureBottomY);
      hp = thisa->creatures[side][i].creature.hp;
      if ( lowestScore > 1000 * dist - thisa->creatures[side][i].quantity * hp )
      {
        bestIdx = i;
        lowestScore = 1000 * dist - thisa->creatures[side][i].quantity * hp;
      }
    }
    t *= 2;
  }
  return bestIdx;
}

//----- (0046CAB0) --------------------------------------------------------
int __thiscall combatManager::GetStrength(void *this, int a2, int a3)
{
  void *v4; // [sp+Ch] [bp-14h]@1
  int v5; // [sp+14h] [bp-Ch]@1
  signed int v6; // [sp+18h] [bp-8h]@1
  int i; // [sp+1Ch] [bp-4h]@1

  v4 = this;
  v6 = 1;
  v5 = 0;
  for ( i = 0; *(_DWORD *)((char *)v4 + 4 * a2 + 13639) > i; ++i )
  {
    if ( v6 & a3 && (char *)v4 + 24234 * a2 + 1154 * i != (void *)-13647 )
    {
      if ( !(*((_BYTE *)v4 + 24234 * a2 + 1154 * i + 13855) & 0x10) )
        v5 += army::Strength((army *)((char *)v4 + 24234 * a2 + 1154 * i + 13647));
    }
    v6 *= 2;
  }
  return v5;
}

//----- (0046CB80) --------------------------------------------------------
signed int __thiscall combatManager::AttemptAttack(combatManager *this, int a2, int a3, int a4)
{
  int hex; // [sp+10h] [bp-8h]@8
  int hexa; // [sp+10h] [bp-8h]@12
  signed int v8; // [sp+14h] [bp-4h]@4

  while ( a4 )
  {
    if ( *(_DWORD *)(a2 + 118) == 59 )
      v8 = combatManager::GetWorstArmy(this, a3, a4);
    else
      v8 = combatManager::GetBestArmy(this, a3, a4);
    if ( v8 == -1 )
      return 0;
    *(_DWORD *)(a2 + 82) = a3;
    *(_DWORD *)(a2 + 86) = v8;
    hex = this->creatures[a3][v8].occupiedHex;
    *(_DWORD *)(a2 + 98) = hex;
    if ( army::ValidPath((army *)a2, hex, 0) )
    {
      giNextAction = 2;
      giNextActionGridIndex = hex;
      return 1;
    }
    if ( this->creatures[a3][v8].creature.creature_flags & 1 )
    {
      hexa = this->creatures[a3][v8].facingRight ? hex + 1 : hex - 1;
      *(_DWORD *)(a2 + 98) = hexa;
      if ( army::ValidPath((army *)a2, hexa, 0) )
      {
        giNextAction = 2;
        giNextActionGridIndex = hexa;
        return 1;
      }
    }
    a4 &= ~(1 << v8);
  }
  return 0;
}

//----- (0046CD40) --------------------------------------------------------
signed int __thiscall combatManager::AttemptAdjacentAttack(void *this, int a2)
{
  signed int result; // eax@2
  void *v3; // [sp+Ch] [bp-20h]@1
  int v4; // [sp+10h] [bp-1Ch]@3
  signed int v5; // [sp+14h] [bp-18h]@3
  int neighbor; // [sp+18h] [bp-14h]@6
  signed int neighborIdx; // [sp+1Ch] [bp-10h]@3
  int v8; // [sp+24h] [bp-8h]@11
  int v9; // [sp+28h] [bp-4h]@1

  v3 = this;
  v9 = ~army::GetAttackMask((army *)a2, *(_DWORD *)(a2 + 122), 1, -1);
  if ( v9 )
  {
    v5 = 1;
    v4 = 0;
    for ( neighborIdx = 0; neighborIdx < 8; ++neighborIdx )
    {
      if ( v5 & v9 && army::ValidAttack((army *)a2, *(_DWORD *)(a2 + 122), neighborIdx, 1, -1, &neighbor) )
      {
        if ( neighbor >= 0 )
          v4 |= 1 << *((_BYTE *)v3 + 98 * neighbor + 1317);
      }
      v5 *= 2;
    }
    if ( *(_DWORD *)(a2 + 118) == 59 )
      v8 = combatManager::GetWorstArmy(v3, 1 - *(_DWORD *)((char *)v3 + 62127), v4);
    else
      v8 = combatManager::GetBestArmy(v3, 1 - *(_DWORD *)((char *)v3 + 62127), v4);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      giNextAction = 2;
      giNextActionGridIndex = *(_DWORD *)((char *)v3 + 24234 * (1 - *(_DWORD *)((char *)v3 + 62127)) + 1154 * v8 + 13769);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0046CED0) --------------------------------------------------------
signed int __thiscall combatManager::WalkTowardArmyFront(void *this, int a2, int a3, int a4)
{
  signed int result; // eax@2
  char v5; // ST3C_1@11
  void *thisa; // [sp+Ch] [bp-20h]@1
  int v7; // [sp+10h] [bp-1Ch]@12
  int v8; // [sp+14h] [bp-18h]@12
  int targHex; // [sp+18h] [bp-14h]@3
  int targHexa; // [sp+18h] [bp-14h]@6
  signed int v11; // [sp+20h] [bp-Ch]@3
  signed int v12; // [sp+24h] [bp-8h]@1

  thisa = this;
  *(_DWORD *)(a2 + 82) = -1;
  *(_DWORD *)(a2 + 86) = -1;
  v12 = combatManager::GetClosestArmy((combatManager *)this, (army *)a2, a3, a4);
  if ( v12 == -1 )
  {
    result = 0;
  }
  else
  {
    v11 = 1;
    targHex = *(_DWORD *)((char *)thisa + 24234 * a3 + 1154 * v12 + 13769);
    if ( *((_BYTE *)thisa + 24234 * a3 + 1154 * v12 + 13855) & 1 )
      v11 = 2;
    if ( *(_DWORD *)(a2 + 134) == 1 )
      targHexa = v11 + targHex;
    else
      targHexa = targHex - v11;
    if ( targHexa % 13 != 12 && targHexa % 13 )
    {
      v5 = *(_BYTE *)(a2 + 197);
      *(_BYTE *)(a2 + 197) = 127;
      searchArray::FindCombatPath(gpSearchArray, *(_DWORD *)(a2 + 122), targHexa, (army *)a2, 1, 0);
      *(_BYTE *)(a2 + 197) = v5;
      if ( gpSearchArray->field_8 <= 0 )
      {
        result = combatManager::WalkTowardArmy((combatManager *)thisa, (army *)a2, a3, a4);
      }
      else
      {
        giNextAction = 2;
        v7 = *(_BYTE *)(a2 + 197);
        v8 = gpSearchArray->field_8 - 1;
        giNextActionGridIndex = *(_DWORD *)(a2 + 122);
        while ( v8 >= 0 && v7 )
        {
          giNextActionGridIndex = army::GetAdjacentCellIndex(
                                    (army *)a2,
                                    giNextActionGridIndex,
                                    *((_BYTE *)&gpSearchArray->field_2418 + v8--));
          --v7;
          if ( giNextActionGridIndex > 0 )
          {
            if ( bIsMoatSlowed[giNextActionGridIndex] )
              v7 = 0;
          }
        }
        result = 1;
      }
    }
    else
    {
      result = combatManager::WalkTowardArmy((combatManager *)thisa, (army *)a2, a3, a4);
    }
  }
  return result;
}

//----- (0046D110) --------------------------------------------------------
signed int __thiscall combatManager::WalkTowardArmy(combatManager *this, army *stack, int side, int stackBmask)
{
  signed int result; // eax@2
  char *v5; // eax@3
  int v6; // [sp+Ch] [bp-2Ch]@7
  combatManager *thisa; // [sp+10h] [bp-28h]@1
  int v8; // [sp+14h] [bp-24h]@15
  int v9; // [sp+18h] [bp-20h]@15
  army *othStack; // [sp+1Ch] [bp-1Ch]@3
  int targHex; // [sp+20h] [bp-18h]@3
  int bestIdx; // [sp+30h] [bp-8h]@1
  char v13; // [sp+34h] [bp-4h]@5

  thisa = this;
  bestIdx = combatManager::GetClosestArmy(this, stack, side, stackBmask);
  if ( bestIdx == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = (char *)thisa + 24234 * side + 1154 * bestIdx;
    othStack = (army *)(v5 + 13647);
    targHex = *(_DWORD *)(v5 + 13769);
    stack->targetOwner = side;
    stack->targetStackIdx = bestIdx;
    if ( army::GetAttackMask(stack, stack->occupiedHex, 0, -1) == 255 )
    {
      v13 = stack->creature.speed;
      stack->creature.speed = 127;
      if ( !searchArray::FindCombatPath(gpSearchArray, stack->occupiedHex, targHex, stack, -1, 0)
        && othStack->creature.creature_flags & TWO_HEXER )
      {
        v6 = othStack->facingRight;
        if ( v6 )
        {
          if ( v6 == 1 )
            ++targHex;
        }
        else
        {
          --targHex;
        }
        if ( targHex != -1 )
          searchArray::FindCombatPath(gpSearchArray, stack->occupiedHex, targHex, stack, -1, 0);
      }
      stack->creature.speed = v13;
      if ( gpSearchArray->field_8 <= 1 )
      {
        result = 0;
      }
      else
      {
        giNextAction = 2;
        v8 = stack->creature.speed;
        v9 = gpSearchArray->field_8 - 1;
        giNextActionGridIndex = stack->occupiedHex;
        while ( v9 >= 1 && v8 )
        {
          giNextActionGridIndex = army::GetAdjacentCellIndex(
                                    stack,
                                    giNextActionGridIndex,
                                    *((_BYTE *)&gpSearchArray->field_2418 + v9--));
          --v8;
          if ( giNextActionGridIndex > 0 )
          {
            if ( bIsMoatSlowed[giNextActionGridIndex] )
              v8 = 0;
          }
        }
        result = 1;
      }
    }
    else
    {
      giNextAction = 3;
      result = 1;
    }
  }
  return result;
}

//----- (0046D360) --------------------------------------------------------
void __cdecl RemoteCleanup()
{
  LogStr("RC1");
  if ( gbRemoteOn )
  {
    LogStr("RC2");
    if ( !gbInRemoteMain )
    {
      if ( !gbInRemoteCleanup )
      {
        gbInRemoteCleanup = 1;
        LogStr("RC3");
        switch ( GameMode )
        {
          case 1:
          case 2:
            UnloadRemoteDriver(1);
            break;
          case 3:
          case 4:
            UnloadRemoteDriver(0);
            break;
          default:
            break;
        }
        gbRemoteOn = 0;
        xNetHasOldPlayers = 0;
        iInOrderCtr = 0;
        iCurLastID = 0;
        dword_512578 = -1;
        GameMode = 0;
        lLastHeartbeatSend = 0;
        gbInRemoteMain = 0;
        iIDCtr = 0;
        iTimesDropped = 0;
        bUseDirectPlay = 0;
        bUseWinsock = 0;
        bInTimeoutFail = 0;
        iMPNetProtocol = 0;
        iLastDiffSendTo = -2;
        gbGotFirstHeartbeat = 0;
        gbInRemoteCleanup = 0;
      }
    }
  }
}
// 4F3094: using guessed type int gbGotFirstHeartbeat;
// 4F31B4: using guessed type int iMPNetProtocol;
// 4F31B8: using guessed type int iLastDiffSendTo;
// 4F7494: using guessed type int gbRemoteOn;
// 512570: using guessed type int iInOrderCtr;
// 512574: using guessed type int iCurLastID;
// 512578: using guessed type int dword_512578;
// 51257C: using guessed type char GameMode;
// 512580: using guessed type int lLastHeartbeatSend;
// 512584: using guessed type int gbInRemoteMain;
// 512588: using guessed type int gbInRemoteCleanup;
// 51258C: using guessed type int iIDCtr;
// 512590: using guessed type int iTimesDropped;
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;
// 5125A0: using guessed type char bInTimeoutFail;
// 51AC64: using guessed type char xNetHasOldPlayers;

//----- (0046D4F0) --------------------------------------------------------
void __thiscall RemoteMain(void *this)
{
  int v1; // edx@41
  char *v2; // edi@44
  int v3; // esi@44
  int v4; // edx@59
  void *v5; // [sp+14h] [bp-6Ch]@1
  signed int v6; // [sp+1Ch] [bp-64h]@39
  char v7[8]; // [sp+20h] [bp-60h]@39
  void *v8; // [sp+28h] [bp-58h]@41
  int v9; // [sp+2Ch] [bp-54h]@44
  void *v10; // [sp+34h] [bp-4Ch]@56
  int i; // [sp+38h] [bp-48h]@1
  int a2; // [sp+7Ch] [bp-4h]@5

  v5 = this;
  gbInRemoteMain = 1;
  bGotGameType = 0;
  LogStr("In Remote Main");
  LogStr("RM 1");
  for ( i = 0; i < 6; ++i )
  {
    lLastHeartbeatReceive[i] = 1999999999;
    sprintf((char *)&gsNetPlayerInfo + 34 * i + 4, "Player %d", i + 1);
  }
  LogStr("RM 2");
  gbRemoteGameOpen = 1;
  if ( bLastMouseOffscreen )
    a2 = bLastOnscreenMouseColor;
  else
    a2 = gbColorMice;
  mouseManager::SetColorMice(gpMouseManager, 0);
  LogStr("RM 3");
  gbInNetSetup = 1;
  if ( iMPNetProtocol == 1 )
  {
    bUseDirectPlay = 1;
  }
  else if ( iMPNetProtocol == 2 )
  {
    bUseWinsock = 1;
  }
  else
  {
    bUseWinsock = 0;
    bUseDirectPlay = 0;
  }
  LogStr("RM 4");
  memset(&sMapChangeQueue, 0, 0x86Cu);
  for ( i = 0; i < 128; ++i )
    rcvBuf[i] = 0;
  LogStr("RM 5");
  memset(&iLastIds, 0, 0x1Eu);
  GameMode = (char)v5;
  LogStr("RM 6");
  memset(&gsNetPlayerInfo, 0, 0xCCu);
  memset(&gsThisNetPlayerInfo, 0, 0x22u);
  LogStr("RM 7");
  if ( giTCPHostStatus == -1 )
  {
    GetDataEntry(
      "Please enter a 'handle' by which you will be known.",
      (int)&unk_526CBC,
      20,
      (const char *)&gConfig + 392,
      1u,
      0);
  }
  else if ( strlen(gcTCPName) )
  {
    strcpy((char *)&gsThisNetPlayerInfo + 4, gcTCPName);
  }
  else
  {
    strcpy((char *)&gsThisNetPlayerInfo + 4, (char *)&gConfig + 392);
  }
  strcpy((char *)&gConfig + 392, (char *)&gsThisNetPlayerInfo + 4);
  WritePrefs();
  strcpy((char *)&gsThisNetPlayerInfo, (char *)&gConfig + 290);
  byte_526CD1 = 2;
  byte_526CD2 = 1;
  byte_526CD3 = 1;
  byte_526CD4 = 1;
  xNetHasOldPlayers = 0;
  switch ( v5 )
  {
    case 1u:
      memcpy(&gsNetPlayerInfo, &gsThisNetPlayerInfo, 0x22u);
      giThisNetPos = 0;
      goto LABEL_24;
    case 2u:
      giThisNetPos = 1;
LABEL_24:
      if ( bUseDirectPlay )
      {
        gbRemoteOn = 1;
        dpnet_init();
      }
      else if ( bUseWinsock )
      {
        wsnet_init();
        gbRemoteOn = 1;
      }
      else
      {
        nbnet_init();
        gbRemoteOn = 1;
      }
      break;
    case 3u:
      LogStr("MH1");
      gbRemoteOn = 1;
      memcpy(&gsNetPlayerInfo, &gsThisNetPlayerInfo, 0x22u);
      giThisNetPos = 0;
      ModemSetup(v5);
      LogStr("MH2");
      break;
    case 4u:
      gbRemoteOn = 1;
      giThisNetPos = 1;
      ModemSetup(v5);
      break;
    default:
      break;
  }
  if ( !bUseDirectPlay && !bUseWinsock )
    iLastMsgNumHumanPlayers = 2;
  iIDCtr = 100000000 * (giThisNetPos + 1);
  gbInNetSetup = 0;
  mouseManager::SetColorMice(gpMouseManager, a2);
  if ( !bUseDirectPlay && !bUseWinsock )
  {
    LogStr("RM 2");
    if ( giThisNetPos )
    {
      LogStr("RM 5");
      TransmitRemoteData(&gsThisNetPlayerInfo, 0, 0x22u, 34, 1, 1, -1);
      LogStr("RM 6");
    }
    else
    {
      v6 = 1;
      memset(v7, 0, 6u);
      while ( v6 )
      {
        PollSound();
        LogStr("RM 3");
        v8 = GetRemoteData(1, v1);
        LogStr("RM 4");
        if ( v8 )
        {
          if ( *((_BYTE *)v8 + 5) == 2 )
          {
            if ( *((_BYTE *)v8 + 6) == 34 )
            {
              v9 = *(_BYTE *)v8;
              v2 = (char *)&gsNetPlayerInfo + 34 * v9;
              v3 = (int)((char *)v8 + 9);
              memcpy(v2, (char *)v8 + 9, 0x20u);
              *((_WORD *)v2 + 16) = *(_WORD *)(v3 + 32);
              v7[v9] = 1;
              if ( !byte_526CFC[34 * v9] )
                xNetHasOldPlayers = 1;
            }
          }
        }
        v6 = 0;
        for ( i = 1; iLastMsgNumHumanPlayers > i; ++i )
        {
          if ( !v7[i] )
            v6 = 1;
        }
      }
    }
  }
  v10 = 0;
  if ( giThisNetPos )
  {
    while ( !bGotGameType )
    {
      PollSound();
      v10 = GetRemoteData(1, v4);
      if ( v10 && *((_BYTE *)v10 + 5) == 2 && *((_BYTE *)v10 + 6) == 62 )
      {
        bGotGameType = 1;
        giSetupGameType = 1;
      }
      if ( v10 && *((_BYTE *)v10 + 5) == 2 && *((_BYTE *)v10 + 6) == 61 )
      {
        bGotGameType = 1;
        giSetupGameType = 0;
      }
    }
  }
  else
  {
    TransmitRemoteData(0, 127, 0, ((unsigned int)(unsigned __int8)giSetupGameType - 1 < 1) + 61, 1, 1, -1);
  }
  LogStr("Out Remote Main");
  gbInRemoteMain = 0;
}
// 4F19B0: using guessed type int gbColorMice;
// 4F31B4: using guessed type int iMPNetProtocol;
// 4F7494: using guessed type int gbRemoteOn;
// 51257C: using guessed type char GameMode;
// 512584: using guessed type int gbInRemoteMain;
// 51258C: using guessed type int iIDCtr;
// 512594: using guessed type char gbInNetSetup;
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;
// 51AC64: using guessed type char xNetHasOldPlayers;
// 51F6EC: using guessed type int bLastMouseOffscreen;
// 51F6F0: using guessed type int bLastOnscreenMouseColor;
// 523004: using guessed type char giSetupGameType;
// 52340C: using guessed type int giTCPHostStatus;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 524A6C: using guessed type int gbRemoteGameOpen;
// 526CD1: using guessed type char byte_526CD1;
// 526CD2: using guessed type char byte_526CD2;
// 526CD3: using guessed type char byte_526CD3;
// 526CD4: using guessed type char byte_526CD4;
// 526DB0: using guessed type int lLastHeartbeatReceive[];
// 526ED4: using guessed type int bGotGameType;
// 46D4F0: using guessed type char var_60[8];

//----- (0046DBD0) --------------------------------------------------------
void __fastcall UnloadRemoteDriver(__int16 a1)
{
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      if ( bUseDirectPlay )
      {
        dpnet_term();
      }
      else if ( bUseWinsock )
      {
        wsnet_term();
      }
      else
      {
        nb_term();
      }
    }
  }
  else
  {
    com_term(0);
  }
}
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;

//----- (0046DC60) --------------------------------------------------------
int __fastcall calc_crc_long(int a1, int a2)
{
  int v2; // ST14_4@2
  int v3; // ST20_4@3
  int v5; // [sp+Ch] [bp-1Ch]@1
  int v6; // [sp+10h] [bp-18h]@1
  int v7; // [sp+1Ch] [bp-Ch]@1
  unsigned int v8; // [sp+24h] [bp-4h]@1

  v5 = a2;
  v6 = a1;
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    v2 = v5--;
    if ( !v2 )
      break;
    v3 = v7 & 0x8000000;
    v7 = *(_BYTE *)v6 + 2 * v7;
    v8 += *(_BYTE *)v6;
    if ( v3 )
      ++v7;
    ++v6;
  }
  return (v8 << 16) + (v8 >> 16) + v7;
}

//----- (0046DCF0) --------------------------------------------------------
int __fastcall calc_crc(int a1, int a2, int a3)
{
  int v3; // ST10_4@1
  int result; // eax@1

  v3 = a1;
  result = calc_crc_long(a2, a3);
  *(_WORD *)v3 = result;
  return result;
}

//----- (0046DD20) --------------------------------------------------------
unsigned int __fastcall EncodePacket(const void *a1, int a2, char a3, size_t a4)
{
  __int16 v5; // [sp+14h] [bp-4h]@1

  *(_BYTE *)&PacketSend = a2;
  byte_527219 = a3;
  byte_52721A = 0;
  byte_52721B = a4;
  v5 = 0;
  word_52721C = 0;
  memcpy((char *)&PacketSend + 6, a1, a4);
  calc_crc((int)&v5, (int)&PacketSend, a4 + 6);
  word_52721C = v5;
  return a4 + 6;
}
// 527219: using guessed type char byte_527219;
// 52721A: using guessed type char byte_52721A;
// 52721B: using guessed type char byte_52721B;
// 52721C: using guessed type __int16 word_52721C;

//----- (0046DDB0) --------------------------------------------------------
signed int __thiscall DecodePacket(void *this)
{
  signed int result; // eax@3
  void *v2; // [sp+10h] [bp-DCh]@1
  size_t v3; // [sp+14h] [bp-D8h]@4
  char msg; // [sp+18h] [bp-D4h]@3
  int v5; // [sp+E0h] [bp-Ch]@1
  int v6; // [sp+E8h] [bp-4h]@4

  v2 = this;
  LOWORD(v5) = 0;
  if ( byte_526DC9 == giThisNetPos || byte_526DC9 == 127 )
  {
    v3 = (unsigned __int8)byte_526DCB;
    LOWORD(v6) = word_526DCC;
    word_526DCC = 0;
    calc_crc((int)&v5, (int)packet, (unsigned __int8)byte_526DCB + 6);
    if ( (unsigned __int16)v6 == (unsigned __int16)v5 )
    {
      memcpy(v2, &packet[6], v3);
      result = 1;
    }
    else
    {
      sprintf(&msg, "CRC Check Failed CRC 1 %d CRC 2 %d\n", (unsigned __int16)v6, (unsigned __int16)v5);
      LogStr(&msg);
      result = 0;
    }
  }
  else
  {
    sprintf(&msg, "not mine %d\n", byte_526DC9);
    LogStr(&msg);
    result = 0;
  }
  return result;
}
// 526DC9: using guessed type char byte_526DC9;
// 526DCB: using guessed type char byte_526DCB;
// 526DCC: using guessed type __int16 word_526DCC;

//----- (0046DEE0) --------------------------------------------------------
signed int __thiscall SendRemoteData(int a1, int a2, size_t a3)
{
  signed __int16 v3; // ax@10
  signed int v5; // [sp+118h] [bp-10h]@1
  unsigned int v6; // [sp+124h] [bp-4h]@5

  v5 = 1;
  if ( a2 == 127 && !bUseDirectPlay && !bUseWinsock )
    a2 = 1 - giThisNetPos;
  v6 = EncodePacket((const void *)a1, giThisNetPos, a2, a3);
  switch ( GameMode )
  {
    case 1:
    case 2:
      if ( bUseDirectPlay )
      {
        dpnet_snd(a2, v6, &PacketSend);
      }
      else if ( bUseWinsock )
      {
        wsnet_snd(a2, v6, &PacketSend);
      }
      else
      {
        v3 = nb_snd(a2, v6, &PacketSend);
        if ( v3 )
        {
          LogInt((int)"Bad return on Send Data", a2, v3, v6, 0, 0, -999, -999);
          v5 = 0;
        }
      }
      break;
    case 3:
    case 4:
      WriteModemPacket((int)&PacketSend, v6);
      v5 = 1;
      break;
    default:
      return v5;
  }
  return v5;
}
// 51257C: using guessed type char GameMode;
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;

//----- (0046E070) --------------------------------------------------------
signed int __fastcall ReceiveRemoteData(int a1, void *a2, int a3)
{
  signed int result; // eax@4
  void *v4; // [sp+10h] [bp-10h]@1
  signed int v5; // [sp+1Ch] [bp-4h]@1

  v4 = a2;
  v5 = 1;
  switch ( GameMode )
  {
    case 1:
    case 2:
      if ( bUseDirectPlay )
      {
        if ( dpnet_rcv(packet) )
        {
          v5 = DecodePacket(v4);
          goto LABEL_18;
        }
        result = 0;
      }
      else if ( bUseWinsock )
      {
        if ( wsnet_rcv(packet) )
        {
          v5 = DecodePacket(v4);
          goto LABEL_18;
        }
        result = 0;
      }
      else
      {
        if ( nb_rcv(0x10Au, packet) )
        {
          v5 = DecodePacket(v4);
          goto LABEL_18;
        }
        result = 0;
      }
      break;
    case 3:
    case 4:
      if ( ReadPacket() )
      {
        v5 = DecodePacket(v4);
        goto LABEL_18;
      }
      result = 0;
      break;
    default:
LABEL_18:
      result = v5;
      break;
  }
  return result;
}
// 51257C: using guessed type char GameMode;
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;

//----- (0046E1D0) --------------------------------------------------------
int __fastcall TransmitRemoteData(const void *a1, int a2, size_t a3, char a4, char a5, char a6, char a7)
{
  int result; // eax@3
  int a2a; // [sp+Ch] [bp-118h]@1
  signed int v9; // [sp+14h] [bp-110h]@4
  _BYTE a1a[5]; // [sp+18h] [bp-10Ch]@4
  char v11; // [sp+1Dh] [bp-107h]@5
  char v12; // [sp+1Eh] [bp-106h]@9
  __int16 v13; // [sp+1Fh] [bp-105h]@9
  char v14; // [sp+21h] [bp-103h]@10
  int i; // [sp+11Ch] [bp-8h]@17
  int v16; // [sp+120h] [bp-4h]@4

  a2a = a2;
  if ( gbRemoteOn && !gbInNetSetup )
  {
    v16 = 0;
    v9 = 0;
    ++iIDCtr;
    a1a[0] = giThisNetPos;
    *(_DWORD *)&a1a[1] = iIDCtr;
    if ( a7 == -1 )
    {
      if ( a5 )
        v11 = 2;
      else
        v11 = 3;
    }
    else
    {
      v11 = a7;
    }
    v13 = a3;
    v12 = a4;
    if ( (signed int)a3 > 0 )
      memcpy(&v14, a1, a3);
    while ( !v16 && v9 <= 25 )
    {
      v16 = SendRemoteData((int)a1a, a2a, a3 + 9);
      if ( !a5 && v16 )
        return 1;
      if ( v16 )
      {
        for ( i = 0; i < 50; ++i )
        {
          ForcePollSound();
          if ( iIDCtr == dword_512578 )
            return 1;
          v16 = 0;
          DelayMilli(20);
        }
      }
      else
      {
        DelayMilli(1000);
      }
      if ( a6 && v9 == 25 && !v16 )
      {
        NormalDialog("Error sending data.  Keep trying??", 2, -1, -1, -1, 0, -1, 0, -1, 0);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          v9 = -1;
      }
      ++v9;
    }
    result = v16;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 512578: using guessed type int dword_512578;
// 51258C: using guessed type int iIDCtr;
// 512594: using guessed type char gbInNetSetup;

//----- (0046E3F0) --------------------------------------------------------
void *__fastcall GetRemoteData(char relinquish, int a2)
{
  void *result; // eax@3
  char v3; // [sp+Ch] [bp-10h]@1
  signed int v4; // [sp+10h] [bp-Ch]@4
  signed int i; // [sp+14h] [bp-8h]@4
  signed int v6; // [sp+18h] [bp-4h]@4

  v3 = relinquish;
  if ( gbRemoteOn && !gbInNetSetup )
  {
    v4 = 999999999;
    v6 = -1;
    for ( i = 0; i < 128; ++i )
    {
      if ( rcvBuf[i] )
      {
        if ( iInOrder[i] < v4 )
        {
          v4 = iInOrder[i];
          v6 = i;
        }
      }
    }
    if ( v6 < 0 )
    {
      result = 0;
    }
    else
    {
      memcpy(&rcvBufOut, (const void *)rcvBuf[v6], 0x100u);
      if ( v3 )
      {
        BaseFree((void *)rcvBuf[v6], (int)"F:\\h2xsrc\\Source\\REMOTE.CPP", word_512728 + 25);
        rcvBuf[v6] = 0;
      }
      result = &rcvBufOut;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 512594: using guessed type char gbInNetSetup;
// 512728: using guessed type __int16 word_512728;
// 526EE0: using guessed type int iInOrder[];

//----- (0046E500) --------------------------------------------------------
void __cdecl PollRemote()
{
  int v0; // ST40_4@29
  int v1; // eax@29
  int v2; // ST34_4@43
  int v3; // eax@43
  int a2; // [sp+Ch] [bp-30h]@18
  __int16 v5; // [sp+18h] [bp-24h]@0
  char v6; // [sp+1Ah] [bp-22h]@0
  signed int v7; // [sp+1Ch] [bp-20h]@33
  __int16 v8; // [sp+24h] [bp-18h]@0
  char v9; // [sp+26h] [bp-16h]@0
  char v10; // [sp+28h] [bp-14h]@12
  void *i; // [sp+2Ch] [bp-10h]@22
  signed int j; // [sp+2Ch] [bp-10h]@48
  signed int k; // [sp+2Ch] [bp-10h]@69
  signed int l; // [sp+2Ch] [bp-10h]@74
  signed int m; // [sp+2Ch] [bp-10h]@78
  int v16; // [sp+30h] [bp-Ch]@12
  signed int v17; // [sp+34h] [bp-8h]@55
  int v18; // [sp+38h] [bp-4h]@12

  if ( gbRemoteOn && !gbInRemoteCleanup )
  {
    if ( iMPBaseType )
    {
      if ( iMPBaseType == 1 )
      {
        if ( bUseDirectPlay )
        {
          dpProcessMessages();
        }
        else if ( bUseWinsock )
        {
          wsProcessMessages();
        }
        else
        {
          nb_thr_ctl();
        }
      }
    }
    else
    {
      comm_wrt_task();
    }
    if ( !gbInNetSetup )
    {
      v16 = 0;
      v18 = gbInPollSound;
      v10 = 0;
      if ( KBTickCount() - lLastHeartbeatSend > 5000 )
      {
        sndBuf = giThisNetPos;
        byte_52710D = 4;
        word_52710F = 0;
        if ( gbThisNetGotAdventureControl )
          byte_52710E = iCurHourGlassPhase | (unsigned __int8)(16 * (giCurPlayer + 1)) | 0x80;
        else
          byte_52710E = 0;
        if ( giThisNetPos && !gbThisNetGotAdventureControl )
          a2 = 0;
        else
          a2 = 127;
        SendRemoteData((int)&sndBuf, a2, 0xAu);
        lLastHeartbeatSend = KBTickCount();
      }
      if ( giThisNetPos )
      {
        v7 = 60000;
        if ( giThisNetPos != 1 )
          v7 = 90000;
        if ( KBTickCount() > v7 + lLastHeartbeatReceive[0] && !bInTimeoutFail )
        {
          bInTimeoutFail = 1;
          gbInPollSound = 0;
          if ( giThisNetPos == 1 )
            sprintf(
              gText,
              "%s's computer is not responding.  Do you wish to keep waiting for a response?",
              (char *)&gsNetPlayerInfo + 4);
          else
            sprintf(
              gText,
              "Your remote connection to the other players appears to be broken.  Do you wish to keep waiting for a response?");
          NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
          if ( gpWindowManager->buttonPressedCode == 30725 )
          {
            lLastHeartbeatReceive[0] = KBTickCount();
          }
          else if ( giThisNetPos == 1 )
          {
            LOBYTE(v2) = 0;
            v3 = NetPosToGamePos(0);
            BYTE1(v2) = v3;
            HIWORD(v2) = 257;
            LOBYTE(v5) = 0;
            LOBYTE(v3) = v6;
            v3 <<= 16;
            LOWORD(v3) = v5;
            ReceiveRemotePlayerExit(v2, v3);
          }
          else
          {
            game::SaveGame(gpGame, "PLYREXIT", 1, 0);
            sprintf(
              gText,
              "The current game has been saved as 'PLYREXIT'. Do you wish to keep playing with the computer filling in for the other humans?");
            NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
            if ( gpWindowManager->buttonPressedCode == 30725 )
              DropDownToOnePlayer();
            else
              ShutDown(byte_5128E8);
          }
          gbInPollSound = v18;
          bInTimeoutFail = 1;
        }
      }
      else
      {
        for ( i = 0; iLastMsgNumHumanPlayers > (signed int)i; i = (char *)i + 1 )
        {
          if ( (void *)giThisNetPos != i
            && lLastHeartbeatReceive[(signed int)i] + 60000 < KBTickCount()
            && !bInTimeoutFail )
          {
            bInTimeoutFail = 1;
            gbInPollSound = 0;
            sprintf(
              gText,
              "%s's computer is not responding.  Do you wish to keep waiting for a response?",
              (char *)&gsNetPlayerInfo + 34 * (_DWORD)i + 4);
            NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
            if ( gpWindowManager->buttonPressedCode == 30725 )
            {
              lLastHeartbeatReceive[(signed int)i] = KBTickCount();
            }
            else
            {
              LOBYTE(v0) = (_BYTE)i;
              v1 = NetPosToGamePos(i);
              BYTE1(v0) = v1;
              HIWORD(v0) = 257;
              LOBYTE(v8) = 0;
              LOBYTE(v1) = v9;
              v1 <<= 16;
              LOWORD(v1) = v8;
              ReceiveRemotePlayerExit(v0, v1);
            }
            gbInPollSound = v18;
            bInTimeoutFail = 0;
          }
        }
      }
      for ( j = 0; j < 128; ++j )
      {
        if ( rcvBuf[j] )
          ++v16;
      }
      if ( v16 == 128 )
        v10 = 1;
      v17 = 1;
      while ( v17 )
      {
LABEL_57:
        v17 = ReceiveRemoteData(0, rcvBufIn, 127);
        if ( v17 && rcvBufIn[0] != giThisNetPos )
        {
          if ( byte_52732D == 1 )
          {
            dword_512578 = dword_527329;
            return;
          }
          if ( byte_52732D == 4 )
          {
            lLastHeartbeatReceive[rcvBufIn[0]] = KBTickCount();
            if ( byte_52732E & 0x80 && !gbThisNetGotAdventureControl )
              LODWORD(iCurHourGlassPhase) = byte_52732E & 0xF;
            return;
          }
          if ( v10 )
            return;
          if ( byte_52732D == 2 )
          {
            sndBuf = giThisNetPos;
            dword_527109 = dword_527329;
            byte_52710D = 1;
            word_52710F = 0;
            SendRemoteData((int)&sndBuf, rcvBufIn[0], 9u);
          }
          for ( k = 0; k < 128; ++k )
          {
            if ( rcvBuf[k] && *(_DWORD *)(rcvBuf[k] + 1) == dword_527329 )
              goto LABEL_57;
          }
          for ( l = 0; l < 30; ++l )
          {
            if ( *((_DWORD *)&iLastIds + l) == dword_527329 )
              goto LABEL_57;
          }
          for ( m = 0; m < 128; ++m )
          {
            if ( !rcvBuf[m] )
            {
              rcvBuf[m] = (int)BaseAlloc(0x100u, "F:\\h2xsrc\\Source\\REMOTE.CPP", word_512748 + 235);
              iInOrder[m] = iInOrderCtr++;
              memcpy((void *)rcvBuf[m], rcvBufIn, 0x100u);
              ++v16;
              *((_DWORD *)&iLastIds + iCurLastID) = dword_527329;
              iCurLastID = (iCurLastID + 1) % 30;
              if ( v16 == 128 )
                return;
              goto LABEL_57;
            }
          }
        }
      }
    }
  }
}
// 4F7494: using guessed type int gbRemoteOn;
// 4F74BC: using guessed type int gbInPollSound;
// 50EAA8: using guessed type __int64 iCurHourGlassPhase;
// 512570: using guessed type int iInOrderCtr;
// 512574: using guessed type int iCurLastID;
// 512578: using guessed type int dword_512578;
// 512580: using guessed type int lLastHeartbeatSend;
// 512588: using guessed type int gbInRemoteCleanup;
// 512594: using guessed type char gbInNetSetup;
// 512598: using guessed type int bUseDirectPlay;
// 51259C: using guessed type int bUseWinsock;
// 5125A0: using guessed type char bInTimeoutFail;
// 512748: using guessed type __int16 word_512748;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;
// 524778: using guessed type int iMPBaseType;
// 526DB0: using guessed type int lLastHeartbeatReceive[];
// 526EE0: using guessed type int iInOrder[];
// 527108: using guessed type char sndBuf;
// 527109: using guessed type int dword_527109;
// 52710D: using guessed type char byte_52710D;
// 52710E: using guessed type char byte_52710E;
// 52710F: using guessed type __int16 word_52710F;
// 527329: using guessed type int dword_527329;
// 52732D: using guessed type char byte_52732D;
// 52732E: using guessed type char byte_52732E;

//----- (0046EC00) --------------------------------------------------------
signed int __fastcall TransmitAndWait(const void *a1, int a2, size_t a3, char a4, char a5, int a6)
{
  signed int result; // eax@3
  int v7; // edx@11
  int v8; // [sp+18h] [bp-10h]@5
  char v9; // [sp+1Ch] [bp-Ch]@5
  void *v10; // [sp+20h] [bp-8h]@4
  int v11; // [sp+24h] [bp-4h]@4

  if ( gbRemoteOn && !gbInNetSetup )
  {
    v10 = 0;
    v11 = TransmitRemoteData(a1, a2, a3, a4, 1, 1, -1);
    if ( v11 )
    {
      v8 = KBTickCount();
      v9 = 0;
      while ( !v9 )
      {
        if ( KBTickCount() > v8 + 90000 )
        {
          NormalDialog("Error sending data.  Keep trying??", 2, -1, -1, -1, 0, -1, 0, -1, 0);
          if ( gpWindowManager->buttonPressedCode != 30725 )
          {
            v11 = 0;
            goto LABEL_17;
          }
          v8 = KBTickCount();
        }
        ForcePollSound();
        v10 = GetRemoteData(1, v7);
        if ( v10 && *((_BYTE *)v10 + 5) == 2 )
        {
          if ( *((_BYTE *)v10 + 6) == a5 )
            v9 = 1;
        }
      }
      *(_DWORD *)a6 = v10;
    }
LABEL_17:
    result = v11;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 512594: using guessed type char gbInNetSetup;

//----- (0046ED70) --------------------------------------------------------
armyGroup *__thiscall armyGroup::armyGroup(armyGroup *this)
{
  armyGroup *thisa; // ST18_4@1

  thisa = this;
  memset(this, 0xFFu, 5u);
  memset(thisa->quantities, 0, 0xAu);
  return thisa;
}

//----- (0046EDD0) --------------------------------------------------------
signed int __thiscall armyGroup::HasAllUndead(armyGroup *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    if ( this->creatureTypes[i] != -1
      && !(HIBYTE(gMonsterDatabase[this->creatureTypes[i]].creature_flags) & ATTR_UNDEAD) )
      return 0;
  }
  return 1;
}

//----- (0046EE50) --------------------------------------------------------
signed int __thiscall armyGroup::HasSomeUndead(armyGroup *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    if ( this->creatureTypes[i] != -1 && HIBYTE(gMonsterDatabase[this->creatureTypes[i]].creature_flags) & ATTR_UNDEAD )
      return 1;
  }
  return 0;
}

//----- (0046EED0) --------------------------------------------------------
signed int __thiscall armyGroup::GetMorale(armyGroup *this, hero *hro, town *castle, char *enemyCreaturesList)
{
  signed int hasUndead; // [sp+10h] [bp-18h]@1
  signed int artifactMorale; // [sp+18h] [bp-10h]@1
  int totMorale; // [sp+18h] [bp-10h]@36
  signed int i; // [sp+1Ch] [bp-Ch]@6
  signed int enemyHasBoneDragon; // [sp+20h] [bp-8h]@5
  signed int v11; // [sp+24h] [bp-4h]@1

  artifactMorale = 0;
  hasUndead = 0;
  v11 = armyGroup::IsHomogeneous(this, -1);
  if ( armyGroup::HasAllUndead(this) )
    return 0;
  if ( armyGroup::HasSomeUndead(this) )
    hasUndead = 1;
  enemyHasBoneDragon = 0;
  if ( enemyCreaturesList )
  {
    for ( i = 0; i < 5; ++i )
    {
      if ( enemyCreaturesList[i] == CREATURE_BONE_DRAGON )
        enemyHasBoneDragon = 1;
    }
  }
  if ( enemyHasBoneDragon )
    artifactMorale = -1;
  if ( hro )
  {
    if ( hero::HasArtifact(hro, 90) )
      return 3;
    artifactMorale += hro->tempMoraleBonuses + hro->secondarySkillLevel[6];
    if ( hero::HasArtifact(hro, 12) )
      ++artifactMorale;
    if ( hero::HasArtifact(hro, 13) )
      ++artifactMorale;
    if ( hero::HasArtifact(hro, 14) )
      ++artifactMorale;
    if ( hero::HasArtifact(hro, 15) )
      ++artifactMorale;
    if ( hero::HasArtifact(hro, 16) )
      artifactMorale -= 2;
    if ( hero::HasArtifact(hro, 87) )
      hasUndead = 1;
    if ( hero::HasArtifact(hro, 97) && hro->flags & HERO_AT_SEA )
      ++artifactMorale;
  }
  if ( hasUndead )
    --artifactMorale;
  if ( hasUndead && v11 > 0 )
    v11 = 0;
  totMorale = v11 + artifactMorale;
  if ( castle && castle->factionID != FACTION_NECROMANCER && castle->buildingsBuiltFlags & 4 )
    ++totMorale;
  if ( castle
    && castle->factionID == FACTION_BARBARIAN
    && BYTE1(castle->buildingsBuiltFlags) & BUILDING_SPECIAL_DEFENSE_BUILT )
    totMorale += 2;
  if ( totMorale >= -3 )
  {
    if ( totMorale > 3 )
      totMorale = 3;
  }
  else
  {
    totMorale = -3;
  }
  return totMorale;
}

//----- (0046F120) --------------------------------------------------------
void __thiscall armyGroup::Dismiss(armyGroup *this, int idx)
{
  this->creatureTypes[idx] = -1;
  this->quantities[idx] = 0;
}

//----- (0046F150) --------------------------------------------------------
signed int __thiscall armyGroup::IsMember(armyGroup *this, int creatureType)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    if ( this->creatureTypes[i] == creatureType )
      return 1;
  }
  return 0;
}

//----- (0046F1B0) --------------------------------------------------------
signed int __thiscall armyGroup::IsHomogeneous(armyGroup *this, int a2)
{
  int alignment; // eax@5
  signed int result; // eax@10
  armyGroup *thisa; // [sp+Ch] [bp-1Ch]@1
  char numOfEachAlignment[8]; // [sp+10h] [bp-18h]@1
  int lastCreatureID; // [sp+18h] [bp-10h]@1
  int i; // [sp+1Ch] [bp-Ch]@1
  int numCreatureIDsSeen; // [sp+20h] [bp-8h]@1
  int numAlignments; // [sp+24h] [bp-4h]@11

  thisa = this;
  numCreatureIDsSeen = 0;
  memset(numOfEachAlignment, 0, 7u);
  lastCreatureID = -1;
  for ( i = 0; i < 5; ++i )
  {
    if ( thisa->creatureTypes[i] != -1 )
    {
      if ( a2 == -1 )
      {
        alignment = gMonsterDatabase[thisa->creatureTypes[i]].faction;
        ++numOfEachAlignment[alignment];
      }
      if ( thisa->creatureTypes[i] != lastCreatureID )
      {
        ++numCreatureIDsSeen;
        lastCreatureID = thisa->creatureTypes[i];
      }
    }
  }
  if ( numCreatureIDsSeen > 1 )
  {
    numAlignments = 0;
    for ( i = 0; i < 7; ++i )
    {
      if ( numOfEachAlignment[i] )
        ++numAlignments;
    }
    switch ( numAlignments )
    {
      case 1:
        result = 1;
        break;
      case 3:
        result = -1;
        break;
      case 4:
        result = -2;
        break;
      default:
        if ( numAlignments < 5 )
          result = 0;
        else
          result = -3;
        break;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 46F1B0: using guessed type char numOfEachAlignment[8];

//----- (0046F300) --------------------------------------------------------
bool __thiscall armyGroup::CanJoin(armyGroup *this, int creatureType)
{
  bool result; // eax@2
  armyGroup *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( armyGroup::IsMember(this, creatureType) )
    result = 1;
  else
    result = armyGroup::IsMember(thisa, -1) != 0;
  return result;
}

//----- (0046F360) --------------------------------------------------------
int __thiscall armyGroup::GetNumArmies(armyGroup *this)
{
  signed int i; // [sp+10h] [bp-8h]@1
  int numStacks; // [sp+14h] [bp-4h]@1

  numStacks = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( this->creatureTypes[i] != -1 )
      ++numStacks;
  }
  return numStacks;
}

//----- (0046F3C0) --------------------------------------------------------
signed int __thiscall armyGroup::Add(armyGroup *this, int creatureType, __int16 quantity, signed int stackIdx)
{
  signed int result; // eax@16
  signed int i; // [sp+10h] [bp-4h]@2
  signed int j; // [sp+10h] [bp-4h]@8

  if ( stackIdx == -1 )
  {
    for ( i = 0; i < 5; ++i )
    {
      if ( this->creatureTypes[i] == creatureType )
      {
        stackIdx = i;
        break;
      }
    }
  }
  if ( stackIdx == -1 )
  {
    for ( j = 0; j < 5; ++j )
    {
      if ( this->creatureTypes[j] == -1 || this->creatureTypes[j] == creatureType )
      {
        stackIdx = j;
        break;
      }
    }
  }
  if ( stackIdx < 5 && stackIdx >= 0 )
  {
    this->creatureTypes[stackIdx] = creatureType;
    if ( this->quantities[stackIdx] < 0 )
      this->quantities[stackIdx] = 0;
    this->quantities[stackIdx] += quantity;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (0046F4E0) --------------------------------------------------------
void __thiscall armyGroup::Swap(armyGroup *this, int idx, armyGroup *oth, int othIdx)
{
  char tmpType; // ST10_1@1
  __int16 tmpQuant; // ST10_2@1

  tmpType = this->creatureTypes[idx];
  this->creatureTypes[idx] = oth->creatureTypes[othIdx];
  oth->creatureTypes[othIdx] = tmpType;
  tmpQuant = this->quantities[idx];
  this->quantities[idx] = oth->quantities[othIdx];
  oth->quantities[othIdx] = tmpQuant;
}

//----- (0046F560) --------------------------------------------------------
void __thiscall armyGroup::DamageGroup(armyGroup *this, float chance)
{
  armyGroup *thisa; // [sp+Ch] [bp-18h]@1
  int numKilled; // [sp+10h] [bp-14h]@4
  signed int j; // [sp+18h] [bp-Ch]@4
  signed int i; // [sp+1Ch] [bp-8h]@1
  signed int mustSpareACreature; // [sp+20h] [bp-4h]@1

  thisa = this;
  mustSpareACreature = 1;
  for ( i = 0; i < 5; ++i )
  {
    if ( thisa->creatureTypes[i] == -1 )
    {
      thisa->quantities[i] = 0;
    }
    else
    {
      numKilled = 0;
      for ( j = 0; thisa->quantities[i] > j; ++j )
      {
        if ( SRandom(0, 100) < (signed int)(signed __int64)(chance * 100.0) )
          ++numKilled;
      }
      if ( mustSpareACreature && thisa->quantities[i] == numKilled && chance < 0.999 )
        LOWORD(numKilled) = numKilled - 1;
      thisa->quantities[i] -= numKilled;
      if ( thisa->quantities[i] <= 0 || chance >= 1.0 )
      {
        thisa->quantities[i] = 0;
        thisa->creatureTypes[i] = -1;
      }
      mustSpareACreature = 0;
    }
  }
}

//----- (0046F6B0) --------------------------------------------------------
fullMap *__thiscall fullMap::fullMap(fullMap *this)
{
  this->tiles = 0;
  this->cellExtras = 0;
  this->numCellExtras = 0;
  return this;
}

//----- (0046F6F0) --------------------------------------------------------
void __thiscall fullMap::_fullMap(mapCell **this)
{
  fullMap::Close((fullMap *)this);
}

//----- (0046F710) --------------------------------------------------------
void __thiscall fullMap::Close(fullMap *this)
{
  if ( this->tiles )
    operator delete(this->tiles);
  this->tiles = 0;
  if ( this->cellExtras )
    operator delete(this->cellExtras);
  this->cellExtras = 0;
  this->numCellExtras = 0;
}

//----- (0046F7A0) --------------------------------------------------------
void __thiscall fullMap::Init(fullMap *this, int width, int height)
{
  this->width = width;
  this->height = height;
  fullMap::Close(this);
  this->tiles = (mapCell *)operator new(sizeof(mapCell) * this->height * this->width);
}

//----- (0046F800) --------------------------------------------------------
void __thiscall fullMap::ClearCellExtra(fullMap *this, int i)
{
  *(&this->cellExtras->_1_q_7_objTileset + 8 * i - i) &= 1u;
  *(&this->cellExtras->objectIndex + 8 * i - i) = -1;
  *(&this->cellExtras->_1_q_7_objTileset + 8 * i - i) &= 0xFEu;
  *(&this->cellExtras->field_4_1_1_1_isShadow_5 + 8 * i - i) &= 0xFEu;
  *(&this->cellExtras->field_4_1_1_1_isShadow_5 + 8 * i - i) &= 0xFDu;
  *(&this->cellExtras->field_4_1_1_1_isShadow_5 + 8 * i - i) &= 0xFBu;
  *(&this->cellExtras->_1_q_1_hasLateOverlay_6_q + 8 * i - i) &= 3u;
  *(&this->cellExtras->field_6 + 8 * i - i) = -1;
  *(&this->cellExtras->_1_q_1_hasLateOverlay_6_q + 8 * i - i) &= 0xFEu;
  *(&this->cellExtras->_1_q_1_hasLateOverlay_6_q + 8 * i - i) &= 0xFDu;
  this->cellExtras[i].nextIdx = 0;
}

//----- (0046F8D0) --------------------------------------------------------
int __thiscall fullMap::GetNewCellExtraIndex(fullMap *this)
{
  mapCellExtra *newCellExtras; // ST2C_4@6
  int i; // [sp+18h] [bp-Ch]@1
  int j; // [sp+1Ch] [bp-8h]@6

  for ( i = 1; this->numCellExtras > i; ++i )
  {
    if ( this->cellExtras[i].nextIdx == 65535 )
    {
      fullMap::ClearCellExtra(this, i);
      return i;
    }
  }
  newCellExtras = (mapCellExtra *)operator new(sizeof(mapCellExtra) * (this->numCellExtras + 100));
  memcpy(newCellExtras, this->cellExtras, sizeof(mapCellExtra) * this->numCellExtras);
  operator delete(this->cellExtras);
  this->cellExtras = newCellExtras;
  for ( j = this->numCellExtras; this->numCellExtras + 100 > j; ++j )
    this->cellExtras[j].nextIdx = -1;
  this->numCellExtras += 100;
  fullMap::ClearCellExtra(this, this->numCellExtras - 100);
  return this->numCellExtras - 100;
}

//----- (0046FA00) --------------------------------------------------------
mapCellExtra *__thiscall fullMap::GetNewCellExtraOverlay(fullMap *this, int col, int row)
{
  mapCellExtra *result; // eax@2
  __int16 v4; // ST14_2@7
  char *v5; // ST1C_4@7
  int v7; // [sp+18h] [bp-8h]@3
  mapCellExtra *cellEx; // [sp+1Ch] [bp-4h]@3

  if ( *(&this->tiles[col].extraIdx + 6 * row * this->width) )
  {
    v7 = *(&this->tiles[col].extraIdx + 6 * row * this->width);
    for ( cellEx = &this->cellExtras[*(&this->tiles[col].extraIdx + 6 * row * this->width)];
          ;
          cellEx = &this->cellExtras[cellEx->nextIdx] )
    {
      if ( cellEx->field_6 == 255 )
        return cellEx;
      if ( !cellEx->nextIdx )
        break;
      v7 = cellEx->nextIdx;
    }
    v4 = fullMap::GetNewCellExtraIndex(this);
    v5 = (char *)this->cellExtras + 8 * v7 - v7;
    *(_WORD *)v5 = v4;
    result = &this->cellExtras[*(_WORD *)v5];
  }
  else
  {
    *(&this->tiles[col].extraIdx + 6 * row * this->width) = fullMap::GetNewCellExtraIndex(this);
    result = &this->cellExtras[*(&this->tiles[col].extraIdx + 6 * row * this->width)];
  }
  return result;
}

//----- (0046FBE0) --------------------------------------------------------
mapCellExtra *__thiscall fullMap::GetNewCellExtraObject(fullMap *this, int col, int row)
{
  mapCellExtra *result; // eax@2
  __int16 v4; // ST14_2@7
  mapCellExtra *lastCellExtra; // ST1C_4@7
  int lastCellExtraIdx; // [sp+18h] [bp-8h]@3
  mapCellExtra *ce; // [sp+1Ch] [bp-4h]@3

  if ( *(&this->tiles[col].extraIdx + 6 * row * this->width) )
  {
    lastCellExtraIdx = *(&this->tiles[col].extraIdx + 6 * row * this->width);
    for ( ce = &this->cellExtras[*(&this->tiles[col].extraIdx + 6 * row * this->width)];
          ;
          ce = &this->cellExtras[ce->nextIdx] )
    {
      if ( ce->objectIndex == 255 )
        return ce;
      if ( !ce->nextIdx )
        break;
      lastCellExtraIdx = ce->nextIdx;
    }
    v4 = fullMap::GetNewCellExtraIndex(this);
    lastCellExtra = (mapCellExtra *)((char *)this->cellExtras + 8 * lastCellExtraIdx - lastCellExtraIdx);
    lastCellExtra->nextIdx = v4;
    result = &this->cellExtras[lastCellExtra->nextIdx];
  }
  else
  {
    *(&this->tiles[col].extraIdx + 6 * row * this->width) = fullMap::GetNewCellExtraIndex(this);
    result = &this->cellExtras[*(&this->tiles[col].extraIdx + 6 * row * this->width)];
  }
  return result;
}

//----- (0046FDC0) --------------------------------------------------------
void __thiscall fullMap::Write(fullMap *this, int fd)
{
  _write(fd, &this->width, 4);
  _write(fd, &this->height, 4);
  _write(fd, this->tiles, sizeof(mapCell) * this->height * this->width);
  _write(fd, &this->numCellExtras, 4);
  _write(fd, this->cellExtras, sizeof(mapCellExtra) * this->numCellExtras);
}

//----- (0046FE60) --------------------------------------------------------
BOOL __thiscall fullMap::Read(fullMap *this, UINT fd, int isNewGame)
{
  BOOL result; // eax@16
  void *v5; // [sp+28h] [bp-14h]@13
  void *buf; // [sp+2Ch] [bp-10h]@2
  int j; // [sp+30h] [bp-Ch]@4
  int i; // [sp+34h] [bp-8h]@2
  int k; // [sp+38h] [bp-4h]@13

  _read(fd, &this->width, 4u);
  _read(fd, &this->height, 4u);
  fullMap::Init(this, this->width, this->height);
  if ( isNewGame )
  {
    buf = operator new(20 * this->height * this->width);
    _read(fd, buf, 20 * this->height * this->width);
    for ( i = 0; this->width > i; ++i )
    {
      for ( j = 0; this->height > j; ++j )
        memcpy(&this->tiles[j * this->width] + i, (char *)buf + 20 * i + 20 * j * this->width, sizeof(mapCell));
    }
    operator delete(buf);
  }
  else
  {
    _read(fd, this->tiles, sizeof(mapCell) * this->height * this->width);
  }
  _read(fd, &this->numCellExtras, 4u);
  if ( this->cellExtras )
    operator delete(this->cellExtras);
  this->cellExtras = (mapCellExtra *)operator new(7 * this->numCellExtras);
  if ( isNewGame )
  {
    v5 = operator new(15 * this->numCellExtras);
    _read(fd, v5, 15 * this->numCellExtras);
    for ( k = 0; this->numCellExtras > k; ++k )
      memcpy((char *)this->cellExtras + 8 * k - k, (char *)v5 + 15 * k, 7u);
    result = operator delete(v5);
  }
  else
  {
    result = _read(fd, this->cellExtras, 7 * this->numCellExtras);
  }
  return result;
}

//----- (00470100) --------------------------------------------------------
void __thiscall fullMap::ChangeTilesetIndex(fullMap *this, mapCell *cell, int x, int y, int a5, int a6, int a7, int a8)
{
  mapCellExtra *v8; // eax@14
  mapCellExtra *v9; // eax@27
  char v10; // [sp+10h] [bp-10h]@2
  mapCellExtra *v11; // [sp+14h] [bp-Ch]@9
  mapCellExtra *v12; // [sp+14h] [bp-Ch]@22
  int j; // [sp+1Ch] [bp-4h]@7
  int i; // [sp+1Ch] [bp-4h]@20

  if ( a6 == 255 )
    v10 = 0;
  else
    v10 = a5;
  if ( a7 )
  {
    if ( cell->overlayIndex == 255
      || (((unsigned __int8)cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F) == a5 )
    {
      cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset &= 0xFEu;
      cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset &= 0xFDu;
      cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset = 4 * v10 | cell->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset & 3;
      cell->overlayIndex = a6;
    }
    else
    {
      for ( i = cell->extraIdx; i; i = v12->nextIdx )
      {
        v12 = (mapCellExtra *)((char *)this->cellExtras + 8 * i - i);
        if ( v12->field_6 == 255 || (((unsigned __int8)v12->_1_q_1_hasLateOverlay_6_q >> 2) & 0x3F) == a5 )
        {
          v12->_1_q_1_hasLateOverlay_6_q &= 0xFEu;
          v12->_1_q_1_hasLateOverlay_6_q &= 0xFDu;
          v12->_1_q_1_hasLateOverlay_6_q = 4 * v10 | v12->_1_q_1_hasLateOverlay_6_q & 3;
          v12->field_6 = a6;
          break;
        }
      }
      if ( !i )
      {
        v9 = fullMap::GetNewCellExtraOverlay(this, x, y);
        v9->_1_q_1_hasLateOverlay_6_q = 4 * v10 | v9->_1_q_1_hasLateOverlay_6_q & 3;
        v9->field_6 = a6;
      }
    }
  }
  else if ( cell->objectIndex == 255 || (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == a5 )
  {
    cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 0xFEu;
    cell->field_4_1_1_isShadow_1_13_extraInfo &= 0xFFFEu;
    cell->field_4_1_1_isShadow_1_13_extraInfo &= 0xFFFDu;
    cell->field_4_1_1_isShadow_1_13_extraInfo &= 0xFFFBu;
    cell->bitfield_1_hasObject_1_isRoad_6_objTileset = 4 * v10 | cell->bitfield_1_hasObject_1_isRoad_6_objTileset & 3;
    cell->objectIndex = a6;
  }
  else
  {
    for ( j = cell->extraIdx; j; j = v11->nextIdx )
    {
      v11 = (mapCellExtra *)((char *)this->cellExtras + 8 * j - j);
      if ( v11->objectIndex == 255 || ((v11->_1_q_7_objTileset >> 1) & 0x7F) == a5 )
      {
        v11->_1_q_7_objTileset &= 0xFEu;
        v11->field_4_1_1_1_isShadow_5 &= 0xFEu;
        v11->field_4_1_1_1_isShadow_5 &= 0xFDu;
        v11->field_4_1_1_1_isShadow_5 &= 0xFBu;
        v11->_1_q_7_objTileset = 2 * v10 | v11->_1_q_7_objTileset & 1;
        v11->objectIndex = a6;
        break;
      }
    }
    if ( !j )
    {
      v8 = fullMap::GetNewCellExtraObject(this, x, y);
      v8->_1_q_7_objTileset = 2 * v10 | v8->_1_q_7_objTileset & 1;
      v8->objectIndex = a6;
    }
  }
}

//----- (004703F0) --------------------------------------------------------
int __thiscall ExpCampaign::ExpCampaign(int this)
{
  *(_DWORD *)(this + 71) = 0;
  return this;
}

//----- (00470440) --------------------------------------------------------
void *__thiscall ExpCampaign::ResetMapChoices(int this)
{
  return memset((void *)(this + 12), 0, 8u);
}

//----- (00470470) --------------------------------------------------------
void *__thiscall ExpCampaign::ResetMapsPlayed(int this)
{
  return memset((void *)(this + 20), 0, 8u);
}

//----- (004704A0) --------------------------------------------------------
void *__thiscall ExpCampaign::ResetAwards(int this)
{
  return memset((void *)(this + 44), 0, 0xBu);
}

//----- (004704D0) --------------------------------------------------------
void *__thiscall ExpCampaign::ResetBonusChoices(int this)
{
  return memset((void *)(this + 55), 0, 8u);
}

//----- (00470500) --------------------------------------------------------
int __cdecl _ismbbprint(unsigned int a1)
{
  int v1; // ecx@0
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + v1 + 44) = 1;
  return result;
}
// 470500: inconsistent function type and number of purged bytes

//----- (00470530) --------------------------------------------------------
int __cdecl _ismbbpunct(unsigned int a1)
{
  int v1; // ecx@0
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + v1 + 44) = 0;
  return result;
}
// 470530: inconsistent function type and number of purged bytes

//----- (00470560) --------------------------------------------------------
char __thiscall ExpCampaign::HasAward(void *this, int a2)
{
  return *((_BYTE *)this + a2 + 44);
}

//----- (00470590) --------------------------------------------------------
int __cdecl _finite(double a1)
{
  int v1; // ecx@0
  int result; // eax@1

  result = *(_DWORD *)(v1 + 4);
  *(_BYTE *)(result + v1 + 20) = 1;
  return result;
}

//----- (004705C0) --------------------------------------------------------
void *__thiscall ExpCampaign::InitNewCampaign(int this, int a2)
{
  int v2; // ST0C_4@1

  v2 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = -1;
  *(_DWORD *)(this + 8) = dword_512A30[a2];
  ExpCampaign::ResetMapChoices(this);
  ExpCampaign::ResetMapsPlayed(v2);
  ExpCampaign::ResetAwards(v2);
  return ExpCampaign::ResetBonusChoices(v2);
}
// 512A30: using guessed type int dword_512A30[];

//----- (00470620) --------------------------------------------------------
void __thiscall ExpCampaign::InitMap(int this)
{
  char *v1; // ST2C_4@31
  int v3; // [sp+24h] [bp-1Ch]@30
  char *v4; // [sp+28h] [bp-18h]@1
  char *thisa; // [sp+2Ch] [bp-14h]@0
  char *v6; // [sp+30h] [bp-10h]@3
  signed int i; // [sp+38h] [bp-8h]@12
  signed int j; // [sp+38h] [bp-8h]@34
  signed int l; // [sp+38h] [bp-8h]@57
  signed int k; // [sp+3Ch] [bp-4h]@46

  v4 = (char *)&xCampaignChoices
     + 120 * *(_DWORD *)this
     + 15 * *(_DWORD *)(this + 4)
     + 5 * *(_BYTE *)(*(_DWORD *)(this + 4) + this + 55);
  memset(&gpGame->field_44D, 0, 0x41u);
  sprintf(gpGame->mapFilename, "CAMP%d_%02d.HXC", *(_DWORD *)this + 1, *(_DWORD *)(this + 4) + 1);
  gpGame->mapFilename[20] = 0;
  if ( !*(_DWORD *)(this + 4) )
    *(_WORD *)(this + 28) = 0;
  strcpy(gMapName, gpGame->mapFilename);
  GetMapHeader(gpGame->mapFilename, &gpGame->mapHeader);
  game::LoadGame(gpGame, "origdata.bin", 1, 0);
  game::InitNewGame(gpGame, 0);
  gpGame->difficulty = *(&byte_512C20[8 * *(_DWORD *)this] + *(_DWORD *)(this + 4));
  gpGame->numPlayers = gpGame->mapHeader.numPlayers;
  game::NewMap(gpGame, gMapName);
  v6 = (char *)gpGame->players;
  switch ( *v4 )
  {
    case 0:
      *(_DWORD *)&v6[4 * *(_WORD *)(v4 + 1) + 143] += *(_WORD *)(v4 + 3);
      break;
    case 1:
      if ( gpGame->players[0].numHeroes > 0 )
        GiveArtifact(&gpGame->heroes[gpGame->players[0].heroesOwned[0]], (ARTIFACT)*(_WORD *)(v4 + 1), 0, -1);
      break;
    case 2:
      if ( gpGame->players[0].numHeroes > 0 )
        gpGame->heroes[gpGame->players[0].heroesOwned[0]].spellsLearned[*(_WORD *)(v4 + 1)] = 1;
      break;
    case 3:
      if ( gpGame->players[0].numHeroes > 0 )
      {
        for ( i = 0; gpGame->players[0].numHeroes > i; ++i )
        {
          thisa = (char *)&gpGame->heroes[v6[i + 4]];
          if ( *(_DWORD *)this != 3 || *(_DWORD *)(this + 4) != 3 )
          {
            if ( *(_DWORD *)this != 3 || *(_DWORD *)(this + 4) != 2 || gpGame->heroes[v6[i + 4]].heroID == 67 )
              break;
          }
          else if ( gpGame->heroes[v6[i + 4]].heroID == 65 )
          {
            break;
          }
        }
        hero::SetSS((hero *)thisa, *(_WORD *)(v4 + 1), *(_WORD *)(v4 + 3));
      }
      break;
    case 4:
      if ( gpGame->players[0].numHeroes > 0 )
        armyGroup::Add(
          &gpGame->heroes[gpGame->players[0].heroesOwned[0]].army,
          *(_WORD *)(v4 + 1),
          *(_WORD *)(v4 + 3),
          -1);
      break;
    case 5:
      gpGame->players[0]._3[0] = v4[1];
      break;
    case 6:
      v3 = gbInNewGameSetup;
      gbInNewGameSetup = 1;
      if ( gpGame->players[0].numHeroes > 0 )
      {
        v1 = (char *)&gpGame->heroes[gpGame->players[0].heroesOwned[0]];
        *(_DWORD *)(v1 + 57) += *(_WORD *)(v4 + 1);
        hero::CheckLevel(&gpGame->heroes[v6[4]]);
      }
      gbInNewGameSetup = v3;
      break;
    case 9:
      if ( gpGame->players[0].numHeroes > 0 )
      {
        for ( j = 0; ; ++j )
        {
          if ( gpGame->players[0].numHeroes > j )
          {
            thisa = (char *)&gpGame->heroes[v6[j + 4]];
            if ( *(_DWORD *)this == 3 )
            {
              if ( *(_DWORD *)(this + 4) == 2 && gpGame->heroes[v6[j + 4]].heroID != 67 )
                continue;
            }
          }
          break;
        }
        thisa[*(_WORD *)(v4 + 1) + 63] += *(_WORD *)(v4 + 3);
      }
      break;
    case 0xA:
      if ( gpGame->players[0].numHeroes > 0 )
        GiveArtifact(&gpGame->heroes[gpGame->players[0].heroesOwned[0]], ARTIFACT_SPELL_SCROLL, 0, *(_WORD *)(v4 + 1));
      break;
    case 7:
      break;
  }
  for ( k = 0; k < 11; ++k )
  {
    if ( *(_BYTE *)(k + this + 44) )
    {
      switch ( k )
      {
        case 1:
          if ( v6[1] > 0 )
            GiveArtifact(&gpGame->heroes[v6[4]], ARTIFACT_BREASTPLATE_OF_ANDURAN, 0, -1);
          break;
        case 3:
          if ( v6[1] > 0 )
            GiveArtifact(&gpGame->heroes[v6[4]], ARTIFACT_HELMET_OF_ANDURAN, 0, -1);
          break;
        case 4:
          for ( l = 0; l < 54; ++l )
          {
            if ( gpGame->heroes[l].heroID == 61 )
              hero::Deallocate(&gpGame->heroes[l], 0);
          }
          break;
        case 5:
          if ( v6[1] > 0 )
            GiveArtifact(&gpGame->heroes[v6[4]], ARTIFACT_BATTLE_GARB_OF_ANDURAN, 0, -1);
          break;
        case 8:
          if ( v6[1] > 0 )
            GiveArtifact(&gpGame->heroes[v6[4]], ARTIFACT_LEGENDARY_SCEPTER, 0, -1);
          break;
        case 9:
          if ( v6[1] > 0 )
            gpGame->heroes[v6[4]].spellsLearned[61] = 1;
          break;
        case 10:
          if ( v6[1] > 0 )
            GiveArtifact(&gpGame->heroes[v6[4]], ARTIFACT_SPHERE_OF_NEGATION, 0, -1);
          break;
        case 0:
        case 2:
        case 6:
        case 7:
          continue;
      }
    }
  }
  gbRetreatWin = 1;
}
// 523F1C: using guessed type int gbInNewGameSetup;
// 524210: using guessed type char gbRetreatWin;

//----- (00470DF0) --------------------------------------------------------
void __thiscall ExpCampaign::ShowInfo(int this, int a2, int a3)
{
  int v3; // [sp+Ch] [bp-44h]@1
  iconWidget *v4; // [sp+18h] [bp-38h]@14
  iconWidget *v5; // [sp+1Ch] [bp-34h]@8
  heroWindow *thisa; // [sp+20h] [bp-30h]@1
  widget *v7; // [sp+24h] [bp-2Ch]@15
  int evt; // [sp+28h] [bp-28h]@19
  int v9; // [sp+2Ch] [bp-24h]@20
  int v10; // [sp+30h] [bp-20h]@20
  int v11; // [sp+40h] [bp-10h]@20
  int v12; // [sp+44h] [bp-Ch]@1
  int i; // [sp+48h] [bp-8h]@6
  widget *guiObj; // [sp+4Ch] [bp-4h]@6

  v3 = this;
  *(_DWORD *)(this + 75) = a2;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  mouseManager::ReallyShowPointer(gpMouseManager);
  v12 = gbUseEvilInterface;
  gbUseEvilInterface = 1;
  *(_DWORD *)(v3 + 67) = *(_DWORD *)(v3 + 4);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    *(_DWORD *)(v3 + 71) = heroWindow::heroWindow(thisa, 0, 0, "x_camp.bin");
  else
    *(_DWORD *)(v3 + 71) = 0;
  if ( !*(_DWORD *)(v3 + 71) )
    MemError();
  guiObj = 0;
  for ( i = 0; *(_DWORD *)(v3 + 8) > i; ++i )
  {
    v5 = (iconWidget *)operator new(45);
    if ( v5 )
      guiObj = (widget *)iconWidget::iconWidget(
                           v5,
                           *(&dword_512930[16 * *(_DWORD *)v3] + 2 * i),
                           *(&dword_512934[16 * *(_DWORD *)v3] + 2 * i),
                           41,
                           41,
                           "x_cmpext.icn",
                           0,
                           0,
                           i + 850,
                           16,
                           1);
    else
      guiObj = 0;
    if ( !guiObj )
      MemError();
    heroWindow::AddWidget(*(heroWindow **)(v3 + 71), guiObj, -1);
  }
  v4 = (iconWidget *)operator new(45);
  if ( v4 )
    v7 = (widget *)iconWidget::iconWidget(v4, 24, 25, 376, 49, "x_cmpext.icn", *(_WORD *)v3 + 15, 0, -1, 16, 1);
  else
    v7 = 0;
  if ( !v7 )
    MemError();
  heroWindow::AddWidget(*(heroWindow **)(v3 + 71), v7, -1);
  evt = 512;
  if ( !a2 )
  {
    v9 = 6;
    v10 = 901;
    v11 = 6;
    heroWindow::BroadcastMessage(*(heroWindow **)(v3 + 71), (tag_message *)&evt);
  }
  if ( gbLowMemory )
  {
    v9 = 6;
    v10 = 902;
    v11 = 6;
    heroWindow::BroadcastMessage(*(heroWindow **)(v3 + 71), (tag_message *)&evt);
  }
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, 24);
  ExpCampaign::UpdateInfo((void *)v3, 0);
  heroWindowManager::DoDialog(
    gpWindowManager,
    *(heroWindow **)(v3 + 71),
    (int (__fastcall *)(tag_message *))ExpCampaign::MessageHandler,
    0);
  operator delete(*(void **)(v3 + 71));
  gbUseEvilInterface = v12;
  if ( gpWindowManager->buttonPressedCode == 901 )
  {
    NormalDialog("Are you sure you want to restart this scenario?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      ExpCampaign::InitMap(v3);
      gpAdvManager->field_A2 = 0;
      giBottomViewOverride = 0;
      heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
      advManager::SetInitialMapOrigin(gpAdvManager);
      advManager::RedrawAdvScreen(gpAdvManager, 1, 0);
      heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
    }
  }
}
// 4F19D4: using guessed type int gbUseEvilInterface;
// 4F74A8: using guessed type int gbLowMemory;
// 512930: using guessed type int dword_512930[];
// 512934: using guessed type int dword_512934[];
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;

//----- (00471130) --------------------------------------------------------
void __thiscall ExpCampaign::UpdateInfo(void *this, int a2)
{
  int v2; // [sp+Ch] [bp-84h]@58
  void *v3; // [sp+18h] [bp-78h]@1
  char v4; // [sp+1Ch] [bp-74h]@58
  char *v5; // [sp+20h] [bp-70h]@20
  int evt; // [sp+24h] [bp-6Ch]@1
  int v7; // [sp+28h] [bp-68h]@10
  int v8; // [sp+2Ch] [bp-64h]@10
  int v9; // [sp+3Ch] [bp-54h]@4
  char a1; // [sp+40h] [bp-50h]@52
  char v11; // [sp+74h] [bp-1Ch]@11
  int i; // [sp+78h] [bp-18h]@1

  v3 = this;
  evt = 512;
  for ( i = 0; *((_DWORD *)v3 + 2) > i; ++i )
  {
    if ( *((_BYTE *)v3 + i + 12) )
    {
      v9 = 1;
    }
    else if ( *((_BYTE *)v3 + i + 20) )
    {
      v9 = 0;
    }
    else
    {
      v9 = 2;
    }
    if ( *(_DWORD *)((char *)v3 + 67) == i )
      v9 += 3 * *(_DWORD *)v3 + 3;
    v7 = 4;
    v8 = i + 850;
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  }
  v7 = 9;
  v8 = 809;
  v9 = (int)gText;
  sprintf(gText, "x_track%d.icn", *(_DWORD *)v3 + 1);
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  v7 = 3;
  v9 = (int)gText;
  v8 = 801;
  sprintf(gText, "%d", *(_DWORD *)((char *)v3 + 67) + 1);
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  v8 = 802;
  sprintf(gText, "%s", (&xScenarioName[8 * *(_DWORD *)v3])[4 * *(_DWORD *)((char *)v3 + 67)]);
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  v8 = 803;
  sprintf(gText, "%s", (&xScenarioDescription[8 * *(_DWORD *)v3])[4 * *(_DWORD *)((char *)v3 + 67)]);
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  v8 = 804;
  sprintf(gText, "%d", *((_WORD *)v3 + *(_DWORD *)((char *)v3 + 67) + 14));
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  v11 = 0;
  v8 = 805;
  strcpy(gText, byte_512CE8);
  for ( i = 0; i < 11; ++i )
  {
    if ( *((_BYTE *)v3 + i + 44) )
    {
      v11 = 1;
      strcat(gText, (&xCampaignAwards)[4 * i]);
      strcat(gText, L"\n");
    }
  }
  if ( !v11 )
    sprintf(gText, "None");
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  for ( i = 0; i < 3; ++i )
  {
    v5 = (char *)&xCampaignChoices + 120 * *(_DWORD *)v3 + 15 * *(_DWORD *)((char *)v3 + 67) + 5 * i;
    switch ( *v5 )
    {
      case 0:
        sprintf(gText, "%d %s", *(_WORD *)(v5 + 3), gResourceNames[*(_WORD *)(v5 + 1)]);
        break;
      case 1:
        switch ( *(_WORD *)(v5 + 1) )
        {
          case 26:
            strcpy(gText, "Minor Scroll");
            break;
          case 10:
            strcpy(gText, "Mage's Ring");
            break;
          case 19:
            strcpy(gText, "Defender Helm");
            break;
          case 24:
            strcpy(gText, "Power Axe");
            break;
          case 23:
            strcpy(gText, "Dragon Sword");
            break;
          case 25:
            strcpy(gText, "Breastplate");
            break;
          case 16:
            strcpy(gText, "Fizbin Medal");
            break;
          case 17:
            strcpy(gText, "Thunder Mace");
            break;
          case 18:
            strcpy(gText, "Gauntlets");
            break;
          case 27:
            strcpy(gText, "Major Scroll");
            break;
          case 29:
            strcpy(gText, "Foremost Scroll");
            break;
          case 21:
            strcpy(gText, "Ballista");
            break;
          case 22:
            strcpy(gText, "Stealth Shield");
            break;
          case 33:
            strcpy(gText, "Nomad Boots");
            break;
          case 34:
            strcpy(gText, "Traveler's Boots");
            break;
          default:
            sprintf(gText, "%s", gArtifactNames[*(_WORD *)(v5 + 1)]);
            break;
        }
        break;
      case 2:
        if ( *(_WORD *)(v5 + 1) == 43 )
          sprintf(gText, "Summon Earth");
        else
          sprintf(gText, "%s", gSpellNames[*(_WORD *)(v5 + 1)]);
        break;
      case 3:
        if ( (*(_WORD *)(v5 + 3) != 1 || *(_WORD *)(v5 + 1) != 12)
          && (*(_WORD *)(v5 + 3) != 2 || *(_WORD *)(v5 + 1) != 2) )
          sprintf(gText, "%s %s", secondarySkillLevels[*(_WORD *)(v5 + 3)], gSecondarySkills[*(_WORD *)(v5 + 1)]);
        else
          sprintf(gText, "%s %s", off_51A904[*(_WORD *)(v5 + 3)], gSecondarySkills[*(_WORD *)(v5 + 1)]);
        break;
      case 4:
        strcpy(&a1, gArmyNamesPlural[*(_WORD *)(v5 + 1)]);
        a1 -= 32;
        sprintf(gText, "%d %s", *(_WORD *)(v5 + 3), &a1);
        break;
      case 5:
        sprintf(gText, "%d %s", *(_WORD *)(v5 + 1), "Puzzle Pieces");
        break;
      case 6:
        sprintf(gText, "%d %s", *(_WORD *)(v5 + 1), "Experience");
        break;
      case 7:
        sprintf(gText, "n/a");
        break;
      case 8:
        sprintf(gText, gAlignmentNames[*(_WORD *)(v5 + 1)]);
        break;
      case 9:
        sprintf(gText, "%s +%d", gStatNames[*(_WORD *)(v5 + 1)], *(_WORD *)(v5 + 3));
        break;
      case 0xA:
        v4 = 1;
        v2 = *(_WORD *)(v5 + 1);
        if ( v2 == 34 || v2 == 39 )
          v4 = 0;
        if ( v4 )
          sprintf(gText, "%s %s", gSpellNames[*(_WORD *)(v5 + 1)], "Scroll");
        else
          sprintf(gText, "%s", gSpellNames[*(_WORD *)(v5 + 1)]);
        break;
      default:
        break;
    }
    v8 = i + 806;
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  }
  for ( i = 0; i < 3; ++i )
  {
    v8 = i + 810;
    v7 = 4;
    if ( *(_DWORD *)((char *)v3 + 75) || !*((_BYTE *)v3 + *(_DWORD *)((char *)v3 + 67) + 12) )
      v9 = 9;
    else
      v9 = 8;
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
    if ( *((_BYTE *)v3 + *(_DWORD *)((char *)v3 + 67) + 55) == i )
      v7 = 5;
    else
      v7 = 6;
    v9 = 4;
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 71), (tag_message *)&evt);
  }
  if ( a2 )
    heroWindow::DrawWindow(*(heroWindow **)((char *)v3 + 71));
}
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 51A770: using guessed type char *xScenarioName[20];
// 51A7F0: using guessed type char *xScenarioDescription[20];
// 51A904: using guessed type char *off_51A904[4];

//----- (00471A60) --------------------------------------------------------
bool __thiscall ExpCampaign::HandleVictory(int this)
{
  bool result; // eax@10
  int v2; // [sp+10h] [bp-Ch]@1
  int i; // [sp+14h] [bp-8h]@11
  __int16 v4; // [sp+18h] [bp-4h]@1

  v2 = this;
  v4 = 0;
  if ( *(_DWORD *)(this + 4) > -1 )
  {
    v4 = ExpCampaign::Days(this);
    *(_BYTE *)(*(_DWORD *)(v2 + 4) + v2 + 20) = 1;
  }
  memset((void *)(v2 + 12), 0, *(_DWORD *)(v2 + 8));
  switch ( *(_DWORD *)v2 )
  {
    case 0:
      ExpCampaign::HandleVictory1(v2);
      break;
    case 1:
      ExpCampaign::HandleVictory2(v2);
      break;
    case 2:
      ExpCampaign::HandleVictory3(v2);
      break;
    case 3:
      ExpCampaign::HandleVictory4(v2);
      break;
    default:
      break;
  }
  if ( ExpCampaign::IsCompleted(v2) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = -1;
    for ( i = 0; *(_DWORD *)(v2 + 8) > i; ++i )
    {
      if ( *(_BYTE *)(i + v2 + 12) )
      {
        *(_WORD *)(v2 + 2 * i + 28) = v4;
        if ( *(_DWORD *)(v2 + 4) == -1 )
          *(_DWORD *)(v2 + 4) = i;
      }
    }
    ExpCampaign::ShowInfo(v2, 0, 0);
    result = gpWindowManager->buttonPressedCode == 30722;
  }
  return result;
}

//----- (00471BE0) --------------------------------------------------------
int __thiscall ExpCampaign::HandleVictory1(int this)
{
  int result; // eax@2
  int v2; // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4) + 1;
  switch ( *(_DWORD *)(this + 4) + 1 )
  {
    case 0:
      PlaySmacker(39);
      result = v2;
      *(_BYTE *)(v2 + 12) = 1;
      break;
    case 1:
      PlaySmacker(40);
      result = v2;
      *(_BYTE *)(v2 + 13) = 1;
      break;
    case 2:
      PlaySmacker(41);
      *(_BYTE *)(v2 + 14) = 1;
      *(_BYTE *)(v2 + 15) = 1;
      result = v2;
      *(_BYTE *)(v2 + 45) = 1;
      break;
    case 3:
      PlaySmacker(42);
      *(_BYTE *)(v2 + 16) = 1;
      *(_BYTE *)(v2 + 44) = 1;
      result = v2;
      *(_BYTE *)(v2 + 46) = 1;
      break;
    case 4:
      PlaySmacker(43);
      result = v2;
      *(_BYTE *)(v2 + 17) = 1;
      break;
    case 5:
      PlaySmacker(43);
      result = v2;
      *(_BYTE *)(v2 + 17) = 1;
      break;
    case 6:
      PlaySmacker(44);
      *(_BYTE *)(v2 + 18) = 1;
      *(_BYTE *)(v2 + 19) = 1;
      result = v2;
      *(_BYTE *)(v2 + 47) = 1;
      break;
    case 7:
      PlaySmacker(45);
      *(_BYTE *)(v2 + 19) = 1;
      *(_BYTE *)(v2 + 49) = 1;
      *(_BYTE *)(v2 + 45) = 0;
      *(_BYTE *)(v2 + 47) = 0;
      result = v2;
      *(_BYTE *)(v2 + 48) = 1;
      break;
    case 8:
      result = PlaySmacker(46);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00471D50) --------------------------------------------------------
int __thiscall ExpCampaign::HandleVictory2(int this)
{
  int result; // eax@2
  int v2; // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4) + 1;
  switch ( *(_DWORD *)(this + 4) + 1 )
  {
    case 0:
      PlaySmacker(47);
      result = v2;
      *(_BYTE *)(v2 + 12) = 1;
      break;
    case 1:
      PlaySmacker(48);
      result = v2;
      *(_BYTE *)(v2 + 13) = 1;
      break;
    case 2:
      PlaySmacker(49);
      *(_BYTE *)(v2 + 14) = 1;
      result = v2;
      *(_BYTE *)(v2 + 15) = 1;
      break;
    case 3:
      PlaySmacker(50);
      *(_BYTE *)(v2 + 16) = 1;
      result = v2;
      *(_BYTE *)(v2 + 50) = 1;
      break;
    case 4:
      PlaySmacker(50);
      *(_BYTE *)(v2 + 16) = 1;
      result = v2;
      *(_BYTE *)(v2 + 51) = 1;
      break;
    case 5:
      PlaySmacker(51);
      *(_BYTE *)(v2 + 17) = 1;
      result = v2;
      *(_BYTE *)(v2 + 18) = 1;
      break;
    case 6:
      PlaySmacker(52);
      *(_BYTE *)(v2 + 19) = 1;
      result = v2;
      *(_BYTE *)(v2 + 52) = 1;
      break;
    case 7:
      PlaySmacker(52);
      *(_BYTE *)(v2 + 19) = 1;
      result = v2;
      *(_BYTE *)(v2 + 44) = 1;
      break;
    case 8:
      result = PlaySmacker(53);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00471EA0) --------------------------------------------------------
int __thiscall ExpCampaign::HandleVictory3(int this)
{
  int result; // eax@2
  int v2; // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4) + 1;
  switch ( *(_DWORD *)(this + 4) + 1 )
  {
    case 0:
      PlaySmacker(54);
      result = v2;
      *(_BYTE *)(v2 + 12) = 1;
      break;
    case 1:
      PlaySmacker(55);
      result = v2;
      *(_BYTE *)(v2 + 13) = 1;
      break;
    case 2:
      PlaySmacker(56);
      *(_BYTE *)(v2 + 14) = 1;
      *(_BYTE *)(v2 + 15) = 1;
      result = v2;
      *(_BYTE *)(v2 + 53) = 1;
      break;
    case 3:
      PlaySmacker(57);
      *(_BYTE *)(v2 + 15) = 1;
      result = v2;
      *(_BYTE *)(v2 + 54) = 1;
      break;
    case 4:
      result = PlaySmacker(58);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00471F70) --------------------------------------------------------
int __thiscall ExpCampaign::HandleVictory4(int this)
{
  int result; // eax@2
  int v2; // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4) + 1;
  switch ( *(_DWORD *)(this + 4) + 1 )
  {
    case 0:
      PlaySmacker(59);
      result = v2;
      *(_BYTE *)(v2 + 12) = 1;
      break;
    case 1:
      PlaySmacker(60);
      result = v2;
      *(_BYTE *)(v2 + 13) = 1;
      break;
    case 2:
      PlaySmacker(61);
      *(_BYTE *)(v2 + 14) = 1;
      result = v2;
      *(_BYTE *)(v2 + 15) = 1;
      break;
    case 3:
      result = PlaySmacker(62);
      break;
    case 4:
      result = PlaySmacker(63);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00472030) --------------------------------------------------------
heroWindowManager *__thiscall ExpCampaign::ReplaySmacker(void *this)
{
  heroWindowManager *result; // eax@7

  switch ( *(_DWORD *)this )
  {
    case 0:
      ExpCampaign::ReplaySmacker1((int)this);
      break;
    case 1:
      ExpCampaign::ReplaySmacker2((int)this);
      break;
    case 2:
      ExpCampaign::ReplaySmacker3((int)this);
      break;
    case 3:
      ExpCampaign::ReplaySmacker4((int)this);
      break;
    default:
      break;
  }
  result = gpWindowManager;
  gpWindowManager->cycleColors = 1;
  return result;
}

//----- (004720C0) --------------------------------------------------------
int __thiscall ExpCampaign::ReplaySmacker1(int this)
{
  int result; // eax@2

  result = *(_DWORD *)(this + 67);
  switch ( *(_DWORD *)(this + 67) )
  {
    case 0:
      result = PlaySmacker(39);
      break;
    case 1:
      result = PlaySmacker(40);
      break;
    case 2:
      result = PlaySmacker(41);
      break;
    case 3:
      result = PlaySmacker(41);
      break;
    case 4:
      result = PlaySmacker(42);
      break;
    case 5:
      result = PlaySmacker(43);
      break;
    case 6:
      result = PlaySmacker(44);
      break;
    case 7:
      if ( *(_BYTE *)(this + 26) )
        result = PlaySmacker(45);
      else
        result = PlaySmacker(44);
      break;
    default:
      return result;
  }
  return result;
}

//----- (004721C0) --------------------------------------------------------
int __thiscall ExpCampaign::ReplaySmacker2(int this)
{
  int result; // eax@2

  result = *(_DWORD *)(this + 67);
  switch ( *(_DWORD *)(this + 67) )
  {
    case 0:
      result = PlaySmacker(47);
      break;
    case 1:
      result = PlaySmacker(48);
      break;
    case 2:
      result = PlaySmacker(49);
      break;
    case 3:
      result = PlaySmacker(49);
      break;
    case 4:
      result = PlaySmacker(50);
      break;
    case 5:
      result = PlaySmacker(51);
      break;
    case 6:
      result = PlaySmacker(51);
      break;
    case 7:
      result = PlaySmacker(52);
      break;
    default:
      return result;
  }
  return result;
}

//----- (004722A0) --------------------------------------------------------
int __thiscall ExpCampaign::ReplaySmacker3(int this)
{
  int result; // eax@2

  result = *(_DWORD *)(this + 67);
  switch ( *(_DWORD *)(this + 67) )
  {
    case 0:
      result = PlaySmacker(54);
      break;
    case 1:
      result = PlaySmacker(55);
      break;
    case 2:
      result = PlaySmacker(56);
      break;
    case 3:
      if ( *(_BYTE *)(this + 22) )
        result = PlaySmacker(57);
      else
        result = PlaySmacker(56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (00472350) --------------------------------------------------------
int __thiscall ExpCampaign::ReplaySmacker4(int this)
{
  int result; // eax@2

  result = *(_DWORD *)(this + 67);
  switch ( *(_DWORD *)(this + 67) )
  {
    case 0:
      result = PlaySmacker(59);
      break;
    case 1:
      result = PlaySmacker(60);
      break;
    case 2:
      result = PlaySmacker(61);
      break;
    case 3:
      result = PlaySmacker(61);
      break;
    default:
      return result;
  }
  return result;
}

//----- (004723E0) --------------------------------------------------------
char __thiscall ExpCampaign::IsCompleted(int this)
{
  char result; // al@2

  if ( *(_BYTE *)(*(_DWORD *)(this + 8) + this + 19) )
    result = 1;
  else
    result = *(_DWORD *)this == 3 && *(_BYTE *)(this + 22);
  return result;
}

//----- (00472440) --------------------------------------------------------
char __thiscall ExpCampaign::IsThisMapCompleted(int this)
{
  return *(_BYTE *)(*(_DWORD *)(this + 4) + this + 20) != 0;
}

//----- (00472480) --------------------------------------------------------
signed int __thiscall ExpCampaign::MessageHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-14h]@21
  int v3; // [sp+14h] [bp-Ch]@8
  void *v4; // [sp+18h] [bp-8h]@1
  int v5; // [sp+1Ch] [bp-4h]@10

  v4 = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) && gpAdvManager->ready == 1 )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( giDialogTimeout && KBTickCount() > giDialogTimeout )
  {
    *(_DWORD *)v4 = 512;
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    giDialogTimeout = 0;
    return 2;
  }
  if ( *(_DWORD *)v4 != 512 )
    return 1;
  v3 = *((_DWORD *)v4 + 1);
  if ( v3 == 12 )
    goto LABEL_41;
  if ( v3 == 13 )
  {
    v2 = *((_DWORD *)v4 + 2);
    if ( v2 > 30721 )
    {
      if ( v2 != 30722 )
        return 1;
      if ( !dword_53049B )
      {
        if ( !byte_53045C[dword_530493] )
        {
          NormalDialog(
            "The currently selected map is not a valid choice for your next scenario.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          return 1;
        }
        dword_530454 = dword_530493;
      }
    }
    else if ( v2 != 30721 && v2 != 901 )
    {
      if ( v2 == 902 )
      {
        ExpCampaign::ReplaySmacker(&xCampaign);
        heroWindow::DrawWindow(dword_530497);
      }
      return 1;
    }
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    giDialogTimeout = 0;
    return 2;
  }
  if ( v3 == 14 )
  {
LABEL_41:
    switch ( *((_DWORD *)v4 + 2) )
    {
      case 0x352:
      case 0x353:
      case 0x354:
      case 0x355:
      case 0x356:
      case 0x357:
      case 0x358:
      case 0x359:
      case 0x35A:
      case 0x35B:
      case 0x35C:
      case 0x35D:
        v5 = *((_DWORD *)v4 + 2) - 850;
        if ( giDebugLevel >= 1 || byte_53045C[v5] || byte_530464[v5] )
        {
          dword_530493 = *((_DWORD *)v4 + 2) - 850;
          ExpCampaign::UpdateInfo(&xCampaign, 1);
        }
        break;
      case 0x32A:
      case 0x32B:
      case 0x32C:
        if ( !dword_53049B && byte_53045C[dword_530493] )
        {
          byte_530487[dword_530493] = *((_DWORD *)v4 + 2) - 42;
          ExpCampaign::UpdateInfo(&xCampaign, 1);
        }
        break;
      default:
        return 1;
    }
  }
  return 1;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F21F0: using guessed type int giDebugLevel;
// 5240A8: using guessed type int gpSoundManager;
// 530454: using guessed type int dword_530454;
// 530493: using guessed type int dword_530493;
// 53049B: using guessed type int dword_53049B;

//----- (004727B0) --------------------------------------------------------
signed int __thiscall ExpCampaign::Autosave(signed int this)
{
  signed int result; // eax@1

  result = this;
  if ( *(_DWORD *)(this + 4) != -1 )
  {
    *(_BYTE *)(*(_DWORD *)(this + 4) + this + 20) = 1;
    sprintf(gText, "%s_%d", xShortCampaignNames[*(_DWORD *)this], *(_DWORD *)(this + 4) + 1);
    result = game::SaveGame(gpGame, gText, 1, 0);
  }
  return result;
}
// 51A870: using guessed type char *xShortCampaignNames[2];

//----- (00472820) --------------------------------------------------------
int __cdecl ExpCampaign::Choose()
{
  PlaySmacker(67);
  return xLastChoice;
}
// 5304C8: using guessed type int xLastChoice;

//----- (00472850) --------------------------------------------------------
int __thiscall ExpCampaign::Days(int this)
{
  return gpGame->day
       + *(_WORD *)(this + 2 * *(_DWORD *)(this + 4) + 28)
       - (gpGame->week
        - 1)
       + 8 * (gpGame->week - 1)
       + 28 * (gpGame->month - 1);
}

//----- (004728C0) --------------------------------------------------------
int __thiscall ExpCampaign::CampaignID(void *this)
{
  return *(_DWORD *)this;
}

//----- (004728E0) --------------------------------------------------------
char *__thiscall ExpCampaign::JosephName(int this)
{
  char *result; // eax@2

  if ( *(_DWORD *)(this + 4) >= 4 )
    result = (&xStableText)[4 * *(_DWORD *)(this + 4)];
  else
    result = off_51A8D8[0];
  return result;
}
// 51A8D8: using guessed type char *off_51A8D8[15];

//----- (00472920) --------------------------------------------------------
char *__thiscall ExpCampaign::IvanName(int this)
{
  char *result; // eax@2

  if ( *(_DWORD *)(this + 4) >= 4 )
    result = off_51A8E0[*(_DWORD *)(this + 4)];
  else
    result = off_51A8F0[0];
  return result;
}
// 51A8E0: using guessed type char *off_51A8E0[13];
// 51A8F0: using guessed type char *off_51A8F0[9];

//----- (00472960) --------------------------------------------------------
char __thiscall ExpCampaign::IsSpecialGoldenBow(int this, int a2, int a3)
{
  return *(_DWORD *)this == 1 && *(_DWORD *)(this + 4) == 6 && a2 == 5 && !a3;
}

//----- (004729B0) --------------------------------------------------------
char __thiscall ExpCampaign::IsSpecialUA(int this)
{
  return *(_DWORD *)this == 2 && *(_DWORD *)(this + 4) == 2;
}

//----- (004729F0) --------------------------------------------------------
char __thiscall ExpCampaign::IsSpecialLossCondition(int this, int a2)
{
  return !a2 && !*(_DWORD *)this && *(_DWORD *)(this + 4) == 3 && !gpGame->players[a2].numHeroes;
}

//----- (00472A70) --------------------------------------------------------
signed int __cdecl is_netbios_avail()
{
  signed int result; // eax@6
  struct _NCB pncb; // [sp+Ch] [bp-40h]@1

  memset(&pncb, 0, 0x40u);
  for ( byte_512EB4 = 0; ; ++byte_512EB4 )
  {
    if ( (signed int)(unsigned __int8)byte_512EB4 < 254 )
    {
      memset(&pncb, 0, 0x40u);
      pncb.ncb_command = 127;
      pncb.ncb_lana_num = byte_512EB4;
      if ( thunk_Netbios(&pncb) != 3 )
        continue;
    }
    break;
  }
  if ( (signed int)(unsigned __int8)byte_512EB4 >= 254 )
  {
    result = 0;
  }
  else
  {
    byte_512EB0 = 1;
    result = 1;
  }
  return result;
}
// 512EB0: using guessed type char byte_512EB0;
// 512EB4: using guessed type char byte_512EB4;

//----- (00472B20) --------------------------------------------------------
signed __int16 __fastcall nb_init(int a1, char a2)
{
  signed __int16 result; // ax@2
  char v3; // [sp+Ch] [bp-54h]@1
  UCHAR *a1a; // [sp+14h] [bp-4Ch]@10
  struct _NCB pncb; // [sp+18h] [bp-48h]@10
  int i; // [sp+58h] [bp-8h]@4

  v3 = a2;
  memset(&byte_527840, 0, 7u);
  memset(&::pncb, 0, 0x40u);
  memset(&byte_52F868, 0, 0x1C0u);
  memset(Dest, 0xFFu, 0x1000u);
  memset(&unk_527850, 0xFFu, 0x7000u);
  memset(&hObject, 0, 0x24u);
  if ( is_netbios_avail() )
  {
    if ( byte_512EB0 )
    {
      byte_512EBC = v3;
      for ( i = 0; i < 7; ++i )
      {
        byte_512EC4[i] = 0;
        *((_BYTE *)&byte_527840 + i) = -1;
        memset((char *)&byte_52F868 + 64 * i, 0, 0x40u);
      }
      memset(dword_52FA68, 0, 0x70u);
      InitializeCriticalSection(&CriticalSection);
      InitializeCriticalSection(&stru_52FAD8);
      init_anchor((int)&unk_527838, 0);
      init_anchor((int)&unk_527848, 0);
      init_anchor((int)&unk_527808, 0);
      for ( i = 0; i < 9; ++i )
        *(&hObject + i) = CreateEventA(0, 1, 0, 0);
      memset(&pncb, 0, 0x40u);
      a1a = (UCHAR *)BaseAlloc(0x400u, "F:\\h2xsrc\\Source\\netwin.cpp", word_512EE8 + 40);
      pncb.ncb_command = 51;
      pncb.ncb_length = 1024;
      pncb.ncb_buffer = a1a;
      pncb.ncb_lana_num = byte_512EB4;
      if ( thunk_Netbios(&pncb) == 52 )
      {
        memset(&pncb, 0, 0x40u);
        pncb.ncb_command = 50;
        pncb.ncb_lana_num = byte_512EB4;
        pncb.ncb_callname[0] = 20;
        pncb.ncb_callname[2] = 10;
        thunk_Netbios(&pncb);
      }
      BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512EE8 + 54);
      byte_512EB8 = 0;
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 512EB0: using guessed type char byte_512EB0;
// 512EB4: using guessed type char byte_512EB4;
// 512EB8: using guessed type char byte_512EB8;
// 512EBC: using guessed type char byte_512EBC;
// 512EE8: using guessed type __int16 word_512EE8;

//----- (00472D70) --------------------------------------------------------
void __cdecl nb_term()
{
  struct _NCB pncb; // [sp+Ch] [bp-48h]@5
  void *a1; // [sp+4Ch] [bp-8h]@9
  int i; // [sp+50h] [bp-4h]@1

  for ( i = 0; i < 7; ++i )
    sub_474160(i);
  if ( (unsigned __int8)byte_52FA59 == 255 )
  {
    memset(&pncb, 0, 0x40u);
    pncb.ncb_command = 53;
    pncb.ncb_lana_num = byte_512EB4;
    pncb.ncb_buffer = (PUCHAR)&::pncb;
    thunk_Netbios(&pncb);
  }
  if ( byte_512EC4[(unsigned __int8)byte_512EBC] & 2 )
  {
    memset(&pncb, 0, 0x40u);
    memcpy(pncb.ncb_name, &dword_52FA68[16 * (unsigned __int8)byte_512EBC], 0x10u);
    pncb.ncb_command = 49;
    pncb.ncb_lana_num = byte_512EB4;
    thunk_Netbios(&pncb);
  }
  EnterCriticalSection(&stru_52FAD8);
  while ( 1 )
  {
    a1 = (void *)pop_node((int)&unk_527848);
    if ( !a1 )
      break;
    BaseFree(a1, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512F24 + 31);
  }
  while ( 1 )
  {
    a1 = (void *)pop_node((int)&unk_527808);
    if ( !a1 )
      break;
    BaseFree(a1, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512F24 + 35);
  }
  LeaveCriticalSection(&stru_52FAD8);
  DeleteCriticalSection(&stru_52FAD8);
  for ( i = 0; i < 9; ++i )
  {
    CloseHandle(*(&hObject + i));
    *(&hObject + i) = 0;
  }
  byte_512EB8 |= 1u;
  SetEvent(hObject);
  EnterCriticalSection(&CriticalSection);
  while ( 1 )
  {
    a1 = (void *)pop_node((int)&unk_527838);
    if ( !a1 )
      break;
    BaseFree(a1, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512F24 + 50);
  }
  LeaveCriticalSection(&CriticalSection);
  DeleteCriticalSection(&CriticalSection);
}
// 512EB4: using guessed type char byte_512EB4;
// 512EB8: using guessed type char byte_512EB8;
// 512EBC: using guessed type char byte_512EBC;
// 512F24: using guessed type __int16 word_512F24;
// 52FA59: using guessed type char byte_52FA59;

//----- (00472F80) --------------------------------------------------------
__int16 __fastcall nb_rcv(unsigned __int16 a1, void *a2)
{
  __int16 result; // ax@5
  void *v3; // [sp+Ch] [bp-10h]@1
  unsigned __int16 v4; // [sp+10h] [bp-Ch]@1
  size_t v5; // [sp+14h] [bp-8h]@3
  int a1a; // [sp+18h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  EnterCriticalSection(&CriticalSection);
  a1a = pop_node((int)&unk_527838);
  LeaveCriticalSection(&CriticalSection);
  if ( a1a )
  {
    if ( *(_WORD *)(a1a + 8) < (signed __int16)v4 )
      v5 = *(_WORD *)(a1a + 8);
    else
      v5 = v4;
    memcpy(v3, (const void *)(a1a + 11), v5);
    BaseFree((void *)a1a, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512F7C + 11);
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 512F7C: using guessed type __int16 word_512F7C;

//----- (00473040) --------------------------------------------------------
signed __int16 __fastcall nb_snd(__int16 a1, __int16 a2, const void *a3)
{
  signed __int16 result; // ax@3
  LPVOID v4; // eax@6
  int v5; // ST20_4@6
  __int16 v6; // [sp+Ch] [bp-Ch]@1
  char v7; // [sp+10h] [bp-8h]@1

  v6 = a2;
  v7 = a1;
  if ( (unsigned __int8)byte_512EBC != a1 || a2 )
  {
    if ( byte_512EC4[a1] & 1 )
    {
      v4 = BaseAlloc(a2 + 11, "F:\\h2xsrc\\Source\\netwin.cpp", word_512F9C + 15);
      v5 = (int)v4;
      *((_WORD *)v4 + 4) = v6;
      *((_BYTE *)v4 + 10) = v7;
      memcpy((char *)v4 + 11, a3, v6);
      EnterCriticalSection(&stru_52FAD8);
      add_node((int)&unk_527848, v5);
      LeaveCriticalSection(&stru_52FAD8);
      SetEvent(hObject);
      result = 0;
    }
    else
    {
      result = 8;
    }
  }
  else
  {
    sub_4738A0();
    result = 0;
  }
  return result;
}
// 512EBC: using guessed type char byte_512EBC;
// 512F9C: using guessed type __int16 word_512F9C;

//----- (00473130) --------------------------------------------------------
signed __int16 __cdecl nb_sess(__int16 a1, int a2)
{
  signed __int16 result; // ax@5
  int v3; // ST24_4@10
  int v4; // ST24_4@11
  int v5; // ST24_4@12
  int v6; // [sp+Ch] [bp-60h]@4
  int v7; // [sp+14h] [bp-58h]@13
  int v8; // [sp+18h] [bp-54h]@3
  int v9; // [sp+18h] [bp-54h]@13
  int v10; // [sp+18h] [bp-54h]@20
  struct _NCB pncb; // [sp+1Ch] [bp-50h]@8
  int v12; // [sp+5Ch] [bp-10h]@13
  int *v13; // [sp+60h] [bp-Ch]@1
  __int16 v14; // [sp+64h] [bp-8h]@2
  void *v15; // [sp+68h] [bp-4h]@2

  v13 = &a2;
  switch ( a1 )
  {
    case 0:
      ++v13;
      v15 = (void *)*(v13 - 1);
      byte_512EC4[(unsigned __int8)byte_512EBC] &= 0x7Fu;
      sub_4743B0((int)v15, &dword_52FA68[16 * (unsigned __int8)byte_512EBC]);
      memset((char *)&byte_52F868 + 64 * (unsigned __int8)byte_512EBC, 0, 0x40u);
      memcpy(
        (char *)&byte_52F868 + 64 * (unsigned __int8)byte_512EBC + 26,
        &dword_52FA68[16 * (unsigned __int8)byte_512EBC],
        0x10u);
      *((_BYTE *)&byte_52F868 + 64 * (unsigned __int8)byte_512EBC) = -80;
      dword_52F894[16 * (unsigned __int8)byte_512EBC] = (int)sub_473960;
      byte_52F899[64 * (unsigned __int8)byte_512EBC] = -1;
      byte_52F898[64 * (unsigned __int8)byte_512EBC] = byte_512EB4;
      v14 = thunk_Netbios((PNCB)&byte_52F868 + (unsigned __int8)byte_512EBC);
      goto LABEL_27;
    case 1:
      ++v13;
      v8 = *(v13 - 1);
      if ( (unsigned __int8)byte_52F899[64 * v8] != 255 )
        goto LABEL_9;
      v6 = *((_BYTE *)&byte_52F868 + 64 * v8) & 0x7F;
      if ( v6 == 16 || v6 == 35 )
        return 0;
      memset(&pncb, 0, 0x40u);
      pncb.ncb_command = 53;
      pncb.ncb_lana_num = byte_512EB4;
      pncb.ncb_buffer = (PUCHAR)((char *)&byte_52F868 + 64 * v8);
      thunk_Netbios(&pncb);
LABEL_9:
      v14 = sub_473B30(v8);
      goto LABEL_27;
    case 2:
      ++v13;
      v3 = *(v13 - 1);
      sub_4743B0(*v13, &dword_52FA68[16 * v3]);
      v14 = sub_473D40(v3, &dword_52FA68[16 * v3]);
      goto LABEL_27;
    case 3:
      v4 = *v13;
      nb_snd((unsigned __int8)byte_512EBC, 0, 0);
      v14 = sub_473E10(v4, off_512ED4);
      goto LABEL_27;
    case 4:
      ++v13;
      v5 = *(v13 - 1);
      sub_4743B0(*v13, &dword_52FA68[16 * v5]);
      v14 = sub_473E10(v5, &dword_52FA68[16 * v5]);
      goto LABEL_27;
    case 5:
      ++v13;
      v12 = *(v13 - 1);
      ++v13;
      v9 = *(v13 - 1);
      ++v13;
      v7 = *(v13 - 1);
      if ( (unsigned __int8)byte_512EBC == v12 )
        byte_512EBC = v9;
      if ( *((_BYTE *)&byte_527840 + v12) == 255 )
      {
        result = 0;
      }
      else
      {
        *((_BYTE *)&byte_527840 + v9) = *((_BYTE *)&byte_527840 + v12);
        byte_512EC4[v9] = byte_512EC4[v12];
        memcpy(&dword_52FA68[16 * v9], &dword_52FA68[16 * v12], 0x10u);
        sub_474010(v9);
        if ( v7 )
        {
          *((_BYTE *)&byte_527840 + v12) = -1;
          byte_512EC4[v12] = 0;
          memset(&dword_52FA68[16 * v12], 0, 0x10u);
        }
        v14 = 0;
LABEL_27:
        if ( v14 == 255 )
          v14 = 0;
        result = v14;
      }
      return result;
    case 6:
      ++v13;
      v10 = *(v13 - 1);
      if ( (unsigned __int8)byte_52F899[64 * v10] == 255 )
      {
        memset(&pncb, 0, 0x40u);
        pncb.ncb_command = 53;
        pncb.ncb_lana_num = byte_512EB4;
        pncb.ncb_buffer = (PUCHAR)((char *)&byte_52F868 + 64 * v10);
        thunk_Netbios(&pncb);
      }
      sub_474160(v10);
      v14 = 0;
      goto LABEL_27;
    case 7:
      byte_512EC4[*v13] &= 0xF7u;
      v14 = 0;
      goto LABEL_27;
    case 9:
      memcpy((void *)v13[1], &dword_52FA68[16 * *v13], 0x10u);
      v14 = 0;
      goto LABEL_27;
    default:
      return 1;
  }
}
// 512EB4: using guessed type char byte_512EB4;
// 512EBC: using guessed type char byte_512EBC;
// 512ED4: using guessed type wchar_t *off_512ED4;
// 52F894: using guessed type int dword_52F894[];

//----- (00473600) --------------------------------------------------------
char __fastcall nb_stat(__int16 a1)
{
  return byte_512EC4[a1];
}

//----- (00473630) --------------------------------------------------------
void __cdecl nb_thr_ctl()
{
  signed int v0; // [sp+Ch] [bp-58h]@17
  signed int v1; // [sp+50h] [bp-14h]@15
  int a1; // [sp+54h] [bp-10h]@10
  signed int v3; // [sp+58h] [bp-Ch]@1
  int i; // [sp+5Ch] [bp-8h]@4

  v3 = 1;
  if ( WaitForMultipleObjects(9u, &hObject, 0, 0) != 258 )
  {
    if ( !WaitForSingleObject(hObject, 0) )
      ResetEvent(hObject);
    for ( i = 0; i < 5; ++i )
    {
      if ( !WaitForSingleObject(*(&hHandle + i), 0) )
      {
        ResetEvent(*(&hHandle + i));
        sub_474230(i);
      }
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !v3 )
          return;
        EnterCriticalSection(&stru_52FAD8);
        a1 = pop_node((int)&unk_527808);
        if ( !a1 )
          a1 = pop_node((int)&unk_527848);
        LeaveCriticalSection(&stru_52FAD8);
        if ( a1 )
          break;
        v3 = 0;
      }
      memset(&pncb, 0, 0x40u);
      byte_52FA2A = *((_BYTE *)&byte_527840 + *(_BYTE *)(a1 + 10));
      if ( (unsigned __int8)byte_52FA2A != 255 )
        break;
LABEL_29:
      BaseFree((void *)a1, (int)"F:\\h2xsrc\\Source\\netwin.cpp", word_512FBC + 96);
    }
    memcpy(Dest, (const void *)(a1 + 11), *(_WORD *)(a1 + 8));
    dword_52FA2C = (int)Dest;
    word_52FA30 = *(_WORD *)(a1 + 8);
    pncb.ncb_command = 20;
    byte_52FA58 = byte_512EB4;
    v1 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v1 )
          goto LABEL_29;
        v0 = thunk_Netbios(&pncb);
        if ( v0 <= 8 )
          break;
        if ( v0 == 10 || v0 == 24 )
        {
LABEL_20:
          byte_512EC4[*(_BYTE *)(a1 + 10)] &= 0xFEu;
        }
        else if ( v0 == 255 )
        {
          ProcessAssert(0, "F:\\h2xsrc\\Source\\netwin.cpp", word_512FBC + 83);
        }
      }
      if ( v0 == 8 )
        goto LABEL_20;
      if ( !v0 )
        v1 = 1;
    }
  }
}
// 512EB4: using guessed type char byte_512EB4;
// 512FBC: using guessed type __int16 word_512FBC;
// 52FA2A: using guessed type char byte_52FA2A;
// 52FA2C: using guessed type int dword_52FA2C;
// 52FA30: using guessed type __int16 word_52FA30;
// 52FA58: using guessed type char byte_52FA58;

//----- (004738A0) --------------------------------------------------------
UCHAR __cdecl sub_4738A0()
{
  UCHAR result; // al@1
  const void *v1; // ST04_4@2
  unsigned int v2; // eax@2

  result = byte_52FA59;
  if ( (unsigned __int8)byte_52FA59 != 255 )
  {
    strcpy(Dest, off_512ED0);
    v1 = &dword_52FA68[16 * (unsigned __int8)byte_512EBC];
    v2 = strlen(off_512ED0);
    memcpy(&Dest[v2], v1, 0x10u);
    memset(&pncb, 0, 0x40u);
    pncb.ncb_command = -94;
    byte_52FA2B = byte_512EC0;
    word_52FA30 = strlen(off_512ED0) + 16;
    dword_52FA2C = (int)Dest;
    byte_52FA58 = byte_512EB4;
    result = thunk_Netbios(&pncb);
  }
  return result;
}
// 512EB4: using guessed type char byte_512EB4;
// 512EBC: using guessed type char byte_512EBC;
// 512EC0: using guessed type char byte_512EC0;
// 52FA2B: using guessed type char byte_52FA2B;
// 52FA2C: using guessed type int dword_52FA2C;
// 52FA30: using guessed type __int16 word_52FA30;
// 52FA58: using guessed type char byte_52FA58;
// 52FA59: using guessed type char byte_52FA59;

//----- (00473960) --------------------------------------------------------
UCHAR __stdcall sub_473960(int pncb)
{
  UCHAR result; // al@2
  signed int i; // [sp+10h] [bp-4h]@3

  ProcessAssert(
    (char *)&byte_52F868 + 64 * (unsigned __int8)byte_512EBC == (void *)pncb,
    "F:\\h2xsrc\\Source\\netwin.cpp",
    word_512FF8 + 3);
  result = *(_BYTE *)(pncb + 1);
  switch ( 0 )
  {
    case 0:
    case 36:
      byte_512EC0 = *(_BYTE *)(pncb + 3);
      memcpy(&dword_52FA68[16 * (unsigned __int8)byte_512EBC], (const void *)(pncb + 26), 0x10u);
      result = byte_512EBC;
      byte_512EC4[(unsigned __int8)byte_512EBC] |= 2u;
      break;
    case 13:
    case 22:
    case 25:
    case 48:
      for ( i = 15; ; --i )
      {
        if ( i >= 0 )
        {
          ++*(_BYTE *)(i + pncb + 26);
          if ( *(&dword_52FA68[16 * (unsigned __int8)byte_512EBC] + i) == *(_BYTE *)(i + pncb + 26) )
            continue;
        }
        break;
      }
      result = thunk_Netbios((PNCB)pncb);
      break;
    case 11:
      return result;
    default:
      sprintf(gText, "Add Name Error %02x\n", *(_BYTE *)(pncb + 1));
      ShutDown(gText);
      result = byte_512EBC;
      byte_512EC4[(unsigned __int8)byte_512EBC] |= 0x80u;
      break;
  }
  return result;
}
// 512EBC: using guessed type char byte_512EBC;
// 512EC0: using guessed type char byte_512EC0;
// 512FF8: using guessed type __int16 word_512FF8;

//----- (00473B30) --------------------------------------------------------
int __fastcall sub_473B30(int a1)
{
  int v1; // eax@3
  int v3; // [sp+Ch] [bp-4h]@1

  v3 = a1;
  if ( (unsigned __int8)byte_52F899[64 * a1] != 255 )
  {
    memset((char *)&byte_52F868 + 64 * a1, 0, 0x40u);
    *((_BYTE *)&byte_52F868 + 64 * v3) = -93;
    byte_52F86B[64 * v3] = byte_512EC0;
    word_52F870[32 * v3] = 4096;
    dword_52F86C[16 * v3] = (int)((char *)&unk_527850 + 4096 * v3);
    dword_52F894[16 * v3] = (int)sub_473BF0;
    thunk_Netbios((PNCB)&byte_52F868 + v3);
  }
  v1 = v3 << 6;
  LOBYTE(v1) = byte_52F899[64 * v3];
  return v1 & 0xFFFF00FF;
}
// 512EC0: using guessed type char byte_512EC0;
// 52F86C: using guessed type int dword_52F86C[];
// 52F870: using guessed type __int16 word_52F870[];
// 52F894: using guessed type int dword_52F894[];

//----- (00473BF0) --------------------------------------------------------
void __stdcall sub_473BF0(void *a1)
{
  unsigned int v1; // eax@7
  unsigned int v2; // eax@8
  int i; // [sp+Ch] [bp-4h]@1

  for ( i = 0; i < 7 && (char *)&byte_52F868 + 64 * i != a1; ++i )
    ;
  if ( i < 7 )
  {
    if ( byte_52F869[64 * i] )
    {
      if ( (unsigned __int8)byte_52F869[64 * i] != 11 && (unsigned __int8)byte_52F869[64 * i] != 36 )
        thunk_Netbios((PNCB)&byte_52F868 + i);
    }
    else
    {
      v1 = strlen(off_512ED0);
      if ( !memcmp((int)((char *)&unk_527850 + 4096 * i), (int)off_512ED0, v1) )
      {
        v2 = strlen(off_512ED0);
        memcpy(&dword_52FA68[16 * i], (char *)&unk_527850 + 4096 * i + v2, 0x10u);
        sub_473D40(i, &dword_52FA68[16 * i]);
      }
      else
      {
        thunk_Netbios((PNCB)&byte_52F868 + i);
      }
    }
  }
}

//----- (00473D40) --------------------------------------------------------
int __fastcall sub_473D40(int a1, const void *a2)
{
  const void *v2; // ST18_4@1
  int v3; // ST1C_4@1
  int v4; // eax@1

  v2 = a2;
  v3 = a1;
  memset((char *)&byte_52F868 + 64 * a1, 0, 0x40u);
  memcpy((char *)&byte_52F868 + 64 * v3 + 10, v2, 0x10u);
  memcpy((char *)&byte_52F868 + 64 * v3 + 26, &dword_52FA68[16 * (unsigned __int8)byte_512EBC], 0x10u);
  *((_BYTE *)&byte_52F868 + 64 * v3) = -112;
  byte_52F899[64 * v3] = -1;
  dword_52F894[16 * v3] = (int)sub_473EE0;
  byte_52F898[64 * v3] = byte_512EB4;
  byte_512EAC = 0;
  LOBYTE(v4) = thunk_Netbios((PNCB)&byte_52F868 + v3);
  return v4 & 0xFFFF00FF;
}
// 512EAC: using guessed type char byte_512EAC;
// 512EB4: using guessed type char byte_512EB4;
// 512EBC: using guessed type char byte_512EBC;
// 52F894: using guessed type int dword_52F894[];

//----- (00473E10) --------------------------------------------------------
int __fastcall sub_473E10(int a1, const void *a2)
{
  const void *v2; // ST18_4@1
  int v3; // ST1C_4@1
  int v4; // eax@1

  v2 = a2;
  v3 = a1;
  memset((char *)&byte_52F868 + 64 * a1, 0, 0x40u);
  memcpy((char *)&byte_52F868 + 64 * v3 + 10, v2, 0x10u);
  memcpy((char *)&byte_52F868 + 64 * v3 + 26, &dword_52FA68[16 * (unsigned __int8)byte_512EBC], 0x10u);
  *((_BYTE *)&byte_52F868 + 64 * v3) = -111;
  byte_52F899[64 * v3] = -1;
  dword_52F894[16 * v3] = (int)sub_473EE0;
  byte_52F898[64 * v3] = byte_512EB4;
  byte_512EAC = 0;
  LOBYTE(v4) = thunk_Netbios((PNCB)&byte_52F868 + v3);
  return v4 & 0xFFFF00FF;
}
// 512EAC: using guessed type char byte_512EAC;
// 512EB4: using guessed type char byte_512EB4;
// 512EBC: using guessed type char byte_512EBC;
// 52F894: using guessed type int dword_52F894[];

//----- (00473EE0) --------------------------------------------------------
char __stdcall sub_473EE0(char *a1)
{
  char *v1; // eax@3
  int v3; // [sp+Ch] [bp-8h]@6
  int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; ; ++i )
  {
    if ( i < 7 )
    {
      v1 = (char *)&byte_52F868 + 64 * i;
      if ( v1 != a1 )
        continue;
    }
    break;
  }
  if ( i < 7 )
  {
    LOBYTE(v1) = (_BYTE)i << 6;
    v3 = (unsigned __int8)byte_52F869[64 * i];
    if ( byte_52F869[64 * i] )
    {
      if ( v3 != 11 )
      {
        if ( v3 != 36 )
        {
          ++byte_512EAC;
          LOBYTE(v1) = byte_512EAC;
          if ( (signed int)(unsigned __int8)byte_512EAC < 20 )
          {
            Sleep(0x64u);
            LOBYTE(v1) = thunk_Netbios((PNCB)&byte_52F868 + i);
          }
        }
      }
    }
    else
    {
      *((_BYTE *)&byte_527840 + i) = byte_52F86A[64 * i];
      memcpy(&dword_52FA68[16 * i], (char *)&byte_52F868 + 64 * i + 10, 0x10u);
      byte_512EC4[i] |= 9u;
      LOBYTE(v1) = sub_474010(i);
    }
  }
  return (char)v1;
}
// 512EAC: using guessed type char byte_512EAC;

//----- (00474010) --------------------------------------------------------
UCHAR __fastcall sub_474010(int a1)
{
  UCHAR result; // al@2
  int v2; // [sp+10h] [bp-8h]@1
  UCHAR v3; // [sp+14h] [bp-4h]@2

  v2 = a1;
  while ( 1 )
  {
    ProcessAssert((unsigned __int8)byte_52F869[64 * v2] != 255, "F:\\h2xsrc\\Source\\netwin.cpp", word_513030 + 5);
    memset((char *)&byte_52F868 + 64 * v2, 0, 0x40u);
    *((_BYTE *)&byte_52F868 + 64 * v2) = -107;
    byte_52F86A[64 * v2] = *((_BYTE *)&byte_527840 + v2);
    dword_52F86C[16 * v2] = (int)((char *)&unk_527850 + 4096 * v2);
    word_52F870[32 * v2] = 4096;
    byte_52F898[64 * v2] = byte_512EB4;
    dword_52F8A4[16 * v2] = (int)*(&hHandle + v2);
    v3 = thunk_Netbios((PNCB)&byte_52F868 + v2);
    result = v3;
    if ( (signed int)v3 > 8 )
      break;
    if ( v3 == 8 || !v3 )
      return result;
LABEL_3:
    Sleep(0x32u);
  }
  if ( v3 != 10 && v3 != 24 && v3 != 255 )
    goto LABEL_3;
  return result;
}
// 512EB4: using guessed type char byte_512EB4;
// 513030: using guessed type __int16 word_513030;
// 52F86C: using guessed type int dword_52F86C[];
// 52F870: using guessed type __int16 word_52F870[];
// 52F8A4: using guessed type int dword_52F8A4[];

//----- (00474160) --------------------------------------------------------
int __fastcall sub_474160(int a1)
{
  int result; // eax@3
  int v2; // [sp+Ch] [bp-44h]@1
  struct _NCB pncb; // [sp+10h] [bp-40h]@2

  v2 = a1;
  if ( (unsigned __int8)byte_52F899[64 * a1] == 255 )
  {
    memset(&pncb, 0, 0x40u);
    pncb.ncb_command = 53;
    pncb.ncb_lana_num = byte_512EB4;
    pncb.ncb_buffer = (PUCHAR)((char *)&byte_52F868 + 64 * v2);
    thunk_Netbios(&pncb);
  }
  result = v2;
  if ( *((_BYTE *)&byte_527840 + v2) != 255 )
  {
    memset(&pncb, 0, 0x40u);
    pncb.ncb_lsn = *((_BYTE *)&byte_527840 + v2);
    pncb.ncb_command = 18;
    pncb.ncb_lana_num = byte_512EB4;
    thunk_Netbios(&pncb);
    result = v2;
    byte_512EC4[v2] &= 0xFEu;
  }
  return result;
}
// 512EB4: using guessed type char byte_512EB4;

//----- (00474230) --------------------------------------------------------
char __fastcall sub_474230(int a1)
{
  char result; // al@1
  int v2; // [sp+14h] [bp-8h]@1
  int v3; // [sp+18h] [bp-4h]@3

  v2 = a1;
  result = (_BYTE)a1 << 6;
  if ( (*((_BYTE *)&byte_52F868 + 64 * a1) & 0x7F) == 21 )
  {
    switch ( byte_52F869[64 * a1] )
    {
      case 0:
        v3 = (int)BaseAlloc(
                    (unsigned __int16)word_52F870[32 * a1] + 11,
                    "F:\\h2xsrc\\Source\\netwin.cpp",
                    word_513050 + 16);
        if ( v3 )
        {
          *(_WORD *)(v3 + 8) = word_52F870[32 * v2];
          *(_BYTE *)(v3 + 10) = v2;
          memcpy((void *)(v3 + 11), (char *)&unk_527850 + 4096 * v2, *(_WORD *)(v3 + 8));
          EnterCriticalSection(&CriticalSection);
          add_node((int)&unk_527838, v3);
          LeaveCriticalSection(&CriticalSection);
        }
        result = sub_474010(v2);
        break;
      case 8:
      case 0xA:
      case 0x18:
        result = a1;
        byte_512EC4[a1] &= 0xFEu;
        break;
      default:
        result = sub_474010(a1);
        break;
    }
  }
  return result;
}
// 513050: using guessed type __int16 word_513050;
// 52F870: using guessed type __int16 word_52F870[];

//----- (004743B0) --------------------------------------------------------
char __fastcall sub_4743B0(int a1, void *a2)
{
  char result; // al@1
  void *v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+10h] [bp-8h]@1
  unsigned int i; // [sp+14h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  result = (unsigned int)memset(a2, 0, 0x10u);
  for ( i = 0; i < 0xF; *((_BYTE *)v3 + i++) = *(_BYTE *)v4++ )
  {
    result = *(_BYTE *)v4;
    if ( !*(_BYTE *)v4 )
      break;
    result = *(_BYTE *)v4;
  }
  while ( i < 0xF )
  {
    result = i;
    *((_BYTE *)v3 + i++) = 32;
  }
  return result;
}

//----- (00474440) --------------------------------------------------------
combatManager *__thiscall combatManager::combatManager(combatManager *this)
{
  army *i; // [sp+10h] [bp-10h]@4
  signed int v4; // [sp+14h] [bp-Ch]@4
  hexcell *hexTile; // [sp+18h] [bp-8h]@1
  COMBAT_CONSTANTS v6; // [sp+1Ch] [bp-4h]@1

  baseManager::baseManager((baseManager *)this);
  v6 = HEX_GRID_SIZE;
  for ( hexTile = this->combatGrid; ; ++hexTile )
  {
    --v6;
    if ( (signed int)v6 < 0 )
      break;
    hexcell::hexcell(hexTile);
  }
  hero::hero(&this->captain);
  v4 = 42;
  for ( i = (army *)this->creatures; ; ++i )
  {
    --v4;
    if ( v4 < 0 )
      break;
    army::army(i);
  }
  this->vtable = &combatManager_vtable;
  this->field_F373 = -1;
  this->activeStackOwner = 1;
  this->currentActionSide = 1;
  this->field_F2BB = 0;
  this->field_F2B7 = 0;
  this->field_F2BF = 1;
  this->field_F2CF = 0;
  this->field_F35B = 0;
  LODWORD(this->field_F353) = -1;
  this->zeroedInHandleCatapult2 = LODWORD(this->field_F353);
  this->probablyCatapultImgIdx[0] = this->zeroedInHandleCatapult2;
  this->probablyCatapultImgIdx[1] = this->probablyCatapultImgIdx[0];
  *(_DWORD *)&this->_12[0] = 0;
  *(_DWORD *)&this->_12[4] = *(_DWORD *)&this->_12[0];
  this->isCastleBattle = 0;
  this->shadedHex = -1;
  this->field_F42F = 0;
  strcpy(this->combatMessageRow1, byte_513078);
  strcpy(this->combatMessageRow2, byte_51307C);
  return this;
}

//----- (00474600) --------------------------------------------------------
void __stdcall combatManager::CombineGroups(armyGroup *a1, armyGroup *a2)
{
  signed int stackIdx; // [sp+10h] [bp-8h]@12
  int idx; // [sp+14h] [bp-4h]@4
  int idxa; // [sp+14h] [bp-4h]@9

  if ( a1 && a2 )
  {
    for ( idx = 0; idx < 5; ++idx )
    {
      if ( armyGroup::IsMember(a2, a1->creatureTypes[idx]) )
      {
        armyGroup::Add(a2, a1->creatureTypes[idx], a1->quantities[idx], -1);
        armyGroup::Dismiss(a1, idx);
      }
    }
    for ( idxa = 0; idxa < 5; ++idxa )
    {
      if ( a1->creatureTypes[idxa] != -1 )
      {
        for ( stackIdx = 0; stackIdx < 5; ++stackIdx )
        {
          if ( a2->creatureTypes[stackIdx] == -1 )
          {
            armyGroup::Add(a2, a1->creatureTypes[idxa], a1->quantities[idxa], stackIdx);
            armyGroup::Dismiss(a1, idxa);
          }
        }
      }
    }
  }
}

//----- (00474730) --------------------------------------------------------
combatManager *__thiscall combatManager::SetupCombat(combatManager *this, __int64 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  char *v10; // eax@4
  combatManager *result; // eax@57
  combatManager *thisa; // [sp+Ch] [bp-8h]@1
  signed int side; // [sp+10h] [bp-4h]@12
  signed int sidea; // [sp+10h] [bp-4h]@45
  signed int sideb; // [sp+10h] [bp-4h]@48
  signed int sidec; // [sp+10h] [bp-4h]@51

  thisa = this;
  giSeed = a10;
  SRand(a9 + 100 * a8);
  *(_DWORD *)&thisa->_15[28] = a8;
  *(_DWORD *)&thisa->_15[32] = a9;
  if ( a2 < 0 )
    thisa->field_327B = 0;
  else
    thisa->field_327B = (int)advManager::GetCell(gpAdvManager, a2, SHIDWORD(a2));
  thisa->terrainType = (unsigned __int8)giGroundToTerrain[*(_WORD *)thisa->field_327B];
  v10 = combatManager::GetBackgroundName(thisa);
  sprintf(thisa->combatBackgroundFilename, v10);
  if ( a3 )
  {
    thisa->playerID[0] = *(_BYTE *)(a3 + 3);
    a4 = a3 + 101;
  }
  else
  {
    thisa->playerID[0] = -1;
  }
  if ( a6 )
  {
    thisa->playerID[1] = *(_BYTE *)(a6 + 3);
    a7 = a6 + 101;
  }
  else if ( a5 )
  {
    thisa->playerID[1] = *(_BYTE *)(a5 + 1);
    a7 = a5 + 8;
  }
  else
  {
    thisa->playerID[1] = -1;
  }
  for ( side = 0; side < 2; ++side )
  {
    if ( thisa->playerID[side] < 0 )
      thisa->involvedInBadMorale[side] = 0;
    else
      thisa->involvedInBadMorale[side] = gbHumanPlayer[thisa->playerID[side]];
    if ( side )
      thisa->heroes[side] = (hero *)a6;
    else
      thisa->heroes[0] = (hero *)a3;
    if ( thisa->heroes[side] )
      thisa->heroes[side]->isCaptain = 0;
    if ( side )
      thisa->armies[side] = (armyGroup *)a7;
    else
      thisa->armies[0] = (armyGroup *)a4;
    thisa->timesCatapultMustFire[side] = 1;
    *(_DWORD *)&thisa->_11[4 * side] = thisa->timesCatapultMustFire[side];
    if ( thisa->heroes[side] && hero::HasArtifact(thisa->heroes[side], 21) )
    {
      thisa->timesCatapultMustFire[side] = 2;
      *(_DWORD *)&thisa->_11[4 * side] = thisa->timesCatapultMustFire[side];
    }
    if ( thisa->heroes[side] )
    {
      if ( thisa->heroes[side]->secondarySkillLevel[10] >= 2 )
      {
        ++*(_DWORD *)&thisa->_11[4 * side];
        ++thisa->timesCatapultMustFire[side];
      }
    }
    thisa->timesGarrisonMustFire[side] = 1;
    *(_DWORD *)&thisa->_12[4 * side + 8] = 0;
    *(&thisa->field_353F + side) = 0;
  }
  thisa->hasMoat = 0;
  if ( a5 )
  {
    if ( *(_BYTE *)(a5 + 23) == -1 )
    {
      *(_DWORD *)&thisa->_12[12] = 0;
    }
    else
    {
      thisa->armies[1] = &thisa->heroes[1]->army;
      combatManager::CombineGroups((armyGroup *)(a5 + 8), (armyGroup *)((char *)&thisa->heroes[26] + 1));
      *(_DWORD *)&thisa->_12[12] = 1;
    }
    if ( *(_BYTE *)(a5 + 24) & 0x40 )
      thisa->isCastleBattle = 1;
    else
      thisa->isCastleBattle = 0;
    if ( thisa->isCastleBattle )
    {
      if ( *(_BYTE *)(a5 + 25) & 0x10 )
        thisa->hasMoat = 1;
      else
        thisa->hasMoat = 0;
    }
    thisa->drawBridgePosition = 4;
    thisa->castles[1] = (town *)a5;
    thisa->field_31E6 = (int)thisa->castles[1];
    if ( !thisa->heroes[1] && *(_BYTE *)(a5 + 25) & 0x80 )
    {
      thisa->heroes[1] = &thisa->captain;
      memset(&thisa->captain, 0, 0xFAu);
      for ( sidea = 0; sidea < 4; ++sidea )
        thisa->captain.primarySkills[sidea] = *(&captainStats[4 * thisa->castles[1]->factionID] + sidea);
      thisa->captain.spellpoints = 10 * hero::Stats(&thisa->captain, PRIMARY_SKILL_KNOWLEDGE);
      thisa->captain.factionID = thisa->castles[1]->factionID;
      thisa->captain.heroID = thisa->castles[1]->factionID + 90;
      strcpy(thisa->captain.name, "Captain");
      for ( sideb = 0; sideb < 5; ++sideb )
        thisa->captain.army.creatureTypes[sideb] = -1;
      for ( sidec = 0; sidec < 14; ++sidec )
        thisa->captain.artifacts[sidec] = -1;
      thisa->captain.artifacts[0] = 81;
      town::GiveSpells(thisa->castles[1], &thisa->captain);
      thisa->captain.isCaptain = 1;
    }
  }
  else
  {
    thisa->isCastleBattle = 0;
    thisa->castles[1] = 0;
  }
  result = thisa;
  thisa->castles[0] = 0;
  return result;
}
// 513074: using guessed type int giSeed;

//----- (00474D30) --------------------------------------------------------
void __thiscall combatManager::InitNonVisualVars(combatManager *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  this->field_F2B3 = 0;
  this->field_F357 = 0;
  for ( i = 0; i < 2; ++i )
  {
    this->heroSpellpowers[i] = 0;
    if ( this->heroes[i] )
      this->heroSpellpowers[i] = hero::Stats(this->heroes[i], PRIMARY_SKILL_SPELLPOWER);
    if ( this->castles[i] && this->castles[i]->factionID == FACTION_NECROMANCER )
    {
      if ( BYTE1(this->castles[i]->buildingsBuiltFlags) & BUILDING_SPECIAL_DEFENSE_BUILT )
        this->heroSpellpowers[i] += 2;
    }
  }
  this->heroFlagIconIdx[0] = 0;
  this->heroFlagIconIdx[1] = 3;
  this->field_F377[0] = 0;
  this->field_F377[1] = 0;
  this->winningSide = 3;
  this->field_33A1[1] = 0;
  this->field_33A1[0] = this->field_33A1[1];
  this->field_33A3[1] = 0;
  this->field_33A3[0] = this->field_33A3[1];
  this->shouldDoHeroFidget1[1] = 0;
  this->shouldDoHeroFidget1[0] = this->shouldDoHeroFidget1[1];
  this->shouldDoHeroFidget2[1] = 0;
  this->shouldDoHeroFidget2[0] = this->shouldDoHeroFidget2[1];
  this->eagleEyeSpellLearned[0] = -1;
  this->eagleEyeSpellLearned[1] = -1;
  giNextAction = 0;
  this->summonedCreatureType[0] = 0;
  this->summonedCreatureType[1] = 0;
  this->field_F2C3 = -1;
  this->field_F2BB = -1;
  this->field_F2CB = -99;
  this->currentActionSide = 1;
  this->activeStackOwner = 1;
  this->field_F2AB = 15;
  gbRetreatWin = 0;
  gbCombatSurrender = 0;
  this->field_351F[0] = 0;
  this->field_351F[1] = 0;
  this->field_F2B7 = 1;
  this->numCombatObjs = 0;
  combatManager::SetupAdjacencyArray(this);
  combatManager::GenerateMap(this);
  combatManager::LoadArmies(this);
}
// 523450: using guessed type char gbCombatSurrender;
// 524210: using guessed type char gbRetreatWin;

//----- (00474FB0) --------------------------------------------------------
char __thiscall combatManager::SetupAdjacencyArray(combatManager *this)
{
  int v1; // eax@3
  signed int v3; // [sp+14h] [bp-10h]@1
  signed int j; // [sp+18h] [bp-Ch]@3
  signed int i; // [sp+1Ch] [bp-8h]@1
  int v6; // [sp+20h] [bp-4h]@3

  v3 = 0;
  for ( i = 0; i < 117; ++i )
  {
    v1 = i / 13;
    v6 = i / 13;
    for ( j = 0; j < 6; ++j )
    {
      if ( i % 13 && i % 13 != 12 )
      {
        switch ( j )
        {
          case 0:
            if ( v6 & 1 )
              v3 = i - 13;
            else
              v3 = i - 12;
            break;
          case 2:
            if ( v6 & 1 )
              v3 = i + 13;
            else
              v3 = i + 14;
            break;
          case 3:
            if ( v6 & 1 )
              v3 = i + 12;
            else
              v3 = i + 13;
            break;
          case 5:
            if ( v6 & 1 )
              v3 = i - 14;
            else
              v3 = i - 13;
            break;
          case 1:
            v3 = i + 1;
            break;
          case 4:
            v3 = i - 1;
            break;
          default:
            break;
        }
        if ( v3 % 13 && v3 % 13 != 12 && v3 >= 0 && v3 < 117 )
        {
          LOBYTE(v1) = v3;
          this->hexNeighbors[i][j] = v3;
        }
        else
        {
          v1 = j + 6 * i;
          this->hexNeighbors[0][v1] = -1;
        }
      }
      else
      {
        v1 = j + 6 * i;
        this->hexNeighbors[0][v1] = -1;
      }
    }
  }
  return v1;
}

//----- (004751C0) --------------------------------------------------------
int __thiscall combatManager::Open(combatManager *this, int a2)
{
  int v2; // edx@12
  void *v3; // ecx@12
  int v4; // eax@14
  heroWindow *window; // [sp+10h] [bp-20h]@7
  bitmap *v8; // [sp+1Ch] [bp-14h]@4
  bitmap *thisb; // [sp+20h] [bp-10h]@1
  __int64 res; // [sp+24h] [bp-Ch]@7
  int oldShowCombatMouse; // [sp+2Ch] [bp-4h]@1

  LogStr("Op1");
  memcpy(this->_1, gPalette->contents, 0x300u);
  gpMouseManager->field_7E = 1;
  oldShowCombatMouse = *(_DWORD *)&showCombatMouseHex;
  *(_DWORD *)&showCombatMouseHex = 0;
  this->otherCombatMessageRelatedTime = 0;
  this->combatMessageRelatedTime = 0;
  this->couldBeShouldResetCombatMessage = 0;
  this->field_F42F = 0;
  soundManager::PlayAmbientMusic(gpSoundManager, -1, 0, -1);
  thisb = (bitmap *)operator new(26);
  if ( thisb )
    this->couldBeBitmapForFieldItself = bitmap::bitmap(thisb, 0, 507, 380);
  else
    this->couldBeBitmapForFieldItself = 0;
  v8 = (bitmap *)operator new(26);
  if ( v8 )
    this->probablyBitmapForCombatScreen = bitmap::bitmap(v8, 0, 640, 443);
  else
    this->probablyBitmapForCombatScreen = 0;
  this->bitmap1 = 0;
  this->field_F553 = -1;
  this->field_F557 = -1;
  memset(this->field_49F, 0, 0x75u);
  combatManager::LoadIcons(this);
  combatManager::InitNonVisualVars(this);
  combatManager::SetupAndLoadObstacles(this);
  memset(this->field_42A, 0, 0x75u);
  combatManager::GetNextArmy(this, 0);
  this->zeroedAfterAnimatingDeathAndHolySpells = 0;
  LogStr("Op2");
  res = LoadPlaySample("PREBATTL.82M");
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  giCycleType = this->field_31EA;
  CycleColors(1);
  CycleColors(1);
  gCurLoadedSpellIcon = 0;
  gCurLoadedSpellEffect = -1;
  gpMouseManager->field_7E = 0;
  mouseManager::SetPointer(gpMouseManager, "cmbtmous.mse", 6, -999);
  bMouseWasVis = mouseManager::IsVis(gpMouseManager);
  mouseManager::ShowColorPointer(gpMouseManager);
  window = (heroWindow *)operator new(68);
  if ( window )
    this->window = heroWindow::heroWindow(window, 0, 0, "cmbtwin.bin");
  else
    this->window = 0;
  if ( !this->window )
    MemError();
  heroWindowManager::AddWindow(gpWindowManager, this->window, -1, 1);
  this->field_F42F = 1;
  combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
  glTimers = KBTickCount();
  this->palette = (palette *)resourceManager::GetPalette(gpResourceManager, "kb.pal");
  KBChangeMenu(hmnuCmbt);
  combatManager::CombatMessage(this, byte_5130C4, 1, 1, 0);
  *(_DWORD *)&showCombatMouseHex = oldShowCombatMouse;
  v3 = gpBufferPalette->contents;
  if ( (void *)this->palette->contents != v3 )
    memmove(v3, v2, this->palette->contents, gpBufferPalette->contents, 768u);
  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, this->palette);
  gbLimitedCombatUpdatePalette = 1;
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
  LogStr("Op3");
  v4 = SRandom(2, 4);
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, v4);
  nextCombatAnimationTime = KBTickCount();
  combatManager::ResetCycleTimers(this);
  LogStr("Op4");
  inputManager::Flush(gpInputManager);
  combatManager::ResetMouse(this);
  this->type = 512;
  this->idx = a2;
  this->ready = 1;
  strcpy(this->name, "combatManager");
  LogStr("Op5");
  return 0;
}
// 4F19A0: using guessed type int giCycleType;
// 4F7460: using guessed type int gbLimitedCombatUpdatePalette;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 5240A8: using guessed type int gpSoundManager;
// 524C08: using guessed type int nextCombatAnimationTime;
// 52FAF8: using guessed type int bMouseWasVis;

//----- (00475600) --------------------------------------------------------
combatManager *__thiscall combatManager::Close(combatManager *this)
{
  combatManager *result; // eax@31
  bitmap *v3; // [sp+1Ch] [bp-24h]@8
  bitmap *v4; // [sp+24h] [bp-1Ch]@5
  bitmap *v5; // [sp+2Ch] [bp-14h]@3
  bool v6; // [sp+34h] [bp-Ch]@13
  signed int side; // [sp+38h] [bp-8h]@10
  signed int sidea; // [sp+38h] [bp-8h]@13
  signed int v9; // [sp+3Ch] [bp-4h]@13

  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, -1);
  gbLimitedCombatUpdatePalette = 0;
  if ( !gbClosingApp )
  {
    memcpy(gPalette->contents, this->_1, 0x300u);
    memcpy(gpBufferPalette->contents, this->_1, 0x300u);
  }
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  giCycleType = 0;
  CycleColors(0);
  v5 = this->couldBeBitmapForFieldItself;
  if ( v5 )
    ((void (__thiscall *)(bitmap *))v5->vtable->scalarDeletingDestructor)(v5);
  v4 = this->probablyBitmapForCombatScreen;
  if ( v4 )
    ((void (__thiscall *)(bitmap *))v4->vtable->scalarDeletingDestructor)(v4);
  if ( this->bitmap1 )
  {
    v3 = this->bitmap1;
    if ( v3 )
      ((void (__thiscall *)(bitmap *))v3->vtable->scalarDeletingDestructor)(v3);
  }
  for ( side = 0; side < 2; ++side )
    combatManager::UpdateArmyGroup(this, side);
  v9 = 0;
  v6 = this->playerID[1] == -1;
  for ( sidea = 0; sidea < 5; ++sidea )
  {
    if ( this->armies[v6]->creatureTypes[sidea] != -1 )
      v9 += this->armies[v6]->quantities[sidea];
  }
  if ( *(_BYTE *)(this->field_327B + 9) == 152 )
  {
    if ( v9 > 4000 )
      LOWORD(v9) = 4000;
    *(_WORD *)(this->field_327B + 4) = 8 * (v9 & 0xFFF) | *(_WORD *)(this->field_327B + 4) & 7;
  }
  if ( *(_BYTE *)(this->field_327B + 9) == 151
    && gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(this->field_327B + 4) >> 8) >> -5)].guardianType != -1 )
    gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(this->field_327B + 4) >> 8) >> -5)].guadianQty = v9;
  if ( *(_BYTE *)(this->field_327B + 9) == 170
    && gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(this->field_327B + 4) >> 8) >> -5)].occupiedObjType == 151
    && gpGame->mines[gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(this->field_327B + 4) >> 8) >> -5)].occupiedObjVal].guardianType != -1 )
    gpGame->mines[gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(this->field_327B + 4) >> 8) >> -5)].occupiedObjVal].guadianQty = v9;
  heroWindowManager::RemoveWindow(gpWindowManager, this->window);
  combatManager::FreeArmies(this);
  combatManager::FreeIcons(this);
  resourceManager::Dispose(gpResourceManager, (resource *)this->palette);
  operator delete(this->window);
  if ( !bMouseWasVis )
    mouseManager::HideColorPointer(gpMouseManager);
  this->ready = 0;
  result = this;
  this->field_F42F = 0;
  return result;
}
// 4F0A0C: using guessed type int gbClosingApp;
// 4F19A0: using guessed type int giCycleType;
// 4F7460: using guessed type int gbLimitedCombatUpdatePalette;
// 5240A8: using guessed type int gpSoundManager;
// 52FAF8: using guessed type int bMouseWasVis;

//----- (004759E0) --------------------------------------------------------
void __thiscall combatManager::UpdateArmyGroup(combatManager *this, signed int side)
{
  signed int i; // [sp+14h] [bp-4h]@1
  int j; // [sp+14h] [bp-4h]@4

  for ( i = 0; i < 5; ++i )
  {
    this->armies[side]->creatureTypes[i] = -1;
    this->armies[side]->quantities[i] = 0;
  }
  for ( j = 0; this->numCreatures[side] > j; ++j )
  {
    if ( !(this->creatures[side][j].creature.creature_flags & DEAD)
      && this->creatures[side][j].quantity > 0
      && (this->playerID[side] == -1
       || this->creatures[side][j].creatureIdx != CREATURE_EARTH_ELEMENTAL
       && this->creatures[side][j].creatureIdx != CREATURE_AIR_ELEMENTAL
       && this->creatures[side][j].creatureIdx != CREATURE_FIRE_ELEMENTAL
       && this->creatures[side][j].creatureIdx != CREATURE_WATER_ELEMENTAL
       || !(HIBYTE(this->creatures[side][j].creature.creature_flags) & 8)) )
    {
      if ( !(HIBYTE(this->creatures[side][j].creature.creature_flags) & ATTR_MIRROR_IMAGE) )
      {
        this->armies[side]->creatureTypes[this->creatures[side][j].armyIdx] = LOBYTE(this->creatures[side][j].creatureIdx);
        this->armies[side]->quantities[this->creatures[side][j].armyIdx] = this->creatures[side][j].quantity;
      }
    }
  }
  if ( *(_DWORD *)&giSkeletonsCreated && this->winningSide == side )
    armyGroup::Add(this->armies[side], 47, giSkeletonsCreated, -1);
}

//----- (00475D70) --------------------------------------------------------
int __thiscall combatManager::GenerateMap(combatManager *this)
{
  signed int i; // [sp+18h] [bp-Ch]@4
  signed int j; // [sp+1Ch] [bp-8h]@6

  if ( this->isCastleBattle == 1 )
    this->probablyCatapultImgIdx[0] = 0;
  else
    this->probablyCatapultImgIdx[0] = -1;
  for ( i = 0; i < 9; ++i )
  {
    for ( j = 0; j < 13; ++j )
    {
      this->combatGrid[j + 13 * i].occupyingCreatureBottomY = 42 * (i + 1) + 63;
      this->combatGrid[j + 13 * i].centerX = 45 * (j - 1) + ((i & 1u) < 1 ? 44 : 22) - (j - 1) + 67;
      this->combatGrid[j + 13 * i].leftX = 45 * (j - 1) + ((i & 1u) < 1 ? 22 : 0) - (j - 1) + 67;
      this->combatGrid[j + 13 * i].topY = 42 * i + 63;
      this->combatGrid[j + 13 * i].rightX = this->combatGrid[j + 13 * i].leftX + 44;
      this->combatGrid[j + 13 * i].otherY1 = this->combatGrid[j + 13 * i].topY + 42;
      this->combatGrid[j + 13 * i].otherY2 = this->combatGrid[j + 13 * i].topY + 52;
      this->combatGrid[j + 13 * i].unitOwner = -1;
      this->combatGrid[j + 13 * i].stackIdx = -1;
      this->combatGrid[j + 13 * i].occupiersOtherHexIsToLeft = -1;
      this->combatGrid[j + 13 * i].combatObjIdx = -1;
      this->combatGrid[j + 13 * i].isBlocked = 0;
      this->combatGrid[j + 13 * i].numCorpses = 0;
    }
  }
  return SRandom(8, 15);
}

//----- (004760E0) --------------------------------------------------------
char *__thiscall combatManager::GetBackgroundName(combatManager *this)
{
  combatManager *thisa; // [sp+10h] [bp-8h]@1
  signed int background; // [sp+14h] [bp-4h]@2

  thisa = this;
  this->field_31EA = 1;
  this->combatFieldFringeID = -1;
  switch ( this->terrainType )
  {
    case 0:
      background = 0;
      this->combatFieldFringeID = 13;
      break;
    case TERRAIN_IDX_GRASS:
      if ( combatManager::MoreTreesNear(this) )
      {
        background = 2;
        thisa->combatFieldFringeID = 12;
      }
      else
      {
        background = 3;
        thisa->combatFieldFringeID = 11;
      }
      break;
    case TERRAIN_IDX_SNOW:
      this->field_31EA = 3;
      if ( combatManager::MoreTreesNear(this) )
      {
        background = 4;
        thisa->combatFieldFringeID = 6;
      }
      else
      {
        background = 5;
        thisa->combatFieldFringeID = 7;
      }
      break;
    case TERRAIN_IDX_SNOW|TERRAIN_IDX_GRASS:
      background = 6;
      this->combatFieldFringeID = 8;
      break;
    case 4:
      background = 8;
      this->combatFieldFringeID = 5;
      break;
    case 5:
      this->field_31EA = 3;
      background = 10;
      this->combatFieldFringeID = 4;
      break;
    case TERRAIN_IDX_DIRT:
      if ( combatManager::MoreTreesNear(this) )
      {
        background = 12;
        thisa->combatFieldFringeID = 10;
      }
      else
      {
        background = 13;
        thisa->combatFieldFringeID = 9;
      }
      break;
    case TERRAIN_IDX_WASTELAND:
      this->field_31EA = 3;
      background = 14;
      this->combatFieldFringeID = 3;
      break;
    case 8:
      this->field_31EA = 3;
      background = 16;
      this->combatFieldFringeID = 2;
      break;
    default:
      background = 0;
      break;
  }
  return cCombatBkgNames[background];
}

//----- (00476310) --------------------------------------------------------
bool __thiscall combatManager::MoreTreesNear(combatManager *this)
{
  combatManager *thisa; // ST1C_4@1
  char v3[24]; // [sp+18h] [bp-3Ch]@1
  mapCell *v4; // [sp+30h] [bp-24h]@10
  int j; // [sp+34h] [bp-20h]@3
  int v6; // [sp+38h] [bp-1Ch]@1
  int i; // [sp+3Ch] [bp-18h]@1
  int v8; // [sp+40h] [bp-14h]@16
  int v9; // [sp+44h] [bp-10h]@1
  int row; // [sp+48h] [bp-Ch]@6
  int col; // [sp+4Ch] [bp-8h]@6
  int v12; // [sp+50h] [bp-4h]@16

  thisa = this;
  memset(v3, 0xFFu, 0x18u);
  v9 = *(_DWORD *)&thisa->_15[28];
  v6 = *(_DWORD *)&thisa->_15[32];
  for ( i = 0; i < 3; ++i )
  {
    for ( j = 0; j < 8; ++j )
    {
      col = v9 + i * normalDirTable[4 * j];
      row = v6 + i * byte_4F1DC1[4 * j];
      if ( col >= 0 && MAP_WIDTH > col && row >= 0 && row < MAP_HEIGHT )
      {
        v4 = advManager::GetCell(gpAdvManager, col, row);
        switch ( ((unsigned __int8)v4->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F )
        {
          case 0x16:
          case 0x17:
          case 0x18:
          case 0x19:
          case 0x1A:
          case 0x1B:
          case 0x1F:
          case 0x20:
            *(&v3[8 * i] + j) = 0;
            break;
          case 0x21:
          case 0x22:
          case 0x2A:
          case 0x2B:
          case 0x2C:
            *(&v3[8 * i] + j) = 1;
            break;
          default:
            continue;
        }
      }
    }
  }
  v8 = 0;
  v12 = 0;
  for ( i = 0; i < 3; ++i )
  {
    for ( j = 0; j < 8; ++j )
    {
      if ( !*(&v3[8 * i] + j) )
        ++v12;
      if ( *(&v3[8 * i] + j) == 1 )
        ++v8;
    }
  }
  return v8 > v12;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 476310: using guessed type char var_3C[24];

//----- (00476530) --------------------------------------------------------
void __thiscall combatManager::LoadIcons(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-Ch]@1
  signed int v2; // [sp+10h] [bp-8h]@19
  signed int i; // [sp+14h] [bp-4h]@1
  signed int j; // [sp+14h] [bp-4h]@4
  signed int k; // [sp+14h] [bp-4h]@11

  thisa = this;
  for ( i = 0; i < 15; ++i )
    this->combatScreenIcons[i] = 0;
  for ( j = 0; j < 8; ++j )
    this->combatObjIcons[j] = 0;
  this->combatScreenIcons[8] = resourceManager::GetIcon(gpResourceManager, "spells.icn");
  thisa->combatScreenIcons[1] = resourceManager::GetIcon(gpResourceManager, "textbar.icn");
  thisa->combatScreenIcons[9] = resourceManager::GetIcon(gpResourceManager, "cmbtmisc.icn");
  thisa->combatScreenIcons[10] = resourceManager::GetIcon(gpResourceManager, "viewarsm.icn");
  thisa->combatScreenIcons[11] = resourceManager::GetIcon(gpResourceManager, "minilkmr.icn");
  thisa->combatScreenIcons[12] = resourceManager::GetIcon(gpResourceManager, "spellinf.icn");
  if ( thisa->isCastleBattle )
  {
    if ( BYTE1(thisa->castles[1]->buildingsBuiltFlags) & 0x10 )
    {
      thisa->combatScreenIcons[13] = resourceManager::GetIcon(gpResourceManager, "moatpart.icn");
      thisa->combatScreenIcons[14] = resourceManager::GetIcon(gpResourceManager, "moatwhol.icn");
    }
    thisa->combatScreenIcons[3] = resourceManager::GetIcon(gpResourceManager, "catapult.icn");
    sprintf(gText, "castle%c.icn", cHeroTypeInitial[thisa->castles[1]->factionID]);
    thisa->combatScreenIcons[5] = resourceManager::GetIcon(gpResourceManager, gText);
    thisa->combatScreenIcons[7] = resourceManager::GetIcon(gpResourceManager, "keep.icn");
  }
  for ( k = 0; k < 2; ++k )
  {
    thisa->heroIcon[k] = 0;
    thisa->heroFlagIcon[k] = 0;
    thisa->heroAnimationType[k] = 0;
    thisa->heroAnimationFrameCount[k] = 0;
    thisa->heroType[k] = -1;
    if ( thisa->heroes[k] )
    {
      if ( thisa->heroes[k]->isCaptain )
      {
        sprintf(gText, "cmbtcap%c.icn", cHeroTypeInitial[thisa->heroes[k]->factionID]);
        thisa->heroIcon[k] = resourceManager::GetIcon(gpResourceManager, gText);
        thisa->heroType[k] = thisa->heroes[k]->factionID + 6;
      }
      else
      {
        sprintf(gText, "cmbthro%c.icn", cHeroTypeInitial[thisa->heroes[k]->factionID]);
        thisa->heroIcon[k] = resourceManager::GetIcon(gpResourceManager, gText);
        thisa->heroType[k] = thisa->heroes[k]->factionID;
      }
    }
    if ( thisa->heroIcon[k] )
    {
      if ( thisa->playerID[k] == -1 )
        v2 = 6;
      else
        v2 = gpGame->players[LOBYTE(thisa->playerID[k])].color;
      sprintf(gText, "herofl%02d.icn", v2);
      thisa->heroFlagIcon[k] = resourceManager::GetIcon(gpResourceManager, gText);
    }
  }
}

//----- (00476920) --------------------------------------------------------
void __thiscall combatManager::FreeIcons(combatManager *this)
{
  combatManager *v1; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1
  signed int j; // [sp+10h] [bp-4h]@6
  signed int k; // [sp+10h] [bp-4h]@11

  v1 = this;
  for ( i = 0; i < 15; ++i )
  {
    if ( v1->combatScreenIcons[i] )
      resourceManager::Dispose(gpResourceManager, (resource *)v1->combatScreenIcons[i]);
  }
  for ( j = 0; j < 8; ++j )
  {
    if ( v1->combatObjIcons[j] )
      resourceManager::Dispose(gpResourceManager, (resource *)v1->combatObjIcons[j]);
  }
  for ( k = 0; k < 2; ++k )
  {
    if ( v1->heroIcon[k] )
      resourceManager::Dispose(gpResourceManager, (resource *)v1->heroIcon[k]);
    if ( v1->heroFlagIcon[k] )
      resourceManager::Dispose(gpResourceManager, (resource *)v1->heroFlagIcon[k]);
  }
}

//----- (00476A50) --------------------------------------------------------
void __thiscall combatManager::LoadArmies(combatManager *this)
{
  signed int i; // [sp+10h] [bp-Ch]@3
  signed int j; // [sp+10h] [bp-Ch]@7
  signed int armyIdx; // [sp+14h] [bp-8h]@1
  signed int armyIdxa; // [sp+14h] [bp-8h]@9
  int armyIdxb; // [sp+14h] [bp-8h]@13
  int attackerOccHex; // [sp+18h] [bp-4h]@18
  int defenderOccHex; // [sp+18h] [bp-4h]@26

  this->numCreatures[1] = 0;
  this->numCreatures[0] = this->numCreatures[1];
  for ( armyIdx = 0; armyIdx < 20; ++armyIdx )
  {
    for ( i = 0; i < 2; ++i )
    {
      this->creatures[i][armyIdx].quantity = 0;
      this->creatures[i][armyIdx].creatureIdx = -1;
    }
  }
  for ( j = 0; j < 2; ++j )
  {
    for ( armyIdxa = 0; armyIdxa < 20; ++armyIdxa )
      army::InitClean(&this->creatures[j][armyIdxa]);
  }
  for ( armyIdxb = 0; armyIdxb < 5; ++armyIdxb )
  {
    if ( this->armies[0]->creatureTypes[armyIdxb] != -1 )
    {
      if ( this->heroes[0] && BYTE1(this->heroes[0]->flags) & HERO_ARMY_COMPACT )
        attackerOccHex = 13 * armyIdxb + 27;
      else
        attackerOccHex = 26 * armyIdxb + 1;
      army::Init(
        (army *)this->creatures + this->numCreatures[0],
        this->armies[0]->creatureTypes[armyIdxb],
        this->armies[0]->quantities[armyIdxb],
        0,
        this->numCreatures[0],
        attackerOccHex,
        armyIdxb);
      army::LoadResources((army *)this->creatures + this->numCreatures[0]++);
    }
    if ( this->armies[1]->creatureTypes[armyIdxb] != -1 )
    {
      if ( this->heroes[1] && BYTE1(this->heroes[1]->flags) & HERO_ARMY_COMPACT
        || this->castles[1] && this->castles[1]->field_38 )
        defenderOccHex = 13 * armyIdxb + 37;
      else
        defenderOccHex = 26 * armyIdxb + 11;
      army::Init(
        &this->creatures[1][this->numCreatures[1]],
        this->armies[1]->creatureTypes[armyIdxb],
        this->armies[1]->quantities[armyIdxb],
        1,
        this->numCreatures[1],
        defenderOccHex,
        armyIdxb);
      army::LoadResources(&this->creatures[1][this->numCreatures[1]++]);
    }
  }
}

//----- (00476DC0) --------------------------------------------------------
void __thiscall combatManager::FreeArmies(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-8h]@1
  int i; // [sp+10h] [bp-4h]@1
  int j; // [sp+10h] [bp-4h]@4

  thisa = this;
  soundManager::StopAllSamples((soundManager *)gpSoundManager, 1);
  for ( i = 0; thisa->numCreatures[0] > i; ++i )
    army::FreeResources((army *)thisa->creatures + i);
  for ( j = 0; thisa->numCreatures[1] > j; ++j )
    army::FreeResources(&thisa->creatures[1][j]);
  if ( gCurLoadedSpellIcon )
    resourceManager::Dispose(gpResourceManager, (resource *)gCurLoadedSpellIcon);
  gCurLoadedSpellIcon = 0;
  gCurLoadedSpellEffect = -1;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (00476EA0) --------------------------------------------------------
int __thiscall combatManager::GetGridIndex(combatManager *this, signed int x, signed int y)
{
  int result; // eax@20
  combatManager *thisa; // [sp+Ch] [bp-20h]@1
  signed int v5; // [sp+14h] [bp-18h]@1
  signed int v6; // [sp+18h] [bp-14h]@1
  int v7; // [sp+1Ch] [bp-10h]@1
  int v8; // [sp+20h] [bp-Ch]@3

  thisa = this;
  v5 = y - 63;
  v7 = (y - 63) / 42;
  v6 = x - 23;
  if ( !(v7 & 1) )
    v6 = x - 45;
  v8 = v6 / 44;
  if ( v6 / 44 < 0 )
    goto LABEL_37;
  if ( v5 % 42 < 10 && v5 % 42 < abs(v6 % 44 - 22) / 2 )
  {
    --v7;
    if ( v6 % 44 >= 22 )
    {
      if ( v7 & 1 )
        ++v8;
    }
    else if ( !(v7 & 1) )
    {
      --v8;
    }
  }
  if ( v8 > 0 && v8 < 12 && v7 < 9 && v7 >= 0 )
  {
    result = v8 + 13 * v7;
  }
  else
  {
LABEL_37:
    if ( x < 0 || x > 74 || y < 80 || y > 196 )
    {
      if ( x < 566 || x > 639 || y < 37 || y > 153 )
      {
        if ( x >= 566 && x <= 639 && y >= 154 && y <= 310 && thisa->isCastleBattle )
          result = 77;
        else
          result = -1;
      }
      else
      {
        result = 25;
      }
    }
    else
    {
      result = 26;
    }
  }
  return result;
}

//----- (00477090) --------------------------------------------------------
void __thiscall combatManager::CheckApplyGoodMorale(combatManager *this, int side, int stackIdx)
{
  combatManager *thisa; // [sp+Ch] [bp-18h]@1
  army *v4; // [sp+18h] [bp-Ch]@6
  __int64 res; // [sp+1Ch] [bp-8h]@0

  thisa = this;
  if ( side >= 0 && stackIdx >= 0 )
  {
    if ( bInHighMoraleBonus )
    {
      bInHighMoraleBonus = 0;
    }
    else
    {
      bInHighMoraleBonus = 0;
      v4 = &this->creatures[side][stackIdx];
      if ( !(HIBYTE(this->creatures[side][stackIdx].creature.creature_flags) & ATTR_UNDEAD)
        && this->creatures[side][stackIdx].quantity
        && this->creatures[side][stackIdx].morale > 0
        && SRandom(1, 24) <= this->creatures[side][stackIdx].morale )
      {
        bInHighMoraleBonus = 1;
        if ( !gbNoShowCombat )
        {
          sprintf(gText, "goodmrle.82M");
          res = LoadPlaySample(gText);
          if ( thisa->creatures[side][stackIdx].quantity > 1 )
            sprintf(
              gText,
              "High morale enables the \n%s to attack again.",
              gArmyNamesPlural[thisa->creatures[side][stackIdx].creatureIdx]);
          else
            sprintf(
              gText,
              "High morale enables the \n%s to attack again.",
              gArmyNames[thisa->creatures[side][stackIdx].creatureIdx]);
          combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        }
        army::SpellEffect(v4, 11, 180, 0);
        if ( thisa->creatures[side][stackIdx].creature.creature_flags & MAYBE_NOT_LOST_TURN )
          *(_DWORD *)&thisa->creatures[side][stackIdx].creature.creature_flags -= MAYBE_NOT_LOST_TURN;
        *(_DWORD *)&thisa->creatures[side][stackIdx].creature.creature_flags |= HAS_GOOD_MORALE;
        if ( !gbNoShowCombat )
          WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
      }
    }
  }
}
// 513070: using guessed type int bInHighMoraleBonus;
// 518CFC: using guessed type int gbNoShowCombat;

//----- (00477280) --------------------------------------------------------
signed int __thiscall combatManager::CheckApplyBadMorale(combatManager *this, int side, int stackIdx)
{
  signed int result; // eax@3
  combatManager *thisa; // [sp+Ch] [bp-18h]@1
  army *creature; // [sp+18h] [bp-Ch]@4
  __int64 res; // [sp+1Ch] [bp-8h]@0

  thisa = this;
  if ( side >= 0 && stackIdx >= 0 )
  {
    creature = &this->creatures[side][stackIdx];
    if ( HIBYTE(this->creatures[side][stackIdx].creature.creature_flags) & ATTR_UNDEAD )
    {
      result = 0;
    }
    else if ( this->creatures[side][stackIdx].morale < 0 && SRandom(1, 12) <= -this->creatures[side][stackIdx].morale )
    {
      if ( thisa->involvedInBadMorale[side] || SRandom(1, 4) != 1 )
      {
        if ( !gbNoShowCombat )
        {
          res = LoadPlaySample("BADMRLE.82M");
          if ( thisa->creatures[side][stackIdx].quantity > 1 )
            sprintf(
              gText,
              "Low morale causes the \n%s to freeze in panic.",
              gArmyNamesPlural[thisa->creatures[side][stackIdx].creatureIdx]);
          else
            sprintf(
              gText,
              "Low morale causes the \n%s to freeze in panic.",
              gArmyNames[thisa->creatures[side][stackIdx].creatureIdx]);
          combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        }
        army::SpellEffect(creature, ANIM_MORALE_BAD_IDX, 180, 1);
        *(_DWORD *)&thisa->creatures[side][stackIdx].creature.creature_flags |= MAYBE_NOT_LOST_TURN;
        if ( !gbNoShowCombat )
          WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
        result = 1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 518CFC: using guessed type int gbNoShowCombat;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (00477450) --------------------------------------------------------
signed int __thiscall combatManager::GetNextArmy(combatManager *this, int a2)
{
  combatManager *thisa; // [sp+Ch] [bp-24h]@1
  int side; // [sp+10h] [bp-20h]@2
  signed int j; // [sp+18h] [bp-18h]@4
  signed int k; // [sp+18h] [bp-18h]@38
  int stackIdx; // [sp+1Ch] [bp-14h]@6
  int stackIdxa; // [sp+1Ch] [bp-14h]@40
  signed int v9; // [sp+24h] [bp-Ch]@2
  signed int v10; // [sp+28h] [bp-8h]@8
  signed int i; // [sp+2Ch] [bp-4h]@2

  thisa = this;
  while ( 1 )
  {
    v9 = 0;
    side = thisa->activeStackOwner;
    thisa->field_F2AB = 14;
    for ( i = 0; i < 15; ++i )
    {
      for ( j = 0; j < 2; ++j )
      {
        side ^= 1u;
        for ( stackIdx = 0; ; ++stackIdx )
        {
          if ( thisa->numCreatures[side] > stackIdx )
          {
            v10 = 0;
            if ( thisa->creatures[side][stackIdx].creature.creature_flags & (MAYBE_NOT_LOST_TURN|DEAD)
              || thisa->creatures[side][stackIdx].effectStrengths[6]
              || thisa->creatures[side][stackIdx].effectStrengths[11]
              || thisa->creatures[side][stackIdx].effectStrengths[2]
              || thisa->creatures[side][stackIdx].creature.speed != thisa->field_F2AB
              && !(thisa->creatures[side][stackIdx].creature.creature_flags & HAS_GOOD_MORALE) )
              v10 = 1;
            if ( !v10 && !i && !(thisa->creatures[side][stackIdx].creature.creature_flags & HAS_GOOD_MORALE) )
              v10 = 1;
            if ( HIBYTE(thisa->creatures[side][stackIdx].creature.creature_flags) & 0x10 )
            {
              v10 = 1;
              v9 = 1;
            }
            if ( !v10 && a2 && combatManager::CheckApplyBadMorale(thisa, side, stackIdx) )
              v10 = 1;
            if ( v10 )
              continue;
          }
          break;
        }
        if ( thisa->numCreatures[side] != stackIdx )
        {
          thisa->activeStackOwner = side;
          thisa->activeStack = stackIdx;
          if ( thisa->creatures[side][stackIdx].effectStrengths[7] )
            thisa->currentActionSide = 1 - side;
          else
            thisa->currentActionSide = side;
          combatManager::GetControl(thisa);
          return 1;
        }
      }
      if ( i )
      {
        --thisa->field_F2AB;
        if ( !thisa->field_F2AB )
          thisa->field_F2AB = 15;
      }
    }
    if ( !v9 )
      break;
    a2 = 0;
    for ( k = 0; k < 2; ++k )
    {
      for ( stackIdxa = 0; thisa->numCreatures[k] > stackIdxa; ++stackIdxa )
        *(_DWORD *)&thisa->creatures[k][stackIdxa].creature.creature_flags &= 0xFFFFEFFFu;
    }
  }
  combatManager::CheckCastleAttack(thisa);
  thisa->currentActionSide = 1 - thisa->currentActionSide;
  combatManager::CheckCastleAttack(thisa);
  thisa->currentActionSide = 1 - thisa->currentActionSide;
  return 0;
}

//----- (004777E0) --------------------------------------------------------
signed int __thiscall combatManager::IsWinner(combatManager *this, int side)
{
  signed int result; // eax@2
  int i; // [sp+10h] [bp-8h]@5
  signed int v4; // [sp+14h] [bp-4h]@5
  int sidea; // [sp+20h] [bp+8h]@5

  if ( this->field_351F[1 - side] )
  {
    result = 1;
  }
  else if ( this->field_F377[1 - side] )
  {
    result = 1;
  }
  else
  {
    sidea = side ^ 1;
    v4 = 1;
    for ( i = 0; this->numCreatures[sidea] > i; ++i )
    {
      if ( !(this->creatures[sidea][i].creature.creature_flags & DEAD) )
        v4 = 0;
    }
    result = v4;
  }
  return result;
}

//----- (004778C0) --------------------------------------------------------
void __thiscall combatManager::CatAttack(combatManager *this, int side)
{
  int randNeighbor; // [sp+50h] [bp-B0h]@68
  char missTiles[11]; // [sp+54h] [bp-ACh]@68
  int neighb; // [sp+60h] [bp-A0h]@70
  int v6; // [sp+64h] [bp-9Ch]@60
  int v7; // [sp+68h] [bp-98h]@52
  int hexIdx; // [sp+6Ch] [bp-94h]@5
  icon *boulderICN; // [sp+70h] [bp-90h]@43
  unsigned int missed; // [sp+74h] [bp-8Ch]@5
  int v11; // [sp+78h] [bp-88h]@83
  H2RECT rect; // [sp+7Ch] [bp-84h]@103
  int v13; // [sp+8Ch] [bp-74h]@83
  int i; // [sp+90h] [bp-70h]@72
  int j; // [sp+94h] [bp-6Ch]@68
  icon *cloudICN; // [sp+98h] [bp-68h]@116
  int garrisonIsTarget; // [sp+9Ch] [bp-64h]@5
  int numTurrets; // [sp+A0h] [bp-60h]@5
  int targetTurret; // [sp+A4h] [bp-5Ch]@5
  __int64 v20; // [sp+A8h] [bp-58h]@43
  int catDamage; // [sp+B0h] [bp-50h]@5
  int targY; // [sp+B4h] [bp-4Ch]@43
  float v23; // [sp+B8h] [bp-48h]@83
  float boulderY; // [sp+BCh] [bp-44h]@83
  int targetWall; // [sp+C0h] [bp-40h]@5
  int targX; // [sp+C4h] [bp-3Ch]@43
  float v27; // [sp+C8h] [bp-38h]@83
  float boulderX; // [sp+CCh] [bp-34h]@83
  int numWalls; // [sp+D0h] [bp-30h]@5
  SAMPLE2 res; // [sp+D4h] [bp-2Ch]@43
  float v32; // [sp+DCh] [bp-24h]@83
  int gateIsTargetl; // [sp+E0h] [bp-20h]@5
  float v33; // [sp+E4h] [bp-1Ch]@83
  int v34; // [sp+E8h] [bp-18h]@83
  int rndNum; // [sp+ECh] [bp-14h]@5
  resource *catapultSound; // [sp+F0h] [bp-10h]@43
  int imageIdx; // [sp+F8h] [bp-8h]@83
  int v38; // [sp+FCh] [bp-4h]@83

  if ( this->isCastleBattle )
  {
    LogStr("CA1");
    if ( *(_DWORD *)&this->_15[100] != -1 || *(_DWORD *)&this->_15[104] != -1 )
    {
      *(_DWORD *)&this->_15[104] = -1;
      *(_DWORD *)&this->_15[100] = *(_DWORD *)&this->_15[104];
      combatManager::DrawSmallView(this, 0, 1);
      combatManager::DrawSmallView(this, 1, 1);
    }
    rndNum = SRandom(0, 20);
    numWalls = 0;
    numTurrets = 0;
    targetWall = -1;
    targetTurret = -1;
    gateIsTargetl = -1;
    garrisonIsTarget = -1;
    hexIdx = -1;
    missed = 0;
    catDamage = 1;
    if ( this->wallStatus[0] != 2 && this->wallStatus[0] != 6 )
      ++numWalls;
    if ( this->wallStatus[1] != 2 && this->wallStatus[1] != 6 )
      ++numWalls;
    if ( this->wallStatus[2] != 2 && this->wallStatus[2] != 6 )
      ++numWalls;
    if ( this->wallStatus[3] != 2 && this->wallStatus[3] != 6 )
      ++numWalls;
    if ( this->turretStatus[0] == 1 )
      ++numTurrets;
    if ( this->turretStatus[3] == 1 )
      ++numTurrets;
    if ( numWalls )
    {
      rndNum = rndNum % numWalls + 1;
      targetWall = -1;
      while ( rndNum )
      {
        ++targetWall;
        if ( this->wallStatus[targetWall] != 2 )
        {
          if ( this->wallStatus[targetWall] != 6 )
            --rndNum;
        }
      }
    }
    else if ( numTurrets )
    {
      rndNum %= numTurrets;
      if ( rndNum != 1 && this->turretStatus[0] != 2 )
        targetTurret = 0;
      else
        targetTurret = 3;
    }
    else if ( this->drawBridgePosition == 3 )
    {
      if ( !this->ballistaDestroyed )
        garrisonIsTarget = 0;
    }
    else
    {
      gateIsTargetl = 1;
    }
    if ( targetTurret != -1 || targetWall != -1 || gateIsTargetl != -1 || garrisonIsTarget != -1 )
    {
      sprintf(gText, "catsnd%02d.82M", 2);
      catapultSound = (resource *)resourceManager::GetSample(gpResourceManager, gText);
      res = NULL_SAMPLE2;
      boulderICN = resourceManager::GetIcon(gpResourceManager, "boulder.icn");
      sprintf(gText, "catsnd%02d.82M", 0);
      v20 = LoadPlaySample(gText);
      targX = -1;
      targY = -1;
      if ( targetWall != -1 )
      {
        targX = wallPos[targetWall].x;
        targY = wallPos[targetWall].y;
        hexIdx = (unsigned __int8)byte_4F5234[targetWall];
      }
      if ( targetTurret != -1 )
      {
        targX = towerPos[targetTurret].x;
        targY = towerPos[targetTurret].y;
        hexIdx = (unsigned __int8)byte_4F5238[targetTurret];
      }
      if ( gateIsTargetl != -1 )
      {
        targX = (unsigned __int16)doorPos.x;
        targY = (unsigned __int16)doorPos.y;
        hexIdx = 59;
      }
      if ( garrisonIsTarget != -1 )
      {
        targX = 600;
        targY = 160;
        hexIdx = 77;
      }
      if ( this->heroes[0]->secondarySkillLevel[10] )
      {
        if ( this->heroes[0]->secondarySkillLevel[10] > 2 )
        {
          if ( this->heroes[0]->secondarySkillLevel[10] == 3 )
            catDamage = 2;
        }
        else
        {
          v6 = SRandom(0, 100);
          if ( !gbHumanPlayer[this->heroes[0]->ownerIdx] )
            v6 -= 5;
          if ( v6 < 50 )
            catDamage = 2;
        }
      }
      else
      {
        v7 = SRandom(0, 100);
        if ( !gbHumanPlayer[this->heroes[0]->ownerIdx] )
          v7 -= 5;
        if ( v7 >= 25 )
        {
          if ( v7 > 75 )
          {
            missed = 1;
            catDamage = 0;
          }
        }
        else
        {
          catDamage = 2;
        }
      }
      if ( missed )                             // The catapult will hit a tile adjacent to its target
      {
        missTiles[0] = 32;
        missTiles[1] = 46;
        missTiles[2] = 10;
        missTiles[3] = 23;
        missTiles[4] = 35;
        missTiles[5] = 48;
        missTiles[6] = 60;
        missTiles[7] = 74;
        missTiles[8] = 87;
        missTiles[9] = 101;
        missTiles[10] = 114;
        randNeighbor = SRandom(0, 5);
        for ( j = 0; j < 6; ++j )
        {
          neighb = GetAdjacentCellIndexNoArmy(hexIdx, (j + randNeighbor) % 6);
          if ( neighb != -1 && this->combatGrid[neighb].unitOwner == -1 )
          {
            for ( i = 0; i < 11; ++i )
            {
              if ( (unsigned __int8)missTiles[i] == neighb )
              {
                targX = this->combatGrid[neighb].centerX;
                targY = this->combatGrid[neighb].occupyingCreatureBottomY - 17;
                goto LABEL_79;
              }
            }
          }
        }
        missed = 0;
        catDamage = 1;
LABEL_79:
        ++j;
      }
      giMinExtentX = 0;
      giMaxExtentX = 160;
      giMinExtentY = 263;
      giMaxExtentY = 413;
      for ( this->probablyCatapultImgIdx[side] = 0;
            this->probablyCatapultImgIdx[side] < 5;
            ++this->probablyCatapultImgIdx[side] )
        combatManager::DrawFrame(this, 1, 0, 1, 0, 75, 1, 1);
      v13 = 84;
      v11 = 304;
      imageIdx = 0;
      boulderX = (double)84;
      boulderY = (double)304;
      v33 = (double)((targX + 84) / 2);
      v32 = (double)targY - (double)(targX - 84) * 0.3 - (double)targY * 0.35;
      v27 = (v33 - (double)84) / 12.5;
      v23 = (v32 - (double)304) / 78.0;
      v38 = -1;
      v34 = -1;
      for ( j = 0; j < 25; ++j )
      {
        if ( j == 12 )
          v23 = (v32 - (double)targY) / 78.0;
        if ( j )
        {
          giMinExtentX = v38 - 15;
          giMaxExtentX = (signed __int64)(boulderX + 15.0);
          giMinExtentY = (signed __int64)(boulderY - 15.0);
          giMaxExtentY = (signed __int64)(boulderY + 15.0);
          if ( (double)v34 >= boulderY )
            giMaxExtentY = v34 + 15;
          else
            giMinExtentY = v34 - 15;
          if ( j <= 6 )
          {
            giMinExtentX = 0;
            giMaxExtentY = 413;
          }
          if ( giMinExtentX < 0 )
            giMinExtentX = 0;
          if ( giMinExtentY < 0 )
            giMinExtentY = 0;
          if ( giMaxExtentX > 639 )
            giMaxExtentX = 639;
          if ( giMaxExtentY > 442 )
            giMaxExtentY = 442;
          if ( giMaxExtentY < 1 )
            giMaxExtentY = 1;
        }
        combatManager::DrawFrame(this, 0, 0, 1, 0, 63, 1, 1);
        icon::CombatClipDrawToBuffer(
          boulderICN,
          (signed __int64)boulderX,
          (signed __int64)boulderY,
          imageIdx,
          &rect,
          0,
          0,
          0,
          0);
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          giMinExtentX,
          giMinExtentY,
          giMaxExtentX - giMinExtentX + 1,
          giMaxExtentY - giMinExtentY + 1);
        v38 = (signed __int64)boulderX;
        v34 = (signed __int64)boulderY;
        boulderX = boulderX + v27;
        boulderY = (double)(12 - j) * v23 + boulderY;
        ++imageIdx;
        imageIdx = (((unsigned __int64)imageIdx >> 32) ^ abs(imageIdx) & 7) - ((unsigned __int64)imageIdx >> 32);
        if ( j < 4 )
          ++this->probablyCatapultImgIdx[side];
      }
      sprintf(gText, "catsnd%02d.82M", 2);
      res = (SAMPLE2)LoadPlaySample(gText);
      this->zeroedInHandleCatapult1 = 0;
      this->zeroedInHandleCatapult2 = 0;
      giMinExtentX = targX - 75;
      giMaxExtentX = targX + 75;
      giMinExtentY = targY - 50;
      giMaxExtentY = targY + 150;
      if ( gateIsTargetl != -1 )
        giMinExtentX -= 75;
      if ( giMinExtentX < 0 )
        giMinExtentX = 0;
      if ( giMaxExtentX > 639 )
        giMaxExtentX = 639;
      if ( giMinExtentY < 0 )
        giMinExtentY = 0;
      if ( giMaxExtentY > 442 )
        giMaxExtentY = 442;
      cloudICN = resourceManager::GetIcon(
                   gpResourceManager,
                   &aSmalclod_icn[("lichclod.icn" - "smalclod.icn") & ((missed != 0) - 1)]);
      for ( j = 0; j < 12; ++j )
      {
        if ( j < 10 || gateIsTargetl == -1 && !missed )
        {
          animTimer = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
          combatManager::DrawFrame(this, 0, 0, 1, 0, 0, 1, 0);
          if ( gateIsTargetl != -1 && j >= 2 && !missed )
            IconToBitmap(
              cloudICN,
              gpWindowManager->screenBuffer,
              targX - 45,
              targY + 70,
              j - 2,
              1,
              0,
              0,
              0x280u,
              443,
              0);
          if ( j < 10 )
            IconToBitmap(
              cloudICN,
              gpWindowManager->screenBuffer,
              targX,
              targY + (missed < 1 ? 0x19 : 0),
              j,
              1,
              0,
              0,
              0x280u,
              443,
              0);
          heroWindowManager::UpdateScreenRegion(
            gpWindowManager,
            giMinExtentX,
            giMinExtentY,
            giMaxExtentX - giMinExtentX + 1,
            giMaxExtentY - giMinExtentY + 1);
          DelayTil(&animTimer);
          if ( (j == 6 && gateIsTargetl == -1 || j == 7 && gateIsTargetl != -1) && !missed )
          {
            if ( targetWall == -1 )
            {
              if ( targetTurret == -1 )
              {
                if ( gateIsTargetl == -1 )
                {
                  if ( garrisonIsTarget != -1 )
                    this->ballistaDestroyed = 1;
                }
                else
                {
                  this->drawBridgePosition = 3;
                }
              }
              else
              {
                this->turretStatus[targetTurret] = 2;
              }
            }
            else
            {
              if ( this->wallStatus[targetWall] < 3 || this->wallStatus[targetWall] > 5 )
              {
                if ( catDamage <= 1 )
                  ++this->wallStatus[targetWall];
                else
                  this->wallStatus[targetWall] = 2;
              }
              else
              {
                this->wallStatus[targetWall] += catDamage;
                if ( this->wallStatus[targetWall] > 5 )
                  this->wallStatus[targetWall] = 6;
              }
              if ( this->wallStatus[targetWall] == 2 || this->wallStatus[targetWall] == 6 )
                this->combatGrid[(unsigned __int8)byte_4F5234[targetWall]].isBlocked = 0;
            }
          }
        }
      }
      resourceManager::Dispose(gpResourceManager, (resource *)cloudICN);
      this->probablyCatapultImgIdx[side] = 0;
      combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
      resourceManager::Dispose(gpResourceManager, (resource *)boulderICN);
      WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
      WaitEndSample((void *)0xFFFFFFFF, (resource *)v20, HIDWORD(v20));
      if ( catapultSound )
        resourceManager::Dispose(gpResourceManager, catapultSound);
      LogStr("CA2");
    }
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00478860) --------------------------------------------------------
void __thiscall combatManager::KeepAttack(combatManager *this, int towerIdx)
{
  char heroAttack; // al@32
  combatManager *thisa; // [sp+10h] [bp-D4h]@1
  char *createName; // [sp+18h] [bp-CCh]@46
  signed int targetPriority; // [sp+24h] [bp-C0h]@9
  Point16 v6[6][3]; // [sp+2Ch] [bp-B8h]@31
  int targetStrength; // [sp+74h] [bp-70h]@9
  int yFrom; // [sp+78h] [bp-6Ch]@31
  int xFrom; // [sp+8Ch] [bp-58h]@31
  signed int dam; // [sp+90h] [bp-54h]@39
  int creaturesPerished; // [sp+94h] [bp-50h]@44
  int i; // [sp+98h] [bp-4Ch]@9
  int stackPriority; // [sp+9Ch] [bp-48h]@19
  int targetIdx; // [sp+A0h] [bp-44h]@9
  army *targStack; // [sp+A4h] [bp-40h]@14
  SAMPLE2 res; // [sp+A8h] [bp-3Ch]@31
  int attack; // [sp+B0h] [bp-34h]@31
  int yTarg; // [sp+B4h] [bp-30h]@31
  int xTarg; // [sp+B8h] [bp-2Ch]@31
  float a7[9]; // [sp+BCh] [bp-28h]@31
  int numberOfArchers; // [sp+E0h] [bp-4h]@31

  thisa = this;
  if ( this->isCastleBattle
    && (towerIdx || !this->ballistaDestroyed)
    && (towerIdx != 1 || this->turretStatus[0] == 1)
    && (towerIdx != 2 || this->turretStatus[3] == 1) )
  {
    LogStr("KA1");
    targetPriority = -1;
    targetStrength = 0;
    targetIdx = -1;
    for ( i = 0; i < 20; ++i )
    {
      if ( thisa->creatures[0][i].creatureIdx >= 0 && thisa->creatures[0][i].quantity > 0 )
      {
        targStack = (army *)((char *)thisa->creatures + 1154 * i);
        if ( thisa->creatures[0][i].effectStrengths[2]
          || targStack->effectStrengths[6]
          || targStack->effectStrengths[11]
          || targStack->effectStrengths[5]
          || targStack->effectStrengths[7] )
        {
          stackPriority = 0;
        }
        else if ( targStack->creature.creature_flags & SHOOTER )
        {
          stackPriority = 3;
        }
        else if ( targStack->creature.creature_flags & FLYER )
        {
          stackPriority = 2;
        }
        else
        {
          stackPriority = 1;
        }
        if ( targetPriority < stackPriority
          || targetPriority == stackPriority
          && targStack->quantity * gMonsterDatabase[targStack->creatureIdx].fight_value > targetStrength )
        {
          targetStrength = targStack->quantity * gMonsterDatabase[targStack->creatureIdx].fight_value;
          targetPriority = stackPriority;
          targetIdx = i;
        }
      }
    }
    if ( targetIdx != -1 )
    {
      targStack = (army *)((char *)gpCombatManager->creatures + 1154 * targetIdx);
      sprintf(gText, "keepshot.82M");
      res = (SAMPLE2)LoadPlaySample(gText);
      *(_QWORD *)&v6[0][0].x = 16890336860242506i64;
      v6[0][2] = (Point16)20578732;
      *(_QWORD *)&v6[1][0].x = 16890336860242506i64;
      v6[1][2] = (Point16)20578732;
      *(_QWORD *)&v6[2][0].x = 16890336860242506i64;
      v6[2][2] = (Point16)20578732;
      *(_QWORD *)&v6[3][0].x = 16890336860242506i64;
      v6[3][2] = (Point16)20578732;
      *(_QWORD *)&v6[4][0].x = 16890336860242506i64;
      v6[4][2] = (Point16)20578732;
      *(_QWORD *)&v6[5][0].x = 16890336860242506i64;
      v6[5][2] = (Point16)20578732;
      xFrom = *(_DWORD *)&v6[thisa->castles[1]->factionID][towerIdx] & 0xFFFF;
      yFrom = v6[thisa->castles[1]->factionID][towerIdx].y;
      xTarg = army::MidX(targStack);
      yTarg = army::MidY(targStack);
      LODWORD(a7[0]) = 0x42B40000u;
      LODWORD(a7[1]) = 0x42890000u;
      LODWORD(a7[2]) = 0x42340000u;
      LODWORD(a7[3]) = 0x41A66666u;
      LODWORD(a7[4]) = 0;
      LODWORD(a7[5]) = 0xC1A66666u;
      LODWORD(a7[6]) = 0xC2340000u;
      LODWORD(a7[7]) = 0xC2890000u;
      LODWORD(a7[8]) = 0xC2B40000u;
      combatManager::ShootMissile(xFrom, yFrom, xTarg, yTarg, a7, thisa->combatScreenIcons[7]);
      town::CalcNumLevelArchers(thisa->castles[1], &numberOfArchers, &attack);
      attack += 2;
      if ( thisa->heroes[1] )
      {
        heroAttack = hero::Stats(thisa->heroes[1], PRIMARY_SKILL_ATTACK);
        attack += heroAttack;
      }
      attack -= targStack->creature.defense;
      if ( attack > 20 )
        attack = 20;
      if ( attack < -20 )
        attack = -20;
      if ( towerIdx )
        numberOfArchers /= 2;
      dam = 0;
      for ( i = 0; numberOfArchers > i; ++i )
        dam += SRandom(2, 3);
      dam = (signed __int64)((double)dam * gfBattleStat[attack + 20]);
      if ( dam <= 0 )
        dam = 1;
      creaturesPerished = army::Damage(targStack, dam, SPELL_NONE);
      if ( creaturesPerished <= 0 )
      {
        sprintf(
          gText,
          "%s %d %s.",
          &aGarrisonDoes_0[("Tower does" - "Garrison does") & ((towerIdx == 0) - 1)],
          dam,
          "damage");
      }
      else
      {
        if ( creaturesPerished <= 1 )
          createName = gArmyNames[targStack->creatureIdx];
        else
          createName = gArmyNamesPlural[targStack->creatureIdx];
        sprintf(
          gText,
          "%s %d %s.\n%d %s %s.",
          &aGarrisonDoes[("Tower does" - "Garrison does") & ((towerIdx == 0) - 1)],
          dam,
          "damage",
          creaturesPerished,
          createName,
          &aPerish[("perishes" - "perish") & ((creaturesPerished > 1) - 1)]);
      }
      combatManager::CombatMessage(gpCombatManager, gText, 1, 1, 0);
      army::CancelSpellType(targStack, CREATURE_TOOK_DAMAGE_CODE);
      army::PowEffect(targStack, -1, 1, -1, -1);
      WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
      LogStr("KA2");
    }
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (00478F80) --------------------------------------------------------
int __thiscall combatManager::ExperienceValueOfStack(combatManager *this, int side)
{
  int v3; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v3 = 0;
  for ( i = 0; i < 20; ++i )
  {
    if ( this->creatures[side][i].creatureIdx != -1 )
    {
      if ( !(HIBYTE(this->creatures[side][i].creature.creature_flags) & 8) )
        v3 += gMonsterDatabase[this->creatures[side][i].creatureIdx].hp
            * (this->creatures[side][i].initialQuantity - this->creatures[side][i].quantity);
    }
  }
  if ( this->heroes[side] )
    v3 += 500;
  return v3;
}

//----- (00479100) --------------------------------------------------------
void __thiscall combatManager::ResetHitByCreature(combatManager *this)
{
  signed int j; // [sp+10h] [bp-8h]@3
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; j < 20; ++j )
      this->creatures[i][j].hitByHydraAttack = 0;
  }
}

//----- (00479190) --------------------------------------------------------
// 0<=num<117
bool __fastcall ValidHex(int a1)
{
  return a1 >= 0 && a1 < 117;
}

//----- (00479210) --------------------------------------------------------
void __thiscall combatManager::SetupAndLoadObstacles(combatManager *this)
{
  int v1; // ST1C_4@14
  combatManager *thisa; // [sp+Ch] [bp-58h]@1
  int v3; // [sp+14h] [bp-50h]@13
  signed int botSq; // [sp+18h] [bp-4Ch]@32
  char cobjAlreadyPlaced[32]; // [sp+1Ch] [bp-48h]@23
  int cantPlace; // [sp+3Ch] [bp-28h]@30
  int coverID; // [sp+40h] [bp-24h]@15
  int numCoveredHexes; // [sp+44h] [bp-20h]@13
  int i; // [sp+48h] [bp-1Ch]@2
  int row; // [sp+4Ch] [bp-18h]@29
  int hex; // [sp+50h] [bp-14h]@26
  int covObjsToPlace; // [sp+54h] [bp-10h]@13
  int v13; // [sp+58h] [bp-Ch]@13
  int terrainMask; // [sp+5Ch] [bp-8h]@13
  int cobjID; // [sp+60h] [bp-4h]@26

  thisa = this;
  this->combatFieldCoverID = 0;
  if ( this->isCastleBattle )
  {
    this->ballistaDestroyed = 0;
    for ( i = 0; i < 4; ++i )
    {
      this->wallStatus[i] = 0;
      if ( !this->castles[1]->factionID )
      {
        if ( BYTE1(this->castles[1]->buildingsBuiltFlags) & BUILDING_SPECIAL_DEFENSE_BUILT )
          this->wallStatus[i] = 3;
      }
      this->turretStatus[i] = 0;
    }
    if ( BYTE1(this->castles[1]->buildingsBuiltFlags) & BUILDING_RIGHT_TURRET_BUILT )
      this->turretStatus[0] = 1;
    if ( BYTE1(this->castles[1]->buildingsBuiltFlags) & BUILDING_LEFT_TURRET_BUILT )
      this->turretStatus[3] = 1;
    this->combatGrid[9].isBlocked = 1;
    this->combatGrid[22].isBlocked = 1;
    this->combatGrid[34].isBlocked = 1;
    this->combatGrid[47].isBlocked = 1;
    this->combatGrid[59].isBlocked = 1;
    this->combatGrid[73].isBlocked = 1;
    this->combatGrid[86].isBlocked = 1;
    this->combatGrid[100].isBlocked = 1;
    this->combatGrid[113].isBlocked = 1;
    this->combatGrid[92].isBlocked = 1;
  }
  else
  {
    covObjsToPlace = SRandom(3, 7);
    v3 = 0;
    terrainMask = 1 << LOBYTE(thisa->terrainType);
    v13 = 0;
    numCoveredHexes = 0;
    if ( SRandom(0, 99) < 40 )
    {
      while ( 1 )
      {
        v1 = v13++;
        if ( v1 >= 100 )
          break;
        coverID = SRandom(0, 24);
        if ( sElevationOverlay[coverID].terrains & (unsigned __int16)terrainMask )
        {
          thisa->combatFieldCoverID = coverID;
          for ( i = 0; i < 15; ++i )
          {
            if ( sElevationOverlay[thisa->combatFieldCoverID].coveredHexes[i] != -1 )
            {
              thisa->combatGrid[sElevationOverlay[thisa->combatFieldCoverID].coveredHexes[i]].isBlocked = 1;
              ++numCoveredHexes;
            }
          }
          break;
        }
      }
    }
    covObjsToPlace -= numCoveredHexes / 2;
    v13 = 0;
    memset(cobjAlreadyPlaced, 0, 0x20u);
    while ( covObjsToPlace > v3 && v13 < 500 )
    {
      ++v13;
      hex = SRandom(0, 116);
      cobjID = SRandom(0, 32);                  // Confused. I believe range is inclusive, but this can here give OOB cobj
      if ( sCmbtObstacles[cobjID].terrains & terrainMask )
      {
        if ( !cobjAlreadyPlaced[cobjID] )
        {
          row = hex / 13;
          if ( (unsigned __int8)byte_4F3904[14 * cobjID] <= hex / 13 + 1 )
          {
            cantPlace = 0;
            for ( i = 0; (unsigned __int8)byte_4F3905[14 * cobjID] > i; ++i )
            {
              botSq = hex + *(&byte_4F3906[14 * cobjID] + i);
              if ( botSq % 13 <= 2 || botSq % 13 >= 10 )
                cantPlace = 1;
              if ( thisa->combatGrid[botSq].isBlocked )
                cantPlace = 1;
            }
            if ( !cantPlace )
            {
              v13 = 0;
              v3 += (unsigned __int8)byte_4F3905[14 * cobjID];
              cobjAlreadyPlaced[cobjID] = 1;
              for ( i = 0; (unsigned __int8)byte_4F3905[14 * cobjID] > i; ++i )
                thisa->combatGrid[hex + *(&byte_4F3906[14 * cobjID] + i)].isBlocked = 1;
              sprintf(gText, "cobj%04d.icn", cobjID);
              thisa->combatObjIcons[thisa->numCombatObjs] = resourceManager::GetIcon(gpResourceManager, gText);
              thisa->combatGrid[hex].combatObjIdx = LOBYTE(thisa->numCombatObjs);
              ++thisa->numCombatObjs;
            }
          }
        }
      }
    }
  }
}
// 479210: using guessed type char cobjAlreadyPlaced[32];

//----- (004796F0) --------------------------------------------------------
void __thiscall combatManager::MakeCreaturesVanish(combatManager *this)
{
  army *v1; // ST3C_4@15
  signed int i; // [sp+10h] [bp-1Ch]@1
  signed int k; // [sp+10h] [bp-1Ch]@9
  int height; // [sp+14h] [bp-18h]@9
  int y; // [sp+18h] [bp-14h]@9
  int x; // [sp+1Ch] [bp-10h]@9
  int j; // [sp+24h] [bp-8h]@3
  int l; // [sp+24h] [bp-8h]@11
  int width; // [sp+28h] [bp-4h]@9

  combatManager::ResetLimitCreature(this);
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
    {
      if ( this->shouldVanish[i][j] )
        this->limitCreature[i][j] = 1;
    }
  }
  combatManager::DrawFrame(this, 0, 1, 0, 1, 75, 1, 1);
  x = giMinExtentX;
  y = giMinExtentY;
  width = giMaxExtentX - giMinExtentX + 1;
  height = giMaxExtentY - giMinExtentY + 1;
  for ( k = 0; k < 2; ++k )
  {
    for ( l = 0; gpCombatManager->numCreatures[k] > l; ++l )
    {
      if ( this->shouldVanish[k][l] )
      {
        this->combatGrid[this->creatures[k][l].occupiedHex].unitOwner = -1;
        this->combatGrid[this->creatures[k][l].occupiedHex].stackIdx = -1;
        if ( this->creatures[k][l].creature.creature_flags & TWO_HEXER )
        {
          this->combatGrid[this->creatures[k][l].occupiedHex
                         + ((unsigned int)(this->creatures[k][l].facingRight - 1) < 1 ? 1 : -1)].unitOwner = -1;
          v1 = &this->creatures[k][l];
          this->combatGrid[v1->occupiedHex + ((unsigned int)(v1->facingRight - 1) < 1 ? 1 : -1)].stackIdx = -1;
        }
      }
    }
  }
  heroWindowManager::SaveFizzleSource(gpWindowManager, x, y, width, height);
  combatManager::DrawFrame(gpCombatManager, 0, 0, 1, 0, 75, 1, 1);
  heroWindowManager::FizzleForward(
    gpWindowManager,
    x,
    y,
    width,
    height,
    (signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 150.0),
    0,
    0);
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004799A0) --------------------------------------------------------
void __thiscall combatManager::LowerDoor(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-18h]@1
  int i; // [sp+18h] [bp-Ch]@1
  __int64 res; // [sp+1Ch] [bp-8h]@1

  thisa = this;
  res = LoadPlaySample("drawbrg.82m");
  giMinExtentX = 304;
  giMinExtentY = 218;
  giMaxExtentX = 384;
  giMaxExtentY = 294;
  for ( i = 2; i >= 0; --i )
  {
    thisa->drawBridgePosition = i;
    combatManager::DrawFrame(thisa, 1, 0, 1, 0, 75, 1, 1);
  }
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00479A60) --------------------------------------------------------
void __thiscall combatManager::RaiseDoor(combatManager *this)
{
  combatManager *thisa; // ST28_4@1
  __int64 v2; // ST34_8@1

  thisa = this;
  v2 = LoadPlaySample("drawbrg.82m");
  giMinExtentX = 304;
  giMinExtentY = 218;
  giMaxExtentX = 384;
  giMaxExtentY = 294;
  thisa->drawBridgePosition = 1;
  combatManager::DrawFrame(thisa, 1, 0, 1, 0, 75, 1, 1);
  thisa->drawBridgePosition = 2;
  combatManager::DrawFrame(thisa, 1, 0, 1, 0, 75, 1, 1);
  thisa->drawBridgePosition = 4;
  combatManager::DrawFrame(thisa, 1, 0, 1, 0, 75, 1, 1);
  WaitEndSample((void *)0xFFFFFFFF, (resource *)v2, HIDWORD(v2));
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00479B50) --------------------------------------------------------
void __fastcall combatManager::TestRaiseDoor(combatManager *a1)
{
  if ( a1->isCastleBattle
    && !a1->drawBridgePosition
    && a1->combatGrid[58].unitOwner == -1
    && !a1->combatGrid[58].numCorpses
    && a1->combatGrid[59].unitOwner == -1 )
  {
    if ( !a1->combatGrid[59].numCorpses )
      combatManager::RaiseDoor(a1);
  }
}

//----- (00479BE0) --------------------------------------------------------
bool __stdcall combatManager::InCastle(signed int hex)
{
  return (hex < 0 || hex > 8)
      && (hex < 13 || hex > 21)
      && (hex < 26 || hex > 33)
      && (hex < 39 || hex > 46)
      && (hex < 52 || hex > 58)
      && (hex < 65 || hex > 72)
      && (hex < 78 || hex > 85)
      && (hex < 91 || hex > 99)
      && (hex < 104 || hex > 112);
}

//----- (00479CC0) --------------------------------------------------------
signed int __thiscall combatManager::ShotIsThroughWall(combatManager *this, int side, signed int occupiedHex, signed int targHex)
{
  signed int result; // eax@2
  int colDist; // ebx@10
  double v6; // st7@15
  combatManager *thisa; // [sp+2Ch] [bp-3Ch]@1
  int rowDiff; // [sp+38h] [bp-30h]@10
  int colDiff; // [sp+3Ch] [bp-2Ch]@10
  int v10; // [sp+40h] [bp-28h]@15
  float v11; // [sp+44h] [bp-24h]@13
  float v12; // [sp+48h] [bp-20h]@13
  signed int j; // [sp+4Ch] [bp-1Ch]@15
  int i; // [sp+50h] [bp-18h]@13
  int v15; // [sp+54h] [bp-14h]@11
  float v16; // [sp+5Ch] [bp-Ch]@11
  float v17; // [sp+5Ch] [bp-Ch]@13
  float v18; // [sp+64h] [bp-4h]@11
  float v19; // [sp+64h] [bp-4h]@13

  thisa = this;
  if ( this->isCastleBattle )
  {
    if ( this->heroes[side]
      && (hero::HasArtifact(this->heroes[side], 63) || thisa->heroes[side]->secondarySkillLevel[1]) )
    {
      result = 0;
    }
    else if ( !combatManager::InCastle(occupiedHex) && combatManager::InCastle(targHex) )
    {
      colDiff = targHex % 13 - occupiedHex % 13;
      rowDiff = targHex / 13 - occupiedHex / 13;
      colDist = abs(targHex % 13 - occupiedHex % 13);
      if ( colDist <= abs(rowDiff) )
      {
        v15 = abs(rowDiff);
        v16 = (double)(rowDiff <= 0 ? -1 : 1);
        v18 = (double)colDiff / (double)abs(rowDiff);
      }
      else
      {
        v15 = abs(colDiff);
        v18 = (double)(colDiff <= 0 ? -1 : 1);
        v16 = (double)rowDiff / (double)abs(colDiff);
      }
      v19 = v18 / 10.0;
      v17 = v16 / 10.0;
      v12 = (double)(occupiedHex % 13);
      v11 = (double)(occupiedHex / 13);
      for ( i = 0; 10 * v15 > i; ++i )
      {
        v12 = v12 + v19;
        v6 = v11 + v17;
        v11 = v6;
        v10 = (signed __int64)v12 + 13 * (unsigned __int64)(signed __int64)v6;
        for ( j = 0; j < 4; ++j )
        {
          if ( (unsigned __int8)byte_4F5234[j] == v10 && thisa->wallStatus[j] != 2 && thisa->wallStatus[j] != 6 )
            return 1;
          if ( (unsigned __int8)byte_4F5238[j] == v10 && thisa->turretStatus[j] != 2 )
            return 1;
          if ( v10 == 59 && thisa->drawBridgePosition == 4 )
            return 1;
        }
      }
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00479FC0) --------------------------------------------------------
void __stdcall combatManager::ShootMissile(int xFrom, int yFrom, int xTarg, int yTarg, float *anglesOfImgIdxs, icon *icn)
{
  float v6; // ST40_4@8
  bitmap *this; // [sp+30h] [bp-64h]@18
  float angleDeg; // [sp+34h] [bp-60h]@8
  int deltaY; // [sp+3Ch] [bp-58h]@3
  int v10; // [sp+40h] [bp-54h]@21
  int deltaX; // [sp+44h] [bp-50h]@1
  int v12; // [sp+4Ch] [bp-48h]@21
  int offsetY; // [sp+50h] [bp-44h]@21
  signed int i; // [sp+54h] [bp-40h]@8
  int j; // [sp+54h] [bp-40h]@21
  bitmap *oldRect; // [sp+58h] [bp-3Ch]@19
  int offsetX; // [sp+5Ch] [bp-38h]@21
  int stepY; // [sp+68h] [bp-2Ch]@16
  int y; // [sp+6Ch] [bp-28h]@18
  signed int v20; // [sp+70h] [bp-24h]@1
  int stepX; // [sp+74h] [bp-20h]@16
  int x; // [sp+78h] [bp-1Ch]@18
  signed int v23; // [sp+7Ch] [bp-18h]@1
  char mirror; // [sp+80h] [bp-14h]@1
  int probablyNumFrames; // [sp+84h] [bp-10h]@15
  int oldY; // [sp+88h] [bp-Ch]@21
  int spriteIdx; // [sp+8Ch] [bp-8h]@5
  int oldX; // [sp+90h] [bp-4h]@21

  v20 = xTarg - xFrom;
  v23 = yTarg - yFrom;
  deltaX = xTarg - xFrom;
  mirror = 0;
  if ( xTarg - xFrom < 0 )
  {
    mirror = 1;
    deltaX = -deltaX;
  }
  deltaY = yTarg - yFrom;
  if ( deltaX )
  {
    v6 = (double)-deltaY / (double)deltaX;
    angleDeg = atan(v6) * 180.0 / 3.14159;
    for ( i = 1; i < 9 && (anglesOfImgIdxs[i - 1] + anglesOfImgIdxs[i]) / 2.0 >= angleDeg; ++i )
      ;
    if ( i >= 9 )
      spriteIdx = 8;
    else
      spriteIdx = i - 1;
  }
  else if ( deltaY <= 0 )
  {
    spriteIdx = 0;
  }
  else
  {
    spriteIdx = 8;
  }
  probablyNumFrames = (signed int)((unsigned __int64)(signed __int64)sqrt((double)(v23 * v23 + v20 * v20)) + 15) / 31;
  if ( probablyNumFrames <= 1 )
  {
    stepX = xTarg - xFrom;
    stepY = yTarg - yFrom;
  }
  else
  {
    stepX = v20 / (probablyNumFrames - 1);
    stepY = v23 / (probablyNumFrames - 1);
  }
  x = xFrom;
  y = yFrom;
  this = (bitmap *)operator new(26);
  if ( this )
    oldRect = bitmap::bitmap(this, 33, 50, 50);
  else
    oldRect = 0;
  bitmap::GrabBitmapCareful(oldRect, gpWindowManager->screenBuffer, xFrom - 25, yFrom - 25);
  oldX = xFrom;
  oldY = yFrom;
  offsetX = 639;
  v12 = 0;
  offsetY = 480;
  v10 = 0;
  for ( j = 0; probablyNumFrames > j; ++j )
  {
    if ( oldX - 25 < offsetX )
      offsetX = oldX - 25;
    if ( offsetX < 0 )
      offsetX = 0;
    if ( oldX + 25 > v12 )
      v12 = oldX + 25;
    if ( v12 > 639 )
      v12 = 639;
    if ( oldY - 25 < offsetY )
      offsetY = oldY - 25;
    if ( offsetY < 0 )
      offsetY = 0;
    if ( oldY + 25 > v10 )
      v10 = oldY + 25;
    if ( v10 > 442 )
      v10 = 442;
    if ( j )
    {
      bitmap::DrawToBufferCareful(oldRect, oldX - 25, oldY - 25);
      bitmap::GrabBitmapCareful(oldRect, gpWindowManager->screenBuffer, x - 25, y - 25);
    }
    else
    {
      if ( offsetX < giMinExtentX )
        giMinExtentX = offsetX;
      if ( v12 > giMaxExtentX )
        giMaxExtentX = v12;
      if ( offsetY < giMinExtentY )
        giMinExtentY = offsetY;
      if ( giMaxExtentY < v10 )
        giMaxExtentY = v10;
    }
    icon::DrawToBuffer(icn, x, y, spriteIdx, mirror);
    if ( j )
    {
      DelayTil(&glTimers);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, offsetX, offsetY, v12 - offsetX + 1, v10 - offsetY + 1);
    }
    else
    {
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
    }
    glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 25.0);
    oldX = x;
    oldY = y;
    x += stepX;
    y += stepY;
    offsetX = x - 25;
    v12 = x + 25;
    offsetY = y - 25;
    v10 = y + 25;
  }
  bitmap::DrawToBuffer(oldRect, oldX - 25, oldY - 25);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, oldX - 25, oldY - 25, 0x32u, 50);
  if ( oldRect )
    oldRect->vtable->scalarDeletingDestructor((resource *)oldRect, 1);
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (0047A4B0) --------------------------------------------------------
void __thiscall combatManager::CombatSystemOptions(void *this)
{
  void *v1; // [sp+Ch] [bp-2Ch]@1
  heroWindow *thisa; // [sp+18h] [bp-20h]@1

  v1 = this;
  bCPrefsChanged = 0;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    CSPanel = heroWindow::heroWindow(thisa, 160, 33, "cspanel.bin");
  else
    CSPanel = 0;
  if ( !CSPanel )
    MemError();
  SetWinText(CSPanel, 1);
  UpdateCombatSystemOptions((void *)1);
  heroWindowManager::DoDialog(
    gpWindowManager,
    CSPanel,
    (int (__fastcall *)(tag_message *))CombatSystemOptionsHandler,
    0);
  operator delete(CSPanel);
  if ( bCPrefsChanged )
    WritePrefs();
  *(_DWORD *)((char *)v1 + 12919) = 0;
  combatManager::DrawFrame((combatManager *)v1, 1, 0, 0, 0, 75, 1, 1);
}
// 52FAF0: using guessed type int bCPrefsChanged;

//----- (0047A5B0) --------------------------------------------------------
void __thiscall UpdateCombatSystemOptions(void *this)
{
  void *v1; // ST18_4@1
  int evt; // [sp+10h] [bp-1Ch]@1
  int v3; // [sp+14h] [bp-18h]@1
  int v4; // [sp+18h] [bp-14h]@1
  int v5; // [sp+28h] [bp-4h]@1

  v1 = this;
  evt = 512;
  v3 = 4;
  v4 = 10;
  v5 = giCombatSpeed;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 11;
  v5 = *(_DWORD *)&combatArmyInfoLevel + 3;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 12;
  v5 = *(_DWORD *)&autoCombatUseSpells + 6;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 13;
  v5 = *(_DWORD *)&showCombatGrid + 8;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 14;
  v5 = combatShadeLevel + 10;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 15;
  v5 = *(_DWORD *)&showCombatMouseHex + 12;
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v3 = 3;
  v4 = 20;
  v5 = (int)combatSpeedText[giCombatSpeed];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 21;
  v5 = (int)combatMiniInfoText[*(_DWORD *)&combatArmyInfoLevel];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 22;
  v5 = (int)onOffText[*(_DWORD *)&autoCombatUseSpells];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 23;
  v5 = (int)onOffText[*(_DWORD *)&showCombatGrid];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 24;
  v5 = (int)onOffText[combatShadeLevel];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  v4 = 25;
  v5 = (int)onOffText[*(_DWORD *)&showCombatMouseHex];
  heroWindow::BroadcastMessage(CSPanel, (tag_message *)&evt);
  if ( !v1 )
    heroWindow::DrawWindow(CSPanel, 1, 0, 32767);
}
// 4F62B0: using guessed type char *onOffText[11];
// 4F6F38: using guessed type char *combatSpeedText[3];
// 4F6F48: using guessed type char *combatMiniInfoText[3];

//----- (0047A7A0) --------------------------------------------------------
signed int __thiscall CombatSystemOptionsHandler(void *this)
{
  signed int result; // eax@38
  int v2; // [sp+14h] [bp-90h]@19
  signed int v3; // [sp+18h] [bp-8Ch]@5
  void *v4; // [sp+1Ch] [bp-88h]@1
  signed int v5; // [sp+20h] [bp-84h]@5
  signed int v6; // [sp+9Ch] [bp-8h]@1
  signed int v7; // [sp+A0h] [bp-4h]@1

  v4 = this;
  v6 = 0;
  v7 = 0;
  if ( *(_DWORD *)this == 512 )
  {
    if ( *((_BYTE *)this + 13) & 2 )
    {
      if ( *((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14 )
      {
        v5 = -1;
        v3 = *((_DWORD *)this + 2);
        if ( v3 <= 30720 )
        {
          if ( v3 == 30720 )
          {
            v5 = 0;
          }
          else
          {
            switch ( v3 )
            {
              case 10:
                v5 = 1;
                break;
              case 11:
                v5 = 2;
                break;
              case 12:
                v5 = 3;
                break;
              case 13:
                v5 = 4;
                break;
              case 14:
                v5 = 5;
                break;
              case 15:
                v5 = 6;
                break;
              default:
                break;
            }
          }
        }
        if ( v5 >= 0 )
          NormalDialog(gEventText[v5 + 102], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      }
    }
    else
    {
      v2 = *((_DWORD *)this + 1);
      if ( v2 == 12 )
      {
        switch ( *((_DWORD *)this + 2) )
        {
          case 0xA:
            giCombatSpeed = (giCombatSpeed + 1) % 3;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          case 0xB:
            *(_DWORD *)&combatArmyInfoLevel = (*(_DWORD *)&combatArmyInfoLevel + 1) % 3;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          case 0xC:
            *(_DWORD *)&autoCombatUseSpells = 1 - *(_DWORD *)&autoCombatUseSpells;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          case 0xD:
            *(_DWORD *)&showCombatGrid = 1 - *(_DWORD *)&showCombatGrid;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          case 0xE:
            combatShadeLevel = 1 - combatShadeLevel;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          case 0xF:
            *(_DWORD *)&showCombatMouseHex = 1 - *(_DWORD *)&showCombatMouseHex;
            v6 = 1;
            bCPrefsChanged = 1;
            break;
          default:
            break;
        }
      }
      else if ( v2 == 13 && *((_DWORD *)this + 2) == 30720 )
      {
        v7 = 1;
      }
    }
  }
  if ( v6 )
    UpdateCombatSystemOptions(0);
  if ( v7 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 52FAF0: using guessed type int bCPrefsChanged;

//----- (0047AB40) --------------------------------------------------------
int __thiscall army::army(army *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  this->creatureIcon = 0;
  this->occupiedHex = 0;
  for ( i = 0; i < 7; ++i )
    this->combatSounds[i] = 0;
  this->field_11D = 1;
  this->targetOwner = -1;
  this->targetStackIdx = -1;
  this->targetNeighborIdx = -1;
  this->field_5E = 0;
  this->targetHex = 0;
  this->field_125 = 0;
  LODWORD(this->field_4E) = 1;
  this->yDrawOffset = 0;
  this->xDrawOffset = 0;
  return (int)this;
}

//----- (0047AC10) --------------------------------------------------------
void __stdcall army::WaitSample(int a1)
{
  ;
}

//----- (0047AC30) --------------------------------------------------------
void __thiscall army::InitClean(army *this)
{
  army *thisa; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  thisa = this;
  for ( i = 0; i < 7; ++i )
    this->combatSounds[i] = 0;
  this->lifespan = -1;
  this->numActiveEffects = 0;
  memset(this->effectStrengths, 0, 0xFu);
  thisa->baseFidgetTime = KBTickCount();
  thisa->field_11D = 1;
  thisa->creatureIcon = 0;
  thisa->probablyIsNeedDrawSpellEffect = 0;
  thisa->spellEnemyCreatureAbilityIsCasting = -1;
  thisa->mirroredIdx = -1;
  thisa->mirrorIdx = -1;
  thisa->armyIdx = -1;
  thisa->previousQuantity = -1;
}

//----- (0047AD10) --------------------------------------------------------
void __thiscall army::Init(army *this, int creatureIdx, int quantity, int owner, int stackIdx, int startHex, int armyIdx)
{
  int othOccHex; // [sp+10h] [bp-8h]@10
  hero *hro; // [sp+14h] [bp-4h]@1

  army::InitClean(this);
  this->creatureIdx = creatureIdx;
  this->field_6 = 1;
  memcpy(&this->creature, &gMonsterDatabase[creatureIdx], sizeof(this->creature));
  this->field_D4 = 6;
  hro = gpCombatManager->heroes[owner];
  if ( hro )
  {
    this->creature.attack += hero::Stats(hro, 0);
    this->creature.defense += hero::Stats(hro, PRIMARY_SKILL_DEFENSE);
  }
  this->facingRight = owner ^ 1;
  this->animationType = 7;
  this->animationFrame = 0;
  this->luckStatus = 0;
  this->targetOwner = -1;
  this->targetStackIdx = -1;
  this->targetNeighborIdx = -1;
  this->speed = this->creature.speed;
  this->quantity = quantity;
  this->initialQuantity = this->quantity;
  this->temporaryQty = 0;
  this->mightBeIsAttacking = 0;
  this->damage = 0;
  this->otherBadLuckThing = 0;
  this->hasTakenLosses = 0;
  this->dead = this->hasTakenLosses;
  this->damageTakenDuringSomeTimePeriod = this->dead;
  this->owningSide = owner;
  this->stackIdx = stackIdx;
  this->morale = armyGroup::GetMorale(
                   gpCombatManager->armies[this->owningSide],
                   gpCombatManager->heroes[this->owningSide],
                   gpCombatManager->castles[this->owningSide],
                   gpCombatManager->armies[1 - this->owningSide]->creatureTypes);
  if ( this->creatureIdx == CREATURE_EARTH_ELEMENTAL
    || this->creatureIdx == CREATURE_AIR_ELEMENTAL
    || this->creatureIdx == CREATURE_FIRE_ELEMENTAL
    || this->creatureIdx == CREATURE_WATER_ELEMENTAL
    || HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD )
    this->morale = 0;
  this->luck = game::GetLuck(
                 gpCombatManager->heroes[this->owningSide],
                 this,
                 gpCombatManager->castles[this->owningSide]);
  this->occupiedHex = startHex;
  gpCombatManager->combatGrid[this->occupiedHex].unitOwner = LOBYTE(this->owningSide);
  gpCombatManager->combatGrid[this->occupiedHex].stackIdx = LOBYTE(this->stackIdx);
  if ( this->creature.creature_flags & TWO_HEXER )
  {
    othOccHex = this->occupiedHex + (this->owningSide < 1u ? 1 : -1);
    gpCombatManager->combatGrid[othOccHex].unitOwner = LOBYTE(this->owningSide);
    gpCombatManager->combatGrid[othOccHex].stackIdx = LOBYTE(this->stackIdx);
    gpCombatManager->combatGrid[othOccHex].occupiersOtherHexIsToLeft = this->occupiedHex <= othOccHex;
    gpCombatManager->combatGrid[this->occupiedHex].occupiersOtherHexIsToLeft = this->occupiedHex > othOccHex;
  }
  this->armyIdx = armyIdx;
}

//----- (0047B160) --------------------------------------------------------
void __thiscall army::LoadResources(army *this)
{
  int formFileID; // eax@2
  army *thisa; // [sp+Ch] [bp-28h]@1
  signed int i; // [sp+30h] [bp-4h]@34

  thisa = this;
  if ( !gbNoShowCombat )
  {
    formFileID = resourceManager::MakeId(gpResourceManager, cArmyFrameFileNames[this->creatureIdx], 1);
    resourceManager::PointToFile(gpResourceManager, formFileID);
    resourceManager::ReadBlock(gpResourceManager, &thisa->frameInfo, 821u);
    ModifyFrameInfo(&thisa->frameInfo, (CREATURES)thisa->creatureIdx);
    thisa->field_B2 = thisa->frameInfo.stepTime;
    sprintf(gText, "%smove.82M", thisa->creature.short_name);
    thisa->combatSounds[0] = resourceManager::GetSample(gpResourceManager, gText);
    sprintf(gText, "%sattk.82M", thisa->creature.short_name);
    thisa->combatSounds[1] = resourceManager::GetSample(gpResourceManager, gText);
    sprintf(gText, "%swnce.82M", thisa->creature.short_name);
    thisa->combatSounds[2] = resourceManager::GetSample(gpResourceManager, gText);
    sprintf(gText, "%skill.82M", thisa->creature.short_name);
    thisa->combatSounds[4] = resourceManager::GetSample(gpResourceManager, gText);
    if ( thisa->creature.creature_flags & SHOOTER )
    {
      sprintf(gText, "%sshot.82M", thisa->creature.short_name);
      thisa->combatSounds[3] = resourceManager::GetSample(gpResourceManager, gText);
    }
    if ( thisa->creatureIdx == CREATURE_VAMPIRE || thisa->creatureIdx == CREATURE_VAMPIRE_LORD )
    {
      sprintf(gText, "%sext1.82M", thisa->creature.short_name);
      thisa->combatSounds[5] = resourceManager::GetSample(gpResourceManager, gText);
      sprintf(gText, "%sext2.82M", thisa->creature.short_name);
      thisa->combatSounds[6] = resourceManager::GetSample(gpResourceManager, gText);
    }
    if ( thisa->creatureIdx == CREATURE_LICH || thisa->creatureIdx == CREATURE_POWER_LICH )
    {
      sprintf(gText, "%sexpl.82M", thisa->creature.short_name);
      thisa->combatSounds[5] = resourceManager::GetSample(gpResourceManager, gText);
    }
    thisa->creatureIcon = resourceManager::GetIcon(gpResourceManager, cMonFilename[thisa->creatureIdx]);
    if ( thisa->creature.creature_flags & SHOOTER )
    {
      if ( thisa->creatureIdx != CREATURE_GIANT && thisa->creatureIdx != CREATURE_TITAN )
      {
        if ( thisa->creatureIdx == CREATURE_HALFLING )
        {
          sprintf(gText, "halflmsl.icn");
        }
        else if ( thisa->creatureIdx != CREATURE_ARCHER && thisa->creatureIdx != CREATURE_RANGER )
        {
          if ( thisa->creatureIdx != CREATURE_LICH && thisa->creatureIdx != CREATURE_POWER_LICH )
          {
            if ( thisa->creatureIdx != CREATURE_ORC && thisa->creatureIdx != CREATURE_ORC_CHIEF )
            {
              if ( thisa->creatureIdx != CREATURE_DRUID && thisa->creatureIdx != CREATURE_GREATER_DRUID )
              {
                if ( thisa->creatureIdx != CREATURE_TROLL && thisa->creatureIdx != CREATURE_WAR_TROLL )
                  sprintf(gText, "elf__msl.icn");
                else
                  sprintf(gText, "trollmsl.icn");
              }
              else
              {
                sprintf(gText, "druidmsl.icn");
              }
            }
            else
            {
              sprintf(gText, "orc__msl.icn");
            }
          }
          else
          {
            sprintf(gText, "lich_msl.icn");
          }
        }
        else
        {
          sprintf(gText, "arch_msl.icn");
        }
      }
      else
      {
        sprintf(gText, "titanmsl.icn");
      }
      thisa->missileIcon = resourceManager::GetIcon(gpResourceManager, gText);
    }
    else
    {
      thisa->combatSounds[3] = 0;
      thisa->missileIcon = 0;
    }
    for ( i = 0; i < 5; ++i )
    {
      if ( thisa->combatSounds[i] )
      {
        thisa->combatSounds[i]->field_28 = 64;
        thisa->combatSounds[i]->codeThing = 3;
        thisa->combatSounds[i]->loopCount = 1;
      }
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (0047B610) --------------------------------------------------------
army *__thiscall army::FreeResources(army *this)
{
  army *result; // eax@4
  army *v2; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@6

  v2 = this;
  if ( !gbNoShowCombat )
  {
    if ( this->missileIcon )
    {
      resourceManager::Dispose(gpResourceManager, (resource *)this->missileIcon);
      v2->missileIcon = 0;
    }
    result = v2;
    if ( v2->creatureIcon )
    {
      resourceManager::Dispose(gpResourceManager, (resource *)v2->creatureIcon);
      result = v2;
      v2->creatureIcon = 0;
    }
    for ( i = 0; i < 7; ++i )
    {
      result = (army *)i;
      if ( v2->combatSounds[i] )
      {
        resourceManager::Dispose(gpResourceManager, (resource *)v2->combatSounds[i]);
        result = (army *)i;
        v2->combatSounds[i] = 0;
      }
    }
  }
  return result;
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (0047B700) --------------------------------------------------------
void __thiscall army::DrawToBuffer(army *this, int centX, int standingBotY, int a4)
{
  unsigned int quant; // [sp+14h] [bp-5Ch]@83
  char str; // [sp+18h] [bp-58h]@85
  int v7; // [sp+24h] [bp-4Ch]@75
  int numPosEffects; // [sp+28h] [bp-48h]@61
  bool hexInFrontClear; // [sp+2Ch] [bp-44h]@52
  int inRedrawZone; // [sp+30h] [bp-40h]@72
  int hexInFront; // [sp+34h] [bp-3Ch]@46
  int v12; // [sp+38h] [bp-38h]@52
  int numNegEffects; // [sp+3Ch] [bp-34h]@61
  int a11; // [sp+40h] [bp-30h]@3
  int offsetY; // [sp+44h] [bp-2Ch]@59
  int i; // [sp+48h] [bp-28h]@61
  int v17; // [sp+4Ch] [bp-24h]@88
  int xa; // [sp+50h] [bp-20h]@46
  int offsetX; // [sp+54h] [bp-1Ch]@88
  char *paletteSubstitution; // [sp+58h] [bp-18h]@29
  bool v21; // [sp+5Ch] [bp-14h]@6
  int v22; // [sp+60h] [bp-10h]@10
  int v23; // [sp+64h] [bp-Ch]@10
  int v24; // [sp+68h] [bp-8h]@3
  int walkLen; // [sp+6Ch] [bp-4h]@10
  int x; // [sp+78h] [bp+8h]@8
  int y; // [sp+7Ch] [bp+Ch]@8

  if ( !gpCombatManager->field_F357 && !gbNoShowCombat )
  {
    v24 = 0;
    a11 = 0;
    v21 = this->animationType == 7 || this->animationType >= 8 && this->animationType <= 12;
    y = this->yDrawOffset + standingBotY;
    x = this->xDrawOffset + centX;
    if ( this->animationType == ANIMATION_TYPE_WALKING && !(this->creature.creature_flags & FLYER) )
    {
      walkLen = this->frameInfo.animationLengths[this->animationType];
      v22 = 42 * this->animationFrame / walkLen;
      v23 = 22 * this->animationFrame / walkLen;
      if ( !this->field_8A || this->field_8A == 5 )
      {
        y -= v22;
        giWalkingYMod = -v22;
      }
      if ( this->field_8A == 2 || this->field_8A == 3 )
      {
        y += v22;
        giWalkingYMod = v22;
      }
      if ( !this->field_8A || this->field_8A == 2 )
        x -= v23;
      if ( this->field_8A == 5 || this->field_8A == 3 )
        x += v23;
    }
    if ( !giSpellEffectShowType && v21 && this->numActiveEffects > 0 )
      a11 = 237;
    if ( this->occupiedHex == gpCombatManager->field_F2BB && gpCombatManager->field_F2B7 == 1 )
      a11 = 236;
    paletteSubstitution = 0;
    if ( this->effectStrengths[11] )
    {
      paletteSubstitution = gColorTableGray;
    }
    else if ( HIBYTE(this->creature.creature_flags) & ATTR_BLOODLUST_RED )
    {
      paletteSubstitution = gColorTableRed;
    }
    else if ( HIBYTE(this->creature.creature_flags) & ATTR_BROWN )
    {
      paletteSubstitution = gColorTableDarkBrown;
    }
    else if ( HIBYTE(this->creature.creature_flags) & ATTR_PETRIFY_GRAY )
    {
      paletteSubstitution = gColorTableGray;
    }
    else if ( HIBYTE(this->creature.creature_flags) & ATTR_MIRROR_IMAGE )
    {
      paletteSubstitution = gColorTableLighten;
    }
    if ( !a4 )
      icon::CombatClipDrawToBuffer(
        this->creatureIcon,
        x,
        y,
        this->frameInfo.animationFrameToImgIdx[this->animationType][this->animationFrame],
        &this->bounds,
        this->facingRight < 1u,
        a11,
        paletteSubstitution,
        (int)this->field_125);
    if ( v21 && gpCombatManager->field_F2BF && LODWORD(this->field_4E) )
    {
      if ( this->creature.creature_flags & TWO_HEXER )
      {
        if ( this->facingRight == 1 )
        {
          xa = x + 53;
          hexInFront = this->occupiedHex + 2;
        }
        else
        {
          xa = x - 73;
          hexInFront = this->occupiedHex - 2;
        }
      }
      else if ( this->facingRight == 1 )
      {
        xa = x + 9;
        hexInFront = this->occupiedHex + 1;
      }
      else
      {
        xa = x - 29;
        hexInFront = this->occupiedHex - 1;
      }
      hexInFrontClear = gpCombatManager->combatGrid[hexInFront].unitOwner != -1;
      v12 = this->frameInfo.stackNumDispXShift[1 - this->facingRight];
      if ( hexInFrontClear && v12 > 0 )
        v12 = 0;
      if ( this->facingRight == 1 )
        xa += v12;
      else
        xa -= v12;
      if ( this->facingRight == 1 )
        offsetY = y - 11;
      else
        offsetY = y - 23;
      numPosEffects = 0;
      numNegEffects = 0;
      for ( i = 0; i < 15; ++i )
      {
        if ( this->effectStrengths[i] )
        {
          switch ( i )
          {
            case EFFECT_HASTE:
            case EFFECT_BLESS:
            case EFFECT_DRAGON_SLAYER:
            case EFFECT_BLOOD_LUST:
            case EFFECT_SHIELD:
            case EFFECT_ANTI_MAGIC:
            case EFFECT_STONESKIN:
            case EFFECT_STEELSKIN:
              ++numPosEffects;
              break;
            default:
              ++numNegEffects;
              break;
          }
        }
      }
      if ( giSpellEffectShowType && v21 && this->numActiveEffects > 0 )
      {
        if ( giSpellEffectShowType == 1 )
        {
          inRedrawZone = icon::CombatClipDrawToBuffer(
                           gpCombatManager->combatScreenIcons[1],
                           xa,
                           offsetY,
                           11,
                           &this->stackSizeDispBounds,
                           0,
                           237,
                           0,
                           0);
        }
        else
        {
          v7 = 2;
          if ( numPosEffects <= 0 || numNegEffects <= 0 )
          {
            if ( numNegEffects > 0 )
              v7 += 2;
          }
          else
          {
            ++v7;
          }
          inRedrawZone = icon::CombatClipDrawToBuffer(
                           gpCombatManager->combatScreenIcons[1],
                           xa,
                           offsetY,
                           v7 + 10,
                           &this->stackSizeDispBounds,
                           0,
                           0,
                           0,
                           0);
        }
      }
      else
      {
        inRedrawZone = icon::CombatClipDrawToBuffer(
                         gpCombatManager->combatScreenIcons[1],
                         xa,
                         offsetY,
                         10,
                         &this->stackSizeDispBounds,
                         0,
                         0,
                         0,
                         0);
      }
      if ( inRedrawZone )
      {
        if ( this->previousQuantity == -1 )
          quant = this->quantity;
        else
          quant = this->previousQuantity;
        sprintf(&str, "%d", quant);
        font::DrawBoundedString(smallFont, &str, xa, offsetY + 2, 20, 12, 1, 1);
      }
    }
    if ( this->probablyIsNeedDrawSpellEffect && !a4 )
    {
      offsetX = x;
      v17 = army::GetPowBaseY(this);
      if ( this->animationType == 14 || this->animationType == 15 )
      {
        if ( this->facingRight == 1 )
          offsetX -= 4;
        else
          offsetX += 4;
      }
      if ( this->creature.creature_flags & TWO_HEXER )
      {
        if ( this->facingRight == 1 )
          offsetX += 22;
        else
          offsetX -= 22;
      }
      if ( gCurLoadedSpellEffect == ANIM_SHIELD_IDX )
      {
        if ( this->facingRight == 1 )
          offsetX = army::RightX(this);
        else
          offsetX = army::LeftX(this);
      }
      if ( gCurLoadedSpellEffect == ANIM_BLIND_IDX )
      {
        offsetX = x + this->frameInfo.offsetForBlind[0] * ((unsigned int)(this->facingRight - 1) < 1 ? 1 : -1);
        v17 = y + this->frameInfo.offsetForBlind[1];
      }
      icon::CombatClipDrawToBuffer(
        gCurLoadedSpellIcon,
        offsetX,
        v17 + this->field_FA,
        gCurSpellEffectFrame,
        &this->effectAnimationBounds,
        1 - this->facingRight,
        0,
        0,
        0);
    }
  }
}
// 4F38A0: using guessed type int giSpellEffectShowType;
// 4F5474: using guessed type int giWalkingYMod;
// 518CFC: using guessed type int gbNoShowCombat;

//----- (0047BEE0) --------------------------------------------------------
void __thiscall army::Wince(army *this)
{
  this->animationType = ANIMATION_TYPE_WINCE;
  this->animationFrame = 0;
}

//----- (0047BF10) --------------------------------------------------------
void __thiscall army::Walk(army *ecx0, signed int dir, int last, int notFirst)
{
  int v4; // ST3C_4@78
  int v6; // [sp+1Ch] [bp-24h]@26
  int v7; // [sp+20h] [bp-20h]@80
  int i; // [sp+24h] [bp-1Ch]@47
  int v9; // [sp+28h] [bp-18h]@77
  signed int targCell; // [sp+30h] [bp-10h]@1
  int offsetY; // [sp+34h] [bp-Ch]@26
  int v12; // [sp+38h] [bp-8h]@26
  int offsetX; // [sp+3Ch] [bp-4h]@26

  targCell = army::GetAdjacentCellIndex(ecx0, ecx0->occupiedHex, dir);
  if ( ecx0->owningSide == 1
    && gpCombatManager->isCastleBattle
    && (targCell == 58 || targCell == 59 || targCell == 60 && ecx0->owningSide == 1 && ecx0->creature.creature_flags & 1)
    && gpCombatManager->drawBridgePosition == BRIDGE_CLOSED )
  {
    ecx0->animationType = ANIMATION_TYPE_STANDING;
    ecx0->animationFrame = 0;
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    combatManager::LowerDoor(gpCombatManager);
    notFirst = 0;
  }
  giWalkingFrom = ecx0->occupiedHex;
  if ( ecx0->creature.creature_flags & 1 )
    giWalkingFrom2 = ecx0->occupiedHex + ((unsigned int)(ecx0->facingRight - 1) < 1 ? 1 : -1);
  else
    giWalkingFrom2 = -1;
  giWalkingTo = targCell;
  if ( ecx0->creature.creature_flags & 1 )
    giWalkingTo2 = targCell + ((unsigned int)(ecx0->facingRight - 1) < 1 ? 1 : -1);
  else
    giWalkingTo2 = -1;
  giWalkingYMod = 0;
  BuildTempWalkSeq(&ecx0->frameInfo, last, notFirst);
  ecx0->field_8A = dir;
  if ( !notFirst )
  {
    giMinExtentY = 640;
    giMinExtentX = 640;
    giMaxExtentY = 0;
    giMaxExtentX = 0;
    gbComputeExtent = 1;
    gbSaveBiggestExtent = 1;
    gbReturnAfterComputeExtent = 1;
    army::DrawToBuffer(
      ecx0,
      gpCombatManager->combatGrid[ecx0->occupiedHex].centerX,
      gpCombatManager->combatGrid[ecx0->occupiedHex].occupyingCreatureBottomY,
      0);
    gbReturnAfterComputeExtent = 0;
    gbSaveBiggestExtent = 0;
    gbComputeExtent = 0;
  }
  if ( giMinExtentX < 0 )
    giMinExtentX = 0;
  if ( giMinExtentY < 0 )
    giMinExtentY = 0;
  if ( giMaxExtentX > 639 )
    giMaxExtentX = 639;
  if ( giMaxExtentY > 442 )
    giMaxExtentY = 442;
  offsetX = giMinExtentX;
  offsetY = giMinExtentY;
  v12 = giMaxExtentX;
  v6 = giMaxExtentY;
  ecx0->field_8E = 0;
  if ( dir >= 3 )
  {
    if ( ecx0->facingRight == 1 )
    {
      ecx0->field_8E = 1;
      ecx0->facingRight = 1 - ecx0->facingRight;
      if ( ecx0->creature.creature_flags & TWO_HEXER )
        ++ecx0->occupiedHex;
    }
  }
  else if ( !ecx0->facingRight )
  {
    ecx0->field_8E = 1;
    ecx0->facingRight = 1 - ecx0->facingRight;
    if ( ecx0->creature.creature_flags & TWO_HEXER )
      --ecx0->occupiedHex;
  }
  if ( !dir || dir == 5 )
    ecx0->field_6 = 0;
  if ( dir == 2 || dir == 3 )
    ecx0->field_6 = 3;
  ecx0->animationFrame = 0;
  ecx0->animationType = 6;
  if ( !gbNoShowCombat )
    soundManager::MemorySample((soundManager *)gpSoundManager, ecx0->combatSounds[0]);
  if ( !notFirst )
  {
    gpCombatManager->combatGrid[ecx0->occupiedHex].unitOwner = -1;
    combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 1, 1);
    gpCombatManager->combatGrid[ecx0->occupiedHex].unitOwner = LOBYTE(gpCombatManager->activeStackOwner);
    if ( !gbNoShowCombat )
      bitmap::CopyTo(
        gpWindowManager->screenBuffer,
        gpCombatManager->probablyBitmapForCombatScreen,
        0,
        0,
        0,
        0,
        0x280u,
        443);
    gpCombatManager->zeroedAfterAnimatingDeathAndHolySpells = 0;
  }
  if ( !gbNoShowCombat )
  {
    for ( i = 0; ecx0->frameInfo.animationLengths[6] > i; ++i )
    {
      ecx0->animationFrame = i;
      if ( notFirst || i )
      {
        bitmap::CopyTo(
          gpCombatManager->probablyBitmapForCombatScreen,
          gpWindowManager->screenBuffer,
          giMinExtentX,
          giMinExtentY,
          giMinExtentX,
          giMinExtentY,
          giMaxExtentX - giMinExtentX + 1,
          giMaxExtentY - giMinExtentY + 1);
        if ( giMinExtentX < 0 )
          giMinExtentX = 0;
        if ( giMinExtentY < 0 )
          giMinExtentY = 0;
        if ( giMaxExtentX > 639 )
          giMaxExtentX = 639;
        if ( giMaxExtentY > 442 )
          giMaxExtentY = 442;
        offsetX = giMinExtentX;
        offsetY = giMinExtentY;
        v12 = giMaxExtentX;
        v6 = giMaxExtentY;
      }
      giMinExtentY = 640;
      giMinExtentX = 640;
      giMaxExtentY = 0;
      giMaxExtentX = 0;
      gbComputeExtent = 1;
      gbSaveBiggestExtent = 1;
      gbReturnAfterComputeExtent = 1;
      army::DrawToBuffer(
        ecx0,
        gpCombatManager->combatGrid[ecx0->occupiedHex].centerX,
        gpCombatManager->combatGrid[ecx0->occupiedHex].occupyingCreatureBottomY,
        0);
      gbReturnAfterComputeExtent = 0;
      gbComputeExtent = 0;
      gbSaveBiggestExtent = 0;
      if ( giMinExtentX < 0 )
        giMinExtentX = 0;
      if ( giMinExtentY < 0 )
        giMinExtentY = 0;
      if ( giMaxExtentX > 639 )
        giMaxExtentX = 639;
      if ( giMaxExtentY > 442 )
        giMaxExtentY = 442;
      gbCurrArmyDrawn = 0;
      gbComputeExtent = 1;
      gbLimitToExtent = 1;
      ecx0->field_11D = 0;
      combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 0, 1);
      ecx0->field_11D = 1;
      gbLimitToExtent = 0;
      gbComputeExtent = 0;
      gbCurrArmyDrawn = 1;
      if ( giMinExtentX < offsetX )
        offsetX = giMinExtentX;
      if ( offsetY > giMinExtentY )
        offsetY = giMinExtentY;
      if ( giMaxExtentX > v12 )
        v12 = giMaxExtentX;
      if ( giMaxExtentY > v6 )
        v6 = giMaxExtentY;
      DelayTil(&glTimers);
      glTimers = (signed __int64)((double)KBTickCount()
                                + (double)ecx0->frameInfo.stepTime
                                * gfCombatSpeedMod[giCombatSpeed]
                                / (double)ecx0->frameInfo.animationLengths[6]);
      heroWindowManager::UpdateScreenRegion(gpWindowManager, offsetX, offsetY, v12 - offsetX + 1, v6 - offsetY + 1);
    }
  }
  v9 = army::GetAdjacentCellIndex(ecx0, ecx0->occupiedHex, dir);
  gpCombatManager->combatGrid[ecx0->occupiedHex].stackIdx = -1;
  gpCombatManager->combatGrid[ecx0->occupiedHex].unitOwner = -1;
  gpCombatManager->combatGrid[ecx0->occupiedHex].occupiersOtherHexIsToLeft = -1;
  if ( ecx0->creature.creature_flags & 1 )
  {
    v4 = ecx0->occupiedHex + ((unsigned int)(ecx0->facingRight - 1) < 1 ? 1 : -1);
    gpCombatManager->combatGrid[v4].stackIdx = -1;
    gpCombatManager->combatGrid[v4].unitOwner = -1;
    gpCombatManager->combatGrid[v4].occupiersOtherHexIsToLeft = -1;
  }
  gpCombatManager->combatGrid[v9].unitOwner = LOBYTE(ecx0->owningSide);
  gpCombatManager->combatGrid[v9].stackIdx = LOBYTE(ecx0->stackIdx);
  gpCombatManager->combatGrid[v9].occupiersOtherHexIsToLeft = -1;
  if ( ecx0->creature.creature_flags & 1 )
  {
    v7 = v9 + ((unsigned int)(ecx0->facingRight - 1) < 1 ? 1 : -1);
    gpCombatManager->combatGrid[v7].unitOwner = LOBYTE(ecx0->owningSide);
    gpCombatManager->combatGrid[v7].stackIdx = LOBYTE(ecx0->stackIdx);
    gpCombatManager->combatGrid[v7].occupiersOtherHexIsToLeft = v9 <= v7;
    gpCombatManager->combatGrid[v9].occupiersOtherHexIsToLeft = v9 >= v7;
  }
  ecx0->occupiedHex = v9;
  if ( ecx0->field_8E )
  {
    ecx0->facingRight = 1 - ecx0->facingRight;
    if ( ecx0->creature.creature_flags & TWO_HEXER )
    {
      if ( ecx0->facingRight )
        --ecx0->occupiedHex;
      else
        ++ecx0->occupiedHex;
    }
    ecx0->field_8E = 0;
  }
  giWalkingFrom = -1;
  giWalkingFrom2 = -1;
  giWalkingTo = -1;
  giWalkingTo2 = -1;
  ecx0->field_6 = 1;
  if ( last == 1 )
  {
    ecx0->animationType = 7;
    ecx0->animationFrame = 0;
    combatManager::DrawFrame(gpCombatManager, 1, 1, 0, 0, 75, 1, 1);
  }
}
// 4F1998: using guessed type int gbReturnAfterComputeExtent;
// 4F5464: using guessed type int giWalkingFrom;
// 4F5468: using guessed type int giWalkingFrom2;
// 4F546C: using guessed type int giWalkingTo;
// 4F5470: using guessed type int giWalkingTo2;
// 4F5474: using guessed type int giWalkingYMod;
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 4F7488: using guessed type int gbLimitToExtent;
// 4F748C: using guessed type int gbCurrArmyDrawn;
// 518CFC: using guessed type int gbNoShowCombat;
// 5240A8: using guessed type int gpSoundManager;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (0047CA90) --------------------------------------------------------
void __thiscall army::SpecialAttack(army *this)
{
  int v1; // ebx@0
  double xDiff; // st6@0
  int v3; // eax@12
  int v4; // ST64_4@42
  double v5; // st7@51
  char *v7; // [sp+40h] [bp-1ACh]@132
  char *v8; // [sp+44h] [bp-1A8h]@127
  char *v9; // [sp+48h] [bp-1A4h]@124
  bitmap *thisb; // [sp+54h] [bp-198h]@55
  int v11; // [sp+58h] [bp-194h]@0
  army *targ; // [sp+5Ch] [bp-190h]@113
  int projStartX; // [sp+60h] [bp-18Ch]@16
  float angleDeg; // [sp+64h] [bp-188h]@24
  char v15; // [sp+68h] [bp-184h]@103
  int yDiff; // [sp+6Ch] [bp-180h]@20
  int startY; // [sp+70h] [bp-17Ch]@49
  int v18; // [sp+74h] [bp-178h]@46
  int damageDone; // [sp+78h] [bp-174h]@1
  int totXDiff; // [sp+7Ch] [bp-170h]@18
  int v21; // [sp+80h] [bp-16Ch]@43
  signed int startX; // [sp+84h] [bp-168h]@47
  int v23; // [sp+88h] [bp-164h]@46
  int creaturesKilled; // [sp+8Ch] [bp-160h]@1
  int v25; // [sp+90h] [bp-15Ch]@43
  int offsetY; // [sp+94h] [bp-158h]@46
  signed int i; // [sp+98h] [bp-154h]@25
  int offsetX; // [sp+9Ch] [bp-150h]@46
  bitmap *bmp; // [sp+A0h] [bp-14Ch]@56
  int v30; // [sp+A4h] [bp-148h]@43
  int y; // [sp+A8h] [bp-144h]@58
  int origFacingRight; // [sp+ACh] [bp-140h]@1
  army *target; // [sp+B0h] [bp-13Ch]@1
  float slope; // [sp+B4h] [bp-138h]@25
  int v35; // [sp+B8h] [bp-134h]@49
  int x; // [sp+BCh] [bp-130h]@58
  char targRow; // [sp+C0h] [bp-12Ch]@1
  int v38; // [sp+C4h] [bp-128h]@43
  signed int endY; // [sp+C8h] [bp-124h]@49
  int v40; // [sp+CCh] [bp-120h]@53
  int v41; // [sp+D0h] [bp-11Ch]@55
  int targMidY; // [sp+D4h] [bp-118h]@12
  int attackDirectionAnimationIdx; // [sp+D8h] [bp-114h]@33
  signed int endX; // [sp+DCh] [bp-110h]@49
  int v45; // [sp+E0h] [bp-10Ch]@49
  int v46; // [sp+E4h] [bp-108h]@53
  int v47; // [sp+E8h] [bp-104h]@55
  char targCol; // [sp+ECh] [bp-100h]@1
  char thisRow; // [sp+F0h] [bp-FCh]@1
  int v50; // [sp+F4h] [bp-F8h]@49
  int animIdx; // [sp+F8h] [bp-F4h]@103
  int a5; // [sp+FCh] [bp-F0h]@103
  char thisCol; // [sp+100h] [bp-ECh]@1
  char firingLeft; // [sp+104h] [bp-E8h]@18
  int v55; // [sp+108h] [bp-E4h]@49
  int v56; // [sp+10Ch] [bp-E0h]@58
  int a4; // [sp+110h] [bp-DCh]@103
  char message; // [sp+114h] [bp-D8h]@135
  int projStartY; // [sp+1DCh] [bp-10h]@18
  int targMidX; // [sp+1E0h] [bp-Ch]@12
  int missleSpriteIdx; // [sp+1E4h] [bp-8h]@22
  int v62; // [sp+1E8h] [bp-4h]@58

  damageDone = 0;
  creaturesKilled = 0;
  origFacingRight = this->facingRight;
  this->field_125 = 0;
  target = &gpCombatManager->creatures[this->targetOwner][this->targetStackIdx];
  targCol = target->occupiedHex % 13;
  targRow = target->occupiedHex / 13;
  thisCol = this->occupiedHex % 13;
  thisRow = this->occupiedHex / 13;
  origFacingRight = this->facingRight;
  this->facingRight = targCol > thisCol || !(thisRow & 1) && targCol == thisCol;
  if ( this->facingRight != origFacingRight )
  {
    if ( this->creature.creature_flags & TWO_HEXER )
    {
      if ( this->facingRight == 1 )
        --this->occupiedHex;
      else
        ++this->occupiedHex;
    }
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
  }
  army::CheckLuck(this);
  soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[3]);
  combatManager::ResetLimitCreature(gpCombatManager);
  v3 = 80 * this->owningSide + 4 * this->stackIdx;
  ++*(signed int *)((char *)gpCombatManager->limitCreature[0] + v3);
  combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
  targMidX = army::MidX(target);
  targMidY = army::MidY(target);
  if ( this->creatureIdx == CREATURE_LICH || this->creatureIdx == CREATURE_POWER_LICH )
  {
    targMidX = gpCombatManager->combatGrid[target->occupiedHex].centerX;
    targMidY = gpCombatManager->combatGrid[target->occupiedHex].occupyingCreatureBottomY - 17;
  }
  if ( this->facingRight == 1 )
    projStartX = this->frameInfo.projectileStartOffset[1][0] + gpCombatManager->combatGrid[this->occupiedHex].centerX;
  else
    projStartX = gpCombatManager->combatGrid[this->occupiedHex].centerX - this->frameInfo.projectileStartOffset[1][0];
  projStartY = this->frameInfo.projectileStartOffset[1][1]
             + gpCombatManager->combatGrid[this->occupiedHex].occupyingCreatureBottomY;
  totXDiff = targMidX - projStartX;
  firingLeft = 0;
  if ( targMidX - projStartX < 0 )
  {
    firingLeft = 1;
    totXDiff = -totXDiff;
  }
  yDiff = targMidY - projStartY;
  if ( totXDiff )
  {
    xDiff = (double)totXDiff;
    slope = (double)-yDiff / xDiff;
    angleDeg = atan(slope) * 180.0 / 3.14159;
    for ( i = 1;
          this->frameInfo.numMissileDirs > i
       && (*(float *)((char *)this->frameInfo.projectileStartOffset[i + 2] + 1) + this->frameInfo.projDirAngle[i]) / 2.0 >= angleDeg;
          ++i )
      ;
    if ( this->frameInfo.numMissileDirs <= i )
      missleSpriteIdx = this->frameInfo.numMissileDirs - 1;
    else
      missleSpriteIdx = i - 1;
  }
  else
  {
    if ( yDiff <= 0 )
      missleSpriteIdx = 0;
    else
      missleSpriteIdx = this->frameInfo.numMissileDirs - 1;
    angleDeg = (double)(yDiff <= 0 ? 90 : -90);
  }
  if ( angleDeg <= 25.0 )
  {
    if ( angleDeg <= -25.0 )
    {
      this->animationType = ANIMATION_TYPE_RANGED_ATTACK_DOWNWARDS;
      attackDirectionAnimationIdx = 2;
    }
    else
    {
      this->animationType = ANIMATION_TYPE_RANGED_ATTACK_FORWARDS;
      attackDirectionAnimationIdx = 1;
    }
  }
  else
  {
    this->animationType = ANIMATION_TYPE_RANGED_ATTACK_UPWARDS;
    attackDirectionAnimationIdx = 0;
  }
  for ( this->animationFrame = 0;
        this->frameInfo.animationLengths[this->animationType] > this->animationFrame;
        ++this->animationFrame )
  {
    if ( this->frameInfo.animationLengths[this->animationType] - 1 == this->animationFrame )
      combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 0, 75, 1, 1);
    else
      combatManager::DrawFrame(gpCombatManager, 1, 1, 0, 0, 75, 1, 1);
    v4 = KBTickCount();
    xDiff = (double)this->frameInfo.shootingTime
          * gfCombatSpeedMod[giCombatSpeed]
          / (double)this->frameInfo.animationLengths[this->animationType];
    glTimers = (signed __int64)((double)v4 + xDiff);
  }
  this->animationFrame = this->frameInfo.animationLengths[this->animationType] - 1;
  v30 = 25;
  v21 = 25;
  v38 = 31;
  v25 = 25;
  if ( this->creatureIdx == CREATURE_LICH || this->creatureIdx == CREATURE_POWER_LICH )
  {
    v38 = 26;
    v25 = 7;
    v30 = 10;
    v21 = 10;
  }
  v23 = 0;
  offsetX = 639;
  v18 = 0;
  offsetY = 479;
  if ( this->facingRight == 1 )
    startX = gpCombatManager->combatGrid[this->occupiedHex].centerX
           + this->frameInfo.projectileStartOffset[attackDirectionAnimationIdx][0];
  else
    startX = gpCombatManager->combatGrid[this->occupiedHex].centerX
           - this->frameInfo.projectileStartOffset[attackDirectionAnimationIdx][0];
  startY = gpCombatManager->combatGrid[this->occupiedHex].occupyingCreatureBottomY
         + this->frameInfo.projectileStartOffset[attackDirectionAnimationIdx][1];
  endX = army::MidX(target);
  endY = army::MidY(target);
  v45 = endX - startX;
  v50 = endY - startY;
  v35 = (signed __int64)sqrt((double)(v50 * v50 + (endX - startX) * (endX - startX)));
  v55 = (v35 + (v38 >> 1)) / v38;
  if ( this->creatureIdx != CREATURE_MAGE && this->creatureIdx != CREATURE_ARCHMAGE )
  {
    if ( v55 <= 1 )
    {
      v46 = v45;
      v40 = v50;
    }
    else
    {
      v46 = v45 / (v55 - 1);
      v40 = v50 / (v55 - 1);
    }
    v47 = startX;
    v41 = startY;
    thisb = (bitmap *)operator new(26);
    if ( thisb )
      bmp = bitmap::bitmap(thisb, 33, 2 * v30, 2 * v21);
    else
      bmp = 0;
    bitmap::GrabBitmapCareful(bmp, gpWindowManager->screenBuffer, v47 - v30, v41 - v21);
    v62 = v47;
    v56 = v41;
    x = 0;
    y = 0;
    for ( i = 0; i < v55; ++i )
    {
      if ( v62 - v30 < offsetX )
        offsetX = v62 - v30;
      if ( offsetX < 0 )
        offsetX = 0;
      if ( v30 + v62 > v23 )
        v23 = v30 + v62;
      if ( v23 > 639 )
        v23 = 639;
      if ( v56 - v21 < offsetY )
        offsetY = v56 - v21;
      if ( offsetY < 0 )
        offsetY = 0;
      if ( v21 + v56 > v18 )
        v18 = v21 + v56;
      if ( v18 > 442 )
        v18 = 442;
      if ( i )
      {
        bitmap::DrawToBufferCareful(bmp, x, y);
      }
      else
      {
        if ( giMinExtentX > offsetX )
          giMinExtentX = offsetX;
        if ( v23 > giMaxExtentX )
          giMaxExtentX = v23;
        if ( offsetY < giMinExtentY )
          giMinExtentY = offsetY;
        if ( v18 > giMaxExtentY )
          giMaxExtentY = v18;
      }
      x = v47 - v30;
      if ( v47 - v30 < 0 )
        x = 0;
      if ( x + bmp->width > 640 )
        x = 640 - bmp->width;
      y = v41 - v21;
      if ( v41 - v21 < 0 )
        y = 0;
      if ( y + bmp->height > 640 )
        y = 640 - bmp->height;
      bitmap::GrabBitmapCareful(bmp, gpWindowManager->screenBuffer, x, y);
      icon::DrawToBuffer(this->missileIcon, v47, v41, missleSpriteIdx, firingLeft);
      if ( i )
      {
        DelayTil(&glTimers);
        heroWindowManager::UpdateScreenRegion(gpWindowManager, offsetX, offsetY, v23 - offsetX + 1, v18 - offsetY + 1);
      }
      else
      {
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          giMinExtentX,
          giMinExtentY,
          giMaxExtentX - giMinExtentX + 1,
          giMaxExtentY - giMinExtentY + 1);
      }
      glTimers = (signed __int64)((double)KBTickCount() + (double)v25 * gfCombatSpeedMod[giCombatSpeed]);
      v62 = v47;
      v56 = v41;
      v47 += v46;
      v41 += v40;
      offsetX = v47 - v30;
      v23 = v30 + v47;
      offsetY = v41 - v21;
      v18 = v21 + v41;
    }
    bitmap::DrawToBuffer(bmp, x, y);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, v62 - v30, v56 - v21, 2 * v30, 2 * v21);
    if ( bmp )
      ((void (__thiscall *)(bitmap *))bmp->vtable->scalarDeletingDestructor)(bmp);
  }
  else
  {
    heroWindowManager::UpdateScreenRegion(
      gpWindowManager,
      giMinExtentX,
      giMinExtentY,
      giMaxExtentX - giMinExtentX + 1,
      giMaxExtentY - giMinExtentY + 1);
    v5 = gfCombatSpeedMod[giCombatSpeed] * 115.0;
    DelayMilli((signed __int64)v5);
    combatManager::DoBolt(
      gpCombatManager,
      v1,
      xDiff,
      v5,
      1,
      startX,
      startY,
      endX,
      endY,
      0,
      0,
      5,
      4,
      302,
      0,
      0,
      v35 / 15 + 15,
      1,
      0,
      10,
      0);
  }
  if ( !gpCombatManager->heroes[this->owningSide]
    || !hero::HasArtifact(gpCombatManager->heroes[this->owningSide], ARTIFACT_AMMO_CART) )
    --this->creature.shots;
  v15 = this->creature.attack;
  animIdx = -1;
  a4 = -1;
  a5 = -1;
  if ( this->creatureIdx != CREATURE_LICH && this->creatureIdx != CREATURE_POWER_LICH )
  {
    army::DamageEnemy(this, target, &damageDone, &creaturesKilled, 1, 0);
  }
  else
  {
    combatManager::ClearEffects();
    for ( i = 0; i < 7; ++i )
    {
      if ( i >= 6 )
        v11 = target->occupiedHex;
      else
        v11 = army::GetAdjacentCellIndex(target, target->occupiedHex, i);
      if ( v11 != -1 )
      {
        if ( gpCombatManager->combatGrid[v11].unitOwner != -1 )
        {
          targ = &gpCombatManager->creatures[gpCombatManager->combatGrid[v11].unitOwner][gpCombatManager->combatGrid[v11].stackIdx];
          if ( !gArmyEffected[gpCombatManager->creatures[gpCombatManager->combatGrid[v11].unitOwner][gpCombatManager->combatGrid[v11].stackIdx].owningSide][gpCombatManager->creatures[gpCombatManager->combatGrid[v11].unitOwner][gpCombatManager->combatGrid[v11].stackIdx].stackIdx] )
          {
            if ( target != targ || i == 6 )
            {
              gArmyEffected[gpCombatManager->creatures[gpCombatManager->combatGrid[v11].unitOwner][gpCombatManager->combatGrid[v11].stackIdx].owningSide][gpCombatManager->creatures[gpCombatManager->combatGrid[v11].unitOwner][gpCombatManager->combatGrid[v11].stackIdx].stackIdx] = 1;
              army::DamageEnemy(this, targ, &damageDone, &creaturesKilled, 1, 0);
            }
          }
        }
      }
    }
    this->field_FA = 0;
    animIdx = 20;
    a4 = gpCombatManager->combatGrid[v11].centerX;
    a5 = gpCombatManager->combatGrid[v11].occupyingCreatureBottomY - 17;
    soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[5]);
  }
  this->creature.attack = v15;
  if ( creaturesKilled <= 0 )
  {
    if ( this->quantity <= 1 )
      v7 = gArmyNames[this->creatureIdx];
    else
      v7 = gArmyNamesPlural[this->creatureIdx];
    sprintf(gText, "%s %s %d %s.", v7, &aDo_0[("does" - "do") & ((this->quantity > 1) - 1)], damageDone, "damage");
    gText[0] -= 32;
  }
  else if ( damageDone == -1 )
  {
    sprintf(gText, "The mirror image is destroyed!");
  }
  else
  {
    if ( creaturesKilled <= 1 )
      v9 = gArmyNames[target->creatureIdx];
    else
      v9 = gArmyNamesPlural[target->creatureIdx];
    if ( this->quantity <= 1 )
      v8 = gArmyNames[this->creatureIdx];
    else
      v8 = gArmyNamesPlural[this->creatureIdx];
    sprintf(
      gText,
      "%s %s %d %s.\n%d %s %s.",
      v8,
      &aDo[("does" - "do") & ((this->quantity > 1) - 1)],
      damageDone,
      "damage",
      creaturesKilled,
      v9,
      &aPerish_0[("perishes" - "perish") & ((creaturesKilled > 1) - 1)]);
    gText[0] -= 32;
  }
  strcpy(&message, gText);
  if ( this->creatureIdx == CREATURE_ARCHMAGE
    && SRandom(1, 100) < 20
    && target
    && army::SpellCastWorks(target, SPELL_ARCHMAGI_DISPEL) )
    target->spellEnemyCreatureAbilityIsCasting = SPELL_ARCHMAGI_DISPEL;
  army::PowEffect(this, animIdx, 0, a4, a5);
  combatManager::CombatMessage(gpCombatManager, &message, 1, 1, 0);
  army::WaitSample(3);
  if ( this->facingRight != origFacingRight )
  {
    if ( this->creature.creature_flags & 1 )
    {
      if ( this->facingRight == 1 )
        ++this->occupiedHex;
      else
        --this->occupiedHex;
    }
    this->facingRight = origFacingRight;
  }
  if ( !bSecondAttack
    && (this->creatureIdx == CREATURE_ELF
     || this->creatureIdx == CREATURE_GRAND_ELF
     || this->creatureIdx == CREATURE_RANGER)
    && target->quantity > 0 )
  {
    bSecondAttack = 1;
    army::SpecialAttack(this);
    bSecondAttack = 0;
  }
  if ( this->effectStrengths[5] || this->effectStrengths[7] )
  {
    army::CancelSpellType(this, CREATURE_TOOK_TURN_EVENT_CODE);
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
  }
}
// 5134A8: using guessed type int bSecondAttack;
// 5240A8: using guessed type int gpSoundManager;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (0047E110) --------------------------------------------------------
void __thiscall army::DirDoAttack(int this, int a2)
{
  *(_DWORD *)(this + 90) = a2;
  army::DoAttack((army *)this, 0);
}

//----- (0047E140) --------------------------------------------------------
void __thiscall army::DoHydraAttack(army *this, int a2)
{
  int v2; // eax@4
  army *thisa; // [sp+Ch] [bp-FCh]@1
  char *v4; // [sp+10h] [bp-F8h]@28
  char *v5; // [sp+14h] [bp-F4h]@24
  signed int neighborIdx; // [sp+18h] [bp-F0h]@4
  int a1; // [sp+1Ch] [bp-ECh]@7
  int a1a; // [sp+1Ch] [bp-ECh]@16
  int v9; // [sp+20h] [bp-E8h]@17
  __int16 v10; // [sp+24h] [bp-E4h]@2
  int v11; // [sp+28h] [bp-E0h]@1
  int damageDone; // [sp+2Ch] [bp-DCh]@20
  int v13; // [sp+30h] [bp-D8h]@1
  army *targ; // [sp+34h] [bp-D4h]@19
  int v15; // [sp+38h] [bp-D0h]@17
  int creaturesKilled; // [sp+3Ch] [bp-CCh]@20
  char message; // [sp+40h] [bp-C8h]@31

  thisa = this;
  v13 = 0;
  v11 = 0;
  combatManager::ResetHitByCreature(gpCombatManager);
  if ( thisa->effectStrengths[5] )
    v10 = army::GetAttackMask(thisa, thisa->occupiedHex, 2, -1);
  else
    v10 = army::GetAttackMask(thisa, thisa->occupiedHex, 1, -1);
  army::CheckLuck(thisa);
  combatManager::ResetLimitCreature(gpCombatManager);
  v2 = 80 * thisa->owningSide + 4 * thisa->stackIdx;
  ++*(signed int *)((char *)gpCombatManager->limitCreature[0] + v2);
  for ( neighborIdx = 0; neighborIdx < 8; ++neighborIdx )
  {
    if ( !(v10 & (1 << neighborIdx)) )
    {
      a1 = thisa->occupiedHex;
      if ( thisa->creature.creature_flags & TWO_HEXER
        && (!thisa->facingRight && neighborIdx > 2 || thisa->facingRight == 1 && (neighborIdx < 3 || neighborIdx > 5)) )
      {
        if ( thisa->facingRight )
          a1 = thisa->occupiedHex + 1;
        else
          a1 = thisa->occupiedHex - 1;
      }
      a1a = army::GetAdjacentCellIndex(thisa, a1, neighborIdx);
      if ( ValidHex(a1a) )
      {
        v9 = gpCombatManager->combatGrid[a1a].unitOwner;
        v15 = gpCombatManager->combatGrid[a1a].stackIdx;
        if ( v9 >= 0 )
        {
          if ( v15 >= 0 )
          {
            ++gpCombatManager->limitCreature[v9][v15];
            targ = &gpCombatManager->creatures[v9][v15];
            if ( !gpCombatManager->creatures[v9][v15].hitByHydraAttack )
            {
              targ->hitByHydraAttack = 1;
              army::DamageEnemy(thisa, targ, &damageDone, &creaturesKilled, 0, 0);
              v11 += damageDone;
              v13 += creaturesKilled;
              ++gpCombatManager->limitCreature[v9][v15];
            }
          }
        }
      }
    }
  }
  combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
  thisa->mightBeIsAttacking = 1;
  thisa->mightBeAttackAnimIdx = 20;
  soundManager::MemorySample((soundManager *)gpSoundManager, thisa->combatSounds[1]);
  if ( v13 <= 0 )
  {
    if ( thisa->quantity <= 1 )
      v4 = gArmyNames[thisa->creatureIdx];
    else
      v4 = gArmyNamesPlural[thisa->creatureIdx];
    sprintf(gText, "%s %s %d %s.", v4, &aDo_2[("does" - "do") & ((thisa->quantity > 1) - 1)], v11, "damage");
  }
  else
  {
    if ( thisa->quantity <= 1 )
      v5 = gArmyNames[thisa->creatureIdx];
    else
      v5 = gArmyNamesPlural[thisa->creatureIdx];
    sprintf(
      gText,
      "%s %s %d %s.\n%d %s %s.",
      v5,
      &aDo_1[("does" - "do") & ((thisa->quantity > 1) - 1)],
      v11,
      "damage",
      v13,
      &aCreatures[("creature" - "creatures") & ((v13 > 1) - 1)],
      &aPerish_1[("perishes" - "perish") & ((v13 > 1) - 1)]);
  }
  gText[0] -= 32;
  strcpy(&message, gText);
  army::PowEffect(thisa, -1, 0, -1, -1);
  combatManager::CombatMessage(gpCombatManager, &message, 1, 1, 0);
  gpCombatManager->limitCreature[thisa->owningSide][thisa->stackIdx] = 1;
}
// 5240A8: using guessed type int gpSoundManager;

//----- (0047E6C0) --------------------------------------------------------
void __thiscall army::DoAttack(army *this, int isRetaliationOrSecondAttack)
{
  int v2; // eax@21
  int v3; // eax@21
  int v4; // eax@22
  int v5; // ecx@114
  char *v7; // [sp+14h] [bp-11Ch]@66
  char *v8; // [sp+18h] [bp-118h]@62
  char *v9; // [sp+1Ch] [bp-114h]@59
  char *v10; // [sp+20h] [bp-110h]@54
  int v11; // [sp+28h] [bp-108h]@114
  int secondTargetHex; // [sp+2Ch] [bp-104h]@15
  int v13; // [sp+30h] [bp-100h]@1
  int shouldFaceRight; // [sp+34h] [bp-FCh]@24
  int targetHex; // [sp+38h] [bp-F8h]@5
  int v16; // [sp+3Ch] [bp-F4h]@150
  int damDone; // [sp+40h] [bp-F0h]@1
  int v18; // [sp+44h] [bp-ECh]@5
  int damageDone; // [sp+48h] [bp-E8h]@1
  float creaturesKilled; // [sp+4Ch] [bp-E4h]@1
  army *primaryTarget; // [sp+54h] [bp-DCh]@1
  int oldFacingRight; // [sp+58h] [bp-D8h]@1
  int enemyIncapacitated; // [sp+5Ch] [bp-D4h]@1
  int targetOldFacingRight; // [sp+60h] [bp-D0h]@23
  army *secondHexTarget; // [sp+64h] [bp-CCh]@1
  char message; // [sp+68h] [bp-C8h]@69

  this->field_6 = 3;
  damDone = 0;
  creaturesKilled = 0.0;
  damageDone = 0;
  v13 = 0;
  enemyIncapacitated = 0;
  primaryTarget = 0;
  secondHexTarget = 0;
  oldFacingRight = this->facingRight;
  if ( isRetaliationOrSecondAttack )
    gpCombatManager->currentActionSide = 1 - gpCombatManager->currentActionSide;
  if ( this->creatureIdx == CREATURE_HYDRA )
  {
    army::DoHydraAttack(this, isRetaliationOrSecondAttack);
  }
  else
  {
    v18 = this->targetNeighborIdx;
    targetHex = this->occupiedHex;
    if ( this->creature.creature_flags & TWO_HEXER
      && (!this->facingRight && this->targetNeighborIdx >= 3
       || this->facingRight == 1 && (this->targetNeighborIdx <= 2 || this->targetNeighborIdx >= 6)) )
    {
      if ( oldFacingRight )
        targetHex = this->occupiedHex + 1;
      else
        targetHex = this->occupiedHex - 1;
    }
    targetHex = army::GetAdjacentCellIndex(this, targetHex, this->targetNeighborIdx);
    primaryTarget = &gpCombatManager->creatures[gpCombatManager->combatGrid[targetHex].unitOwner][gpCombatManager->combatGrid[targetHex].stackIdx];
    if ( this->creature.creature_flags & TWO_HEX_ATTACKER )
    {
      secondTargetHex = army::GetAdjacentCellIndex(this, targetHex, this->targetNeighborIdx);
      if ( ValidHex(secondTargetHex) )
      {
        if ( gpCombatManager->combatGrid[secondTargetHex].unitOwner >= 0
          && gpCombatManager->combatGrid[secondTargetHex].stackIdx >= 0
          && (gpCombatManager->combatGrid[secondTargetHex].unitOwner != primaryTarget->owningSide
           || gpCombatManager->combatGrid[secondTargetHex].stackIdx != primaryTarget->stackIdx) )
          secondHexTarget = &gpCombatManager->creatures[gpCombatManager->combatGrid[secondTargetHex].unitOwner][gpCombatManager->combatGrid[secondTargetHex].stackIdx];
      }
    }
    combatManager::ResetLimitCreature(gpCombatManager);
    v2 = 80 * this->owningSide + 4 * this->stackIdx;
    ++*(signed int *)((char *)gpCombatManager->limitCreature[0] + v2);
    v3 = 80 * primaryTarget->owningSide + 4 * primaryTarget->stackIdx;
    ++*(signed int *)((char *)gpCombatManager->limitCreature[0] + v3);
    if ( secondHexTarget )
    {
      v4 = 80 * secondHexTarget->owningSide + 4 * secondHexTarget->stackIdx;
      ++*(signed int *)((char *)gpCombatManager->limitCreature[0] + v4);
    }
    combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
    targetOldFacingRight = primaryTarget->facingRight;
    if ( this->targetNeighborIdx > 2 )
    {
      if ( this->targetNeighborIdx > 5 )
        shouldFaceRight = this->facingRight;
      else
        shouldFaceRight = 0;
    }
    else
    {
      shouldFaceRight = 1;
    }
    if ( this->facingRight != shouldFaceRight )
    {
      this->facingRight = shouldFaceRight;
      if ( this->creature.creature_flags & TWO_HEXER )
      {
        if ( shouldFaceRight == 1 )
          --this->occupiedHex;
        else
          ++this->occupiedHex;
      }
      primaryTarget->facingRight = 1 - this->facingRight;
      if ( primaryTarget->facingRight != targetOldFacingRight && primaryTarget->creature.creature_flags & TWO_HEXER )
      {
        if ( primaryTarget->facingRight == 1 )
          --primaryTarget->occupiedHex;
        else
          ++primaryTarget->occupiedHex;
      }
    }
    army::CheckLuck(this);
    this->mightBeIsAttacking = 1;
    if ( this->targetNeighborIdx != 6 && this->targetNeighborIdx != 5 && this->targetNeighborIdx )
    {
      if ( this->targetNeighborIdx != 1 && this->targetNeighborIdx != 4 )
        this->mightBeAttackAnimIdx = 24;
      else
        this->mightBeAttackAnimIdx = 20;
    }
    else
    {
      this->mightBeAttackAnimIdx = 16;
    }
    if ( secondHexTarget )
      this->mightBeAttackAnimIdx += 2;
    soundManager::MemorySample((soundManager *)gpSoundManager, this->combatSounds[1]);
    army::DamageEnemy(this, primaryTarget, &damDone, (int *)&creaturesKilled, 0, 0);
    if ( secondHexTarget )
      army::DamageEnemy(this, secondHexTarget, &damageDone, &v13, 0, 0);
    if ( damDone == -1 )
    {
      sprintf(gText, "The mirror image is destroyed!");
    }
    else if ( gbGenieHalf )
    {
      if ( this->quantity <= 1 )
        v10 = gArmyNames[this->creatureIdx];
      else
        v10 = gArmyNamesPlural[this->creatureIdx];
      sprintf(
        gText,
        "%s %s half the enemy troops!",
        v10,
        &aDestroy[("destroys" - "destroy") & ((this->quantity > 1) - 1)]);
      gText[0] -= 32;
    }
    else if ( SLODWORD(creaturesKilled) <= 0 )
    {
      if ( this->quantity <= 1 )
        v7 = gArmyNames[this->creatureIdx];
      else
        v7 = gArmyNamesPlural[this->creatureIdx];
      sprintf(gText, "%s %s %d %s.", v7, &aDo_4[("does" - "do") & ((this->quantity > 1) - 1)], damDone, "damage");
      gText[0] -= 32;
    }
    else
    {
      if ( SLODWORD(creaturesKilled) <= 1 )
        v9 = gArmyNames[primaryTarget->creatureIdx];
      else
        v9 = gArmyNamesPlural[primaryTarget->creatureIdx];
      if ( this->quantity <= 1 )
        v8 = gArmyNames[this->creatureIdx];
      else
        v8 = gArmyNamesPlural[this->creatureIdx];
      sprintf(
        gText,
        "%s %s %d %s.\n%d %s %s.",
        v8,
        &aDo_3[("does" - "do") & ((this->quantity > 1) - 1)],
        damDone,
        "damage",
        LODWORD(creaturesKilled),
        v9,
        &aPerish_2[("perishes" - "perish") & ((SLODWORD(creaturesKilled) > 1) - 1)]);
      gText[0] -= 32;
    }
    strcpy(&message, gText);
    switch ( this->creatureIdx )
    {
      case CREATURE_CYCLOPS:
        if ( primaryTarget->quantity > 0 && (!secondHexTarget || secondHexTarget->quantity > 0) )
        {
          if ( SRandom(1, 100) >= 20 )
          {
            if ( SRandom(1, 100) < 20 && secondHexTarget && army::SpellCastWorks(secondHexTarget, SPELL_PARALYZE) )
              secondHexTarget->spellEnemyCreatureAbilityIsCasting = SPELL_PARALYZE;
          }
          else if ( primaryTarget && army::SpellCastWorks(primaryTarget, SPELL_PARALYZE) )
          {
            primaryTarget->spellEnemyCreatureAbilityIsCasting = SPELL_PARALYZE;
            enemyIncapacitated = 1;
          }
        }
        break;
      case CREATURE_UNICORN:
        if ( SRandom(1, 100) < 20 && primaryTarget && army::SpellCastWorks(primaryTarget, SPELL_BLIND) )
        {
          primaryTarget->spellEnemyCreatureAbilityIsCasting = SPELL_BLIND;
          enemyIncapacitated = 1;
        }
        break;
      case CREATURE_MEDUSA:
        if ( SRandom(1, 100) < 20 && primaryTarget && army::SpellCastWorks(primaryTarget, SPELL_MEDUSA_PETRIFY) )
        {
          primaryTarget->spellEnemyCreatureAbilityIsCasting = SPELL_MEDUSA_PETRIFY;
          enemyIncapacitated = 1;
        }
        break;
      case CREATURE_MUMMY:
        if ( SRandom(1, 100) < 20 )
          goto LABEL_97;
        break;
      case CREATURE_ROYAL_MUMMY:
        if ( SRandom(1, 100) < 30 )
        {
LABEL_97:
          if ( primaryTarget && army::SpellCastWorks(primaryTarget, SPELL_CURSE) )
            primaryTarget->spellEnemyCreatureAbilityIsCasting = SPELL_CURSE;
        }
        break;
      case CREATURE_ARCHMAGE:
        if ( SRandom(1, 100) < 20 && primaryTarget && army::SpellCastWorks(primaryTarget, SPELL_ARCHMAGI_DISPEL) )
          primaryTarget->spellEnemyCreatureAbilityIsCasting = SPELL_ARCHMAGI_DISPEL;
        break;
      case CREATURE_GHOST:
        gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner] = creaturesKilled;
        break;
      case CREATURE_VAMPIRE_LORD:
        LODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner]) = LODWORD(creaturesKilled) * primaryTarget->creature.hp;
        break;
      case CREATURE_SPRITE:
      case CREATURE_DWARF:
      case CREATURE_BATTLE_DWARF:
      case CREATURE_ELF:
      case CREATURE_GRAND_ELF:
      case CREATURE_DRUID:
      case CREATURE_GREATER_DRUID:
      case CREATURE_PHOENIX:
      case CREATURE_CENTAUR:
      case CREATURE_GARGOYLE:
      case CREATURE_GRIFFIN:
      case CREATURE_MINOTAUR:
      case CREATURE_MINOTAUR_KING:
      case CREATURE_HYDRA:
      case CREATURE_GREEN_DRAGON:
      case CREATURE_RED_DRAGON:
      case CREATURE_BLACK_DRAGON:
      case CREATURE_HALFLING:
      case CREATURE_BOAR:
      case CREATURE_IRON_GOLEM:
      case CREATURE_STEEL_GOLEM:
      case CREATURE_ROC:
      case CREATURE_MAGE:
      case CREATURE_GIANT:
      case CREATURE_TITAN:
      case CREATURE_SKELETON:
      case CREATURE_ZOMBIE:
      case CREATURE_MUTANT_ZOMBIE:
      case CREATURE_VAMPIRE:
      case CREATURE_LICH:
      case CREATURE_POWER_LICH:
      case CREATURE_BONE_DRAGON:
      case CREATURE_ROGUE:
      case CREATURE_NOMAD:
      case CREATURE_GENIE:
        break;
    }
    army::PowEffect(this, -1, 0, -1, -1);
    combatManager::CombatMessage(gpCombatManager, &message, 1, 1, 0);
    gpCombatManager->limitCreature[this->owningSide][this->stackIdx] = 1;
    if ( this->creatureIdx == CREATURE_GHOST )
      this->quantity += LODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner]);
    if ( this->creatureIdx == CREATURE_VAMPIRE_LORD )
    {
      if ( SLODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner]) >= this->damage )
      {
        v5 = gpCombatManager->combatGrid[this->occupiedHex].unitOwner;
        LODWORD(gpCombatManager->ghostAndVampireAbilityStrength[v5]) -= this->damage;
        this->damage = 0;
        v11 = SLODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner])
            / this->creature.hp;
        if ( this->initialQuantity - this->quantity <= v11 )
          this->quantity = this->initialQuantity;
        else
          this->quantity += v11;
      }
      else
      {
        this->damage -= LODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[this->occupiedHex].unitOwner]);
      }
    }
    if ( primaryTarget
      && primaryTarget->quantity > 0
      && !primaryTarget->effectStrengths[6]
      && !primaryTarget->effectStrengths[11]
      && (primaryTarget->creatureIdx == CREATURE_GRIFFIN || !(primaryTarget->creature.creature_flags & RETALIATED))
      && this->creatureIdx != CREATURE_ROGUE
      && this->creatureIdx != CREATURE_SPRITE
      && this->creatureIdx != CREATURE_VAMPIRE
      && this->creatureIdx != CREATURE_VAMPIRE_LORD
      && !enemyIncapacitated
      && !isRetaliationOrSecondAttack )
    {
      DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 150.0));
      primaryTarget->targetNeighborIdx = OppositeDirection(this->targetNeighborIdx);
      if ( primaryTarget->creature.creature_flags & TWO_HEXER )
      {
        if ( this->occupiedHex == army::GetAdjacentCellIndex(
                                    this,
                                    primaryTarget->occupiedHex,
                                    (unsigned int)(primaryTarget->facingRight - 1) < 1 ? 0 : 5) )
          primaryTarget->targetNeighborIdx = 6;
        if ( this->occupiedHex == army::GetAdjacentCellIndex(
                                    this,
                                    primaryTarget->occupiedHex,
                                    3 - ((unsigned int)(primaryTarget->facingRight - 1) < 1)) )
          primaryTarget->targetNeighborIdx = 7;
      }
      army::DoAttack(primaryTarget, 1);
      *(_DWORD *)&primaryTarget->creature.creature_flags |= RETALIATED;
      if ( gbRemoteOn
        && gpCombatManager->involvedInBadMorale[0]
        && gpCombatManager->involvedInBadMorale[1]
        && primaryTarget->creatureIdx == CREATURE_GHOST )
        primaryTarget->quantity += LODWORD(gpCombatManager->ghostAndVampireAbilityStrength[gpCombatManager->combatGrid[primaryTarget->occupiedHex].unitOwner]);
    }
    if ( (this->creatureIdx == CREATURE_WOLF
       || this->creatureIdx == CREATURE_PALADIN
       || this->creatureIdx == CREATURE_CRUSADER)
      && primaryTarget
      && primaryTarget->quantity > 0
      && !isRetaliationOrSecondAttack
      && !this->effectStrengths[6]
      && !this->effectStrengths[11]
      && !this->effectStrengths[2]
      && this->quantity > 0 )
    {
      DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 100.0));
      v16 = this->targetNeighborIdx;
      this->targetNeighborIdx = v18;
      army::DoAttack(this, 1);
      this->targetNeighborIdx = v16;
    }
    if ( this->facingRight != oldFacingRight )
    {
      if ( !(this->creature.creature_flags & DEAD) )
      {
        this->facingRight = oldFacingRight;
        if ( this->creature.creature_flags & TWO_HEXER )
        {
          if ( oldFacingRight == 1 )
            --this->occupiedHex;
          else
            ++this->occupiedHex;
        }
      }
      if ( !(primaryTarget->creature.creature_flags & DEAD) )
      {
        if ( primaryTarget->facingRight != targetOldFacingRight )
        {
          primaryTarget->facingRight = targetOldFacingRight;
          if ( primaryTarget->creature.creature_flags & TWO_HEXER )
          {
            if ( primaryTarget->facingRight == 1 )
              --primaryTarget->occupiedHex;
            else
              ++primaryTarget->occupiedHex;
          }
        }
      }
    }
  }
  if ( !isRetaliationOrSecondAttack && (this->effectStrengths[5] || this->effectStrengths[7]) )
  {
    army::CancelSpellType(this, CREATURE_TOOK_TURN_EVENT_CODE);
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
  }
  targetHex = -1;
  this->targetOwner = -1;
  if ( isRetaliationOrSecondAttack )
    gpCombatManager->currentActionSide = 1 - gpCombatManager->currentActionSide;
}
// 4F7494: using guessed type int gbRemoteOn;
// 5240A8: using guessed type int gpSoundManager;
// 52FAFC: using guessed type int gbGenieHalf;

//----- (0047FAA0) --------------------------------------------------------
void __cdecl army::ResetPath()
{
  ;
}

//----- (0047FAC0) --------------------------------------------------------
signed int __thiscall army::WalkTo(army *this)
{
  return army::WalkTo(this, this->targetHex);
}

//----- (0047FAF0) --------------------------------------------------------
signed int __thiscall army::WalkTo(army *this, int hex)
{
  signed int result; // eax@33
  signed int onEnemySideOfMoat; // [sp+10h] [bp-14h]@9
  signed int moatIdx; // [sp+14h] [bp-10h]@3
  signed int goingToMoat; // [sp+18h] [bp-Ch]@3
  signed int v7; // [sp+1Ch] [bp-8h]@34
  signed int i; // [sp+20h] [bp-4h]@3
  signed int j; // [sp+20h] [bp-4h]@17
  int hexIdxb; // [sp+20h] [bp-4h]@34

  this->targetStackIdx = -1;
  this->targetOwner = this->targetStackIdx;
  if ( gpCombatManager->hasMoat && this->creature.creature_flags & TWO_HEXER )
  {
    goingToMoat = 0;
    moatIdx = 0;
    for ( i = 0; i < 9; ++i )
    {
      if ( moatCell[i] == hex )
      {
        goingToMoat = 1;
        moatIdx = i;
      }
    }
    if ( goingToMoat )
    {
      onEnemySideOfMoat = 0;
      if ( moatIdx == 4 && gpCombatManager->drawBridgePosition != 4 )
        onEnemySideOfMoat = 1;
      if ( moatIdx > 0 && *((_BYTE *)&giWalkingYMod + moatIdx + 3) == this->occupiedHex// moatCell[moatIdx-1]
        || moatIdx < 8 && moatCell[moatIdx + 1] == this->occupiedHex )
        onEnemySideOfMoat = 1;
      for ( j = 0; j < 6; ++j )
      {
        if ( moatCell[moatIdx] == army::GetAdjacentCellIndex(this, this->occupiedHex, j) )
          onEnemySideOfMoat = 1;
      }
      if ( !this->owningSide && moatCell[this->occupiedHex / 13] < this->occupiedHex )
        onEnemySideOfMoat = 1;
      if ( this->owningSide == 1 && moatCell[this->occupiedHex / 13] > this->occupiedHex )
        onEnemySideOfMoat = 1;
      if ( !onEnemySideOfMoat )
      {
        if ( this->facingRight == 1 )
          --hex;
        else
          ++hex;
      }
    }
  }
  if ( army::FindPath(this, this->occupiedHex, hex, this->creature.speed, 1, 0) )
  {
    v7 = 0;
    for ( hexIdxb = gpSearchArray->field_8 - 1; hexIdxb >= 0; --hexIdxb )
    {
      army::Walk(this, *((_BYTE *)&gpSearchArray->field_2418 + hexIdxb), 0, gpSearchArray->field_8 - 1 != hexIdxb);
      ++v7;
      if ( this->creature.speed <= v7 )
        hexIdxb = -1;
    }
    army::CancelSpellType(this, 0);
    this->animationType = ANIMATION_TYPE_STANDING;
    this->animationFrame = 0;
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    combatManager::TestRaiseDoor(gpCombatManager);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}
// 4F5474: using guessed type int giWalkingYMod;

//----- (0047FDE0) --------------------------------------------------------
signed int __thiscall army::AttackTo(army *this)
{
  return army::AttackTo(this, this->targetHex);
}

//----- (0047FE10) --------------------------------------------------------
signed int __thiscall army::AttackTo(army *this, signed int targetHex)
{
  signed int result; // eax@4
  army *thisa; // [sp+Ch] [bp-10h]@1
  int a3; // [sp+10h] [bp-Ch]@15
  signed int v5; // [sp+14h] [bp-8h]@11
  int i; // [sp+18h] [bp-4h]@11

  thisa = this;
  if ( this->creature.creature_flags & FLYER )
  {
    if ( this->occupiedHex != targetHex )
      army::FlyTo(this, targetHex);
    army::DoAttack(thisa, 0);
    result = 0;
  }
  else if ( this->creature.creature_flags & TWO_HEX_ATTACKER && this->occupiedHex == this->targetHex )
  {
    army::DoAttack(this, 0);
    result = 0;
  }
  else if ( army::FindPath(this, this->occupiedHex, targetHex, this->creature.speed, 1, 0) )
  {
    if ( gpSearchArray->field_8 == 1 )
    {
      thisa->targetNeighborIdx = LOBYTE(gpSearchArray->field_2418);
      combatManager::TestRaiseDoor(gpCombatManager);
      army::DoAttack(thisa, 0);
    }
    else
    {
      v5 = 0;
      for ( i = gpSearchArray->field_8 - 1; i; --i )
      {
        ++v5;
        a3 = i == 1 || thisa->creature.speed <= v5;
        army::Walk(thisa, *((_BYTE *)&gpSearchArray->field_2418 + i), a3, gpSearchArray->field_8 - 1 != i);
        if ( thisa->creature.speed <= v5 && i != 1 )
          return 3;
      }
      army::CancelSpellType(thisa, 0);
      thisa->targetNeighborIdx = LOBYTE(gpSearchArray->field_2418);
      combatManager::TestRaiseDoor(gpCombatManager);
      army::DoAttack(thisa, 0);
    }
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (00480000) --------------------------------------------------------
void __thiscall army::CheckLuck(army *this)
{
  double v1; // st6@0
  double v2; // st7@0
  char *v4; // [sp+10h] [bp-18h]@18
  char *v5; // [sp+14h] [bp-14h]@14
  __int64 samp; // [sp+20h] [bp-8h]@12

  this->luckStatus = 0;
  if ( gpCombatManager->heroes[this->owningSide] )
  {
    if ( this->luck > 0 && SRandom(1, 24) <= this->luck )
      this->luckStatus = 1;
    if ( this->luck < 0 && SRandom(1, 24) < -this->luck )
      this->luckStatus = -1;
    if ( this->luckStatus )
    {
      if ( this->luckStatus >= 0 )
        sprintf(gText, "goodluck.82m");
      else
        sprintf(gText, "badluck.82m");
      samp = LoadPlaySample(gText);
      if ( this->luckStatus >= 0 )
      {
        if ( this->quantity <= 1 )
          v4 = gArmyNames[this->creatureIdx];
        else
          v4 = gArmyNamesPlural[this->creatureIdx];
        sprintf(gText, "Good luck shines on the %s", v4);
        combatManager::CombatMessage(gpCombatManager, gText, 1, 1, 0);
        combatManager::DoLuck(gpCombatManager, v1, v2, this->owningSide, this->stackIdx);
      }
      else
      {
        if ( this->quantity <= 1 )
          v5 = gArmyNames[this->creatureIdx];
        else
          v5 = gArmyNamesPlural[this->creatureIdx];
        sprintf(gText, "Bad luck descends on the %s", v5);
        combatManager::CombatMessage(gpCombatManager, gText, 1, 1, 0);
        army::SpellEffect(this, ANIM_CLOUD_LUCK_IDX, 180, 0);
      }
      WaitEndSample((void *)0xFFFFFFFF, (resource *)samp, HIDWORD(samp));
      if ( this->luckStatus > 0 )
      {
        combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
        mouseManager::ShowColorPointer(gpMouseManager);
      }
    }
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (00480290) --------------------------------------------------------
void __thiscall army::DamageEnemy(army *this, army *targ, int *damageDone, int *creaturesKilled, int isRanged, int a6)
{
  army *thisa; // [sp+18h] [bp-28h]@1
  int v7; // [sp+1Ch] [bp-24h]@65
  int othHex; // [sp+20h] [bp-20h]@17
  hero *owningHero; // [sp+24h] [bp-1Ch]@47
  float damagePerUnit; // [sp+2Ch] [bp-14h]@2
  float damagePerUnita; // [sp+2Ch] [bp-14h]@29
  int i; // [sp+30h] [bp-10h]@2
  signed int j; // [sp+30h] [bp-10h]@19
  int baseDam; // [sp+34h] [bp-Ch]@63
  int attackDiff; // [sp+3Ch] [bp-4h]@10

  thisa = this;
  if ( targ )
  {
    damagePerUnit = 0.0;
    gbGenieHalf = 0;
    for ( i = 0; thisa->quantity > i; ++i )
    {
      if ( thisa->effectStrengths[3] )
      {
        damagePerUnit = (double)thisa->creature.max_damage + damagePerUnit;
      }
      else if ( thisa->effectStrengths[4] )
      {
        damagePerUnit = (double)thisa->creature.min_damage + damagePerUnit;
      }
      else
      {
        damagePerUnit = (double)SRandom(thisa->creature.min_damage, thisa->creature.max_damage) + damagePerUnit;
      }
    }
    attackDiff = thisa->creature.attack - (a6 + targ->creature.defense);
    if ( thisa->effectStrengths[8]
      && (targ->creatureIdx == CREATURE_GREEN_DRAGON
       || targ->creatureIdx == CREATURE_RED_DRAGON
       || targ->creatureIdx == CREATURE_BLACK_DRAGON
       || targ->creatureIdx == CREATURE_BONE_DRAGON) )
      attackDiff += 5;
    if ( gpCombatManager->hasMoat )
    {
      othHex = -1;
      if ( targ->creature.creature_flags & TWO_HEXER )
        othHex = targ->occupiedHex + ((unsigned int)(targ->facingRight - 1) < 1 ? 1 : -1);
      for ( j = 0; j < 9; ++j )
      {
        if ( moatCell[j] == targ->occupiedHex || moatCell[j] == othHex )
          attackDiff += 3;
      }
    }
    if ( attackDiff > 20 )
      attackDiff = 20;
    if ( attackDiff < -20 )
      attackDiff = -20;
    damagePerUnita = gfBattleStat[attackDiff + 20] * damagePerUnit;
    if ( thisa->creatureIdx == CREATURE_CRUSADER && HIBYTE(targ->creature.creature_flags) & ATTR_UNDEAD
      || thisa->creatureIdx == CREATURE_EARTH_ELEMENTAL && targ->creatureIdx == CREATURE_AIR_ELEMENTAL
      || thisa->creatureIdx == CREATURE_AIR_ELEMENTAL && targ->creatureIdx == CREATURE_EARTH_ELEMENTAL
      || thisa->creatureIdx == CREATURE_WATER_ELEMENTAL && targ->creatureIdx == CREATURE_FIRE_ELEMENTAL
      || thisa->creatureIdx == CREATURE_FIRE_ELEMENTAL && targ->creatureIdx == CREATURE_WATER_ELEMENTAL )
      damagePerUnita = damagePerUnita * 2.0;
    if ( thisa->luckStatus > 0 )
      damagePerUnita = damagePerUnita * 2.0;
    if ( thisa->luckStatus < 0 )
      damagePerUnita = damagePerUnita / 2.0;
    thisa->luckStatus = 0;
    if ( isRanged
      && combatManager::ShotIsThroughWall(gpCombatManager, thisa->owningSide, thisa->occupiedHex, targ->occupiedHex) )
      damagePerUnita = damagePerUnita / 2.0;
    owningHero = gpCombatManager->heroes[thisa->owningSide];
    if ( owningHero && isRanged )
      damagePerUnita = gfSSArcheryMod[owningHero->secondarySkillLevel[1]] * damagePerUnita;
    if ( thisa->creature.creature_flags & SHOOTER
      && !isRanged
      && thisa->creatureIdx != CREATURE_TITAN
      && thisa->creatureIdx != CREATURE_MAGE
      && thisa->creatureIdx != CREATURE_ARCHMAGE )
      damagePerUnita = damagePerUnita / 2.0;
    if ( isRanged && targ->effectStrengths[10] )
      damagePerUnita = damagePerUnita / 2.0;
    if ( thisa->otherBadLuckThing == 2 )
      damagePerUnita = damagePerUnita / 2.0;
    thisa->otherBadLuckThing = 0;
    if ( targ->effectStrengths[11] )
      damagePerUnita = damagePerUnita / 2.0;
    baseDam = (signed __int64)(damagePerUnita + 0.5);
    if ( thisa->creatureIdx == CREATURE_GENIE )
    {
      if ( SRandom(1, 5) == 2 )
      {
        v7 = targ->creature.hp * ((targ->quantity + 1) / 2);
        if ( baseDam < v7 )
        {
          gbGenieHalf = 1;
          baseDam = v7;
        }
      }
    }
    if ( baseDam <= 0 )
      baseDam = 1;
    if ( HIBYTE(targ->creature.creature_flags) & ATTR_MIRROR_IMAGE )
      baseDam = -1;
    *damageDone = baseDam;
    *creaturesKilled = army::Damage(targ, baseDam, SPELL_NONE);
  }
}
// 52FAFC: using guessed type int gbGenieHalf;

//----- (00480780) --------------------------------------------------------
int __thiscall army::Damage(army *this, signed int baseDam, Spell spell)
{
  int v3; // ST20_4@13
  army *thisa; // [sp+Ch] [bp-10h]@1
  int losses; // [sp+14h] [bp-8h]@5

  thisa = this;
  baseDam += this->damage;
  if ( spell != SPELL_NONE )
  {
    if ( gbRemoteOn )
      combatManager::ModifyDamageForArtifacts(
        &baseDam,
        spell,
        gpCombatManager->heroes[this->owningSide],
        gpCombatManager->heroes[gpCombatManager->currentActionSide]);
    else
      combatManager::ModifyDamageForArtifacts(
        &baseDam,
        spell,
        gpCombatManager->heroes[gpCombatManager->currentActionSide],
        gpCombatManager->heroes[this->owningSide]);
  }
  losses = baseDam / thisa->creature.hp;
  thisa->damage = baseDam % thisa->creature.hp;
  if ( HIBYTE(thisa->creature.creature_flags) & ATTR_MIRROR_IMAGE )
  {
    losses = thisa->quantity;
    thisa->damage = 0;
  }
  thisa->damageTakenDuringSomeTimePeriod = 1;
  if ( losses > 0 )
  {
    thisa->hasTakenLosses = 1;
    thisa->previousQuantity = thisa->quantity;
  }
  if ( thisa->quantity < losses )
    losses = thisa->quantity;
  thisa->quantity -= losses;
  if ( thisa->quantity <= 0 )
    thisa->dead = 1;
  v3 = thisa->facingRight;
  thisa->facingRight = gpCombatManager->creatures[gpCombatManager->activeStackOwner][gpCombatManager->activeStack].facingRight ^ 1;// Checked assembly; looks correct. Wow, this is odd!
  thisa->facingRight = v3;
  army::CancelSpellType(thisa, CREATURE_TOOK_DAMAGE_CODE);
  return losses;
}
// 4F7494: using guessed type int gbRemoteOn;

//----- (004809C0) --------------------------------------------------------
void __thiscall army::PowEffect(army *this, int animIdx, int a3, int a4, int a5)
{
  int tmp1; // eax@35
  int tmp2; // eax@37
  int tmp3; // eax@39
  int tmp4; // eax@43
  int tmp5; // eax@45
  int tmp6; // eax@47
  int v11; // eax@70
  int v12; // eax@72
  int v13; // eax@74
  int v14; // eax@76
  int v15; // eax@79
  int v16; // eax@81
  signed int v17; // eax@83
  signed int v18; // eax@85
  IconEntry *animICNHeader; // [sp+20h] [bp-44h]@70
  int maxAnyCreatureAnimLen; // [sp+24h] [bp-40h]@45
  int maxAnyCreatureAnimLena; // [sp+24h] [bp-40h]@47
  signed int i; // [sp+28h] [bp-3Ch]@10
  signed int k; // [sp+28h] [bp-3Ch]@25
  signed int m; // [sp+28h] [bp-3Ch]@51
  signed int jj; // [sp+28h] [bp-3Ch]@88
  signed int mm; // [sp+28h] [bp-3Ch]@110
  signed int i1; // [sp+28h] [bp-3Ch]@161
  signed int i3; // [sp+28h] [bp-3Ch]@173
  signed int i5; // [sp+28h] [bp-3Ch]@210
  signed int i7; // [sp+28h] [bp-3Ch]@220
  signed int i9; // [sp+28h] [bp-3Ch]@229
  int fromAnimLen; // [sp+2Ch] [bp-38h]@1
  int maxOneWayAnimLen; // [sp+30h] [bp-34h]@1
  army *othstack; // [sp+38h] [bp-2Ch]@29
  army *thisc; // [sp+38h] [bp-2Ch]@92
  army *thisd; // [sp+38h] [bp-2Ch]@114
  char *thise; // [sp+38h] [bp-2Ch]@165
  char *thisf; // [sp+38h] [bp-2Ch]@177
  army *thisg; // [sp+38h] [bp-2Ch]@224
  signed int v41; // [sp+3Ch] [bp-28h]@171
  int j; // [sp+40h] [bp-24h]@12
  int l; // [sp+40h] [bp-24h]@27
  int n; // [sp+40h] [bp-24h]@53
  signed int ii; // [sp+40h] [bp-24h]@68
  int kk; // [sp+40h] [bp-24h]@90
  int nn; // [sp+40h] [bp-24h]@112
  int i2; // [sp+40h] [bp-24h]@163
  int i4; // [sp+40h] [bp-24h]@175
  int i6; // [sp+40h] [bp-24h]@212
  int i8; // [sp+40h] [bp-24h]@222
  int i10; // [sp+40h] [bp-24h]@231
  signed int doCreatureEffect; // [sp+44h] [bp-20h]@1
  int ll; // [sp+48h] [bp-1Ch]@108
  int oneWayAnimLen; // [sp+4Ch] [bp-18h]@1
  int maxToAnimLen; // [sp+50h] [bp-14h]@1
  int maxFromAnimLen; // [sp+54h] [bp-10h]@1
  int toAnimLen; // [sp+58h] [bp-Ch]@1
  signed int specialCaseOverlapWeirdness; // [sp+5Ch] [bp-8h]@1
  int creatureEffectNumFrames; // [sp+60h] [bp-4h]@1
  int maxAnimLen; // [sp+60h] [bp-4h]@49

  maxToAnimLen = 0;
  maxFromAnimLen = 0;
  maxOneWayAnimLen = 0;
  creatureEffectNumFrames = 0;
  toAnimLen = 0;
  fromAnimLen = 0;
  oneWayAnimLen = 0;
  doCreatureEffect = 0;
  specialCaseOverlapWeirdness = 1;
  if ( this->creatureIdx == CREATURE_PALADIN || this->creatureIdx == CREATURE_CRUSADER )
    specialCaseOverlapWeirdness = 0;
  if ( this->creatureIdx == CREATURE_DWARF || this->creatureIdx == CREATURE_BATTLE_DWARF )
    specialCaseOverlapWeirdness = 2;
  if ( a4 == -1 )
  {
    if ( animIdx != -1 )
    {
      for ( i = 0; i < 2; ++i )
      {
        for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
        {
          if ( gpCombatManager->creatures[i][j].probablyIsNeedDrawSpellEffect )
            doCreatureEffect = 1;
        }
      }
    }
  }
  else
  {
    doCreatureEffect = 1;
  }
  if ( !gbNoShowCombat && animIdx != -1 && doCreatureEffect && animIdx != gCurLoadedSpellEffect )
  {
    resourceManager::Dispose(gpResourceManager, (resource *)gCurLoadedSpellIcon);
    gCurLoadedSpellIcon = resourceManager::GetIcon(gpResourceManager, gCombatFxNames[animIdx]);
    gCurLoadedSpellEffect = animIdx;
  }
  if ( doCreatureEffect )
    creatureEffectNumFrames = giNumPowFrames[gCurLoadedSpellEffect];
  for ( k = 0; k < 2; ++k )
  {
    for ( l = 0; gpCombatManager->numCreatures[k] > l; ++l )
    {
      othstack = &gpCombatManager->creatures[k][l];
      if ( gpCombatManager->creatures[k][l].mightBeIsAttacking )
      {
        toAnimLen = othstack->frameInfo.animationLengths[this->mightBeAttackAnimIdx];
        fromAnimLen = othstack->frameInfo.animationLengths[this->mightBeAttackAnimIdx + 1] + 1;
      }
      else if ( gpCombatManager->creatures[k][l].dead )
      {
        oneWayAnimLen = gpCombatManager->creatures[k][l].frameInfo.animationLengths[13];
      }
      else if ( gpCombatManager->creatures[k][l].damageTakenDuringSomeTimePeriod )
      {
        oneWayAnimLen = gpCombatManager->creatures[k][l].frameInfo.animationLengths[15]
                      + gpCombatManager->creatures[k][l].frameInfo.animationLengths[14]
                      + 1;
      }
      tmp1 = maxToAnimLen;
      if ( maxToAnimLen <= toAnimLen )
        tmp1 = toAnimLen;
      maxToAnimLen = tmp1;
      tmp2 = maxFromAnimLen;
      if ( maxFromAnimLen <= fromAnimLen )
        tmp2 = fromAnimLen;
      maxFromAnimLen = tmp2;
      tmp3 = maxOneWayAnimLen;
      if ( maxOneWayAnimLen <= oneWayAnimLen )
        tmp3 = oneWayAnimLen;
      maxOneWayAnimLen = tmp3;
    }
  }
  tmp4 = maxOneWayAnimLen + maxToAnimLen - specialCaseOverlapWeirdness;
  if ( tmp4 <= maxFromAnimLen + maxToAnimLen )
    tmp4 = maxFromAnimLen + maxToAnimLen;
  maxAnyCreatureAnimLen = tmp4;
  tmp5 = maxOneWayAnimLen;
  if ( maxOneWayAnimLen <= maxAnyCreatureAnimLen )
    tmp5 = maxAnyCreatureAnimLen;
  maxAnyCreatureAnimLena = tmp5;
  tmp6 = creatureEffectNumFrames;
  if ( creatureEffectNumFrames <= maxAnyCreatureAnimLena )
    tmp6 = maxAnyCreatureAnimLena;
  maxAnimLen = tmp6;
  if ( a3 )
    combatManager::ResetLimitCreature(gpCombatManager);
  for ( m = 0; m < 2; ++m )
  {
    for ( n = 0; gpCombatManager->numCreatures[m] > n; ++n )
    {
      gpCombatManager->creatures[m][n].animatingRangedAttack = gpCombatManager->creatures[m][n].animationType == ANIMATION_TYPE_RANGED_ATTACK_UPWARDS
                                                            || gpCombatManager->creatures[m][n].animationType == ANIMATION_TYPE_RANGED_ATTACK_FORWARDS
                                                            || gpCombatManager->creatures[m][n].animationType == ANIMATION_TYPE_RANGED_ATTACK_DOWNWARDS;
      if ( (gpCombatManager->creatures[m][n].damageTakenDuringSomeTimePeriod
         || gpCombatManager->creatures[m][n].mightBeIsAttacking
         || gpCombatManager->creatures[m][n].animatingRangedAttack)
        && !gpCombatManager->limitCreature[m][n] )
        ++gpCombatManager->limitCreature[m][n];
    }
  }
  combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
  if ( a4 != -1 )
  {
    for ( ii = 0; gCurLoadedSpellIcon->numSprites > ii; ++ii )
    {
      animICNHeader = &gCurLoadedSpellIcon->headersAndImageData[ii];
      v11 = a4 + animICNHeader->offsetX;
      if ( v11 >= giMinExtentX )
        v11 = giMinExtentX;
      giMinExtentX = v11;
      v12 = a5 + animICNHeader->offsetY;
      if ( v12 >= giMinExtentY )
        v12 = giMinExtentY;
      giMinExtentY = v12;
      v13 = a4 + animICNHeader->offsetX + animICNHeader->width - 1;
      if ( v13 <= giMaxExtentX )
        v13 = giMaxExtentX;
      giMaxExtentX = v13;
      v14 = a5 + animICNHeader->height + animICNHeader->offsetY - 1;
      if ( v14 <= giMaxExtentY )
        v14 = giMaxExtentY;
      giMaxExtentY = v14;
    }
    v15 = giMinExtentX;
    if ( giMinExtentX <= 0 )
      v15 = 0;
    giMinExtentX = v15;
    v16 = giMinExtentY;
    if ( giMinExtentY <= 0 )
      v16 = 0;
    giMinExtentY = v16;
    v17 = giMaxExtentX;
    if ( giMaxExtentX >= 639 )
      v17 = 639;
    giMaxExtentX = v17;
    v18 = giMaxExtentY;
    if ( giMaxExtentY >= 442 )
      v18 = 442;
    giMaxExtentY = v18;
  }
  for ( jj = 0; jj < 2; ++jj )
  {
    for ( kk = 0; gpCombatManager->numCreatures[jj] > kk; ++kk )
    {
      thisc = &gpCombatManager->creatures[jj][kk];
      gpCombatManager->creatures[jj][kk].field_3 = -1;
      thisc->field_4 = -1;
      *(_DWORD *)&thisc->effectStrengths[15] = 0;
      if ( thisc->damageTakenDuringSomeTimePeriod || thisc->mightBeIsAttacking )
      {
        if ( thisc->mightBeIsAttacking )
        {
          thisc->field_3 = this->mightBeAttackAnimIdx;
          thisc->field_4 = this->mightBeAttackAnimIdx + 1;
        }
        else if ( thisc->dead )
        {
          thisc->field_3 = ANIMATION_TYPE_DYING;
        }
        else
        {
          thisc->field_3 = ANIMATION_TYPE_WINCE;
          thisc->field_4 = ANIMATION_TYPE_WINCE_RETURN;
        }
        if ( thisc->field_3 == 13 )
          thisc->field_5 = thisc->frameInfo.animationLengths[13];
        else
          thisc->field_5 = thisc->frameInfo.animationLengths[thisc->field_3]
                         + thisc->frameInfo.animationLengths[thisc->field_3 + 1];
        if ( thisc->field_3 == thisc->animationType )
          --thisc->field_5;
        if ( this->field_6 < 2 )
          this->field_6 = 2;
      }
    }
  }
  for ( ll = 0; maxAnimLen > ll; ++ll )
  {
    for ( mm = 0; mm < 2; ++mm )
    {
      for ( nn = 0; gpCombatManager->numCreatures[mm] > nn; ++nn )
      {
        thisd = &gpCombatManager->creatures[mm][nn];
        if ( gpCombatManager->creatures[mm][nn].animatingRangedAttack )
        {
          if ( gpCombatManager->creatures[mm][nn].animationType != ANIMATION_TYPE_RANGED_ATTACK_UPWARDS
            && gpCombatManager->creatures[mm][nn].animationType != ANIMATION_TYPE_RANGED_ATTACK_FORWARDS
            && gpCombatManager->creatures[mm][nn].animationType != ANIMATION_TYPE_RANGED_ATTACK_DOWNWARDS )
          {
            if ( gpCombatManager->creatures[mm][nn].animationType != ANIMATION_TYPE_STANDING )
            {
              if ( gpCombatManager->creatures[mm][nn].frameInfo.animationLengths[gpCombatManager->creatures[mm][nn].animationType] <= gpCombatManager->creatures[mm][nn].animationFrame + 1 )
              {
                gpCombatManager->creatures[mm][nn].animationType = ANIMATION_TYPE_STANDING;
                thisd->animationFrame = 0;
              }
              else
              {
                ++gpCombatManager->creatures[mm][nn].animationFrame;
              }
            }
          }
          else
          {
            ++gpCombatManager->creatures[mm][nn].animationType;
            thisd->animationFrame = 0;
          }
        }
        if ( thisd->field_3 != -1
          && !*(_DWORD *)&thisd->effectStrengths[15]
          && (thisd->mightBeIsAttacking
           || thisd->field_5 >= maxAnimLen - ll - 1
           || maxToAnimLen && maxToAnimLen - 1 <= ll
           || !maxToAnimLen
           && thisd->animationType != 15
           && (thisd->animationType != 14
            || thisd->frameInfo.animationLengths[thisd->animationType] > thisd->animationFrame + 1)) )
        {
          if ( thisd->field_3 == thisd->animationType || thisd->field_4 == thisd->animationType )
          {
            if ( thisd->frameInfo.animationLengths[thisd->animationType] <= thisd->animationFrame + 1 )
            {
              if ( thisd->field_4 == thisd->animationType || thisd->field_4 == -1 )
              {
                if ( thisd->animationType != 7 && thisd->animationType != 13 )
                {
                  thisd->animationType = 7;
                  thisd->animationFrame = 0;
                  *(_DWORD *)&thisd->effectStrengths[15] = 1;
                }
              }
              else
              {
                thisd->animationType = thisd->field_4;
                thisd->animationFrame = 0;
              }
            }
            else
            {
              ++thisd->animationFrame;
            }
          }
          else
          {
            if ( !gbNoShowCombat && thisd->field_3 == 14 )
              soundManager::MemorySample(
                (soundManager *)gpSoundManager,
                gpCombatManager->creatures[mm][nn].combatSounds[2]);
            if ( !gbNoShowCombat && thisd->field_3 == 13 )
              soundManager::MemorySample(
                (soundManager *)gpSoundManager,
                gpCombatManager->creatures[mm][nn].combatSounds[4]);
            thisd->animationType = thisd->field_3;
            thisd->animationFrame = 0;
          }
        }
      }
    }
    glTimers = (signed __int64)((double)KBTickCount() + (double)120 * gfCombatSpeedMod[giCombatSpeed]);
    if ( doCreatureEffect && giNumPowFrames[gCurLoadedSpellEffect] > ll )
      gCurSpellEffectFrame = ll;
    combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 0, 75, 1, 1);
    if ( a4 != -1 && giNumPowFrames[gCurLoadedSpellEffect] > ll )
      icon::CombatClipDrawToBuffer(
        gCurLoadedSpellIcon,
        a4,
        a5 + this->field_FA,
        gCurSpellEffectFrame,
        &this->effectAnimationBounds,
        0,
        0,
        0,
        0);
    heroWindowManager::UpdateScreenRegion(
      gpWindowManager,
      giMinExtentX,
      giMinExtentY,
      giMaxExtentX - giMinExtentX + 1,
      giMaxExtentY - giMinExtentY + 1);
  }
  if ( !gbNoShowCombat )
    army::WaitSample(1);
  for ( i1 = 0; i1 < 2; ++i1 )
  {
    for ( i2 = 0; gpCombatManager->numCreatures[i1] > i2; ++i2 )
    {
      thise = (char *)&gpCombatManager->creatures[i1][i2];
      if ( gpCombatManager->creatures[i1][i2].damageTakenDuringSomeTimePeriod
        && gpCombatManager->creatures[i1][i2].spellEnemyCreatureAbilityIsCasting != -1
        && gpCombatManager->creatures[i1][i2].spellEnemyCreatureAbilityIsCasting != 101 )
      {
        combatManager::CastSpell(
          gpCombatManager,
          (Spell)gpCombatManager->creatures[i1][i2].spellEnemyCreatureAbilityIsCasting,
          gpCombatManager->creatures[i1][i2].occupiedHex,
          1,
          -1);
        *(_DWORD *)(thise + 226) = -1;
      }
    }
  }
  v41 = 1;
  while ( v41 )
  {
    v41 = 0;
    for ( i3 = 0; i3 < 2; ++i3 )
    {
      for ( i4 = 0; gpCombatManager->numCreatures[i3] > i4; ++i4 )
      {
        thisf = (char *)&gpCombatManager->creatures[i3][i4];
        if ( gpCombatManager->creatures[i3][i4].animationType != 14
          && gpCombatManager->creatures[i3][i4].animationType != 16
          && gpCombatManager->creatures[i3][i4].animationType != 20
          && gpCombatManager->creatures[i3][i4].animationType != 24
          && gpCombatManager->creatures[i3][i4].animationType != 18
          && gpCombatManager->creatures[i3][i4].animationType != 22
          && gpCombatManager->creatures[i3][i4].animationType != 26
          && gpCombatManager->creatures[i3][i4].animationType != 28
          && gpCombatManager->creatures[i3][i4].animationType != 30
          && gpCombatManager->creatures[i3][i4].animationType != 32 )
        {
          if ( gpCombatManager->creatures[i3][i4].animationType == 13
            || gpCombatManager->creatures[i3][i4].animationType == 15
            || gpCombatManager->creatures[i3][i4].animationType == 17
            || gpCombatManager->creatures[i3][i4].animationType == 21
            || gpCombatManager->creatures[i3][i4].animationType == 25
            || gpCombatManager->creatures[i3][i4].animationType == 19
            || gpCombatManager->creatures[i3][i4].animationType == 23
            || gpCombatManager->creatures[i3][i4].animationType == 27
            || gpCombatManager->creatures[i3][i4].animationType == 29
            || gpCombatManager->creatures[i3][i4].animationType == 31
            || gpCombatManager->creatures[i3][i4].animationType == 33 )
          {
            if ( gpCombatManager->creatures[i3][i4].frameInfo.animationLengths[gpCombatManager->creatures[i3][i4].animationType] <= gpCombatManager->creatures[i3][i4].animationFrame + 1 )
            {
              if ( gpCombatManager->creatures[i3][i4].animationType != 13 )
              {
                gpCombatManager->creatures[i3][i4].animationType = 7;
                *(_DWORD *)(thisf + 130) = 0;
                v41 = 1;
              }
            }
            else
            {
              ++gpCombatManager->creatures[i3][i4].animationFrame;
              v41 = 1;
            }
          }
        }
        else
        {
          ++gpCombatManager->creatures[i3][i4].animationType;
          *(_DWORD *)(thisf + 130) = 0;
          v41 = 1;
        }
      }
    }
    if ( v41 )
    {
      glTimers = (signed __int64)((double)KBTickCount() + (double)120 * gfCombatSpeedMod[giCombatSpeed]);
      combatManager::DrawFrame(gpCombatManager, 1, 1, 0, 0, 75, 1, 1);
    }
  }
  if ( a3 )
    combatManager::ResetLimitCreature(gpCombatManager);
  memset(gpCombatManager->shouldVanish, 0, 0x28u);
  gpCombatManager->anyStacksShouldVanish = 0;
  for ( i5 = 0; i5 < 2; ++i5 )
  {
    for ( i6 = 0; gpCombatManager->numCreatures[i5] > i6; ++i6 )
    {
      if ( gpCombatManager->creatures[i5][i6].dead )
        army::ProcessDeath(&gpCombatManager->creatures[i5][i6], 0);
    }
  }
  if ( gpCombatManager->anyStacksShouldVanish )
    combatManager::MakeCreaturesVanish(gpCombatManager);
  for ( i7 = 0; i7 < 2; ++i7 )
  {
    for ( i8 = 0; gpCombatManager->numCreatures[i7] > i8; ++i8 )
    {
      thisg = &gpCombatManager->creatures[i7][i8];
      if ( gpCombatManager->creatures[i7][i8].damageTakenDuringSomeTimePeriod
        && gpCombatManager->creatures[i7][i8].spellEnemyCreatureAbilityIsCasting == 101 )
      {
        combatManager::CastSpell(
          gpCombatManager,
          (Spell)gpCombatManager->creatures[i7][i8].spellEnemyCreatureAbilityIsCasting,
          gpCombatManager->creatures[i7][i8].occupiedHex,
          1,
          -1);
        thisg->spellEnemyCreatureAbilityIsCasting = -1;
      }
      thisg->probablyIsNeedDrawSpellEffect = 0;
      thisg->damageTakenDuringSomeTimePeriod = 0;
      thisg->hasTakenLosses = 0;
      thisg->field_6 = 1;
      thisg->mightBeIsAttacking = 0;
      thisg->previousQuantity = -1;
    }
  }
  combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
  for ( i9 = 0; i9 < 2; ++i9 )
  {
    for ( i10 = 0; gpCombatManager->numCreatures[i9] > i10; ++i10 )
      army::WaitSample(2);
  }
}
// 518CFC: using guessed type int gbNoShowCombat;
// 5240A8: using guessed type int gpSoundManager;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (00481D30) --------------------------------------------------------
unsigned __int32 __thiscall army::Strength(army *this)
{
  return this->quantity * gMonsterDatabase[this->creatureIdx].fight_value;
}

//----- (00481D70) --------------------------------------------------------
bool __thiscall army::LeaveNoBody(army *this)
{
  return this->creatureIdx == CREATURE_EARTH_ELEMENTAL
      || this->creatureIdx == CREATURE_AIR_ELEMENTAL
      || this->creatureIdx == CREATURE_FIRE_ELEMENTAL
      || this->creatureIdx == CREATURE_WATER_ELEMENTAL
      || HIBYTE(this->creature.creature_flags) & ATTR_MIRROR_IMAGE;
}

//----- (00481DE0) --------------------------------------------------------
void __thiscall army::ProcessDeath(army *this, int a2)
{
  char *v2; // eax@29
  hexcell *hexTile; // [sp+18h] [bp-Ch]@6
  hexcell *secondHexTile; // [sp+1Ch] [bp-8h]@7
  int v6; // [sp+20h] [bp-4h]@6

  if ( !(this->creature.creature_flags & DEAD) )
  {
    if ( Random(0, 100) >= 60 )
    {
      if ( Random(0, 100) < 80 )
        gpCombatManager->shouldDoHeroFidget2[1 - this->owningSide] = 1;
    }
    else
    {
      gpCombatManager->shouldDoHeroFidget1[this->owningSide] = 1;
    }
    *(_DWORD *)&this->creature.creature_flags |= DEAD;
    this->dead = 0;
    hexTile = &gpCombatManager->combatGrid[this->occupiedHex];
    v6 = 0;
    if ( this->creature.creature_flags & TWO_HEXER )
    {
      v6 = this->occupiedHex + ((unsigned int)(this->facingRight - 1) < 1 ? 1 : -1);
      secondHexTile = &gpCombatManager->combatGrid[v6];
    }
    else
    {
      secondHexTile = 0;
    }
    if ( army::LeaveNoBody(this) )
    {
      if ( a2
        || this->creatureIdx != CREATURE_AIR_ELEMENTAL
        && this->creatureIdx != CREATURE_FIRE_ELEMENTAL
        && this->creatureIdx != CREATURE_WATER_ELEMENTAL
        && this->creatureIdx != CREATURE_EARTH_ELEMENTAL )
      {
        gpCombatManager->shouldVanish[this->owningSide][this->stackIdx] = 1;
        gpCombatManager->anyStacksShouldVanish = 1;
      }
      else
      {
        hexTile->unitOwner = -1;
        hexTile->stackIdx = -1;
      }
    }
    if ( hexTile->numCorpses < 14 && !army::LeaveNoBody(this) && (!secondHexTile || secondHexTile->numCorpses < 14) )
    {
      hexTile->corpseOwners[hexTile->numCorpses] = gpCombatManager->combatGrid[this->occupiedHex].unitOwner;
      hexTile->corpseStackIndices[hexTile->numCorpses] = gpCombatManager->combatGrid[this->occupiedHex].stackIdx;
      hexTile->corpseOtherHexIsToLeft[hexTile->numCorpses++] = gpCombatManager->combatGrid[this->occupiedHex].occupiersOtherHexIsToLeft;
      if ( secondHexTile )
      {
        secondHexTile->corpseOwners[secondHexTile->numCorpses] = gpCombatManager->combatGrid[v6].unitOwner;
        secondHexTile->corpseStackIndices[secondHexTile->numCorpses] = gpCombatManager->combatGrid[v6].stackIdx;
        secondHexTile->corpseOtherHexIsToLeft[secondHexTile->numCorpses++] = gpCombatManager->combatGrid[v6].occupiersOtherHexIsToLeft;
      }
    }
    if ( !army::LeaveNoBody(this) )
    {
      hexTile->unitOwner = -1;
      hexTile->stackIdx = -1;
      if ( secondHexTile )
      {
        secondHexTile->unitOwner = -1;
        secondHexTile->stackIdx = -1;
      }
    }
    if ( this->mirroredIdx != -1 )
      gpCombatManager->creatures[this->owningSide][this->mirroredIdx].mirrorIdx = -1;
    if ( this->mirrorIdx != -1 )
    {
      v2 = (char *)gpCombatManager + 24234 * this->owningSide + 1154 * this->mirrorIdx;
      *(_DWORD *)(v2 + 13797) = 0;
      army::ProcessDeath((army *)(v2 + 13647), 0);
    }
  }
}

//----- (004821E0) --------------------------------------------------------
void __thiscall army::SpellEffect(army *this, int animationIdx, signed int a3, int a4)
{
  int animBottomY; // [sp+28h] [bp-20h]@13
  IconEntry *header; // [sp+2Ch] [bp-1Ch]@10
  signed int animMinOffsetY; // [sp+30h] [bp-18h]@8
  int v8; // [sp+34h] [bp-14h]@16
  int v9; // [sp+34h] [bp-14h]@26
  int k; // [sp+3Ch] [bp-Ch]@7
  int ka; // [sp+3Ch] [bp-Ch]@26
  int j; // [sp+40h] [bp-8h]@8
  int fileID; // [sp+44h] [bp-4h]@1

  fileID = MAKEFILEID(gCombatFxNames[animationIdx]);
  if ( this->animationType == ANIMATION_TYPE_WINCE || this->animationType == ANIMATION_TYPE_WINCE_RETURN )
    a4 = 0;
  if ( !gbNoShowCombat && gCurLoadedSpellEffect != animationIdx )
  {
    resourceManager::Dispose(gpResourceManager, (resource *)gCurLoadedSpellIcon);
    gCurLoadedSpellIcon = resourceManager::GetIcon(gpResourceManager, fileID);
    gCurLoadedSpellEffect = animationIdx;
  }
  k = 0;
  this->probablyIsNeedDrawSpellEffect = 1;
  this->field_FA = 0;
  if ( !gbNoShowCombat )
  {
    animMinOffsetY = 999;
    for ( j = 0; gCurLoadedSpellIcon->numSprites > j; ++j )
    {
      header = GetIconEntry(gCurLoadedSpellIcon, j);
      if ( header->offsetY < animMinOffsetY )
        animMinOffsetY = header->offsetY;
    }
    animBottomY = animMinOffsetY + army::GetPowBaseY(this);
    if ( animBottomY < 0 )
      this->field_FA = -animBottomY;
    if ( a4 )
    {
      v8 = 275 / this->frameInfo.animationLengths[14];
      this->animationType = 14;
      while ( this->frameInfo.animationLengths[14] > k )
      {
        this->animationFrame = k;
        if ( giNumPowFrames[animationIdx] <= k )
          gCurSpellEffectFrame = giNumPowFrames[animationIdx];
        else
          gCurSpellEffectFrame = k;
        animTimer = (signed __int64)((double)KBTickCount() + (double)v8 * gfCombatSpeedMod[giCombatSpeed]);
        combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
        DelayTil(&animTimer);
        ++k;
      }
    }
    while ( giNumPowFrames[animationIdx] > k )
    {
      animTimer = (signed __int64)((double)KBTickCount() + (double)a3 * gfCombatSpeedMod[giCombatSpeed]);
      gCurSpellEffectFrame = k;
      combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
      DelayTil(&animTimer);
      ++k;
    }
  }
  this->probablyIsNeedDrawSpellEffect = 0;
  if ( !gbNoShowCombat )
  {
    if ( a4 )
    {
      v9 = 275 / this->frameInfo.animationLengths[15];
      this->animationType = 15;
      for ( ka = 0; this->frameInfo.animationLengths[15] > ka; ++ka )
      {
        this->animationFrame = ka;
        animTimer = (signed __int64)((double)KBTickCount() + (double)v9 * gfCombatSpeedMod[giCombatSpeed]);
        combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
        DelayTil(&animTimer);
      }
      this->animationType = 7;
      this->animationFrame = 0;
      combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    }
    else
    {
      combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (00482580) --------------------------------------------------------
void __thiscall army::CancelSpellType(army *this, CREATURE_EVENT_CODE code)
{
  army *thisa; // [sp+10h] [bp-4h]@1

  thisa = this;
  switch ( code )
  {
    case CREATURE_TOOK_TURN_EVENT_CODE:
      army::CancelIndividualSpell(this, EFFECT_BERSERKER);
      army::CancelIndividualSpell(thisa, EFFECT_HYPNOTIZE);
      break;
    case CREATURE_TOOK_DAMAGE_CODE:
      if ( this->effectStrengths[2] )
      {
        army::CancelIndividualSpell(this, EFFECT_BLIND);
        thisa->otherBadLuckThing = 2;
        *(_DWORD *)&thisa->creature.creature_flags |= MAYBE_NOT_LOST_TURN;
      }
      if ( thisa->effectStrengths[6] || thisa->effectStrengths[7] || thisa->effectStrengths[11] )
      {
        *(_DWORD *)&thisa->creature.creature_flags |= MAYBE_NOT_LOST_TURN;
        *(_DWORD *)&thisa->creature.creature_flags |= RETALIATED;
        army::CancelIndividualSpell(thisa, EFFECT_PARALYZE);
        army::CancelIndividualSpell(thisa, EFFECT_PETRIFY);
      }
      break;
    case CREATURE_MOVED_CODE:
    case CREATURE_TOOK_DAMAGE_CODE|CREATURE_TOOK_TURN_EVENT_CODE:
      return;
  }
}

//----- (00482690) --------------------------------------------------------
void __thiscall army::CancelIndividualSpell(army *this, STACK_MODIFYING_EFFECT effect)
{
  if ( this->effectStrengths[effect] )
  {
    --this->numActiveEffects;
    this->effectStrengths[effect] = 0;
    switch ( effect )
    {
      case EFFECT_HASTE:
      case EFFECT_SLOW:
        this->creature.speed = LOBYTE(this->speed);
        this->frameInfo.stepTime = this->field_B2;
        *(_DWORD *)&this->creature.creature_flags |= *(_DWORD *)&gMonsterDatabase[this->creatureIdx].creature_flags & FLYER;
        break;
      case EFFECT_BLOOD_LUST:
        this->creature.attack -= 3;
        break;
      case EFFECT_STONESKIN:
        this->creature.defense -= 3;
        break;
      case EFFECT_STEELSKIN:
        this->creature.defense -= 5;
        break;
      case EFFECT_BLIND:
      case EFFECT_BLESS:
      case EFFECT_CURSE:
      case EFFECT_BERSERKER:
      case EFFECT_PARALYZE:
      case EFFECT_HYPNOTIZE:
      case EFFECT_DRAGON_SLAYER:
      case EFFECT_SHIELD:
      case EFFECT_PETRIFY:
      case EFFECT_ANTI_MAGIC:
        return;
    }
  }
}

//----- (00482810) --------------------------------------------------------
signed int __thiscall army::SetSpellInfluence(army *this, STACK_MODIFYING_EFFECT effectType, signed int strength)
{
  signed int result; // eax@4
  __int64 v4; // qax@7
  STACK_MODIFYING_EFFECT effect; // [sp+1Ch] [bp-4h]@15

  if ( this->effectStrengths[effectType] )
  {
    if ( this->effectStrengths[effectType] < strength )
      this->effectStrengths[effectType] = strength;
    result = 0;
  }
  else
  {
    switch ( effectType )
    {
      case EFFECT_HASTE:
        army::CancelIndividualSpell(this, EFFECT_SLOW);
        this->creature.speed += 2;
        this->frameInfo.stepTime = (signed __int64)((double)this->frameInfo.stepTime * 0.65);
        goto LABEL_24;
      case EFFECT_SLOW:
        army::CancelIndividualSpell(this, 0);
        v4 = (signed int)this->creature.speed + 1;
        this->creature.speed = ((signed int)v4 - HIDWORD(v4)) >> 1;
        if ( this->creature.creature_flags & 2 )
          *(_DWORD *)&this->creature.creature_flags -= 2;
        this->frameInfo.stepTime = (signed __int64)((double)this->frameInfo.stepTime * 1.5);
        goto LABEL_24;
      case EFFECT_BLESS:
        army::CancelIndividualSpell(this, EFFECT_CURSE);
        goto LABEL_24;
      case EFFECT_CURSE:
        army::CancelIndividualSpell(this, EFFECT_BLESS);
        goto LABEL_24;
      case EFFECT_BERSERKER:
        army::CancelIndividualSpell(this, EFFECT_HYPNOTIZE);
        goto LABEL_24;
      case EFFECT_HYPNOTIZE:
        army::CancelIndividualSpell(this, EFFECT_BERSERKER);
        goto LABEL_24;
      case EFFECT_BLOOD_LUST:
        this->creature.attack += 3;
        goto LABEL_24;
      case EFFECT_ANTI_MAGIC:
        for ( effect = 0; (signed int)effect < 15; ++effect )
          army::CancelIndividualSpell(this, effect);
        goto LABEL_24;
      case EFFECT_STONESKIN:
        if ( this->effectStrengths[14] )
        {
          result = 0;
        }
        else
        {
          this->creature.defense += 3;
LABEL_24:
          ++this->numActiveEffects;
          this->effectStrengths[effectType] = strength;
          result = 1;
        }
        break;
      case EFFECT_STEELSKIN:
        army::CancelIndividualSpell(this, EFFECT_STONESKIN);
        this->creature.defense += 5;
        goto LABEL_24;
      case EFFECT_BLIND:
      case EFFECT_PARALYZE:
      case EFFECT_DRAGON_SLAYER:
      case EFFECT_SHIELD:
      case EFFECT_PETRIFY:
        goto LABEL_24;
    }
  }
  return result;
}

//----- (00482AA0) --------------------------------------------------------
void __thiscall army::DecrementSpellRounds(army *this)
{
  army *thisa; // [sp+Ch] [bp-8h]@1
  STACK_MODIFYING_EFFECT effect; // [sp+10h] [bp-4h]@1

  thisa = this;
  for ( effect = 0; (signed int)effect < 15; ++effect )
  {
    if ( thisa->effectStrengths[effect] )
    {
      if ( thisa->effectStrengths[effect] == 1 )
        army::CancelIndividualSpell(thisa, effect);
      else
        --thisa->effectStrengths[effect];
    }
  }
  if ( thisa->lifespan > 0 )
    --thisa->lifespan;
}

//----- (00482B40) --------------------------------------------------------
void __thiscall army::GoBerserk(army *this)
{
  int v1; // ST28_4@33
  army *thisa; // [sp+Ch] [bp-50h]@1
  signed int v3; // [sp+18h] [bp-44h]@25
  signed int v4; // [sp+1Ch] [bp-40h]@25
  signed int i; // [sp+24h] [bp-38h]@7
  int j; // [sp+28h] [bp-34h]@9
  signed int v7; // [sp+2Ch] [bp-30h]@7
  signed int v8; // [sp+30h] [bp-2Ch]@7
  signed int v9; // [sp+34h] [bp-28h]@7
  int v10; // [sp+38h] [bp-24h]@17
  int neighbor; // [sp+3Ch] [bp-20h]@4
  int tmp; // [sp+40h] [bp-1Ch]@1
  int freeNeighborBmask; // [sp+44h] [bp-18h]@1
  int targFound; // [sp+48h] [bp-14h]@1
  int v15; // [sp+4Ch] [bp-10h]@1
  signed int neighborIdx; // [sp+50h] [bp-Ch]@1
  int aliveStackBmask[2]; // [sp+54h] [bp-8h]@1

  thisa = this;
  targFound = 0;
  neighborIdx = 0;
  v15 = 0;
  tmp = this->quantity;
  this->quantity = 0;
  aliveStackBmask[0] = combatManager::GetAllMask(gpCombatManager, 0);
  aliveStackBmask[1] = combatManager::GetAllMask(gpCombatManager, 1);
  thisa->quantity = tmp;
  freeNeighborBmask = army::GetAttackMask(thisa, thisa->occupiedHex, 2, -1);
  if ( freeNeighborBmask != 255 )
  {
    while ( !targFound )
    {
      neighborIdx = Random(0, 7);
      if ( !((1 << neighborIdx) & freeNeighborBmask) )
      {
        giNextAction = 2;
        army::ValidAttack(thisa, thisa->occupiedHex, neighborIdx, 2, -1, &neighbor);
        giNextActionGridIndex = neighbor;
        targFound = 1;
        goto LABEL_46;
      }
    }
LABEL_42:
    if ( thisa->creature.creature_flags & FLYER
      || !combatManager::WalkTowardArmy(gpCombatManager, thisa, thisa->owningSide, aliveStackBmask[thisa->owningSide])
      && !combatManager::WalkTowardArmy(
            gpCombatManager,
            thisa,
            1 - thisa->owningSide,
            aliveStackBmask[1 - thisa->owningSide]) )
      giNextAction = 3;
    goto LABEL_46;
  }
  v7 = -1;
  v9 = -1;
  v8 = 999999;
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; gpCombatManager->numCreatures[i] > j; ++j )
    {
      if ( thisa->owningSide != i || thisa->stackIdx != j )
      {
        if ( !(gpCombatManager->creatures[i][j].creature.creature_flags & DEAD) )
        {
          if ( gpCombatManager->creatures[i][j].quantity > 0 )
          {
            v10 = searchArray::QuickDistance(
                    gpCombatManager->combatGrid[thisa->occupiedHex].centerX,
                    gpCombatManager->combatGrid[thisa->occupiedHex].occupyingCreatureBottomY,
                    gpCombatManager->combatGrid[gpCombatManager->creatures[i][j].occupiedHex].centerX,
                    gpCombatManager->combatGrid[gpCombatManager->creatures[i][j].occupiedHex].occupyingCreatureBottomY);
            if ( v10 < v8 )
            {
              v7 = j;
              v9 = i;
              v8 = v10;
            }
          }
        }
      }
    }
  }
  if ( v7 != -1 && thisa->creature.creature_flags & 4 && thisa->creature.shots > 0 )
  {
    giNextAction = 2;
    giNextActionGridIndex = gpCombatManager->creatures[v9][v7].occupiedHex;
    goto LABEL_46;
  }
  v3 = -1;
  v4 = -1;
  if ( combatManager::AttemptAttack(gpCombatManager, (int)thisa, 0, aliveStackBmask[0]) )
  {
    giNextAction = 2;
    v3 = giNextActionGridIndex;
  }
  if ( combatManager::AttemptAttack(gpCombatManager, (int)thisa, 1, aliveStackBmask[1]) )
  {
    giNextAction = 2;
    v4 = giNextActionGridIndex;
  }
  giNextActionGridIndex = -1;
  if ( v3 != -1 || v4 != -1 )
  {
    if ( v3 == -1 || v4 == -1 )
    {
      if ( v3 == -1 )
      {
        if ( v4 != -1 )
          giNextActionGridIndex = v4;
      }
      else
      {
        giNextActionGridIndex = v3;
      }
    }
    else
    {
      v1 = searchArray::QuickDistance(
             gpCombatManager->combatGrid[thisa->occupiedHex].centerX,
             gpCombatManager->combatGrid[thisa->occupiedHex].occupyingCreatureBottomY,
             gpCombatManager->combatGrid[v3].centerX,
             gpCombatManager->combatGrid[v3].occupyingCreatureBottomY);
      if ( v1 >= searchArray::QuickDistance(
                   gpCombatManager->combatGrid[thisa->occupiedHex].centerX,
                   gpCombatManager->combatGrid[thisa->occupiedHex].occupyingCreatureBottomY,
                   gpCombatManager->combatGrid[v4].centerX,
                   gpCombatManager->combatGrid[v4].occupyingCreatureBottomY) )
        giNextActionGridIndex = v4;
      else
        giNextActionGridIndex = v3;
    }
  }
  if ( giNextActionGridIndex == -1 )
    goto LABEL_42;
LABEL_46:
  if ( giNextAction == 2 )
  {
    if ( gpCombatManager->combatGrid[giNextActionGridIndex].unitOwner == thisa->owningSide )
      gpCombatManager->shouldDoHeroFidget1[thisa->owningSide] = 1;
  }
}

//----- (00483190) --------------------------------------------------------
void __thiscall army::MoveAttack(army *this, int hexIdx, int a3)
{
  int knownHex; // [sp+10h] [bp-18h]@24
  int v5; // [sp+14h] [bp-14h]@13
  int v6; // [sp+18h] [bp-10h]@7
  signed int hexIdxa; // [sp+20h] [bp-8h]@20
  int v8; // [sp+24h] [bp-4h]@38

  while ( 1 )
  {
    gpCombatManager->field_F2B7 = 0;
    this->targetOwner = -1;
    this->targetStackIdx = -1;
    if ( !ValidHex(hexIdx) )
      break;
    if ( gpCombatManager->combatGrid[hexIdx].unitOwner == -1
      || gpCombatManager->combatGrid[hexIdx].unitOwner == gpCombatManager->activeStackOwner
      && gpCombatManager->combatGrid[hexIdx].stackIdx == gpCombatManager->activeStack )
    {
      if ( this->creature.creature_flags & FLYER )
      {
        this->targetHex = hexIdx;
        if ( !army::ValidFlight(this, this->targetHex, 0) )
          return;
        army::FlyTo(this, this->targetHex);
      }
      else
      {
        army::WalkTo(this, hexIdx);
      }
      goto LABEL_49;
    }
    if ( a3 )
      return;
    this->targetOwner = gpCombatManager->combatGrid[hexIdx].unitOwner;
    this->targetStackIdx = gpCombatManager->combatGrid[hexIdx].stackIdx;
    this->targetHex = hexIdx;
    v6 = army::GetAttackMask(this, this->occupiedHex, 0, -1);
    if ( !(this->creature.creature_flags & FLYER) || v6 != 255 )
    {
      if ( this->effectStrengths[5] )
        v5 = army::GetAttackMask(this, this->occupiedHex, 2, -1);
      else
        v5 = army::GetAttackMask(this, this->occupiedHex, 1, -1);
      if ( v5 != 0xFF || this->creature.shots <= 0 )
      {
        if ( v6 == 0xFF )
        {
          army::AttackTo(this);
        }
        else
        {
          for ( hexIdxa = 0; hexIdxa < 8; ++hexIdxa )
          {
            if ( hexIdxa < 6 || this->creature.creature_flags & TWO_HEXER )
            {
              knownHex = this->occupiedHex;
              if ( this->creature.creature_flags & TWO_HEXER && this->facingRight == 1 && hexIdxa >= 0 && hexIdxa <= 2 )
                ++knownHex;
              if ( this->creature.creature_flags & TWO_HEXER && !this->facingRight && hexIdxa >= 3 && hexIdxa <= 5 )
                --knownHex;
              if ( hexIdxa >= 6 )
              {
                if ( this->facingRight == 1 )
                  ++knownHex;
                else
                  --knownHex;
              }
              v8 = army::GetAdjacentCellIndex(this, knownHex, hexIdxa);
              if ( ValidHex(v8)
                && gpCombatManager->combatGrid[v8].unitOwner == this->targetOwner
                && gpCombatManager->combatGrid[v8].stackIdx == this->targetStackIdx )
                this->targetNeighborIdx = hexIdxa;
            }
          }
          army::DoAttack(this, 0);
        }
      }
      else
      {
        army::SpecialAttack(this);
      }
LABEL_49:
      gpCombatManager->field_F2B7 = 1;
      return;
    }
    if ( this->occupiedHex != this->targetHex && !army::ValidFlight(this, this->targetHex, 0) )
      return;
    army::FlyTo(this, this->targetHex);
  }
}

//----- (00483590) --------------------------------------------------------
double __thiscall army::SpellCastWorkChance(army *this, Spell spell)
{
  double result; // st7@4
  army *thisa; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+10h] [bp-10h]@141
  int ressurectionStrength; // [sp+14h] [bp-Ch]@125
  signed int hasEffect; // [sp+18h] [bp-8h]@7
  CREATE_STACK_CONSTANTS i; // [sp+1Ch] [bp-4h]@7

  thisa = this;
  if ( HIBYTE(this->creature.creature_flags) & ATTR_MIRROR_IMAGE
    && (spell == SPELL_MIRROR_IMAGE || spell == SPELL_ANTI_MAGIC) )
    return 0.0;
  if ( spell == SPELL_DISPEL_MAGIC || spell == SPELL_MASS_DISPEL )
  {
    hasEffect = 0;
    for ( i = 0; i < NUM_EFFECTS; ++i )
    {
      if ( this->effectStrengths[i] )
      {
        hasEffect = 1;
        break;
      }
    }
    if ( !hasEffect )
      return 0.0;
  }
  if ( this->effectStrengths[12]
    || this->creature.creature_flags & 0x10
    && spell != 7
    && spell != SPELL_RESURRECT_TRUE
    && spell != SPELL_ANIMATE_DEAD
    || this->dead
    || this->creatureIdx == CREATURE_GREEN_DRAGON
    || this->creatureIdx == CREATURE_RED_DRAGON
    || this->creatureIdx == CREATURE_BLACK_DRAGON )
    return 0.0;
  if ( spell == SPELL_MIRROR_IMAGE && this->mirrorIdx != -1 )
    return 0.0;
  if ( (spell == SPELL_RESURRECT || spell == SPELL_RESURRECT_TRUE)
    && (HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD || this->initialQuantity == this->quantity) )
    return 0.0;
  if ( spell == SPELL_ANIMATE_DEAD
    && (!(HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD) || this->initialQuantity == this->quantity) )
    return 0.0;
  if ( (spell == SPELL_HOLY_WORD || spell == SPELL_HOLY_SHOUT) && !(HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD) )
    return 0.0;
  if ( (spell == SPELL_DEATH_RIPPLE || spell == SPELL_DEATH_WAVE) && HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD )
    return 0.0;
  if ( this->creatureIdx == CREATURE_PHOENIX
    && (spell == SPELL_FIREBALL
     || spell == SPELL_FIREBLAST
     || spell == SPELL_LIGHTNING_BOLT
     || spell == SPELL_CHAIN_LIGHTNING
     || spell == SPELL_COLD_RAY
     || spell == SPELL_COLD_RING
     || spell == SPELL_ELEMENTAL_STORM) )
    return 0.0;
  if ( this->creatureIdx == CREATURE_CRUSADER && (spell == SPELL_CURSE || spell == SPELL_MASS_CURSE) )
    return 0.0;
  if ( (HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD
     || this->creatureIdx == CREATURE_EARTH_ELEMENTAL
     || this->creatureIdx == CREATURE_AIR_ELEMENTAL
     || this->creatureIdx == CREATURE_FIRE_ELEMENTAL
     || this->creatureIdx == CREATURE_WATER_ELEMENTAL
     || this->creatureIdx == CREATURE_GIANT
     || this->creatureIdx == CREATURE_TITAN)
    && (spell == SPELL_BERZERKER || spell == SPELL_HYPNOTIZE || spell == SPELL_PARALYZE || spell == SPELL_BLIND) )
    return 0.0;
  if ( HIBYTE(this->creature.creature_flags) & ATTR_UNDEAD
    && (spell == SPELL_CURSE || spell == SPELL_MASS_CURSE || spell == SPELL_BLESS || spell == SPELL_MASS_BLESS) )
    return 0.0;
  if ( this->creatureIdx == CREATURE_EARTH_ELEMENTAL
    && (spell == SPELL_LIGHTNING_BOLT || spell == SPELL_CHAIN_LIGHTNING || spell == SPELL_METEOR_SHOWER) )
    return 0.0;
  if ( this->creatureIdx == CREATURE_AIR_ELEMENTAL && spell == SPELL_METEOR_SHOWER )
    return 0.0;
  if ( this->creatureIdx == CREATURE_FIRE_ELEMENTAL && (spell == SPELL_FIREBALL || spell == SPELL_FIREBLAST) )
    return 0.0;
  if ( this->creatureIdx == CREATURE_WATER_ELEMENTAL && (spell == SPELL_COLD_RAY || spell == SPELL_COLD_RING) )
    return 0.0;
  if ( !gpCombatManager->heroes[this->owningSide] )
    goto LABEL_168;
  if ( hero::HasArtifact(gpCombatManager->heroes[this->owningSide], 55)
    && (spell == SPELL_CURSE || spell == SPELL_MASS_CURSE) )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], ARTIFACT_PENDANT_OF_FREE_WILL)
    && spell == SPELL_HYPNOTIZE )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], 57)
    && (spell == SPELL_DEATH_RIPPLE || spell == SPELL_DEATH_WAVE) )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], 58) && spell == SPELL_BERZERKER )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], 59) && spell == SPELL_BLIND )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], 60) && spell == SPELL_PARALYZE )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], ARTIFACT_PENDANT_OF_DEATH)
    && (spell == SPELL_HOLY_WORD || spell == SPELL_HOLY_SHOUT) )
    return 0.0;
  if ( hero::HasArtifact(gpCombatManager->heroes[thisa->owningSide], ARTIFACT_WAND_OF_NEGATION)
    && (spell == SPELL_DISPEL_MAGIC || spell == SPELL_MASS_DISPEL || spell == SPELL_ARCHMAGI_DISPEL) )
  {
    result = 0.0;
  }
  else
  {
LABEL_168:
    if ( thisa->quantity || spell != SPELL_RESURRECT && spell != SPELL_RESURRECT_TRUE && spell != SPELL_ANIMATE_DEAD )
      goto LABEL_169;
    ressurectionStrength = 50 * gpCombatManager->heroSpellpowers[gpCombatManager->currentActionSide];
    if ( gpCombatManager->heroes[gpCombatManager->currentActionSide]
      && hero::HasArtifact(gpCombatManager->heroes[gpCombatManager->currentActionSide], 52) )
      ressurectionStrength *= 2;
    if ( thisa->creature.hp <= ressurectionStrength )
    {
LABEL_169:
      if ( spell != SPELL_ARCHMAGI_DISPEL
        || thisa->effectStrengths[0]
        || thisa->effectStrengths[3]
        || thisa->effectStrengths[8]
        || thisa->effectStrengths[9]
        || thisa->effectStrengths[10]
        || thisa->effectStrengths[12]
        || thisa->effectStrengths[13]
        || thisa->effectStrengths[14] )
      {
        if ( spell != SPELL_HYPNOTIZE )
          goto LABEL_170;
        v4 = 25 * hero::Stats(gpCombatManager->heroes[gpCombatManager->currentActionSide], PRIMARY_SKILL_SPELLPOWER);
        if ( hero::HasArtifact(gpCombatManager->heroes[gpCombatManager->currentActionSide], 43) )
          v4 *= 2;
        if ( thisa->quantity * thisa->creature.hp <= v4 )
        {
LABEL_170:
          if ( thisa->creatureIdx != CREATURE_DWARF && thisa->creatureIdx != CREATURE_BATTLE_DWARF
            || spell == SPELL_TELEPORT
            || spell == SPELL_CURE
            || spell == SPELL_MASS_CURE
            || spell == SPELL_RESURRECT
            || spell == SPELL_RESURRECT_TRUE
            || spell == SPELL_HASTE
            || spell == SPELL_MASS_HASTE
            || spell == SPELL_BLESS
            || spell == SPELL_MASS_BLESS
            || spell == SPELL_STONESKIN
            || spell == SPELL_STEELSKIN
            || spell == SPELL_ANTI_MAGIC
            || spell == SPELL_DRAGON_SLAYER
            || spell == SPELL_BLOOD_LUST
            || spell == 40
            || spell == 41
            || spell == 42 )
            result = 1.0;
          else
            result = 0.75;
        }
        else
        {
          result = 0.0;
        }
      }
      else
      {
        result = 0.0;
      }
    }
    else
    {
      result = 0.0;
    }
  }
  return result;
}

//----- (00483ED0) --------------------------------------------------------
bool __thiscall army::SpellCastWorks(army *this, Spell spell)
{
  int v2; // ST14_4@1

  v2 = (signed __int64)(army::SpellCastWorkChance(this, spell) * 100.0);
  return SRandom(1, 99) <= v2;
}

//----- (00483F30) --------------------------------------------------------
// IF first hex AND last hex
//   do full-walk-cycle animation
// ELSE
//   
//   IF first hex
//     do start-move animation
//   ELSE
//     IF has sub-start-move animation
//       do sub-start-move-animation
// 
//   do move animation
// 
//   IF last hex
//     do end-move animation
//   ELSE
//     IF has sub-end-move animation
//       do sub-end-move animation
void __fastcall BuildTempWalkSeq(SMonFrameInfo *this, int last, int notFirst)
{
  this->animationLengths[6] = 0;
  if ( notFirst || !last )
  {
    if ( notFirst )
    {
      if ( this->animationLengths[1] > 0 )
      {
        memcpy(
          &this->animationFrameToImgIdx[6][this->animationLengths[6]],
          this->animationFrameToImgIdx[1],
          this->animationLengths[1]);
        memcpy(
          &this->moveAnimInfoIgnored[this->animationLengths[6]],
          this->subStartMoveAnimInfoIgnored,
          this->animationLengths[1]);
        this->animationLengths[6] += this->animationLengths[1];
      }
    }
    else if ( this->animationLengths[0] > 0 )
    {
      memcpy(
        &this->animationFrameToImgIdx[6][this->animationLengths[6]],
        this->animationFrameToImgIdx,
        this->animationLengths[0]);
      memcpy(
        &this->moveAnimInfoIgnored[this->animationLengths[6]],
        this->startMoveAnimInfoIgnored,
        this->animationLengths[0]);
      this->animationLengths[6] += this->animationLengths[0];
    }
    if ( this->animationLengths[2] > 0 )
    {
      memcpy(
        &this->animationFrameToImgIdx[6][this->animationLengths[6]],
        this->animationFrameToImgIdx[2],
        this->animationLengths[2]);
      memcpy(
        &this->moveAnimInfoIgnored[this->animationLengths[6]],
        this->mainMoveAnimInfoIgnored,
        this->animationLengths[2]);
      this->animationLengths[6] += this->animationLengths[2];
    }
    if ( last )
    {
      if ( this->animationLengths[4] > 0 )
      {
        memcpy(
          &this->animationFrameToImgIdx[6][this->animationLengths[6]],
          this->animationFrameToImgIdx[4],
          this->animationLengths[4]);
        memcpy(
          &this->moveAnimInfoIgnored[this->animationLengths[6]],
          this->endMoveAnimInfoIgnored,
          this->animationLengths[4]);
        this->animationLengths[6] += this->animationLengths[4];
      }
    }
    else if ( this->animationLengths[3] > 0 )
    {
      memcpy(
        &this->animationFrameToImgIdx[6][this->animationLengths[6]],
        this->animationFrameToImgIdx[3],
        this->animationLengths[3]);
      memcpy(
        &this->moveAnimInfoIgnored[this->animationLengths[6]],
        this->subEndMoveAnimInfoIgnored,
        this->animationLengths[3]);
      this->animationLengths[6] += this->animationLengths[3];
    }
  }
  else if ( this->animationLengths[5] > 0 )
  {
    memcpy(
      &this->animationFrameToImgIdx[6][this->animationLengths[6]],
      this->animationFrameToImgIdx[5],
      this->animationLengths[5]);
    memcpy(
      &this->moveAnimInfoIgnored[this->animationLengths[6]],
      this->fullMoveAnimInfoIgnored,
      this->animationLengths[5]);
    this->animationLengths[6] += this->animationLengths[5];
  }
}

//----- (004842D0) --------------------------------------------------------
void __thiscall army::DispelGood(army *this)
{
  army *thisa; // ST10_4@1

  thisa = this;
  army::CancelIndividualSpell(this, EFFECT_HASTE);
  army::CancelIndividualSpell(thisa, EFFECT_BLESS);
  army::CancelIndividualSpell(thisa, EFFECT_DRAGON_SLAYER);
  army::CancelIndividualSpell(thisa, EFFECT_BLOOD_LUST);
  army::CancelIndividualSpell(thisa, EFFECT_SHIELD);
  army::CancelIndividualSpell(thisa, EFFECT_ANTI_MAGIC);
  army::CancelIndividualSpell(thisa, EFFECT_STONESKIN);
  army::CancelIndividualSpell(thisa, EFFECT_STEELSKIN);
}

//----- (00484340) --------------------------------------------------------
void __thiscall army::Cure(army *this, int spellpower)
{
  army::CancelIndividualSpell(this, EFFECT_SLOW);
  army::CancelIndividualSpell(this, EFFECT_BLIND);
  army::CancelIndividualSpell(this, EFFECT_CURSE);
  army::CancelIndividualSpell(this, EFFECT_BERSERKER);
  army::CancelIndividualSpell(this, EFFECT_PARALYZE);
  army::CancelIndividualSpell(this, EFFECT_HYPNOTIZE);
  army::CancelIndividualSpell(this, EFFECT_PETRIFY);
  this->damage -= 5 * spellpower;
  if ( this->damage < 0 )
    this->damage = 0;
}

//----- (004843D0) --------------------------------------------------------
int __thiscall army::MidX(army *this)
{
  signed int v2; // [sp+10h] [bp-4h]@3

  if ( this->creature.creature_flags & TWO_HEXER )
  {
    if ( this->facingRight == 1 )
      v2 = 22;
    else
      v2 = -22;
  }
  else
  {
    v2 = 0;
  }
  return v2 + gpCombatManager->combatGrid[this->occupiedHex].centerX;
}

//----- (00484450) --------------------------------------------------------
int __thiscall army::MidY(army *this)
{
  return gpCombatManager->combatGrid[this->occupiedHex].occupyingCreatureBottomY
       - (GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->height >> 1);
}

//----- (004844B0) --------------------------------------------------------
int __thiscall army::TopY(army *this)
{
  return gpCombatManager->combatGrid[this->occupiedHex].occupyingCreatureBottomY
       - GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->height;
}

//----- (00484510) --------------------------------------------------------
int __thiscall army::RightX(army *this)
{
  int width; // ebx@2
  int result; // eax@2
  army *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( this->facingRight == 1 )
  {
    width = GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->width;
    result = GetIconEntry(thisa->creatureIcon, thisa->frameInfo.animationFrameToImgIdx[7][0])->offsetX
           + width
           + gpCombatManager->combatGrid[thisa->occupiedHex].centerX;
  }
  else
  {
    result = gpCombatManager->combatGrid[this->occupiedHex].centerX
           - GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->offsetX;
  }
  return result;
}

//----- (004845E0) --------------------------------------------------------
int __thiscall army::LeftX(army *this)
{
  int result; // eax@2
  int v2; // ebx@3
  int v3; // esi@3
  army *v4; // [sp+Ch] [bp-4h]@1

  v4 = this;
  if ( this->facingRight == 1 )
  {
    result = gpCombatManager->combatGrid[this->occupiedHex].centerX
           + GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->offsetX;
  }
  else
  {
    v2 = gpCombatManager->combatGrid[this->occupiedHex].centerX;
    v3 = GetIconEntry(this->creatureIcon, this->frameInfo.animationFrameToImgIdx[7][0])->width;
    result = v2 - (GetIconEntry(v4->creatureIcon, v4->frameInfo.animationFrameToImgIdx[7][0])->offsetX + v3);
  }
  return result;
}

//----- (004846B0) --------------------------------------------------------
signed int __thiscall army::OtherArmyAdjacent(army *this, int side, int idx)
{
  army *thisa; // [sp+Ch] [bp-1Ch]@1
  signed int neighbor; // [sp+10h] [bp-18h]@6
  signed int neighbora; // [sp+10h] [bp-18h]@14
  int hex; // [sp+18h] [bp-10h]@1
  int secondHex; // [sp+1Ch] [bp-Ch]@2
  int knownHex; // [sp+20h] [bp-8h]@12
  signed int hexIdx; // [sp+24h] [bp-4h]@4
  signed int hexIdxa; // [sp+24h] [bp-4h]@12

  thisa = this;
  hex = gpCombatManager->creatures[side][idx].occupiedHex;
  if ( gpCombatManager->creatures[side][idx].creature.creature_flags & TWO_HEXER )
    secondHex = hex + (gpCombatManager->creatures[side][idx].owningSide < 1u ? 1 : -1);
  else
    secondHex = -1;
  for ( hexIdx = 0; hexIdx < 6; ++hexIdx )
  {
    neighbor = army::GetAdjacentCellIndex(thisa, thisa->occupiedHex, hexIdx);
    if ( hex == neighbor || neighbor != -1 && secondHex == neighbor )
      return 1;
  }
  if ( thisa->creature.creature_flags & TWO_HEXER )
  {
    knownHex = thisa->occupiedHex + (thisa->owningSide < 1u ? 1 : -1);
    for ( hexIdxa = 0; hexIdxa < 6; ++hexIdxa )
    {
      neighbora = army::GetAdjacentCellIndex(thisa, knownHex, hexIdxa);
      if ( hex == neighbora || neighbora != -1 && secondHex == neighbora )
        return 1;
    }
  }
  return 0;
}

//----- (00484830) --------------------------------------------------------
void __fastcall ModifyFrameInfo(SMonFrameInfo *form, CREATURES creature)
{
  int speedDiff; // [sp+28h] [bp-4h]@1

  speedDiff = 0;
  if ( creature == CREATURE_RANGER
    || creature == CREATURE_VETERAN_PIKEMAN
    || creature == CREATURE_MASTER_SWORDSMAN
    || creature == CREATURE_CHAMPION
    || creature == CREATURE_CRUSADER
    || creature == CREATURE_ORC_CHIEF
    || creature == CREATURE_OGRE_LORD
    || creature == CREATURE_WAR_TROLL
    || creature == CREATURE_BATTLE_DWARF
    || creature == CREATURE_GRAND_ELF
    || creature == CREATURE_GREATER_DRUID
    || creature == CREATURE_MINOTAUR_KING
    || creature == CREATURE_STEEL_GOLEM
    || creature == CREATURE_ARCHMAGE
    || creature == CREATURE_MUTANT_ZOMBIE
    || creature == CREATURE_ROYAL_MUMMY
    || creature == CREATURE_VAMPIRE_LORD
    || creature == CREATURE_POWER_LICH )
    speedDiff = gMonsterDatabase[creature].speed - gMonsterDatabase[creature - 1].speed;
  if ( creature == CREATURE_EARTH_ELEMENTAL
    || creature == CREATURE_AIR_ELEMENTAL
    || creature == CREATURE_WATER_ELEMENTAL )
    speedDiff = gMonsterDatabase[creature].speed - gMonsterDatabase[64].speed;
  if ( speedDiff )
  {
    if ( creature == CREATURE_RANGER )
      form->shootingTime = (signed __int64)((double)form->shootingTime * 0.78);
    else
      form->shootingTime = (signed __int64)((1.0 - (double)speedDiff * 0.08) * (double)form->shootingTime);
    form->stepTime = (signed __int64)((1.0 - (double)speedDiff * 0.12) * (double)form->stepTime);
  }
}

//----- (00484A20) --------------------------------------------------------
int __thiscall army::GetPowBaseY(army *this)
{
  army *thisa; // [sp+Ch] [bp-8h]@1
  int v3; // [sp+10h] [bp-4h]@1

  thisa = this;
  v3 = army::MidY(this);
  if ( gCurLoadedSpellEffect == ANIM_HYPNOTIZE_IDX
    || gCurLoadedSpellEffect == ANIM_PARALYZE_IDX
    || gCurLoadedSpellEffect == ANIM_BLESS_IDX
    || gCurLoadedSpellEffect == ANIM_CURSE_IDX
    || gCurLoadedSpellEffect == ANIM_DRAGONSLAYER_IDX
    || gCurLoadedSpellEffect == ANIM_BERZERK_IDX )
    v3 = army::TopY(thisa);
  if ( gCurLoadedSpellEffect == ANIM_STONESKIN_IDX || gCurLoadedSpellEffect == ANIM_STEELSKIN_IDX )
    v3 = gpCombatManager->combatGrid[thisa->occupiedHex].occupyingCreatureBottomY + 5;
  return v3;
}

//----- (00484AE0) --------------------------------------------------------
WPARAM __stdcall WinMain(HINSTANCE instance, HINSTANCE prevInstance, LPSTR lpCmdnLine, int nCmdShow)
{
  WPARAM result; // eax@3
  struct tagMSG Msg; // [sp+Ch] [bp-20h]@8
  DWORD v6; // [sp+28h] [bp-4h]@1

  hInstApp = instance;
  gEventHandle = CreateEventA(0, 0, 0, "Heroes II");
  v6 = GetLastError();
  if ( gEventHandle && v6 != ERROR_CLIENT_ALREADY_EXISTS )
  {
    memset(gcCommandLine, 0, 0x3Du);
    strncpy(gcCommandLine, lpCmdnLine, 0x3Cu);
    if ( EarlySetup() )
    {
      if ( AppInit(instance, prevInstance, nCmdShow, lpCmdnLine) )
      {
        while ( 1 )
        {
          while ( !PeekMessageA(&Msg, 0, 0, 0, 1u) )
          {
            if ( AppIdle() )
              WaitMessage();
          }
          if ( Msg.message == 18 )
            break;
          TranslateMessage(&Msg);
          DispatchMessageA(&Msg);
        }
        ShutDown(0);
        result = Msg.wParam;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    sprintf(gText, "Only one copy of %s may run at a time", "Heroes of Might and Magic II");
    MessageBoxA(0, gText, "Startup Error", 0x10u);
    result = 0;
  }
  return result;
}

//----- (00484C30) --------------------------------------------------------
signed int __fastcall AppInit(HINSTANCE instance, HINSTANCE prevInstance, int nCmdShow, LPSTR lpCmdLine)
{
  HINSTANCE v4; // ST3C_4@1
  signed int result; // eax@3
  LPARAM v6; // eax@11
  HCURSOR v7; // eax@13
  HINSTANCE hInstance; // [sp+10h] [bp-40h]@1
  HMENU hMenu; // [sp+14h] [bp-3Ch]@8
  struct tagRECT Rect; // [sp+18h] [bp-38h]@7
  WNDCLASSA WndClass; // [sp+28h] [bp-28h]@2

  v4 = prevInstance;
  hInstance = instance;
  LogInt((int)"hInstApp", (int)hInstApp, -999, -999, -999, -999, -999, -999);
  memset(bProcessMessage, 0, 0x400u);
  bProcessMessage[1] = 1;
  bProcessMessage[256] = 1;
  bProcessMessage[257] = 1;
  bProcessMessage[512] = 1;
  bProcessMessage[513] = 1;
  bProcessMessage[515] = 1;
  bProcessMessage[516] = 1;
  bProcessMessage[518] = 1;
  bProcessMessage[514] = 1;
  bProcessMessage[517] = 1;
  bProcessMessage[275] = 1;
  bProcessMessage[28] = 1;
  bProcessMessage[20] = 1;
  bProcessMessage[3] = 1;
  bProcessMessage[5] = 1;
  bProcessMessage[273] = 1;
  bProcessMessage[785] = 1;
  bProcessMessage[783] = 1;
  bProcessMessage[15] = 1;
  bProcessMessage[2] = 1;
  bProcessMessage[18] = 1;
  bProcessMessage[16] = 1;
  bProcessMessage[953] = 1;
  if ( v4
    || (WndClass.hCursor = NULL,
        WndClass.hIcon = LoadIconA(hInstance, "Heroes II"),
        WndClass.lpszMenuName = NULL,
        WndClass.lpszClassName = "Heroes II",
        WndClass.hbrBackground = (HBRUSH)COLOR_WINDOWFRAME,
        WndClass.hInstance = hInstance,
        WndClass.style = CS_BYTEALIGNCLIENT|CS_DBLCLKS|CS_HREDRAW|CS_VREDRAW,
        WndClass.lpfnWndProc = (WNDPROC)AppWndProc,
        WndClass.cbWndExtra = 0,
        WndClass.cbClsExtra = 0,
        RegisterClassA(&WndClass)) )
  {
    if ( *(&bMenu + 7 * giCurExe) )
      giCurWindowsStyleFlags = 0x14CF0000u;
    else
      giCurWindowsStyleFlags = 0x14000000u;
    Rect.top = 0;
    Rect.left = 0;
    Rect.right = *(&bMenu + 7 * giCurExe + 3) - 1;
    Rect.bottom = *(&bMenu + 7 * giCurExe + 4) - 1;
    AdjustWindowRect(&Rect, giCurWindowsStyleFlags, *(&bMenu + 7 * giCurExe));
    if ( *(&bMenu + 7 * giCurExe) )
      hMenu = hmnuDflt;
    else
      hMenu = 0;
    hwndApp = CreateWindowExA(
                0,
                "Heroes II",
                "Heroes of Might and Magic II",
                giCurWindowsStyleFlags,
                *(&bMenu + 7 * giCurExe + 1),
                *(&bMenu + 7 * giCurExe + 2),
                Rect.right - Rect.left + 1,
                Rect.bottom - Rect.top + 1,
                0,
                hMenu,
                hInstance,
                0);
    if ( hwndApp )
    {
      v6 = (LPARAM)LoadIconA(hInstance, "Heroes");
      PostMessageA(hwndApp, 0x80u, 0, v6);
      ShowWindow(hwndApp, nCmdShow);
      SetWindowLongA(hwndApp, -16, giCurWindowsStyleFlags);
      if ( !*(&bMenu + 7 * giCurExe) )
        SetMenuStatus(0);
      InitGraphics();
      v7 = LoadCursorA(0, (LPCSTR)0x7F00);
      SetCursor(v7);
      oldmain();
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F2E88: using guessed type int giCurExe;

//----- (00484F70) --------------------------------------------------------
signed int __cdecl AppIdle()
{
  return 1;
}

//----- (00484FB0) --------------------------------------------------------
signed int __stdcall AppWndProc(HWND hWnd, unsigned int Msg, int wParam, unsigned int lParam)
{
  signed int result; // eax@3
  int v5; // eax@5
  signed int v6; // eax@33
  signed int v7; // eax@35

  if ( Msg > WM_HIBERNATE || !bProcessMessage[Msg] )
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  if ( Msg <= WM_PAINT )
  {
    if ( Msg == WM_PAINT )
    {
      AppPaint(hWnd);
      return 0;
    }
    switch ( Msg )
    {
      case WM_CREATE:
        v5 = KBTickCount();
        srand(v5);
        SetTimer(hWnd, 1u, 0xAu, 0);
        GdiSetBatchLimit(1u);
        return 0;
      case WM_MOVE:
        if ( hwndApp )
        {
          lTemp = GetWindowLongA(hwndApp, GWL_STYLE);
          if ( !(BYTE3(lTemp) & 0x21) && !gbClosingApp )
          {
            if ( !*(&bMenu + 7 * giCurExe + 5) )
            {
              GetWindowRect(hWnd, &rcTemp);
              *(&bMenu + 7 * giCurExe + 1) = rcTemp.left;
              *(&bMenu + 7 * giCurExe + 2) = rcTemp.top;
              WritePrefs();
            }
          }
          result = 0;
        }
        else
        {
          result = 0;
        }
        return result;
      case WM_SIZE:
        if ( !hwndApp )
          goto LABEL_83;
        lTemp = GetWindowLongA(hwndApp, GWL_STYLE);
        gbMinimized = lTemp & WS_MINIMIZE;
        if ( !(BYTE3(lTemp) & 0x20) )
          EarlyResizeWindow(0, 0);
        if ( BYTE3(lTemp) & 0x21 || (signed int)(unsigned __int16)lParam >= 240 && (signed int)(lParam >> 16) >= 160 )
        {
LABEL_83:
          iMainWinScreenWidth = (unsigned __int16)lParam;
          iMainWinScreenHeight = lParam >> 16;
          if ( (signed int)(unsigned __int16)lParam < 1 )
            iMainWinScreenWidth = 1;
          if ( iMainWinScreenHeight < 1 )
            iMainWinScreenHeight = 1;
          if ( hwndApp && !(BYTE3(lTemp) & 0x21) && !gbClosingApp && !*(&bMenu + 7 * giCurExe + 5) )
          {
            *(&bMenu + 7 * giCurExe + 3) = iMainWinScreenWidth;
            *(&bMenu + 7 * giCurExe + 4) = iMainWinScreenHeight;
            WritePrefs();
          }
          result = 0;
        }
        else
        {
          v6 = (unsigned __int16)lParam;
          if ( (signed int)(unsigned __int16)lParam <= 240 )
            v6 = 240;
          iTempX = v6;
          v7 = lParam >> 16;
          if ( (signed int)(lParam >> 16) <= 160 )
            v7 = 160;
          iTempY = v7;
          ResizeWindow(-1, -1, iTempX, v7);
          result = 0;
        }
        return result;
      case WM_DESTROY:
        goto LABEL_57;
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  if ( Msg > WM_ACTIVATEAPP )
  {
    if ( Msg <= WM_COMMAND )
    {
      if ( Msg == WM_COMMAND )
        return AppCommand(hWnd, WM_COMMAND, wParam, lParam);
      if ( Msg >= 0x100 && Msg <= 0x101 && !KeyboardMessageHandler(hWnd, Msg, wParam, lParam) )
        return 0;
      return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
    if ( Msg > WM_RBUTTONDBLCLK )
    {
      if ( Msg == WM_QUERYNEWPALETTE )
        return QueryNewPalette();
      if ( Msg != WM_PALETTECHANGED )
      {
        if ( Msg == 953 && wParam == 1 )
          soundManager::CDPlay(
            (soundManager *)gpSoundManager,
            *(_DWORD *)(gpSoundManager + 1684),
            0,
            *(_DWORD *)(gpSoundManager + 1688),
            1);
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
      if ( (HWND)wParam != hWnd )
        return QueryNewPalette();
    }
    else
    {
      if ( Msg >= 0x200 )
      {
        if ( !MouseMessageHandler(hWnd, Msg, wParam, lParam) )
          return 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
      if ( Msg == 275 )
      {
        lTemp = KBTickCount();
        if ( lLastGTimerTickCount + 5 < lTemp )
        {
          lLastGTimerTickCount = lTemp;
          UpdateTimers(0);
        }
        return 0;
      }
    }
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  if ( Msg == WM_ACTIVATEAPP )
  {
    gbForegroundApp = wParam;
    return 0;
  }
  if ( Msg != WM_CLOSE )
  {
    if ( Msg != WM_QUIT )
    {
      if ( Msg == WM_ERASEBKGND )
        return 1;
      return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
    goto LABEL_58;
  }
  if ( hwndApp != hWnd || !GameUnsaved() )
  {
LABEL_57:
    gbClosingApp = 1;
    PostQuitMessage(0);
LABEL_58:
    ShutDown(0);
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  NormalDialog("Are you sure you want to quit?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
  if ( gpWindowManager->buttonPressedCode == 30725 )
    DestroyWindow(hWnd);
  return 0;
}
// 4F0A0C: using guessed type int gbClosingApp;
// 4F0A10: using guessed type int gbForegroundApp;
// 4F2E88: using guessed type int giCurExe;
// 4F3080: using guessed type int gbMinimized;
// 513778: using guessed type int lLastGTimerTickCount;
// 5240A8: using guessed type int gpSoundManager;
// 52FB10: using guessed type int lTemp;

//----- (00485530) --------------------------------------------------------
signed int __stdcall AppAbout(HWND hDlg, int a2, unsigned __int16 a3, int a4)
{
  signed int result; // eax@2

  if ( a2 == 272 )
  {
    result = 1;
  }
  else
  {
    if ( a2 == 273 )
    {
      if ( a3 == 1 )
        EndDialog(hDlg, 1);
    }
    PollSound();
    result = 0;
  }
  return result;
}

//----- (004855E0) --------------------------------------------------------
void __cdecl Process1WindowsMessage()
{
  struct tagMSG Msg; // [sp+Ch] [bp-20h]@1
  int now; // [sp+28h] [bp-4h]@3

  while ( PeekMessageA(&Msg, NULL, 0, 0, PM_REMOVE) )
  {
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  now = KBTickCount();
  if ( now - lLastAilServe > 20 )
  {
    lLastAilServe = now;
    if ( !gbNoSound )
      soundManager::ServiceSound();
  }
  if ( now - lLastGetMessage > 150 )
  {
    lLastGetMessage = now;
    if ( GetMessageA(&Msg, NULL, 0, 0) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
  }
}
// 5137A8: using guessed type int lLastGetMessage;
// 5137AC: using guessed type int lLastAilServe;
// 523F24: using guessed type int gbNoSound;

//----- (004856B0) --------------------------------------------------------
void __fastcall ResizeWindow(int x, int y, unsigned int width, unsigned int heightNeededToDisplay)
{
  int v4; // [sp+Ch] [bp-20h]@1
  int v5; // [sp+10h] [bp-1Ch]@1
  int X; // [sp+14h] [bp-18h]@3
  struct tagRECT Rect; // [sp+18h] [bp-14h]@2
  int Y; // [sp+28h] [bp-4h]@6

  v4 = y;
  v5 = x;
  if ( !*(&bMenu + 7 * giCurExe + 5) )
  {
    GetWindowRect(hwndApp, &Rect);
    if ( v5 == -1 )
      X = Rect.left;
    else
      X = v5;
    if ( v4 == -1 )
      Y = Rect.top;
    else
      Y = v4;
    Rect.left = 0;
    Rect.top = 0;
    Rect.right = width - 1;
    Rect.bottom = heightNeededToDisplay - 1;
    AdjustWindowRect(&Rect, giCurWindowsStyleFlags, *(&bMenu + 7 * giCurExe));
    MoveWindow(hwndApp, X, Y, Rect.right - Rect.left + 1, Rect.bottom - Rect.top + 1, 1);
    *(&bMenu + 7 * giCurExe + 1) = X;
    *(&bMenu + 7 * giCurExe + 2) = Y;
    *(&bMenu + 7 * giCurExe + 3) = width;
    *(&bMenu + 7 * giCurExe + 4) = heightNeededToDisplay;
    WritePrefs();
  }
}
// 4F2E88: using guessed type int giCurExe;

//----- (00485800) --------------------------------------------------------
signed int __fastcall AppCommand(HWND this, int edx0, unsigned __int16 a2, int a3)
{
  signed int result; // eax@9

  switch ( a2 )
  {
    case MENU_BUTTON_ABOUT:
      DialogBoxParamA(hInstApp, "HEROES", this, (DLGPROC)AppAbout, 0);
      goto LABEL_11;
    case MENU_BUTTON_MANUAL:
      WinHelpA(hwndApp, ".\\HELP\\HEROES2.HLP", 0xBu, 0);
      goto LABEL_11;
    case MENU_BUTTON_640X480:
      ResizeWindow(-1, -1, 0x280u, 0x1E0u);
      goto LABEL_11;
    case MENU_BUTTON_800X600:
      ResizeWindow(-1, -1, 0x320u, 0x258u);
      goto LABEL_11;
    case MENU_BUTTON_1024X768:
      ResizeWindow(-1, -1, 0x400u, 0x300u);
      goto LABEL_11;
    case MENU_BUTTON_1280X1024:
      ResizeWindow(-1, -1, 0x500u, 0x400u);
      goto LABEL_11;
    case MENU_BUTTON_FULLSCREEN:
      SetFullScreenStatus((void *)(1 - *(&bMenu + 7 * giCurExe + 5)));
LABEL_11:
      result = 0;
      break;
    default:
      result = HandleAppSpecificMenuCommands(a2, edx0);
      break;
  }
  return result;
}
// 4F2E88: using guessed type int giCurExe;

//----- (004859A0) --------------------------------------------------------
void __thiscall UpdateDfltMenu(HMENU hMenua)
{
  HMENU hMenu; // [sp+Ch] [bp-Ch]@1

  hMenu = hMenua;
  if ( *(&bMenu + 7 * giCurExe) )
  {
    if ( giMainVideoModeWidth <= 640 )
      EnableMenuItem(hMenua, MENU_BUTTON_640X480, MF_GRAYED);
    if ( giMainVideoModeWidth <= 800 )
      EnableMenuItem(hMenu, MENU_BUTTON_800X600, MF_GRAYED);
    if ( giMainVideoModeWidth <= 1024 )
      EnableMenuItem(hMenu, MENU_BUTTON_1024X768, MF_GRAYED);
    if ( giMainVideoModeWidth <= 1280 )
      EnableMenuItem(hMenu, MENU_BUTTON_1280X1024, MF_GRAYED);
    if ( !gbDDrawAttached )
      EnableMenuItem(hMenu, MENU_BUTTON_FULLSCREEN, MF_GRAYED);
  }
}
// 4F0A18: using guessed type int giMainVideoModeWidth;
// 4F2E88: using guessed type int giCurExe;
// 5192EC: using guessed type int gbDDrawAttached;

//----- (00485A80) --------------------------------------------------------
void __thiscall KBChangeMenu(HMENU menu)
{
  HMENU tempMenu; // [sp+Ch] [bp-4h]@1

  tempMenu = menu;
  if ( menu )
    hmnuCurrent = (HMENU *)menu;
  else
    tempMenu = hmnuCurrent;
  hmnuApp = tempMenu;
  if ( *(&bMenu + 7 * giCurExe) )
  {
    if ( tempMenu )
    {
      SetMenu(hwndApp, tempMenu);
      UpdateDfltMenu(tempMenu);
      UpdateAppSpecificMenus(tempMenu);
      DrawMenuBar(hwndApp);
    }
  }
  else
  {
    SetMenu(hwndApp, NULL);
    DrawMenuBar(hwndApp);
  }
}
// 4F2E88: using guessed type int giCurExe;

//----- (00485B30) --------------------------------------------------------
void __thiscall SetMenuStatus(BOOL this)
{
  BOOL v1; // ST1C_4@3
  BOOL v2; // ST20_4@3

  if ( !*(&bMenu + 7 * giCurExe + 5) || !this )
  {
    v1 = *(&bMenu + 7 * giCurExe + 3);
    v2 = *(&bMenu + 7 * giCurExe + 4);
    *(&bMenu + 7 * giCurExe) = this;
    KBChangeMenu(0);
    *(&bMenu + 7 * giCurExe + 3) = v1;
    *(&bMenu + 7 * giCurExe + 4) = v2;
    WritePrefs();
    GetWindowLongA(hwndApp, -16);
    if ( *(&bMenu + 7 * giCurExe) )
      giCurWindowsStyleFlags = 349110272;
    else
      giCurWindowsStyleFlags = 335544320;
    SetWindowLongA(hwndApp, -16, giCurWindowsStyleFlags);
    ShowWindow(hwndApp, 8);
    ResizeWindow(-1, -1, *(&bMenu + 7 * giCurExe + 3), *(&bMenu + 7 * giCurExe + 4));
  }
}
// 4F2E88: using guessed type int giCurExe;

//----- (00485C90) --------------------------------------------------------
int __fastcall SetNoDialogMenus(int a1)
{
  int result; // eax@6

  if ( !gbNoDialogMenusOn || a1 )
  {
    if ( gbNoDialogMenusOn || !a1 )
    {
      if ( hmnuApp )
      {
        gbNoDialogMenusOn = 1 - a1;
        SetMenus(hmnuApp, a1);
      }
    }
  }
  return result;
}
// 5137CC: using guessed type int gbNoDialogMenusOn;

//----- (00485D10) --------------------------------------------------------
void __fastcall SetMenus(HMENU a1, unsigned int a2)
{
  HMENU v2; // eax@4
  unsigned int a2a; // [sp+Ch] [bp-20h]@1
  HMENU hMenua; // [sp+10h] [bp-1Ch]@1
  UINT uIDEnableItem; // [sp+14h] [bp-18h]@3
  signed int i; // [sp+18h] [bp-14h]@7
  int nPos; // [sp+1Ch] [bp-10h]@1
  int v8; // [sp+20h] [bp-Ch]@4
  int v9; // [sp+24h] [bp-8h]@1
  signed int v10; // [sp+28h] [bp-4h]@7

  a2a = a2;
  hMenua = a1;
  v9 = GetMenuItemCount(a1);
  for ( nPos = 0; v9 > nPos; ++nPos )
  {
    uIDEnableItem = GetMenuItemID(hMenua, nPos);
    if ( uIDEnableItem == -1 )
    {
      v2 = GetSubMenu(hMenua, nPos);
      SetMenus(v2, a2a);
      v8 = 0;
    }
    else if ( a2a )
    {
      v8 = 1;
    }
    else
    {
      v10 = 0;
      for ( i = 0; i < 70; ++i )
      {
        if ( *(int *)((char *)&gsMenuEnableStatus + 7 * i) == uIDEnableItem )
          v10 = i;
      }
      if ( gbInSetupDialog )
        v8 = 1 - (unsigned __int8)byte_4F2E95[7 * v10];
      else
        v8 = 1 - (unsigned __int8)byte_4F2E94[7 * v10];
    }
    if ( v8 )
      EnableMenuItem(hMenua, uIDEnableItem, a2a < 1);
  }
  UpdateDfltMenu(hMenua);
}
// 4F2E90: using guessed type int gsMenuEnableStatus;
// 4F307C: using guessed type int gbInSetupDialog;

//----- (00485E70) --------------------------------------------------------
int __cdecl KBTickCount()
{
  return GetTickCount();
}

//----- (00485EA0) --------------------------------------------------------
void __thiscall advManager::DoEvent(advManager *this, mapCell *loc, int locX, int locY)
{
  __int16 v4; // ax@78
  __int16 v5; // ax@78
  __int16 v6; // ax@78
  char v7; // al@107
  unsigned __int16 v8; // ax@141
  __int16 v9; // ax@142
  __int16 v10; // ax@142
  __int16 v11; // ax@142
  __int16 v12; // ax@177
  int v13; // ST28_4@177
  __int16 v14; // ax@177
  __int16 v15; // ax@177
  int v16; // ST38_4@177
  __int16 v17; // ax@177
  __int16 v18; // ax@183
  __int16 v19; // ax@184
  int v20; // ST2C_4@184
  __int16 v21; // ax@184
  __int16 v22; // ax@184
  int v23; // ST38_4@184
  __int16 v24; // ax@184
  unsigned __int16 v25; // ax@191
  __int16 v26; // ax@195
  __int16 v27; // ax@195
  int v28; // ebx@306
  char v29; // al@335
  int v30; // ebx@349
  int v31; // ebx@364
  __int16 v32; // ax@370
  __int16 v33; // ax@370
  __int16 v34; // ax@413
  int v35; // eax@402
  int v36; // eax@409
  __int16 v37; // ax@436
  unsigned __int16 v38; // ax@438
  __int16 v39; // ax@453
  unsigned __int16 v40; // ax@441
  unsigned __int16 v41; // ax@444
  unsigned __int16 v42; // ax@445
  unsigned __int16 v43; // ax@454
  unsigned __int16 v44; // ax@461
  unsigned __int16 v45; // ax@472
  unsigned __int16 v46; // ax@483
  char v47; // al@497
  signed int v48; // [sp+14h] [bp-33Ch]@306
  int v50; // [sp+2Ch] [bp-324h]@230
  int amt; // [sp+30h] [bp-320h]@227
  heroWindow *thisb; // [sp+38h] [bp-318h]@324
  char msg[4]; // [sp+44h] [bp-30Ch]@494
  int v54; // [sp+238h] [bp-118h]@482
  int a3; // [sp+23Ch] [bp-114h]@471
  town *v56; // [sp+240h] [bp-110h]@417
  signed int level; // [sp+244h] [bp-10Ch]@306
  int xp; // [sp+248h] [bp-108h]@306
  signed int a13; // [sp+24Ch] [bp-104h]@275
  int v60; // [sp+250h] [bp-100h]@123
  int v61; // [sp+254h] [bp-FCh]@118
  int maxSP; // [sp+258h] [bp-F8h]@113
  int v63; // [sp+25Ch] [bp-F4h]@107
  int a8; // [sp+260h] [bp-F0h]@16
  int a7; // [sp+264h] [bp-ECh]@16
  signed int img1Type; // [sp+268h] [bp-E8h]@16
  signed int a6; // [sp+26Ch] [bp-E4h]@16
  int v68; // [sp+270h] [bp-E0h]@10
  boat *v69; // [sp+274h] [bp-DCh]@120
  int v70; // [sp+278h] [bp-D8h]@343
  signed int type; // [sp+27Ch] [bp-D4h]@226
  int a2a; // [sp+280h] [bp-D0h]@325
  int v73; // [sp+284h] [bp-CCh]@379
  int y; // [sp+288h] [bp-C8h]@343
  int x; // [sp+28Ch] [bp-C4h]@345
  int a5; // [sp+290h] [bp-C0h]@370
  unsigned int v77; // [sp+294h] [bp-BCh]@370
  int v78; // [sp+298h] [bp-B8h]@436
  hero *v79; // [sp+29Ch] [bp-B4h]@415
  int v80; // [sp+2A0h] [bp-B0h]@419
  sphinxMapExtra *sphinxMapExtra; // [sp+2A4h] [bp-ACh]@7
  int v82; // [sp+2A8h] [bp-A8h]@127
  CREATURES creat; // [sp+2ACh] [bp-A4h]@370
  GUIMessage evt; // [sp+2B0h] [bp-A0h]@329
  int locType; // [sp+2CCh] [bp-84h]@1
  int shouldDelete; // [sp+2ECh] [bp-64h]@1
  char a1; // [sp+2F0h] [bp-60h]@10
  int v88; // [sp+324h] [bp-2Ch]@34
  int v89; // [sp+328h] [bp-28h]@34
  int v90; // [sp+32Ch] [bp-24h]@1
  int a2; // [sp+330h] [bp-20h]@10
  SignExtra *signExtra; // [sp+334h] [bp-1Ch]@424
  int v93; // [sp+338h] [bp-18h]@34
  hero *hero; // [sp+33Ch] [bp-14h]@1
  SAMPLE2 res1; // [sp+340h] [bp-10h]@1
  SAMPLE2 res2; // [sp+348h] [bp-8h]@1

  hero = &gpGame->heroes[gpCurPlayer->curHeroIdx];
  locType = loc->objType & 0x7F;
  shouldDelete = 0;
  v90 = 0;
  res1 = NULL_SAMPLE2;
  mouseManager::ShowColorPointer(gpMouseManager);
  mouseManager::SetPointer(gpMouseManager, 0);
  res2 = NULL_SAMPLE2;
  switch ( locType )
  {
    case LOCATION_TRADING_POST:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      DoTradingPost(0, 1045220557);
      goto LABEL_511;
    case LOCATION_MAGIC_GARDEN:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          1,
          "{Magic Garden}\n\nYou catch a leprechaun foolishly sleeping amidst a cluster of magic mushrooms.  In exchange for his freedom, he guides you to a small pot filled with precious things.",
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
          (unsigned int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 7 < 1 ? 500 : 5,
          -1,
          0,
          -1);
        advManager::GiveResource(
          this,
          hero,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
          (unsigned int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 7 < 1 ? 500 : 5);
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      else
      {
        advManager::EventWindow(
          -1,
          1,
          "{Magic Garden}\n\nYou've found a magic garden, the kind of place that leprechauns and faeries like to cavort in, but there is no one here today.  Perhaps you should try again next week.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_SPHINX:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      sphinxMapExtra = (sphinxMapExtra *)ppMapExtra[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      if ( sphinxMapExtra->unclaimed )
      {
        sprintf(
          gText,
          "\"I have a riddle for you,\" the Sphinx says.  \"Answer correctly, and you shall be rewarded.  Answer incorrectly, and you shall be eaten.  Do you accept the challenge?\"");
        NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
        if ( gpWindowManager->buttonPressedCode == 0x7805 )
        {
          sprintf(gText, "The Sphinx asks you the following riddle:\n\n'%s'\n\nYour answer?", sphinxMapExtra->riddle);
          GetDataEntry(gText, (int)&a1, 12, 0, 0, 1);
          v68 = 0;
          for ( a2 = 0; sphinxMapExtra->numAnswers > a2; ++a2 )
          {
            if ( RiddleStringsEqual(&a1, sphinxMapExtra->answers[a2]) )
              v68 = 1;
          }
          if ( v68 )
          {
            img1Type = -1;
            a6 = 0;
            a7 = -1;
            a8 = 0;
            for ( a2 = 0; a2 < 7; ++a2 )
            {
              gpGame->players[giCurPlayer].resources[a2] += sphinxMapExtra->resourceReward[a2];
              if ( gpGame->players[giCurPlayer].resources[a2] < 0 )
                gpGame->players[giCurPlayer].resources[a2] = 0;
              if ( sphinxMapExtra->resourceReward[a2] )
              {
                if ( img1Type != -1 )
                {
                  a7 = img1Type;
                  a8 = a6;
                }
                img1Type = a2;
                a6 = sphinxMapExtra->resourceReward[a2];
              }
            }
            if ( sphinxMapExtra->artifactReward != -1 && hero::NumArtifacts(hero) < 14 )
            {
              GiveArtifact(hero, (ARTIFACT)sphinxMapExtra->artifactReward, 1, -1);
              if ( img1Type != -1 )
              {
                a7 = img1Type;
                a8 = a6;
              }
              img1Type = 7;
              a6 = sphinxMapExtra->artifactReward;
            }
            NormalDialog(
              "Looking somewhat disappointed, the Sphinx sighs.  You've answered my riddle so here's your reward.  Now begone.",
              1,
              -1,
              -1,
              img1Type,
              a6,
              a7,
              a8,
              -1,
              0);
            sphinxMapExtra->unclaimed = 0;
          }
          else
          {
            NormalDialog(
              "\"You guessed incorrectly,\" the Sphinx says, smiling.  The Sphinx swipes at you with a paw, knocking you to the ground.  Another blow makes the world go black, and you know no more.",
              1,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
            advManager::HeroLoses((int)this, (int)hero);
          }
        }
      }
      else
      {
        NormalDialog(
          "{Sphinx}\n\nYou come across a giant Sphinx.  The Sphinx remains strangely quiet.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      goto LABEL_511;
    case LOCATION_OBSERVATION_TOWER:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      NormalDialog(
        "{Observation Tower}\n\nFrom the observation tower, you are able to see distant lands.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
      game::SetVisibility(gpGame, locX, locY, giCurPlayer, 20);
      advManager::CompleteDraw(this, 0);
      advManager::UpdateScreen(this, 0, 0);
      goto LABEL_511;
    case LOCATION_HILL_FORT:
      v93 = -1;
      v88 = -1;
      v89 = -1;
      if ( hero::CreatureTypeCount(hero, CREATURE_OGRE) )
        v89 = CREATURE_OGRE;
      if ( hero::CreatureTypeCount(hero, CREATURE_ORC) )
      {
        if ( v89 == -1 )
          v89 = CREATURE_ORC;
        else
          v88 = CREATURE_ORC;
      }
      if ( hero::CreatureTypeCount(hero, CREATURE_DWARF) )
      {
        if ( v89 == -1 )
        {
          v89 = CREATURE_DWARF;
        }
        else if ( v88 == -1 )
        {
          v88 = CREATURE_DWARF;
        }
        else
        {
          v93 = CREATURE_DWARF;
        }
      }
      if ( v89 == -1 )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Hill Fort}\n\nAn unusual alliance of Orcs, Ogres, and Dwarves offer to train (upgrade) any such troops brought to them.  Unfortunately, you have none with you.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero::UpgradeCreatures(hero, CREATURE_OGRE, CREATURE_OGRE_LORD);
        hero::UpgradeCreatures(hero, CREATURE_ORC, CREATURE_ORC_CHIEF);
        hero::UpgradeCreatures(hero, CREATURE_DWARF, CREATURE_BATTLE_DWARF);
        if ( v93 == -1 )
        {
          if ( v88 == -1 )
            sprintf(
              gText,
              "{Hill Fort}\n\nAll of the %s you have in your army have been trained by the battle masters of the fort.  Your army now contains %s.",
              gArmyNamesPlural[v89],
              gArmyNamesPlural[v89 + 1]);
          else
            sprintf(
              gText,
              "{Hill Fort}\n\nAll of the %s and %s you have in your army have been trained by the battle masters of the fort.  Your army now contains %s and %s.",
              gArmyNamesPlural[v89],
              gArmyNamesPlural[v88],
              gArmyNamesPlural[v89 + 1],
              gArmyNamesPlural[v88 + 1]);
        }
        else
        {
          sprintf(
            gText,
            "{Hill Fort}\n\n All of the %s, %s and %s you have in your army have been trained by the battle masters of the fort.  Your army now contains %s, %s, and %s.",
            gArmyNamesPlural[v89],
            gArmyNamesPlural[v88],
            gArmyNamesPlural[v93],
            gArmyNamesPlural[v89 + 1],
            gArmyNamesPlural[v88 + 1],
            gArmyNamesPlural[v93 + 1]);
        }
        advManager::EventWindow(-1, 1, gText, 18, v89 + 1, (unsigned int)(v88 + 1) < 1 ? -1 : 18, v88 + 1, -1);
      }
      goto LABEL_511;
    case LOCATION_FREEMANS_FOUNDRY:
      v93 = -1;
      v88 = -1;
      v89 = -1;
      if ( hero::CreatureTypeCount(hero, CREATURE_PIKEMAN) )
        v89 = 3;
      if ( hero::CreatureTypeCount(hero, CREATURE_SWORDSMAN) )
      {
        if ( v89 == -1 )
          v89 = 5;
        else
          v88 = 5;
      }
      if ( hero::CreatureTypeCount(hero, CREATURE_IRON_GOLEM) )
      {
        if ( v89 == -1 )
        {
          v89 = 40;
        }
        else if ( v88 == -1 )
        {
          v88 = 40;
        }
        else
        {
          v93 = 40;
        }
      }
      if ( v89 == -1 )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Freeman's Foundry}\n\nA blacksmith working at the foundry offers to convert all Pikemen and Swordsmen's weapons brought to him from iron to steel. He also says that he knows a process that will convert Iron Golems into Steel Golems.  Unfortunately, you have none of these troops in your army, so he can't help you.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero::UpgradeCreatures(hero, 3, 4);
        hero::UpgradeCreatures(hero, 5, 6);
        hero::UpgradeCreatures(hero, 40, 41);
        if ( v93 == -1 )
        {
          if ( v88 == -1 )
            sprintf(
              gText,
              "{Freeman's Foundry}\n\nAll of your %s have been upgraded into %s.",
              gArmyNamesPlural[v89],
              gArmyNamesPlural[v89 + 1]);
          else
            sprintf(
              gText,
              "{Freeman's Foundry}\n\nAll of your %s and %s have been upgraded into %s and %s.",
              gArmyNamesPlural[v89],
              gArmyNamesPlural[v88],
              gArmyNamesPlural[v89 + 1],
              gArmyNamesPlural[v88 + 1]);
        }
        else
        {
          sprintf(
            gText,
            "{Freeman's Foundry}\n\nAll of your  %s, %s and %s have been upgraded into %s, %s, and %s.",
            gArmyNamesPlural[v89],
            gArmyNamesPlural[v88],
            gArmyNamesPlural[v93],
            gArmyNamesPlural[v89 + 1],
            gArmyNamesPlural[v88 + 1],
            gArmyNamesPlural[v93 + 1]);
        }
        advManager::EventWindow(-1, 1, gText, 18, v89 + 1, (unsigned int)(v88 + 1) < 1 ? -1 : 18, v88 + 1, -1);
      }
      goto LABEL_511;
    case LOCATION_SEA_CHEST:
      if ( ((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 && hero::NumArtifacts(hero) < 14 )
      {
        v4 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        sprintf(
          gText,
          "{Chest}\n\nAfter spending hours trying to fish the chest out of the sea, you open it and find 1000 gold and the %s",
          gArtifactNames[(unsigned __int8)v4]);
        v5 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        NormalDialog(gText, 1, -1, -1, 7, (unsigned __int8)v5, 6, 1000, -1, 0);
        v6 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        GiveArtifact(hero, (ARTIFACT)(unsigned __int8)v6, 1, -1);
        advManager::GiveResource(this, hero, 6, 1000);
      }
      else if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        NormalDialog(
          "{Chest}\n\nAfter spending hours trying to fish the chest out of the sea, you open it and find 1500 gold pieces.",
          1,
          -1,
          -1,
          6,
          1500,
          -1,
          0,
          -1,
          0);
        advManager::GiveResource(this, hero, 6, 1500);
      }
      else
      {
        NormalDialog(
          "{Chest}\n\nAfter spending hours trying to fish the chest out of the sea, you open it, only to find it empty.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      v90 = 1;
      shouldDelete = 1;
      goto LABEL_511;
    case LOCATION_FLOTSAM:
      switch ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        case 0u:
          NormalDialog("{Flotsam}\n\nYou search through the flotsam, but find nothing.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 1u:
          NormalDialog(
            "{Flotsam}\n\nYou search through the flotsam, and find some wood.",
            1,
            -1,
            -1,
            0,
            5,
            -1,
            0,
            -1,
            0);
          advManager::GiveResource(this, hero, 0, 5);
          break;
        case 2u:
          NormalDialog(
            "{Flotsam}\n\nYou search through the flotsam, and find some wood and some gold.",
            1,
            -1,
            -1,
            0,
            5,
            6,
            200,
            -1,
            0);
          advManager::GiveResource(this, hero, 0, 5);
          advManager::GiveResource(this, hero, 6, 200);
          break;
        case 3u:
          NormalDialog(
            "{Flotsam}\n\nYou search through the flotsam and find some wood and some gold.",
            1,
            -1,
            -1,
            0,
            10,
            6,
            500,
            -1,
            0);
          advManager::GiveResource(this, hero, 0, 10);
          advManager::GiveResource(this, hero, 6, 500);
          break;
        default:
          break;
      }
      v90 = 1;
      shouldDelete = 1;
      goto LABEL_511;
    case LOCATION_SHIPWRECK_SURVIVOR:
      if ( hero::NumArtifacts(hero) >= 14 )
      {
        NormalDialog(
          "{Shipwreck Survivor}\n\nYou've pulled a shipwreck survivor from certain death in an unforgiving ocean.  Grateful, he says, \"I would give you an artifact as a reward, but you're all full.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        sprintf(
          gText,
          "{Shipwreck Survivor}\n\nYou've pulled a shipwreck survivor from certain death in an unforgiving ocean.  Grateful, he rewards you for your act of kindness by giving you the %s.",
          gArtifactNames[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
        NormalDialog(
          gText,
          1,
          -1,
          -1,
          7,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          -1,
          0,
          -1,
          0);
        GiveArtifact(
          hero,
          (ARTIFACT)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          1,
          -1);
      }
      v90 = 1;
      shouldDelete = 1;
      goto LABEL_511;
    case LOCATION_MAGELLANS_MAPS:
      if ( gpCurPlayer->resources[6] >= 1000 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Magellan's Maps}\n\nA retired captain living on this refurbished fishing platform offers to sell you maps of the sea he made in his younger days for 1,000 gold.  Do you wish to buy the maps?",
          2,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
        if ( gpWindowManager->buttonPressedCode == 30725 )
        {
          gpCurPlayer->resources[6] -= 1000;
          game::MakeAllWaterVisible(gpGame, giCurPlayer);
          advManager::CompleteDraw(this, 0);
          advManager::UpdateScreen(this, 0, 0);
        }
      }
      else
      {
        NormalDialog(
          "{Magellan's Maps}\n\nThe captain sighs.  \"You don't have enough money, eh?  You can't expect me to give my maps away for free!\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      goto LABEL_511;
    case LOCATION_WITCH_HUT:
      if ( hero->secondarySkillLevel[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] )
      {
        sprintf(
          gText,
          "{Witch's Hut}\n\nYou approach the hut and observe a witch inside studying an ancient tome on %s.  As you approach, she turns and speaks.  \"You already know that which I would teach you. I can help you no further.\"",
          gSecondarySkills[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
        NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
      }
      else if ( hero->numSecSkillsKnown < 8 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        sprintf(
          gText,
          "{Witch's Hut}\n\nAn ancient and immortal witch living in a hut with bird's legs for stilts teaches you %s for her own inscrutable purposes.",
          gSecondarySkills[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
        advManager::EventWindow(
          -1,
          1,
          gText,
          17,
          3 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          -1,
          0,
          -1);
        hero::GiveSS(hero, (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5), 1);
      }
      else
      {
        sprintf(
          gText,
          "{Witch's Hut}\n\nYou approach the hut and observe a witch inside studying an ancient tome on %s.  As you approach, she turns and focuses her one glass eye on you.  \"You already know everything you deserve to learn!\" the witch screeches. \"NOW GET OUT OF MY HOUSE!\"",
          gSecondarySkills[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
        NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
      }
      goto LABEL_511;
    case LOCATION_ARTESIAN_SPRING:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        v7 = hero::Stats(hero, PRIMARY_SKILL_KNOWLEDGE);
        v63 = 10 * v7;
        if ( hero->spellpoints < 20 * v7 )
        {
          NormalDialog(
            "{Artesian Spring}\n\nA drink from the spring fills your blood with magic!  You have twice your normal spell points in reserve.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          hero->spellpoints = 2 * v63;
        }
        else
        {
          NormalDialog(
            "{Artesian Spring}\n\nA drink at the spring is supposed to give you twice your normal spell points, but you are already at that level.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
        }
      }
      else
      {
        NormalDialog(
          "{Artesian Spring}\n\nThe spring only refills once a week, and someone's already been here this week.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      goto LABEL_511;
    case LOCATION_MAGIC_WELL:
      if ( BYTE1(hero->flags) & HERO_VISITED_WELL )
      {
        NormalDialog(
          "{Magic Well}\n\nA second drink at the well in one day will not help you.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        maxSP = 10 * hero::Stats(hero, PRIMARY_SKILL_KNOWLEDGE);
        if ( hero->spellpoints < maxSP )
        {
          NormalDialog(
            "{Magic Well}\n\nA drink from the well has restored your spell points to maximum.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          hero->flags |= 0x1000u;
          hero->spellpoints = maxSP;
        }
        else
        {
          NormalDialog(
            "{Magic Well}\n\nA drink at the well is supposed to restore your spell points, but you are already at maximum.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
        }
      }
      goto LABEL_511;
    case LOCATION_ARMY_CAMP|LOCATION_SKELETON:
      if ( hero->flags & 0x80 )
      {
        hero->flags &= 0xFFFFFF7Fu;
        hero->remainingMobility = 0;
        HIBYTE(hero->field_2B) = LOBYTE(this->field_27E);
        this->field_27A = hero->factionID;
        this->field_282 = advManager::GetCursorBaseFrame(this->field_27E);
        this->field_272 = 1;
        res1 = (SAMPLE2)LoadPlaySample("killfade.82m");
        heroWindowManager::SaveFizzleSource(gpWindowManager, 192, 192, 96, 96);
        advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
        heroWindowManager::FizzleForward(gpWindowManager, 192, 192, 96, 96, -1, 0, 0);
        WaitEndSample((void *)0xFFFFFFFF, (resource *)res1.file, res1.sample);
        advManager::CheckAdjacentMon(this, (signed int)&v61);
      }
      goto LABEL_511;
    case LOCATION_BOAT:
      v69 = &gpGame->boats[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      game::RestoreCell(-1, -1, v69->underlyingObjType, v69->underlyingObjExtra, (int)loc, 2);
      hero->flags |= HERO_AT_SEA;
      hero->remainingMobility = 0;
      v69->field_6 = hero->idx;
      v69->owner = hero->ownerIdx;
      this->field_27A = 6;
      this->field_27E = v69->field_3;
      this->field_282 = advManager::GetCursorBaseFrame(this->field_27E);
      this->field_272 = 1;
      advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
      advManager::UpdateScreen(this, 0, 0);
      goto LABEL_511;
    case LOCATION_MINE:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == giCurPlayer )
        goto LABEL_511;
      if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType == -1 )
        goto LABEL_126;
      v60 = advManager::CombatMonsterEvent(
              this,
              hero,
              gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType,
              gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty,
              loc,
              locX,
              locY,
              0,
              locX,
              locY,
              -1,
              0,
              0,
              -1,
              0,
              0);
      if ( !v60 )
      {
        gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = -1;
        hero::CheckLevel(hero);
LABEL_126:
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type == 6 )
        {
          v82 = 1000;
        }
        else if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type == 2 )
        {
          v82 = 2;
        }
        else
        {
          v82 = 1;
        }
        advManager::EventWindow(
          gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type
        + 59,
          1,
          byte_514A64,
          gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type,
          -v82,
          -1,
          0,
          -1);
        goto LABEL_136;
      }
      goto LABEL_511;
    case LOCATION_ALCHEMIST_LAB:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == giCurPlayer )
        goto LABEL_511;
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(0, 1, byte_514A68, 1, -1, -1, 0, -1);
      goto LABEL_136;
    case LOCATION_SAWMILL:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != giCurPlayer )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(73, 1, byte_514A6C, 0, -2, -1, 0, -1);
LABEL_136:
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          giCurPlayer);
      }
      goto LABEL_511;
    case LOCATION_LIGHTHOUSE:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != giCurPlayer )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          giCurPlayer);
        advManager::EventWindow(58, 1, byte_514A70, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_TREASURE_CHEST:
      if ( !(((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1) )
        goto LABEL_143;
      if ( hero::NumArtifacts(hero) < 14 )
      {
        v9 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        sprintf(
          gText,
          "{Chest}\n\nAfter scouring the area, you fall upon a hidden chest, containing the ancient artifact '%s'",
          gArtifactNames[(unsigned __int8)v9]);
        v10 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        NormalDialog(gText, 1, -1, -1, 7, (unsigned __int8)v10, -1, 0, -1, 0);
        v11 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        GiveArtifact(hero, (ARTIFACT)(unsigned __int8)v11, 1, -1);
      }
      else
      {
        v8 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
        LOBYTE(v8) = v8 | 0x10;
        loc->field_4_1_1_isShadow_1_13_extraInfo = v8;
LABEL_143:
        advManager::EventWindow(
          -1,
          2,
          "{Chest}\n\nAfter scouring the area, you fall upon a hidden treasure cache.  You may take the gold or distribute the gold to the peasants for experience.  Do you wish to keep the gold?",
          6,
          500 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          14,
          125 * (4 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 4),
          1);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          advManager::GiveResource(
            this,
            hero,
            6,
            500 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
        else
          advManager::GiveExperience(
            hero,
            125 * (4 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 4),
            0);
      }
      shouldDelete = 1;
      v90 = 1;
      hero::CheckLevel(hero);
      goto LABEL_511;
    case LOCATION_BUOY:
      if ( hero->flags & 2 )
      {
        advManager::EventWindow(2, 1, byte_514B94, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 2u;
        ++hero->tempMoraleBonuses;
        advManager::EventWindow(3, 1, byte_514B98, 12, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_FAERIE_RING:
      if ( hero->flags & 0x10 )
      {
        advManager::EventWindow(12, 1, byte_514B9C, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 0x10u;
        ++hero->tempLuckBonuses;
        advManager::EventWindow(13, 1, byte_514BA0, 10, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_IDOL:
      if ( BYTE1(hero->flags) & 0x20 )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Idol}\n\nYou've found an ancient and weathered stone idol.  It is supposed to grant luck to visitors, but since the stars are already smiling upon you, it does nothing.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 0x2000u;
        ++hero->tempLuckBonuses;
        advManager::EventWindow(
          -1,
          1,
          "{Idol}\n\nYou've found an ancient and weathered stone idol.  Kissing it is supposed to be lucky, so you do.  The stone is very cold to the touch.",
          10,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_FOUNTAIN:
      if ( hero->flags & 4 )
      {
        advManager::EventWindow(15, 1, byte_514CDC, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 4u;
        ++hero->tempLuckBonuses;
        advManager::EventWindow(16, 1, byte_514CE0, 10, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_WATERING_HOLE:
      if ( BYTE1(hero->flags) & 2 )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Watering Hole}\n\nThe drink at the watering hole is refreshing, but offers no further benefit.  The watering hole might help again if you fought a battle first.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 0x200u;
        ++hero->tempMoraleBonuses;
        hero->mobility += 400;
        hero->remainingMobility += 400;
        advManager::EventWindow(
          -1,
          1,
          "{Watering Hole}\n\nA drink at the watering hole fills your troops with strength and lifts their spirits.  You can travel a bit further today.",
          12,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_OASIS:
      if ( hero->flags & 8 )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Oasis}\n\nThe drink at the oasis is refreshing, but offers no further benefit.  The oasis might help again if you fought a battle first.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 8u;
        ++hero->tempMoraleBonuses;
        hero->mobility += 800;
        hero->remainingMobility += 800;
        advManager::EventWindow(
          -1,
          1,
          "{Oasis}\n\nA drink at the oasis fills your troops with strength and lifts their spirits.  You can travel a bit further today.",
          12,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_TEMPLE:
      if ( BYTE1(hero->flags) & 1 )
      {
        NormalDialog(
          "{Temple}\n\nIt doesn't help to pray twice before a battle.  Come back after you've fought.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        hero->flags |= 0x100u;
        hero->tempMoraleBonuses += 2;
        NormalDialog(
          "{Temple}\n\nA visit and a prayer at the temple raises the morale of your troops.",
          1,
          -1,
          -1,
          12,
          0,
          12,
          0,
          -1,
          0);
      }
      goto LABEL_511;
    case LOCATION_LEAN_TO:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        v12 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v13 = (v12 & 0xF0u) >> 4;
        v14 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        NormalDialog(
          "{Lean To}\n\nYou've found an abandoned lean-to.  Poking about, you discover some resources hidden nearby.",
          1,
          -1,
          -1,
          (v14 & 0xF) - 1,
          v13,
          -1,
          0,
          -1,
          0);
        v15 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v16 = (v15 & 0xF0u) >> 4;
        v17 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        advManager::GiveResource(this, hero, (v17 & 0xF) - 1, v16);
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      else
      {
        NormalDialog(
          "{Lean To}\n\nThe lean-to is long abandoned.  There is nothing of value here.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      goto LABEL_511;
    case LOCATION_WAGON:
      if ( !((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
        goto LABEL_180;
      if ( (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x80 )
      {
        if ( hero::NumArtifacts(hero) == 14 )
        {
LABEL_180:
          advManager::EventWindow(
            -1,
            1,
            "{Wagon}\n\nYou come across an old wagon left by a trader who didn't quite make it to safe terrain.  Unfortunately, others have found it first, and the wagon is empty.",
            -1,
            0,
            -1,
            0,
            -1);
          loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        }
        else
        {
          advManager::EventSound(
            this,
            locType,
            (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
            &res2);
          v18 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
          a2 = v18 & 0x7F;
          sprintf(
            gText,
            "{Wagon}\n\nYou come across an old wagon left by a trader who didn't quite make it to safe terrain.  Searching inside, you find the '%s'.",
            gArtifactNames[v18 & 0x7F]);
          advManager::EventWindow(-1, 1, gText, 7, a2, -1, 0, -1);
          GiveArtifact(hero, (ARTIFACT)a2, 1, -1);
          loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        }
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        v19 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v20 = (v19 & 0xF0u) >> 4;
        v21 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        advManager::EventWindow(
          -1,
          1,
          "{Wagon}\n\nYou come across an old wagon left by a trader who didn't quite make it to safe terrain.  Inside, you find some of the wagon's cargo still intact.",
          (v21 & 0xF) - 1,
          v20,
          -1,
          0,
          -1);
        v22 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v23 = (v22 & 0xF0u) >> 4;
        v24 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        advManager::GiveResource(this, hero, (v24 & 0xF) - 1, v23);
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      goto LABEL_511;
    case LOCATION_SKELETON:
      if ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 1 )
      {
        advManager::EventWindow(93, 1, byte_515240, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        if ( hero::NumArtifacts(hero) == 14 )
        {
          sprintf(gText, "%s.", "Treasure");
          advManager::EventWindow(-1, 1, gText, 6, 1000, -1, 0, -1);
          advManager::GiveResource(this, hero, 6, 1000);
        }
        else
        {
          a2 = (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 2;
          sprintf(gText, "%s %s", gEventText[94], gArtifactNames[a2]);
          GiveArtifact(hero, (ARTIFACT)a2, 1, -1);
          advManager::EventWindow(-1, 1, gText, 7, a2, -1, 0, -1);
        }
        v25 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
        LOBYTE(v25) = v25 | 8;
        loc->field_4_1_1_isShadow_1_13_extraInfo = v25;
      }
      goto LABEL_511;
    case LOCATION_CAMPFIRE:
      v26 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      advManager::EventWindow(
        14,
        1,
        byte_51525C,
        6,
        100
      * ((signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4),
        v26 & 0xF,
        (signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4,
        -1);
      advManager::GiveResource(
        this,
        hero,
        6,
        100
      * ((signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4));
      v27 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      advManager::GiveResource(
        this,
        hero,
        v27 & 0xF,
        (signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4);
      shouldDelete = 1;
      v90 = 1;
      advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
      goto LABEL_511;
    case LOCATION_XANADU:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->xanadusVisited )
      {
        NormalDialog(
          "{Xanadu}\n\nRecognizing you, the butler refuses to admit you.  \"The master,\" he says, \"will not see the same student twice.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else if ( hero->oldLevel + 2 * hero->secondarySkillLevel[4] < 10 )
      {
        NormalDialog(
          "{Xanadu}\n\nThe butler opens the door and looks you up and down.  \"You are neither famous nor diplomatic enough to be admitted to see my master,\" he sniffs.  \"Come back when you think yourself worthy.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Xanadu}\n\nThe butler admits you to see the master of the house.  He trains you in the four skills a hero should know.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
        ++hero->primarySkills[0];
        ++hero->primarySkills[1];
        ++hero->primarySkills[3];
        ++hero->primarySkills[2];
        hero->xanadusVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_511;
    case LOCATION_FORT:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->fortsVisited )
      {
        NormalDialog(
          "{Fort}\n\n \"I'm sorry sir,\" The leader of the soldiers says, \"but you already know everything we have to teach.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Fort}\n\n The soldiers living in the fort teach you a few new defensive tricks.",
          1,
          -1,
          -1,
          25,
          101,
          -1,
          0,
          -1,
          0);
        ++hero->primarySkills[1];
        hero->fortsVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_511;
    case LOCATION_STANDING_STONES:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->standingStonesVisited )
      {
        NormalDialog(
          "{Standing Stones}\n\nYou've found a group of Druids worshipping at one of their strange stone edifices.  Silently, the Druids turn you away, indicating they have nothing new to teach you.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Standing Stones}\n\nYou've found a group of Druids worshipping at one of their strange stone edifices.  Silently, they teach you new ways to cast spells.",
          1,
          -1,
          -1,
          25,
          102,
          -1,
          0,
          -1,
          0);
        ++hero->primarySkills[2];
        hero->standingStonesVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_511;
    case LOCATION_WITCH_DOCTORS_HUT:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->witchDoctorHutsVisited )
      {
        NormalDialog(
          "{Witch Doctor's Hut}\n\n\"Go 'way!\", the witch doctor barks, \"you know all I know.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Witch Doctor's Hut}\n\nAn Orcish witch doctor living in the hut deepens your knowledge of magic by showing you how to cast stones, read portents, and decipher the intricacies of chicken entrails.",
          1,
          -1,
          -1,
          25,
          103,
          -1,
          0,
          -1,
          0);
        ++hero->primarySkills[3];
        hero->witchDoctorHutsVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_511;
    case LOCATION_MERCENARY_CAMP:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->mercenaryCampsVisited )
      {
        NormalDialog(
          "{Mercenary Camp}\n\nYou've come upon a mercenary camp practicing their tactics.  \"You're too advanced for us,\" the mercenary captain says.  \"We can teach nothing more.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        NormalDialog(
          "{Mercenary Camp}\n\nYou've come upon a mercenary camp practicing their tactics.  The mercenaries welcome you and your troops and invite you to train with them.",
          1,
          -1,
          -1,
          25,
          100,
          -1,
          0,
          -1,
          0);
        ++hero->primarySkills[0];
        hero->mercenaryCampsVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_511;
    case LOCATION_GAZEBO:
      if ( (1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hero->gazeboesVisited )
      {
        advManager::EventWindow(17, 1, byte_515894, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(18, 1, byte_515898, 14, 1000, -1, 0, -1);
        advManager::GiveExperience(hero, 1000, 0);
        hero->gazeboesVisited |= 1 << (loc->field_4_1_1_isShadow_1_13_extraInfo >> 3);
        hero::CheckLevel(hero);
      }
      goto LABEL_511;
    case LOCATION_WATERWHEEL:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          60,
          1,
          byte_5158A0,
          6,
          500 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          -1,
          0,
          -1);
        advManager::GiveResource(
          this,
          hero,
          6,
          500 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
        loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      else
      {
        advManager::EventWindow(59, 1, byte_51589C, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_RESOURCE:
      type = loc->objectIndex >> 1;
      if ( type == 6 )
        amt = 100 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      else
        amt = (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      advManager::GiveResource(this, hero, type, amt);
      strcpy(&a1, gResourceNames[type]);
      a1 += 32;
      sprintf(gText, gEventText[72], &a1);
      if ( type == 6 )
        v50 = 100 * (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      else
        v50 = (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      BVResMsg(gText, type, v50);
      shouldDelete = 1;
      v90 = 1;
      goto LABEL_511;
    case LOCATION_WINDMILL:
      if ( (signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) > 6 )
      {
        advManager::EventWindow(86, 1, byte_5158A8, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          87,
          1,
          byte_5158A4,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          2,
          -1,
          0,
          -1);
        advManager::GiveResource(
          this,
          hero,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          2);
        loc->field_4_1_1_isShadow_1_13_extraInfo = loc->field_4_1_1_isShadow_1_13_extraInfo & 7 | 0x318;
      }
      goto LABEL_511;
    case LOCATION_ANCIENT_LAMP:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(19, 2, byte_5158AC, -1, 0, -1, 0, -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        advManager::RecruitEvent(this, hero, 60, loc);
        if ( !((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
        {
          shouldDelete = 1;
          v90 = 1;
        }
      }
      goto LABEL_511;
    case LOCATION_TREE_CITY:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{Tree City}\n\nSome of the Sprites living in the tree city are willing to join your army for a price.  Do you want to recruit Sprites?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          advManager::RecruitEvent(this, hero, 20, loc);
      }
      else
      {
        advManager::EventWindow(
          -1,
          1,
          "{Tree City}\n\nYou've found a Sprite Tree City.  Unfortunately, none of the Sprites living there wish to join an army.  Maybe next week.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_RUINS:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{Ruins}\n\nYou've found some Medusas living in the ruins.  They are willing to join your army for a price.  Do you want to recruit Medusas?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          advManager::RecruitEvent(this, hero, CREATURE_MEDUSA, loc);
      }
      else
      {
        advManager::EventWindow(
          -1,
          1,
          "{Ruins}\n\nYou search the ruins, but the Medusas that used to live here are gone.  Perhaps there will be more next week.",
          -1,
          0,
          -1,
          0,
          -1);
      }
      goto LABEL_511;
    case LOCATION_TROLL_BRIDGE:
      if ( !((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Troll Bridge}\n\nYou've found one of those bridges that Trolls are so fond of living under, but there are none here.  Perhaps there will be some next week.",
          -1,
          0,
          -1,
          0,
          -1);
        goto LABEL_511;
      }
      if ( ((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
      {
        advManager::EventWindow(
          -1,
          2,
          "{Troll Bridge}\n\nTrolls living under the bridge challenge you.  Will you fight them?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
        if ( advManager::CombatMonsterEvent(this, hero, 17, 12, loc, locX, locY, 0, locX, locY, 18, 8, 2, -1, 0, 0) )
          goto LABEL_511;
        hero::CheckLevel(hero);
        loc->field_4_1_1_isShadow_1_13_extraInfo = loc->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                                * ((unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                                                                                                 - 256);
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{Troll Bridge}\n\nA few Trolls remain, cowering under the bridge.  They approach you and offer to join your forces as mercenaries.  Do you want to buy any Trolls?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{Troll Bridge}\n\nSome Trolls living under a bridge are willing to join your army, but for a price.  Do you want to recruit Trolls?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
      }
      advManager::RecruitEvent(this, hero, 17, loc);
      goto LABEL_511;
    case LOCATION_CITY_OF_DEAD:
      if ( !((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        advManager::EventWindow(
          -1,
          1,
          "{City of the Dead}\n\nThe City of the Dead is empty of life, and empty of unlife as well.  Perhaps some undead will move in next week.",
          -1,
          0,
          -1,
          0,
          -1);
        goto LABEL_511;
      }
      if ( ((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
      {
        advManager::EventWindow(
          -1,
          2,
          "{City of the Dead}\n\nYou've found the ruins of an ancient city, now inhabited solely by the undead.  Will you search?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
        if ( advManager::CombatMonsterEvent(this, hero, 53, 10, loc, locX, locY, 0, locX, locY, 48, 40, 2, 55, 5, 1) )
          goto LABEL_511;
        hero::CheckLevel(hero);
        loc->field_4_1_1_isShadow_1_13_extraInfo = loc->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                                * ((unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                                                                                                 - 256);
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{City of the Dead}\n\nSome of the surviving Liches are impressed by your victory over their fellows, and offer to join you for a price.  Do you want to recruit Liches?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{City of the Dead}\n\nSome Liches living here are willing to join your army for a price.  Do you want to recruit Liches?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
      }
      advManager::RecruitEvent(this, hero, 55, loc);
      goto LABEL_511;
    case LOCATION_DRAGON_CITY:
      if ( !((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        advManager::EventWindow(
          -1,
          1,
          "{Dragon City}\n\nThe Dragon city has no Dragons willing to join you this week.  Perhaps a Dragon will become available next week.",
          -1,
          0,
          -1,
          0,
          -1);
        goto LABEL_511;
      }
      if ( !(((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1) )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(
          -1,
          2,
          "{Dragon City}\n\nThe Dragon city is willing to offer some Dragons for your army for a price.  Do you wish to recruit Dragons?",
          -1,
          0,
          -1,
          0,
          -1);
        if ( gpWindowManager->buttonPressedCode != 30725 )
          goto LABEL_511;
        goto LABEL_284;
      }
      advManager::EventWindow(
        -1,
        2,
        "{Dragon City}\n\nYou stand before the Dragon City, a place off-limits to mere humans.  Do you wish to violate this rule and challenge the Dragons to a fight?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        a13 = 1;
        if ( gbInCampaign && gpGame->field_2 == 1 && gpGame->field_4 == 6 )
          a13 = 2;
        if ( !advManager::CombatMonsterEvent(
                this,
                hero,
                35,
                3 * a13,
                loc,
                locX,
                locY,
                0,
                locX,
                locY,
                36,
                a13,
                1,
                37,
                a13,
                1) )
        {
          CheckEndGame(0, 1);
          if ( !gbGameOver )
          {
            hero::CheckLevel(hero);
            loc->field_4_1_1_isShadow_1_13_extraInfo = loc->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 256);
            advManager::EventSound(
              this,
              locType,
              (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              &res2);
            advManager::EventWindow(
              -1,
              2,
              "{Dragon City}\n\nHaving defeated the Dragon champions, the city's leaders agree to supply some Dragons to your army for a price.  Do you wish to recruit Dragons?",
              -1,
              0,
              -1,
              0,
              -1);
            if ( gpWindowManager->buttonPressedCode == 30725 )
            {
LABEL_284:
              advManager::RecruitEvent(this, hero, 36, loc);
              goto LABEL_511;
            }
          }
        }
      }
LABEL_511:
      advManager::UpdateRadar(this, 1, 0);
      advManager::UpdateHeroLocators(this, 1, 1);
      advManager::UpdateTownLocators(this, 1, 1);
      advManager::UpdBottomView(this, 1, 1, 1);
      if ( shouldDelete )
      {
        advManager::EraseObj(this, loc, locX, locY);
        advManager::FizzleCenter(this, v90);
      }
      else
      {
        advManager::CompleteDraw(this, 0);
      }
      advManager::UpdateScreen(this, 0, 0);
      soundManager::SwitchAmbientMusic(
        (soundManager *)gpSoundManager,
        (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
      WaitEndSample((void *)0xFFFFFFFF, (resource *)res2.file, res2.sample);
      CheckEndGame(0, 0);
      return;
    case LOCATION_WAGON_CAMP:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(84, 2, byte_516138, -1, 0, -1, 0, -1);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          advManager::RecruitEvent(this, hero, 57, loc);
      }
      else
      {
        advManager::EventWindow(83, 1, byte_516134, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_DESRT_TENT:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        advManager::EventWindow(82, 2, byte_516140, -1, 0, -1, 0, -1);
        if ( gpWindowManager->buttonPressedCode == 30725 )
          advManager::RecruitEvent(this, hero, 58, loc);
      }
      else
      {
        advManager::EventWindow(81, 1, byte_51613C, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_ARCHERS_HOUSE:
    case LOCATION_GOBLIN_HUT:
    case LOCATION_DWARF_COTTAGE:
    case LOCATION_PEASANT_HUT:
    case LOCATION_LOG_CABIN:
    case LOCATION_WATCH_TOWER:
    case LOCATION_TREE_HOUSE:
    case LOCATION_DWARF_CABIN:
    case LOCATION_HALFLING_HOLE:
    case LOCATION_EXCAVATION:
    case LOCATION_CAVE:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
      advManager::HouseEvent((int)hero, (int)loc);
      goto LABEL_511;
    case LOCATION_ARMY_CAMP:
      advManager::PlayerMonsterInteract(
        this,
        loc,
        loc,
        hero,
        (heroWindow *)&shouldDelete,
        __PAIR__(locY, locX),
        0,
        __PAIR__(locY, locX));
      goto LABEL_511;
    case LOCATION_OBELISK:
      if ( gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                           + 47] & (1 << hero->ownerIdx) )
      {
        advManager::EventWindow(69, 1, byte_516148, -1, 0, -1, 0, -1);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) + 47] |= 1 << hero->ownerIdx;
        advManager::EventWindow(68, 1, byte_516144, -1, 0, -1, 0, -1);
        advManager::ViewPuzzle(this);
      }
      goto LABEL_511;
    case LOCATION_TREE_OF_KNOWLEDGE:
      if ( (1 << ((loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & hero->treesOfKnowledgeVisited )
      {
        NormalDialog(
          "{Tree of Knowledge}\n\nUpon your approach, the tree opens its eyes in delight.  \"It is good to see you, my student.  I hope my teachings have helped you.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        level = hero::GetLevel(hero->experience);
        v28 = hero::GetExperience(level + 1);
        xp = v28 - hero::GetExperience(level);
        v48 = (signed int)(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 6;
        switch ( v48 )
        {
          case 1:
            NormalDialog(
              "{Tree of Knowledge}\n\nUpon your approach, the tree opens its eyes in delight.  \"Ahh, an adventurer!  Allow me to teach you a little of what I have learned over the ages.\"",
              1,
              -1,
              -1,
              14,
              -1,
              -1,
              0,
              -1,
              0);
            advManager::GiveExperience(hero, xp, 0);
            hero->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
            break;
          case 2:
            if ( gpCurPlayer->resources[6] < 2000 )
            {
              NormalDialog(
                "{Tree of Knowledge}\n\nTears brim in the eyes of the tree.  \"I need 2000 gold.\" it whispers. (sniff)  \"Well, come back when you can pay me.\"",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              NormalDialog(
                "{Tree of Knowledge}\n\nUpon your approach, the tree opens its eyes in delight.  \"Ahh, an adventurer! I will be happy to teach you a little of what I have learned over the ages for a mere 2000 gold.\"  (Just bury it around my roots.)",
                2,
                -1,
                -1,
                14,
                -1,
                -1,
                0,
                -1,
                0);
              if ( gpWindowManager->buttonPressedCode == 30725 )
              {
                gpCurPlayer->resources[6] -= 2000;
                advManager::GiveExperience(hero, xp, 0);
                hero->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
              }
            }
            break;
          case 3:
            if ( gpCurPlayer->resources[5] < 10 )
            {
              NormalDialog(
                "{Tree of Knowledge}\n\nTears brim in the eyes of the tree.  \"I need 10 gems.\" it whispers. (sniff)  \"Well, come back when you can pay me.\"",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              NormalDialog(
                "{Tree of Knowledge}\n\nAhh, an adventurer! I will be happy to teach you a little of what I have learned over the ages for a mere 10 gems.\"  (Just bury it around my roots.)",
                2,
                -1,
                -1,
                14,
                -1,
                -1,
                0,
                -1,
                0);
              if ( gpWindowManager->buttonPressedCode == 30725 )
              {
                gpCurPlayer->resources[5] -= 10;
                advManager::GiveExperience(hero, xp, 0);
                hero->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
              }
            }
            break;
        }
      }
      hero::CheckLevel(hero);
      goto LABEL_511;
    case LOCATION_ORACLE:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(74, 1, byte_516540, -1, 0, -1, 0, -1);
      thisb = (heroWindow *)operator new(68);
      if ( thisb )
        a2a = (int)heroWindow::heroWindow(thisb, 0, 0, "thiefwin.bin");
      else
        a2a = 0;
      if ( !a2a )
        MemError();
      SetWinText((heroWindow *)a2a, 14);
      townManager::SetupThievesGuild((heroWindow *)a2a, 99);
      strcpy(gText, "Shrine - Player Rankings");
      evt.eventCode = INPUT_GUI_MESSAGE_CODE;
      evt.messageType = GUI_MESSAGE_SET_TEXT;
      evt.fieldID = 0;
      evt.payload = gText;
      heroWindow::BroadcastMessage((heroWindow *)a2a, (tag_message *)&evt);
      heroWindowManager::DoDialog(gpWindowManager, (heroWindow *)a2a, TrueFalseDialogHandler, 0);
      operator delete((void *)a2a);
      advManager::RedrawAdvScreen(this, 1, 0);
      goto LABEL_511;
    case LOCATION_SHRINE_FIRST:
      sprintf(
        gText,
        "%s'%s'.  ",
        "{Shrine of the 1st Circle}\n\nYou come across a small shrine attended by a group of novice acolytes.  In exchange for your protection, they agree to teach you a simple spell - ",
        dword_4F6ABC[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
      goto LABEL_333;
    case LOCATION_SHRINE_SECOND_ORDER:
      sprintf(
        gText,
        "%s'%s'.  ",
        "{Shrine of the 2nd Circle}\n\nYou come across an ornate shrine attended by a group of rotund friars.  In exchange for your protection, they agree to teach you a spell - ",
        dword_4F6ABC[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
      goto LABEL_333;
    case LOCATION_SHRINE_THIRD_ORDER:
      sprintf(
        gText,
        "%s'%s'.  ",
        "{Shrine of the 3rd Circle}\n\nYou come across a lavish shrine attended by a group of high priests.  In exchange for your protection, they agree to teach you a sophisticated spell - ",
        dword_4F6ABC[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
LABEL_333:
      if ( hero::HasArtifact(hero, 81) )
      {
        if ( gsSpellInfo[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1].level > hero->secondarySkillLevel[7] + 2 )
        {
          strcat(
            gText,
            "Unfortunately, you do not have the wisdom to understand the spell, and you are unable to learn it.  ");
          advManager::EventWindow(-1, 1, gText, -1, 0, -1, 0, -1);
        }
        else
        {
          advManager::EventSound(
            this,
            locType,
            (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
            &res2);
          v29 = hero::Stats(hero, PRIMARY_SKILL_KNOWLEDGE);
          hero::AddSpell(
            hero,
            (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
            v29);
          advManager::EventWindow(
            -1,
            1,
            gText,
            8,
            (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
            -1,
            0,
            -1);
        }
      }
      else
      {
        strcat(gText, "Unfortunately, you have no Magic Book to record the spell with.");
        advManager::EventWindow(-1, 1, gText, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_TOWN:
      advManager::TownEvent((int)this, (int)loc, __PAIR__(locY, locX));
      goto LABEL_511;
    case LOCATION_WHIRLPOOL:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::DoWhirlpool(this, hero);
      goto LABEL_343;
    case LOCATION_STONE_LITHS:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
LABEL_343:
      v70 = 0;
      for ( y = 0; y < MAP_HEIGHT; ++y )
      {
        for ( x = 0; MAP_WIDTH > x; ++x )
        {
          if ( *(&gpGame->map.tiles[x].objType + 12 * y * gpGame->map.width) == (unsigned __int8)((unsigned __int8)locType | 0x80) )
          {
            if ( *(&gpGame->map.tiles[x].objectIndex + 12 * y * gpGame->map.width) == loc->objectIndex )
            {
              v30 = abs(x - locX);
              if ( abs(y - locY) + v30 > ((unsigned int)(locType - 36) < 1 ? 1 : 3) )
                ++v70;
            }
          }
        }
      }
      if ( v70 < 1 )
        goto LABEL_511;
      if ( v70 > 1 )
        v70 = Random(1, v70);
      y = 0;
LABEL_357:
      if ( y < MAP_HEIGHT )
      {
        for ( x = 0; ; ++x )
        {
          if ( MAP_WIDTH <= x )
          {
            ++y;
            goto LABEL_357;
          }
          if ( *(&gpGame->map.tiles[x].objType + 12 * y * gpGame->map.width) == (unsigned __int8)((unsigned __int8)locType | 0x80)
            && *(&gpGame->map.tiles[x].objectIndex + 12 * y * gpGame->map.width) == loc->objectIndex
            && (x != locX || y != locY) )
          {
            v31 = abs(x - locX);
            if ( abs(y - locY) + v31 > ((unsigned int)(locType - 36) < 1 ? 1 : 3) )
            {
              --v70;
              if ( v70 <= 0 )
                break;
            }
          }
        }
      }
      advManager::StopCursor(this, 1);
      advManager::TeleportTo(gpAdvManager, hero, x, y, 1, 0);
      goto LABEL_511;
    case LOCATION_ARTIFACT:
      v32 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      v77 = (v32 & 0xF0u) >> 4;
      a5 = loc->objectIndex >> 1;
      v33 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      creat = v33 & 0x7F;
      if ( hero::NumArtifacts(hero) == 14 )
      {
        NormalDialog("You cannot pick up this artifact, you already have a full load!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
        goto LABEL_511;
      }
      if ( xIsPlayingExpansionCampaign && ExpCampaign::IsSpecialGoldenBow((int)&xCampaign, locX, locY) )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        strcpy(
          gText,
          "The fabled golden bow of the elves lies here in the dust.  You take it and journey back to the elven towns.  They shower you with their graciousness and the king promises that his people will aid you whenever you seek help.");
        advManager::EventWindow(-1, 1, gText, 7, a5, -1, 0, -1);
        GiveArtifact(hero, (ARTIFACT)a5, 1, (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
        shouldDelete = 1;
        v90 = 1;
        goto LABEL_511;
      }
      if ( a5 == ARTIFACT_SPELL_SCROLL )
      {
        advManager::EventSound(this, locType, 1, &res2);
        xTheSpell = (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
        advManager::EventWindow(-1, 1, *(&gArtifactEvents + 86), 7, ARTIFACT_SPELL_SCROLL, -1, 0, -1);
        GiveArtifact(
          hero,
          ARTIFACT_SPELL_SCROLL,
          1,
          (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
        shouldDelete = 1;
        v90 = 1;
        goto LABEL_511;
      }
      if ( ((unsigned __int16)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
      {
        advManager::EventSound(
          this,
          locType,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          &res2);
        if ( creat == 57 )
        {
          NormalDialog(
            "{Artifact}\n\nYou come upon an ancient artifact.  As you reach for it, a pack of Rogues leap out of the brush to guard their stolen loot.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          v73 = 50;
        }
        else
        {
          v73 = 1;
          sprintf(
            gText,
            "{Artifact}\n\nThrough a clearing you observe an ancient artifact.  Unfortunately, it's guarded by a nearby %s.  Do you want to fight the %s for the artifact?",
            gArmyNames[creat],
            gArmyNames[creat]);
          NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
          if ( gpWindowManager->buttonPressedCode != 30725 )
          {
            NormalDialog(
              "Discretion is the better part of valor, and you decide to avoid this fight for today.",
              1,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
            goto LABEL_511;
          }
        }
        if ( advManager::CombatMonsterEvent(this, hero, creat, v73, loc, locX, locY, 0, locX, locY, -1, 0, 0, -1, 0, 0) )
          goto LABEL_511;
        hero::CheckLevel(hero);
        sprintf(gText, "Victorious, you take your prize, the %s", gArtifactNames[a5]);
        NormalDialog(gText, 1, -1, -1, 7, loc->objectIndex >> 1, -1, 0, -1, 0);
LABEL_392:
        GiveArtifact(hero, (ARTIFACT)a5, 1, -1);
        shouldDelete = 1;
        v90 = 1;
      }
      else
      {
        v34 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        switch ( v34 & 0xF )
        {
          case 4:
            if ( hero->secondarySkillLevel[7] )
              goto LABEL_391;
            sprintf(
              gText,
              "{Artifact}\n\nYou've found the humble dwelling of a withered hermit.  The hermit tells you that he is willing to give the %s to the first wise person he meets.",
              gArtifactNames[a5]);
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
            break;
          case 5:
            if ( hero->secondarySkillLevel[6] )
              goto LABEL_391;
            sprintf(
              gText,
              "{Artifact}\n\nYou've come across the spartan quarters of a retired soldier.  The soldier tells you that he is willing to pass on the %s to the first true leader he meets.",
              gArtifactNames[a5]);
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
            break;
          case 1:
LABEL_391:
            advManager::EventSound(
              this,
              locType,
              (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              &res2);
            advManager::EventWindow(-1, 1, (&gArtifactEvents)[4 * a5], 7, a5, -1, 0, -1);
            goto LABEL_392;
          case 3:
            advManager::EventSound(
              this,
              locType,
              (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              &res2);
            sprintf(
              gText,
              "{Artifact}\n\nA leprechaun offers you the %s for the small price of 2000 gold.  Do you wish to buy this artifact?",
              gArtifactNames[a5]);
            advManager::EventWindow(-1, 2, gText, 7, a5, -1, 0, -1);
            if ( gpWindowManager->buttonPressedCode == 30725 )
            {
              if ( gpGame->players[hero->ownerIdx].resources[6] >= 2000 )
              {
                gpGame->players[hero->ownerIdx].resources[6] -= 2000;
                goto LABEL_392;
              }
              NormalDialog(
                "You try to pay the leprechaun, but realize that you can't afford it.  The leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              NormalDialog(
                "Insulted by your refusal of his generous offer, the leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            break;
          case 6:
            advManager::EventSound(
              this,
              locType,
              (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              &res2);
            sprintf(&a1, gResourceNames[v77]);
            a1 += 32;
            sprintf(
              gText,
              "{Artifact}\n\nA leprechaun offers you the %s for the small price of 2500 gold and 3 %s.  Do you wish to buy this artifact?",
              gArtifactNames[a5],
              &a1);
            NormalDialog(gText, 2, -1, -1, 7, a5, -1, 0, -1, 0);
            if ( gpWindowManager->buttonPressedCode == 30725 )
            {
              if ( gpGame->players[hero->ownerIdx].resources[6] >= 2500
                && gpGame->players[hero->ownerIdx].resources[v77] >= 3 )
              {
                gpGame->players[hero->ownerIdx].resources[6] -= 2500;
                v35 = sizeof(playerData) * hero->ownerIdx + 4 * v77;
                *(int *)((char *)gpGame->players[0].resources + v35) -= 3;
                goto LABEL_392;
              }
              NormalDialog(
                "You try to pay the leprechaun, but realize that you can't afford it.  The leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              NormalDialog(
                "Insulted by your refusal of his generous offer, the leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            break;
          case 7:
            advManager::EventSound(
              this,
              locType,
              (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
              &res2);
            sprintf(&a1, gResourceNames[v77]);
            a1 += 32;
            sprintf(
              gText,
              "{Artifact}\n\nA leprechaun offers you the %s for the small price of 3000 gold and 5 %s.  Do you wish to buy this artifact?",
              gArtifactNames[a5],
              &a1);
            NormalDialog(gText, 2, -1, -1, 7, a5, -1, 0, -1, 0);
            if ( gpWindowManager->buttonPressedCode == 30725 )
            {
              if ( gpGame->players[hero->ownerIdx].resources[6] >= 3000
                && gpGame->players[hero->ownerIdx].resources[v77] >= 5 )
              {
                gpGame->players[hero->ownerIdx].resources[6] -= 3000;
                v36 = 283 * hero->ownerIdx + 4 * v77;
                *(int *)((char *)gpGame->players[0].resources + v36) -= 5;
                goto LABEL_392;
              }
              NormalDialog(
                "You try to pay the leprechaun, but realize that you can't afford it.  The leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            else
            {
              NormalDialog(
                "Insulted by your refusal of his generous offer, the leprechaun stamps his foot and ignores you.",
                1,
                -1,
                -1,
                -1,
                0,
                -1,
                0,
                -1,
                0);
            }
            break;
          default:
            break;
        }
      }
      hero::CheckLevel(hero);
      goto LABEL_511;
    case LOCATION_HERO:
      advManager::DemobilizeCurrHero(this);
      v79 = &gpGame->heroes[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      if ( v79->ownerIdx == giCurPlayer )
      {
        advManager::HeroSwap(this, (int)hero, (int)v79);
      }
      else
      {
        v56 = 0;
        if ( v79->occupiedObjType == 163 )
        {
          v56 = &gpGame->castles[v79->occupiedObjVal];
          v56->visitingHeroIdx = v79->idx;
        }
        v80 = advManager::DoCombat(
                this,
                __PAIR__(locY, locX),
                (int)hero,
                &hero->army,
                (int)v56,
                (int)v79,
                &v79->army,
                locX,
                locY,
                -1,
                1);
        if ( !v80 && v56 )
          game::ClaimTown(gpGame, v56->idx, giCurPlayer, 0);
      }
      goto LABEL_511;
    case LOCATION_BOTTLE:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        signExtra = (SignExtra *)ppMapExtra[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
        if ( strlen(signExtra->name) <= 1 )
          advManager::EventWindow(-1, 1, defaultSignMessages[(unsigned __int8)((char)locX % -4)], -1, 0, -1, 0, -1);
        else
          advManager::EventWindow(-1, 1, signExtra->name, -1, 0, -1, 0, -1);
      }
      v90 = 1;
      shouldDelete = 1;
      goto LABEL_511;
    case LOCATION_SIGN:
      if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        signExtra = (SignExtra *)ppMapExtra[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
        if ( strlen(signExtra->name) <= 1 )
          advManager::EventWindow(-1, 1, defaultSignMessages[(unsigned __int8)((char)locX % -4)], -1, 0, -1, 0, -1);
        else
          advManager::EventWindow(-1, 1, signExtra->name, -1, 0, -1, 0, -1);
      }
      goto LABEL_511;
    case LOCATION_DAEMON_CAVE:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(
        -1,
        2,
        "{Daemon Cave}\n\nThe entrance to the cave is dark, and a foul, sulfurous smell issues from the cave mouth.  Will you enter?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode != 30726 )
      {
        if ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 1 )
        {
          advManager::EventWindow(
            -1,
            1,
            "Except for evidence of a terrible battle, the cave is empty.",
            -1,
            0,
            -1,
            0,
            -1);
        }
        else
        {
          v37 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
          v78 = ((v37 & 0xF0u) >> 4) + 62;
          sprintf(
            gText,
            "You find a powerful and grotesque Demon in the cave.  \"Today,\" it rasps, \"you will fight and surely die.  But I will give you a choice of deaths.  You may fight me, or you may fight my servants.  Do you prefer to fight my servants?\"");
          advManager::EventWindow(-1, 2, gText, -1, 0, -1, 0, -1);
          if ( gpWindowManager->buttonPressedCode == 30725 )
          {
            if ( !advManager::CombatMonsterEvent(this, hero, v78, 8, loc, locX, locY, 0, locX, locY, -1, 0, 0, -1, 0, 0) )
            {
              hero::CheckLevel(hero);
              NormalDialog(
                "Upon defeating the daemon's servants, you find a hidden cache with 2500 gold.",
                1,
                -1,
                -1,
                6,
                2500,
                -1,
                0,
                -1,
                0);
              advManager::GiveResource(this, hero, 6, 2500);
              v38 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
              LOBYTE(v38) = v38 | 8;
              loc->field_4_1_1_isShadow_1_13_extraInfo = v38;
            }
          }
          else
          {
            v39 = loc->field_4_1_1_isShadow_1_13_extraInfo >> 3;
            switch ( v39 & 0xF )
            {
              case 2:
                advManager::GiveExperience(hero, 1000, 0);
                advManager::EventWindow(
                  -1,
                  1,
                  "The Demon screams its challenge and attacks!  After a short, desperate battle, you slay the monster and receive 1,000 experience points.",
                  14,
                  1000,
                  -1,
                  0,
                  -1);
                v40 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
                LOBYTE(v40) = v40 | 8;
                loc->field_4_1_1_isShadow_1_13_extraInfo = v40;
                hero::CheckLevel(hero);
                break;
              case 3:
                if ( hero::NumArtifacts(hero) == 14 || game::GetRandomArtifactId(gpGame, 14, 1) == -1 )
                  goto LABEL_445;
                advManager::GiveExperience(hero, 1000, 0);
                a2 = advManager::GiveRandomArtifact(this, hero);
                sprintf(
                  gText,
                  "The Demon screams its challenge and attacks!  After a short, desperate battle, you slay the monster and find the %s in the back of the cave.",
                  gArtifactNames[a2]);
                advManager::EventWindow(-1, 1, gText, 7, a2, 14, 1000, -1);
                v41 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
                LOBYTE(v41) = v41 | 8;
                loc->field_4_1_1_isShadow_1_13_extraInfo = v41;
                hero::CheckLevel(hero);
                break;
              case 4:
LABEL_445:
                advManager::EventWindow(
                  -1,
                  1,
                  "The Demon screams its challenge and attacks!  After a short, desperate battle, you slay the monster and receive 1,000 experience points and 2,500 gold.",
                  6,
                  2500,
                  14,
                  1000,
                  -1);
                advManager::GiveExperience(hero, 1000, 0);
                advManager::GiveResource(this, hero, 6, 2500);
                v42 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
                LOBYTE(v42) = v42 | 8;
                loc->field_4_1_1_isShadow_1_13_extraInfo = v42;
                hero::CheckLevel(hero);
                break;
              case 5:
                advManager::EventWindow(
                  -1,
                  2,
                  "The Demon leaps upon you and has its claws at your throat before you can even draw your sword.  \"Your life is mine,\" it says.  \"I will sell it back to you for 2,500 gold.\"",
                  -1,
                  0,
                  -1,
                  0,
                  -1);
                if ( gpWindowManager->buttonPressedCode == 30725 )
                {
                  if ( gpGame->players[hero->ownerIdx].resources[6] >= 2500 )
                  {
                    gpGame->players[hero->ownerIdx].resources[6] -= 2500;
                  }
                  else
                  {
                    advManager::EventWindow(
                      -1,
                      1,
                      "Seeing that you do not have 2500 gold, the demon slashes you with its claws, and the last thing you see is a red haze.",
                      -1,
                      0,
                      -1,
                      0,
                      -1);
                    advManager::HeroLoses((int)this, (int)hero);
                  }
                }
                else
                {
                  advManager::HeroLoses((int)this, (int)hero);
                }
                break;
              default:
                break;
            }
            v43 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v43) = v43 | 8;
            loc->field_4_1_1_isShadow_1_13_extraInfo = v43;
          }
        }
      }
      goto LABEL_511;
    case LOCATION_SHIPWRECK:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(
        -1,
        2,
        "{Shipwreck}\n\nThe rotting hulk of a great pirate ship creaks eerily as it is pushed against the rocks.  Do you wish to search the shipwreck?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        if ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 1 )
        {
          advManager::EventWindow(
            -1,
            1,
            "Upon defeating the Ghosts you spend several hours sifting through the debris and find nothing.  Such a despicable act reduces your army's morale.",
            13,
            0,
            -1,
            0,
            -1);
          if ( !(hero->flags & 0x40) )
          {
            hero->flags |= 0x40u;
            --hero->tempMoraleBonuses;
          }
        }
        else if ( advManager::GhostEvent(
       this,
       hero,
       loc,
       "Upon defeating the Ghosts you sift through the debris and find something!",
       __PAIR__(locY, locX)) )
        {
          v44 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
          LOBYTE(v44) = v44 | 8;
          loc->field_4_1_1_isShadow_1_13_extraInfo = v44;
        }
      }
      goto LABEL_511;
    case LOCATION_GRAVEYARD:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(20, 2, byte_517684, -1, 0, -1, 0, -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        if ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 1 )
        {
          advManager::EventWindow(21, 1, byte_517688, 13, 0, -1, 0, -1);
          if ( !(hero->flags & 0x20) )
          {
            hero->flags |= 0x20u;
            --hero->tempMoraleBonuses;
          }
        }
        else
        {
          a3 = (int)advManager::GetCell(
                      this,
                      locX - normalDirTable[4 * HIBYTE(hero->field_2B)],
                      locY - byte_4F1DC1[4 * HIBYTE(hero->field_2B)]);
          if ( advManager::ZombieEvent(this, hero, (mapCell *)a3, gEventText[22], locX, locY) )
          {
            v45 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v45) = v45 | 8;
            loc->field_4_1_1_isShadow_1_13_extraInfo = v45;
          }
        }
      }
      goto LABEL_511;
    case LOCATION_DERELICT_SHIP:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(
        -1,
        2,
        "{Derelict Ship}\n\nThe rotting hulk of a great pirate ship creaks eerily as it is pushed against the rocks.  Do you wish to search the ship?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        if ( (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) == 1 )
        {
          advManager::EventWindow(
            -1,
            1,
            "Upon defeating the Skeletons you spend several hours sifting through the debris and find nothing.  Such a despicable act reduces your army's morale.",
            13,
            0,
            -1,
            0,
            -1);
          if ( !(BYTE1(hero->flags) & 4) )
          {
            hero->flags |= 0x400u;
            --hero->tempMoraleBonuses;
          }
        }
        else
        {
          v54 = (int)advManager::GetCell(
                       this,
                       locX - normalDirTable[4 * HIBYTE(hero->field_2B)],
                       locY - byte_4F1DC1[4 * HIBYTE(hero->field_2B)]);
          if ( advManager::SkeletonEvent(
                 (int)this,
                 (int)hero,
                 v54,
                 "Upon defeating the Skeletons you sift through the debris and find something!",
                 __PAIR__(locY, locX)) )
          {
            v46 = loc->field_4_1_1_isShadow_1_13_extraInfo & 7;
            LOBYTE(v46) = v46 | 8;
            loc->field_4_1_1_isShadow_1_13_extraInfo = v46;
          }
        }
      }
      goto LABEL_511;
    case LOCATION_PYRAMID:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(
        -1,
        2,
        "You come upon the pyramid of a great and ancient king.  You are tempted to search it for treasure, but all the old stories warn of fearful curses and undead guardians.  Will you search?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode == 30725 )
      {
        if ( (unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
        {
          if ( !advManager::CombatMonsterEvent(this, hero, 51, 30, loc, locX, locY, 0, locX, locY, 53, 20, 2, -1, 0, 0) )
          {
            hero::CheckLevel(hero);
            sprintf(
              msg,
              "%s'%s'.  ",
              "Upon defeating the monsters, you decipher an ancient glyph on the wall, telling the secret of the spell - ",
              dword_4F6ABC[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]);
            if ( hero::HasArtifact(hero, 81) )
            {
              if ( hero->secondarySkillLevel[7] < 3 )
              {
                strcat(
                  msg,
                  "  Unfortunately, you do not have the wisdom to understand the spell, and you are unable to learn it.  ");
                advManager::EventWindow(-1, 1, msg, -1, 0, -1, 0, -1);
              }
              else
              {
                v47 = hero::Stats(hero, PRIMARY_SKILL_KNOWLEDGE);
                hero::AddSpell(
                  hero,
                  (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
                  v47);
                advManager::EventWindow(
                  -1,
                  1,
                  msg,
                  8,
                  (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
                  -1,
                  0,
                  -1);
              }
            }
            else
            {
              strcat(msg, "  Unfortunately, you have no Magic Book to record the spell with.");
              advManager::EventWindow(-1, 1, msg, -1, 0, -1, 0, -1);
            }
            loc->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          }
        }
        else
        {
          NormalDialog(
            "You come upon the pyramid of a great and ancient king.  Routine exploration reveals that the pyramid is completely empty.",
            1,
            -1,
            -1,
            11,
            0,
            11,
            0,
            -1,
            0);
          if ( !(BYTE1(hero->flags) & 0x40) )
          {
            hero->flags |= 0x4000u;
            hero->tempLuckBonuses -= 2;
          }
        }
      }
      goto LABEL_511;
    case LOCATION_ABANDONED_MINE:
      advManager::EventSound(
        this,
        locType,
        (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
        &res2);
      advManager::EventWindow(
        -1,
        2,
        "You come upon an abandoned gold mine.  The mine appears to be haunted.  Do you wish to enter?",
        -1,
        0,
        -1,
        0,
        -1);
      if ( gpWindowManager->buttonPressedCode == 30725
        && !advManager::CombatMonsterEvent(
              this,
              hero,
              gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType,
              gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty,
              loc,
              locX,
              locY,
              0,
              locX,
              locY,
              -1,
              0,
              0,
              -1,
              0,
              0) )
      {
        hero::CheckLevel(hero);
        advManager::EventWindow(
          -1,
          1,
          "You beat the Ghosts and are able to restore the mine to production.",
          -1,
          0,
          -1,
          0,
          -1);
        game::ConvertObject(gpGame, locX - 2, locY - 1, locX + 1, locY - 1, 56, 0, 4, 26, 104, 64, 23);
        game::ConvertObject(gpGame, locX - 2, locY, locX + 1, locY, 56, 5, 9, 26, 109, 64, 23);
        game::ConvertObject(gpGame, locX - 2, locY - 1, locX + 1, locY - 1, 51, 0, 3, 32, 75, 64, 23);
        game::ConvertObject(gpGame, locX - 2, locY, locX + 1, locY, 51, 4, 7, 32, 80, 64, 23);
        game::ConvertObject(gpGame, locX, locY, locX, locY, 29, 5, 5, 29, 4, 64, 23);
        gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type = 6;
        gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = -1;
        gpGame->mines[(unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = 0;
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          giCurPlayer);
      }
      goto LABEL_511;
    case LOCATION_BARRIER:
      shouldDelete = advManager::BarrierEvent(this, loc, hero);
      goto LABEL_511;
    case LOCATION_TRAVELLER_TENT:
      advManager::PasswordEvent(this, loc, hero);
      goto LABEL_511;
    case LOCATION_ALCHEMIST_TOWER:
      advManager::GenericSiteEvent(this, loc, hero);
      goto LABEL_511;
    case LOCATION_EXPANSION_DWELLING:
      advManager::RecruitSiteEvent(this, (int)loc, (int)hero);
      goto LABEL_511;
    case LOCATION_JAIL:
      advManager::JailEvent(this, (int)loc, (int)hero, locX, locY);
      goto LABEL_511;
    case LOCATION_ROAD:
    case LOCATION_EVENT:
    case LOCATION_WELL:
    case LOCATION_WINDMILL|LOCATION_SKELETON:
    case LOCATION_RANDOM_ARTIFACT:
    case LOCATION_RANDOM_RESOURCE:
    case LOCATION_RANDOM_MONSTER:
    case LOCATION_RANDOM_TOWN:
    case LOCATION_RANDOM_CASTLE:
    case LOCATION_RANDOM_TOWN|LOCATION_SIGN:
    case LOCATION_RANDOM_MONSTER_WEAK:
    case LOCATION_RANDOM_MONSTER_MEDIUM:
    case LOCATION_RANDOM_MONSTER_STRONG:
    case LOCATION_RANDOM_MONSTER_VERY_STRONG:
    case LOCATION_RANDOM_HERO:
    case LOCATION_NOTHING_SPECIAL:
    case LOCATION_NOTHING_SPECIAL|LOCATION_ALCHEMIST_LAB:
    case LOCATION_TAR_PIT:
    case LOCATION_STREAM:
    case LOCATION_TREES:
    case LOCATION_MOUNTAINS:
    case LOCATION_VOLCANO:
    case LOCATION_FLOWERS:
    case LOCATION_ROCK:
    case LOCATION_LAKE:
    case LOCATION_MANDRAKE:
    case LOCATION_DEAD_TREE:
    case LOCATION_STUMP:
    case LOCATION_CRATER:
    case LOCATION_CACTUS:
    case LOCATION_MOUND:
    case LOCATION_DUNE:
    case LOCATION_LAVA_POOL:
    case LOCATION_SHRUB:
    case LOCATION_HOLE:
    case LOCATION_OUTCROPPING:
    case LOCATION_RANDOM_ARTIFACT_TREASURE:
    case LOCATION_RANDOM_ARTIFACT_MINOR:
    case LOCATION_RANDOM_ARTIFACT_MAJOR:
      goto LABEL_511;
  }
}
// 4EF268: using guessed type int gbGameOver;
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F6ABC: using guessed type int dword_4F6ABC[];
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 5240A8: using guessed type int gpSoundManager;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;
// 5304CC: using guessed type int xTheSpell;

//----- (0048BA30) --------------------------------------------------------
void __thiscall advManager::EraseObj(advManager *this, mapCell *cell, int a3, int a4)
{
  __int64 v5; // [sp+18h] [bp-48h]@43
  signed int i; // [sp+28h] [bp-38h]@1
  signed int j; // [sp+28h] [bp-38h]@35
  signed int k; // [sp+28h] [bp-38h]@71
  signed int l; // [sp+28h] [bp-38h]@87
  char v10; // [sp+2Ch] [bp-34h]@1
  mapCell *v11; // [sp+30h] [bp-30h]@75
  mapCell *v12; // [sp+30h] [bp-30h]@91
  mapCell *v13[5]; // [sp+34h] [bp-2Ch]@1
  mapCellExtra *v14; // [sp+48h] [bp-18h]@81
  int v15[4]; // [sp+4Ch] [bp-14h]@3
  int v16; // [sp+5Ch] [bp-4h]@1

  v16 = 0;
  v13[0] = (mapCell *)-1;
  v10 = 0;
  for ( i = 0; i < 4; ++i )
  {
    v13[i + 1] = 0;
    v15[i] = 0;
  }
  v16 = 1;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 11 )
    v13[0] = (mapCell *)(cell->objectIndex - 1);
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 63 )
    v13[0] = (mapCell *)(cell->objectIndex - 1);
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 62 && cell->objectIndex == 9 )
  {
    v13[0] = (mapCell *)9;
    v10 = 1;
  }
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 59
    && cell->objectIndex == 131 )
    v13[0] = (mapCell *)124;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 55
    && cell->objectIndex == 61 )
    v13[0] = (mapCell *)54;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 50
    && cell->objectIndex == 45 )
    v13[0] = (mapCell *)38;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 50
    && cell->objectIndex == 19 )
    v13[0] = (mapCell *)12;
  if ( (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 46 )
  {
    switch ( cell->objectIndex )
    {
      case 1:
        v13[0] = 0;
        break;
      case 3:
        v13[0] = (mapCell *)2;
        break;
      case 5:
        v13[0] = (mapCell *)4;
        break;
      case 7:
        v13[0] = (mapCell *)6;
        break;
      case 9:
        v13[0] = (mapCell *)8;
        break;
      case 11:
        v13[0] = (mapCell *)10;
        break;
      case 13:
        v13[0] = (mapCell *)12;
        break;
      case 15:
        v13[0] = (mapCell *)14;
        break;
      case 19:
        v13[0] = (mapCell *)18;
        break;
      default:
        break;
    }
  }
  for ( j = 0; j < 4; ++j )
  {
    if ( v10 )
    {
      --v13[0];
    }
    else if ( j > 0 )
    {
      break;
    }
    if ( v13[0] != (mapCell *)-1 )
    {
      if ( v10 )
      {
        HIDWORD(v5) = (signed int)v13[0] <= 6 ? &v13[0][-1].field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset + a3 : &v13[0][-1].objectIndex + a3;
        LODWORD(v5) = (signed int)v13[0] <= 6 ? a4 - 1 : a4;
      }
      else
      {
        HIDWORD(v5) = a3 - 1;
        LODWORD(v5) = a4;
      }
      if ( v5 >= 0 )
      {
        v13[j + 1] = &gpGame->map.tiles[v5 * gpGame->map.width] + HIDWORD(v5);
        if ( j <= 1 )
        {
          if ( v13[j + 1]->objectIndex != 255 )
          {
            if ( (mapCell *)v13[j + 1]->objectIndex == v13[0]
              && (((unsigned __int8)v13[j + 1]->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) )
            {
              v13[j + 1]->objectIndex = 0;
              v13[j + 1]->bitfield_1_hasObject_1_isRoad_6_objTileset = v13[j + 1]->bitfield_1_hasObject_1_isRoad_6_objTileset & 3 | 0xBC;
              v13[j + 1]->bitfield_1_hasObject_1_isRoad_6_objTileset &= 0xFEu;
            }
            if ( v13[j + 1]->extraIdx && this->map->cellExtras[v13[j + 1]->extraIdx].objectIndex != 255 )
              v15[j] = (int)&this->map->cellExtras[v13[j + 1]->extraIdx];
            else
              v15[j] = 0;
            while ( v15[j] )
            {
              if ( (mapCell *)*(_BYTE *)(v15[j] + 3) == v13[0]
                && ((*(_BYTE *)(v15[j] + 2) >> 1) & 0x7F) == (((unsigned __int8)cell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) )
              {
                *(_BYTE *)(v15[j] + 3) = 0;
                *(_BYTE *)(v15[j] + 2) = *(_BYTE *)(v15[j] + 2) & 1 | 0x5E;
                *(_BYTE *)(v15[j] + 2) &= 0xFEu;
              }
              if ( *(_WORD *)v15[j] && this->map->cellExtras[*(_WORD *)v15[j]].objectIndex != 255 )
                v15[j] = (int)&this->map->cellExtras[*(_WORD *)v15[j]];
              else
                v15[j] = 0;
            }
          }
        }
        else
        {
          v13[j + 1]->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset &= 3u;
          v13[j + 1]->overlayIndex = -1;
        }
      }
    }
  }
  cell->objType = 0;
  cell->objectIndex = 0;
  cell->bitfield_1_hasObject_1_isRoad_6_objTileset = cell->bitfield_1_hasObject_1_isRoad_6_objTileset & 3 | 0xBC;
  cell->bitfield_1_hasObject_1_isRoad_6_objTileset &= 0xFEu;
  for ( k = 0; k < 5; ++k )
  {
    if ( k )
      v11 = v13[k];
    else
      v11 = cell;
    if ( v11 )
    {
      if ( (((unsigned __int8)v11->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 47 )
      {
        if ( v11->extraIdx )
        {
          if ( *(&this->map->cellExtras->objectIndex + 8 * v11->extraIdx - v11->extraIdx) != 255 )
          {
            v14 = (mapCellExtra *)((char *)this->map->cellExtras + 8 * v11->extraIdx - v11->extraIdx);
            if ( ((v14->_1_q_7_objTileset >> 1) & 0x7F) != 47 && v14->objectIndex != 255 )
            {
              v11->objectIndex = v14->objectIndex;
              v11->bitfield_1_hasObject_1_isRoad_6_objTileset = v11->bitfield_1_hasObject_1_isRoad_6_objTileset & 3 | 4 * (v14->_1_q_7_objTileset >> 1);
              v11->bitfield_1_hasObject_1_isRoad_6_objTileset = v11->bitfield_1_hasObject_1_isRoad_6_objTileset & 0xFE | v14->_1_q_7_objTileset & 1;
              v11->field_4_1_1_isShadow_1_13_extraInfo = v11->field_4_1_1_isShadow_1_13_extraInfo & 0xFFFE | v14->field_4_1_1_1_isShadow_5 & 1;
              v11->field_4_1_1_isShadow_1_13_extraInfo = v11->field_4_1_1_isShadow_1_13_extraInfo & 0xFFFD | 2 * (((unsigned __int8)v14->field_4_1_1_1_isShadow_5 >> 1) & 1);
              v14->objectIndex = 0;
              v14->_1_q_7_objTileset = v14->_1_q_7_objTileset & 1 | 0x5E;
              v14->_1_q_7_objTileset &= 0xFEu;
            }
          }
        }
      }
    }
  }
  for ( l = 0; l < 5; ++l )
  {
    if ( l )
      v12 = v13[l];
    else
      v12 = cell;
    if ( v12
      && ((((unsigned __int8)v12->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) == 47
       || v12->objectIndex == 255
       || (v12->field_4_1_1_isShadow_1_13_extraInfo >> 1) & 1) )
    {
      if ( v12->extraIdx && *(&this->map->cellExtras->objectIndex + 8 * v12->extraIdx - v12->extraIdx) != 255 )
        v14 = (mapCellExtra *)((char *)this->map->cellExtras + 8 * v12->extraIdx - v12->extraIdx);
      else
        v14 = 0;
      while ( v14 )
      {
        if ( ((v14->_1_q_7_objTileset >> 1) & 0x7F) != 47
          && v14->objectIndex != 255
          && !(((unsigned __int8)v14->field_4_1_1_1_isShadow_5 >> 1) & 1) )
          goto LABEL_88;
        if ( v14->nextIdx && *(&this->map->cellExtras->objectIndex + 8 * v14->nextIdx - v14->nextIdx) != 255 )
          v14 = (mapCellExtra *)((char *)this->map->cellExtras + 8 * v14->nextIdx - v14->nextIdx);
        else
          v14 = 0;
      }
      v12->displayFlags |= 0x80u;
    }
LABEL_88:
    ;
  }
  SendMapChange(5, 0, a3, a4, -999, 0, 0);
  advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 1);
  game::SetupAdjacentMons(gpGame);
}
// 48BA30: using guessed type int var_14[4];

//----- (0048C430) --------------------------------------------------------
void __thiscall advManager::HeroSwap(void *this, int a2, int a3)
{
  void *thisa; // [sp+Ch] [bp-14h]@1
  tag_message *v4; // [sp+18h] [bp-8h]@1
  baseManager *a2a; // [sp+1Ch] [bp-4h]@2

  thisa = this;
  v4 = (tag_message *)operator new(90);
  if ( v4 )
    a2a = (baseManager *)swapManager::swapManager(v4);
  else
    a2a = 0;
  if ( !a2a )
    MemError();
  executive::DoDialog(gpExec, a2a);
  operator delete(a2a);
  advManager::RedrawAdvScreen((advManager *)thisa, 1, 0);
}

//----- (0048C4C0) --------------------------------------------------------
signed int __thiscall advManager::BarrierEvent(advManager *this, mapCell *cell, hero *hero)
{
  signed int result; // eax@3
  char v5; // [sp+10h] [bp-20h]@1
  int barrierColor; // [sp+20h] [bp-10h]@1
  SAMPLE2 res; // [sp+24h] [bp-Ch]@1
  int v8; // [sp+2Ch] [bp-4h]@1

  res = NULL_SAMPLE2;
  barrierColor = ((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 7;
  v8 = (signed int)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 3;
  sprintf(
    gText,
    "A magical %s barrier stands tall before you, blocking your way.  Runes on the arch read, \"Speak the key and you may pass.\"",
    xBarrierColor[barrierColor]);
  GetDataEntry(gText, (int)&v5, 14, 0, 0, 1);
  if ( StrEqNoCase((int *)&v5, (int *)xPasswordStrings[v8]) && gpCurPlayer->barrierTentsVisited & (1 << barrierColor) )
  {
    advManager::EventSound(this, cell->objType & 0x7F, barrierColor, &res);
    NormalDialog(
      "As you speak the magic word, the glowing barrier dissolves into nothingness.",
      1,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
    result = 1;
  }
  else
  {
    NormalDialog("You speak, and nothing happens.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
    result = 0;
  }
  return result;
}
// 4F7200: using guessed type char *xBarrierColor[15];
// 51A918: using guessed type char *xPasswordStrings[211];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0048C5F0) --------------------------------------------------------
char __fastcall StrEqNoCase(int *a1, int *a2)
{
  int *v3; // [sp+14h] [bp-14h]@1
  int *v4; // [sp+18h] [bp-10h]@1
  int v5; // [sp+20h] [bp-8h]@1
  char v6; // [sp+24h] [bp-4h]@4

  v4 = a1;
  v3 = a2;
  v5 = 0;
  while ( 1 )
  {
    ++v5;
    if ( v5 == 10 )
      return 1;
    v6 = toupper(*(_BYTE *)v4);
    if ( v6 != (char)toupper(*(_BYTE *)v3) )
      break;
    if ( !v6 )
      return 1;
    v4 = (int *)((char *)v4 + 1);
    v3 = (int *)((char *)v3 + 1);
  }
  return 0;
}

//----- (0048C690) --------------------------------------------------------
void __thiscall advManager::PasswordEvent(advManager *this, mapCell *tile, hero *hero)
{
  int v3; // ST30_4@1
  SAMPLE2 res; // [sp+14h] [bp-Ch]@1
  int v5; // [sp+1Ch] [bp-4h]@1

  res = NULL_SAMPLE2;
  v3 = ((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 7;
  v5 = (unsigned __int8)((unsigned __int8)(tile->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  v5 >>= 3;
  advManager::EventSound(this, tile->objType & 0x7F, v3, &res);
  sprintf(
    gText,
    "You enter the tent and see an old woman gazing into a magic gem.  She looks up and says, \"In my travels, I have learned much in the way of arcane magic.  A great oracle taught me his skill.  I have the answer you seek.  The %s keyword is '%s'.\"",
    xBarrierColor[v3],
    xPasswordStrings[v5]);
  NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
  gpCurPlayer->barrierTentsVisited |= 1 << v3;
}
// 4F7200: using guessed type char *xBarrierColor[15];
// 51A918: using guessed type char *xPasswordStrings[211];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0048C770) --------------------------------------------------------
void __thiscall advManager::GenericSiteEvent(advManager *ecx0, mapCell *cell, hero *this)
{
  advManager *v3; // [sp+14h] [bp-4Ch]@1
  int xp; // [sp+18h] [bp-48h]@44
  int v5; // [sp+1Ch] [bp-44h]@46
  signed int v6; // [sp+20h] [bp-40h]@47
  char v7; // [sp+24h] [bp-3Ch]@55
  int y; // [sp+30h] [bp-30h]@33
  mapCell *v9; // [sp+34h] [bp-2Ch]@35
  signed int i; // [sp+3Ch] [bp-24h]@2
  signed int j; // [sp+3Ch] [bp-24h]@13
  signed int k; // [sp+3Ch] [bp-24h]@44
  int a2; // [sp+40h] [bp-20h]@1
  int x; // [sp+48h] [bp-18h]@31
  int v15; // [sp+4Ch] [bp-14h]@1
  int a3[2]; // [sp+54h] [bp-Ch]@1
  int v17; // [sp+5Ch] [bp-4h]@25

  v3 = ecx0;
  v15 = 0;
  *(_QWORD *)a3 = NULL_SAMPLE2;
  a2 = ((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x3F;
  switch ( ((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x3F )
  {
    case 0:
      for ( i = 0; i < 14; ++i )
      {
        if ( IsCursedItem(this->artifacts[i]) )
          ++v15;
      }
      if ( v15 )
      {
        advManager::EventSound(v3, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
        if ( v15 == 1 )
          sprintf(
            gText,
            "As you enter the Alchemist's Tower, a hobbled, graying man in a brown cloak makes his way towards you.  He checks your pack, and sees that you have 1 cursed item.  For 750 gold, the alchemist will remove it for you.  Do you pay?");
        else
          sprintf(
            gText,
            "As you enter the Alchemist's Tower, a hobbled, graying man in a brown cloak makes his way towards you.  He checks your pack, and sees that you have %d cursed items.  For 750 gold,  the alchemist will remove them for you.  Do you pay?",
            v15);
        NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
        if ( gpWindowManager->buttonPressedCode == 30725 )
        {
          if ( gpCurPlayer->resources[6] < 750 )
          {
            NormalDialog(
              "You hear a voice from behind the locked door, \"You don't have enough gold to pay for my services.\"",
              1,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
          }
          else
          {
            for ( j = 0; j < 14; ++j )
            {
              if ( IsCursedItem(this->artifacts[j]) )
              {
                GiveTakeArtifactStat(this, (ARTIFACT)this->artifacts[j], 1);
                this->artifacts[j] = -1;
              }
            }
            gpCurPlayer->resources[6] -= 750;
          }
        }
      }
      else
      {
        NormalDialog(
          "You hear a voice from high above in the tower, \"Go away! I can't help you!\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      break;
    case 1:
      if ( BYTE2(this->flags) & 0x40 )
      {
        NormalDialog("The Arena guards turn you away.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      }
      else
      {
        advManager::EventSound(ecx0, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
        this->flags |= 0x400000u;
        v17 = DoArenaDialog();
        ++this->primarySkills[v17];
      }
      break;
    case 5:
      if ( BYTE2(this->flags) & 0x10 )
      {
        NormalDialog(
          "The mermaids silently entice you to return later and be blessed again.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        advManager::EventSound(ecx0, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
        this->flags |= 0x100000u;
        ++this->tempLuckBonuses;
        advManager::EventWindow(
          -1,
          1,
          "The magical, soothing beauty of the Mermaids reaches you and your crew.  Just for a moment, you forget your worries and bask in the beauty of the moment.  The mermaids charms bless you with increased luck for your next combat.",
          10,
          0,
          -1,
          0,
          -1);
      }
      break;
    case 2:
      advManager::EventSound(ecx0, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
      NormalDialog(
        "You enter a rickety hut and talk to the magician who lives there.  He tells you of places near and far which may aid you in your journeys.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
      for ( x = 0; MAP_WIDTH > x; ++x )
      {
        for ( y = 0; y < MAP_HEIGHT; ++y )
        {
          v9 = &gpGame->map.tiles[y * gpGame->map.width] + x;
          if ( (v9->objType & 0x7F) == 122
            && (((unsigned __int8)(v9->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 7) == 3 )
          {
            game::SetVisibility(gpGame, x, y, giCurPlayer, 10);
            advManager::CompleteDraw(v3, 0);
            advManager::UpdateScreen(v3, 0, 0);
          }
        }
      }
      break;
    case 3:
      NormalDialog("This eye seems to be intently studying its surroundings.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      break;
    case 6:
      if ( BYTE2(this->flags) & 0x20 )
      {
        NormalDialog(
          "You have your crew stop up their ears with wax before the sirens' eerie song has any chance of luring them to a watery grave.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      else
      {
        xp = 0;
        for ( k = 0; k < 5; ++k )
        {
          v5 = this->army.creatureTypes[k];
          if ( v5 != -1 )
          {
            v6 = this->army.quantities[k];
            if ( v6 > 1 )
            {
              this->army.quantities[k] = (signed __int64)((double)v6 * 0.7);
              xp += gMonsterDatabase[v5].hp * (v6 - this->army.quantities[k]);
            }
          }
        }
        if ( xp )
        {
          advManager::EventSound(ecx0, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
          sprintf(
            gText,
            "An eerie wailing song emanates from the sirens perched upon the rocks.  Many of your crew fall under its spell, and dive into the water where they drown.  You are now wiser for the visit, and gain %d experience.",
            xp);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          advManager::GiveExperience(this, xp, 1);
        }
        else
        {
          NormalDialog(
            "As the sirens sing their eerie song, your small, determined army manages to overcome the urge to dive headlong into the sea.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
        }
        this->flags |= 0x200000u;
      }
      break;
    case 4:
      v7 = 0;
      if ( !(BYTE2(this->flags) & 0x80) )
      {
        this->flags |= 0x800000u;
        this->mobility += 400;
        this->remainingMobility += 400;
        v7 = 1;
      }
      if ( hero::CreatureTypeCount(this, 7) )
      {
        hero::UpgradeCreatures(this, 7, 8);
        v7 |= 2u;
      }
      if ( v7 )
        advManager::EventSound(v3, cell->objType & 0x7F, a2, (SAMPLE2 *)a3);
      sprintf(gText, (&xStableText)[4 * v7]);
      if ( v7 & 2 )
        advManager::EventWindow(-1, 1, gText, 18, 8, -1, 0, -1);
      else
        advManager::EventWindow(-1, 1, gText, -1, 0, -1, 0, -1);
      break;
    default:
      return;
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0048CE90) --------------------------------------------------------
void __thiscall advManager::RecruitSiteEvent(advManager *this, int a1, int a2)
{
  __int16 v3; // [sp+18h] [bp-18h]@1
  int v4; // [sp+1Ch] [bp-14h]@1
  int v5; // [sp+20h] [bp-10h]@11
  int v6; // [sp+24h] [bp-Ch]@2
  int res[2]; // [sp+28h] [bp-8h]@1

  *(_QWORD *)res = NULL_SAMPLE2;
  v4 = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7;
  v3 = (signed __int16)(unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) >> 3;
  switch ( v4 )
  {
    case 0:
      v6 = 59;
      break;
    case 1:
      v6 = 62;
      break;
    case 2:
      v6 = 63;
      break;
    case 3:
      v6 = 64;
      break;
    case 4:
      v6 = 65;
      break;
    default:
      break;
  }
  if ( v3 )
  {
    advManager::EventSound(this, *(_BYTE *)(a1 + 9) & 0x7F, v3, (SAMPLE2 *)res);
    advManager::EventWindow(-1, 2, (&xRecruitBuy)[4 * v4], -1, 0, -1, 0, -1);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      advManager::ExpansionRecruitEvent(a2, v6, (int)&v3);
      v5 = v4 | 8 * v3;
      *(_WORD *)(a1 + 4) = 8 * (v4 | (unsigned __int16)(8 * v3)) | *(_WORD *)(a1 + 4) & 7;
    }
  }
  else
  {
    advManager::EventWindow(-1, 1, (&xRecruitEmpty)[4 * v4], -1, 0, -1, 0, -1);
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0048D030) --------------------------------------------------------
BOOL __stdcall advManager::ExpansionRecruitEvent(int a1, int a2, int a3)
{
  recruitUnit *this; // [sp+18h] [bp-28h]@1
  baseManager *a2a; // [sp+3Ch] [bp-4h]@2

  this = (recruitUnit *)operator new(126);
  if ( this )
    a2a = (baseManager *)recruitUnit::recruitUnit(this, (armyGroup *)(a1 + 101), a2, a3);
  else
    a2a = 0;
  if ( !a2a )
    MemError();
  executive::DoDialog(gpExec, a2a);
  return operator delete(a2a);
}

//----- (0048D0C0) --------------------------------------------------------
void __thiscall advManager::JailEvent(void *this, int a2, int a3, int a4, int a5)
{
  char *v5; // ST30_4@5
  void *v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  int res[2]; // [sp+18h] [bp-8h]@1

  v6 = this;
  *(_QWORD *)res = NULL_SAMPLE2;
  v7 = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5);
  if ( gpGame->relatedToHeroForHireStatus[v7] == 65 )
  {
    if ( gpCurPlayer->numHeroes < 8 )
    {
      advManager::EventSound((advManager *)this, *(_BYTE *)(a2 + 9) & 0x7F, 0, (SAMPLE2 *)res);
      NormalDialog(
        "In a dazzling display of daring, you break into the local jail and free the hero imprisoned there, who, in return, pledges loyalty to your cause.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
      gpGame->heroes[v7].ownerIdx = *(_BYTE *)(a3 + 3);
      gpGame->relatedToHeroForHireStatus[v7] = *(_BYTE *)(a3 + 3);
      v5 = (char *)&gpGame->heroes[v7];
      advManager::EraseObj((advManager *)v6, (mapCell *)a2, a4, a5);
      gpCurPlayer->heroesOwned[gpCurPlayer->numHeroes++] = v7;
      *(_DWORD *)(v5 + 25) = a4;
      *(_DWORD *)(v5 + 29) = a5;
      *(_DWORD *)(v5 + 227) = 0;
      v5[44] = 2;
      *(_DWORD *)(v5 + 53) = hero::CalcMobility((hero *)v5);
      *(_DWORD *)(v5 + 49) = *(_DWORD *)(v5 + 53);
      *(_WORD *)(v5 + 45) = *(_BYTE *)(a2 + 9);
      *(_WORD *)(v5 + 47) = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5);
      *(_BYTE *)(a2 + 9) = -86;
      *(_WORD *)(a2 + 4) = 8 * v7 | *(_WORD *)(a2 + 4) & 7;
      SendMapChange(3, v7, a4, a5, -999, 0, 0);
    }
    else
    {
      NormalDialog(
        "You already have 8 heroes, and regretfully must leave the prisoner in this jail to languish in agony for untold days.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
    }
  }
  else
  {
    NormalDialog(
      "The jailer tells you that the hero who was imprisoned here has been released by the king who imprisoned him.",
      1,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
    advManager::EraseObj((advManager *)v6, (mapCell *)a2, a4, a5);
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (0048D2F0) --------------------------------------------------------
void __thiscall advManager::TownEvent(int this, int a2, __int64 a3)
{
  int thisa; // [sp+Ch] [bp-14h]@1
  int thisb; // [sp+10h] [bp-10h]@1
  hero *v5; // [sp+14h] [bp-Ch]@5
  town *castle; // [sp+1Ch] [bp-4h]@1

  thisa = this;
  castle = &gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5)];
  thisb = (int)&gpGame->heroes[gpCurPlayer->curHeroIdx];
  advManager::DemobilizeCurrHero((advManager *)this);
  if ( castle->ownerIdx == giCurPlayer )
  {
    castle->visitingHeroIdx = gpCurPlayer->curHeroIdx;
    town::View(castle, 0);
  }
  else if ( town::HasGarrison(castle) )
  {
    if ( castle->visitingHeroIdx == -1 )
      v5 = 0;
    else
      v5 = &gpGame->heroes[castle->visitingHeroIdx];
    if ( !advManager::DoCombat(
            (void *)thisa,
            a3,
            thisb,
            (const void *)(thisb + 101),
            (int)castle,
            (int)v5,
            &castle->garrison,
            a3,
            SBYTE4(a3),
            -1,
            1) )
      game::ClaimTown(gpGame, castle->idx, giCurPlayer, 0);
  }
  else
  {
    game::ClaimTown(gpGame, castle->idx, giCurPlayer, 0);
    if ( gbGameOver )
      return;
    advManager::UpdateRadar((advManager *)thisa, 1, 0);
    advManager::UpdateHeroLocators((advManager *)thisa, 1, 1);
    advManager::UpdateTownLocators((void *)thisa, 1, 1);
    castle->visitingHeroIdx = gpCurPlayer->curHeroIdx;
    town::View(castle, 0);
  }
  town::GiveSpells(castle, 0);
  hero::CheckLevel((hero *)thisb);
}
// 4EF268: using guessed type int gbGameOver;

//----- (0048D4D0) --------------------------------------------------------
void __thiscall advManager::EventSound(advManager *this, int locType, int a2, SAMPLE2 *res)
{
  int trackNum; // [sp+30h] [bp-30h]@1
  char a1; // [sp+3Ch] [bp-24h]@1
  int v6; // [sp+5Ch] [bp-4h]@1

  v6 = 22;
  strcpy(&a1, byte_5184CC);
  trackNum = -1;
  switch ( locType )
  {
    case LOCATION_WAGON:
    case LOCATION_LEAN_TO:
    case LOCATION_ARCHERS_HOUSE:
    case LOCATION_GOBLIN_HUT:
    case LOCATION_DWARF_COTTAGE:
    case LOCATION_PEASANT_HUT:
    case LOCATION_LOG_CABIN:
    case LOCATION_WATCH_TOWER:
    case LOCATION_TREE_HOUSE:
    case LOCATION_DWARF_CABIN:
    case LOCATION_HALFLING_HOLE:
    case LOCATION_EXCAVATION:
    case LOCATION_CAVE:
      trackNum = 22;
      break;
    case LOCATION_LIGHTHOUSE:
    case LOCATION_XANADU:
      trackNum = 40;
      break;
    case LOCATION_SHRINE_FIRST:
    case LOCATION_SHRINE_SECOND_ORDER:
    case LOCATION_SHRINE_THIRD_ORDER:
      trackNum = 19;
      break;
    case LOCATION_ARTIFACT:
      if ( a2 == 1 )
        trackNum = 19;
      break;
    case LOCATION_SKELETON:
    case LOCATION_WATERWHEEL:
    case LOCATION_WINDMILL:
      trackNum = 19;
      break;
    case LOCATION_DAEMON_CAVE:
      trackNum = 36;
      break;
    case LOCATION_ORACLE:
    case LOCATION_ARTESIAN_SPRING:
    case LOCATION_MAGIC_WELL:
      trackNum = 32;
      break;
    case LOCATION_FAERIE_RING:
    case LOCATION_FOUNTAIN:
    case LOCATION_IDOL:
      trackNum = 101;
      break;
    case LOCATION_BUOY:
    case LOCATION_OASIS:
    case LOCATION_TEMPLE:
    case LOCATION_WATERING_HOLE:
      trackNum = 100;
      break;
    case LOCATION_GAZEBO:
    case LOCATION_TREE_OF_KNOWLEDGE:
    case LOCATION_WITCH_HUT:
      trackNum = 37;
      break;
    case LOCATION_ANCIENT_LAMP:
    case LOCATION_SPHINX:
      trackNum = 33;
      break;
    case LOCATION_GRAVEYARD:
    case LOCATION_SHIPWRECK:
    case LOCATION_ABANDONED_MINE:
    case LOCATION_MAGELLANS_MAPS:
    case LOCATION_DERELICT_SHIP:
    case LOCATION_OBSERVATION_TOWER:
      trackNum = 39;
      break;
    case LOCATION_DRAGON_CITY:
    case LOCATION_PYRAMID:
    case LOCATION_CITY_OF_DEAD:
    case LOCATION_TROLL_BRIDGE:
      trackNum = 31;
      break;
    case LOCATION_OBELISK:
      trackNum = 22;
      break;
    case LOCATION_FORT:
    case LOCATION_STANDING_STONES:
    case LOCATION_WITCH_DOCTORS_HUT:
    case LOCATION_MERCENARY_CAMP:
      trackNum = 38;
      break;
    case LOCATION_DESRT_TENT:
    case LOCATION_HILL_FORT:
      trackNum = 34;
      break;
    case LOCATION_STONE_LITHS:
      trackNum = 1;
      break;
    case LOCATION_WAGON_CAMP:
    case LOCATION_TREE_CITY:
    case LOCATION_MAGIC_GARDEN:
      trackNum = 35;
      break;
    case LOCATION_BARRIER:
      trackNum = 22;
      break;
    case LOCATION_TRAVELLER_TENT:
      trackNum = 22;
      break;
    case LOCATION_ALCHEMIST_TOWER:
      switch ( a2 )
      {
        case 0:
          trackNum = 22;
          break;
        case 1:
          trackNum = 22;
          break;
        case 5:
          trackNum = 101;
          break;
        case 2:
          trackNum = 22;
          break;
        case 6:
          trackNum = 22;
          break;
        case 4:
          trackNum = 22;
          break;
        case 3:
          goto LABEL_36;
      }
      break;
    case LOCATION_EXPANSION_DWELLING:
      trackNum = 22;
      break;
    case LOCATION_JAIL:
      trackNum = 22;
      break;
    default:
      trackNum = -1;
      break;
  }
LABEL_36:
  if ( trackNum != -1 )
  {
    switch ( trackNum )
    {
      case 19:
        strcpy(&a1, "treasure.82m");
        break;
      case 22:
        strcpy(&a1, "expernce.82m");
        break;
      case 100:
        strcpy(&a1, "goodmrle.82m");
        break;
      case 101:
        strcpy(&a1, "goodluck.82m");
        break;
      case 102:
        strcpy(&a1, "pickup01.82m");
        break;
      case 103:
        strcpy(&a1, "h2mine.82m");
        break;
      default:
        soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, trackNum);
        break;
    }
    if ( strlen(&a1) > 1 )
      *res = (SAMPLE2)LoadPlaySample(&a1);
  }
}
// 5240A8: using guessed type int gpSoundManager;

//----- (0048D9F0) --------------------------------------------------------
void __stdcall advManager::EventWindow(signed int eventID, int a2, const char *msg, int a4, int a5, int resource2Type, int resource2Amt, int a8)
{
  char buf[516]; // [sp+14h] [bp-210h]@3
  int v9; // [sp+218h] [bp-Ch]@1

  v9 = 0;
  if ( eventID < 0 || eventID >= 95 )
  {
    if ( eventID == -1 )
      sprintf(buf, msg);
    else
      sprintf(buf, "Event ID %d", eventID);
  }
  else
  {
    sprintf(buf, gEventText[eventID]);
  }
  NormalDialog(buf, a2, -1, -1, a4, a5, resource2Type, resource2Amt, a8, 0);
}

//----- (0048DAC0) --------------------------------------------------------
signed int __fastcall GiveArtifact(hero *hero, ARTIFACT a2, int a3, char scrollSpell)
{
  signed int result; // eax@6
  hero *heroa; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  heroa = hero;
  for ( i = 0; i < 14 && hero->artifacts[i] != -1; ++i )
    ;
  if ( i == 14 )
  {
    result = -1;
  }
  else
  {
    hero->artifacts[i] = a2;
    hero->scrollSpell[i] = scrollSpell;
    GiveTakeArtifactStat(hero, a2, 0);
    hero::CheckAnduranPieces(heroa, 0);
    if ( a3 )
      CheckEndGame(0, 0);
    result = i;
  }
  return result;
}

//----- (0048DB80) --------------------------------------------------------
int __thiscall advManager::GiveRandomArtifact(void *ecx0, hero *hro)
{
  void *this; // [sp+Ch] [bp-8h]@1
  int grantedArtifact; // [sp+10h] [bp-4h]@1

  this = ecx0;
  grantedArtifact = game::GetRandomArtifactId(gpGame, 14, 1);
  if ( grantedArtifact == -1 )
    advManager::GiveResource((advManager *)this, hro, 6, 1000);
  else
    GiveArtifact(hro, (ARTIFACT)grantedArtifact, 1, -1);
  return grantedArtifact;
}

//----- (0048DBE0) --------------------------------------------------------
int __stdcall advManager::GiveExperience(hero *hro, int xp, int a3)
{
  int newLevel; // [sp+14h] [bp-10h]@1
  int oldLevel; // [sp+20h] [bp-4h]@1

  oldLevel = hero::GetLevel(hro->experience);
  hro->oldLevel = oldLevel;
  hro->experience += xp;
  newLevel = hero::GetLevel(hro->experience);
  if ( a3 )
    hero::CheckLevel(hro);
  return newLevel - oldLevel;
}

//----- (0048DC50) --------------------------------------------------------
void __thiscall advManager::GiveResource(advManager *this, hero *hro, signed int type, int amt)
{
  int v4; // ecx@3

  if ( type >= 0 && type <= 6 )
  {
    v4 = 283 * hro->ownerIdx + 4 * type;
    *(int *)((char *)gpGame->players[0].resources + v4) += amt;
  }
  if ( type == 6 )
  {
    if ( gbHumanPlayer[hro->ownerIdx] )
      CheckEndGame(0, 0);
  }
}

//----- (0048DCD0) --------------------------------------------------------
void __thiscall advManager::RecruitEvent(advManager *this, hero *hro, int creature, mapCell *loc)
{
  recruitUnit *thisa; // [sp+18h] [bp-2Ch]@1
  int quantityAvailable; // [sp+38h] [bp-Ch]@1
  recruitUnit *a2a; // [sp+40h] [bp-4h]@2

  LOWORD(quantityAvailable) = (unsigned __int8)((unsigned __int8)(loc->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  thisa = (recruitUnit *)operator new(sizeof(recruitUnit));
  if ( thisa )
    a2a = recruitUnit::recruitUnit(thisa, &hro->army, creature, (int)&quantityAvailable);
  else
    a2a = 0;
  if ( !a2a )
    MemError();
  executive::DoDialog(gpExec, (baseManager *)a2a);
  operator delete(a2a);
  loc->field_4_1_1_isShadow_1_13_extraInfo = loc->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * quantityAvailable;
}

//----- (0048DD90) --------------------------------------------------------
signed int __thiscall advManager::SkeletonEvent(int this, int a2, int a3, const char *a4, __int64 a5)
{
  int v6; // [sp+Ch] [bp-Ch]@1
  int thisa; // [sp+10h] [bp-8h]@1

  thisa = this;
  v6 = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a3 + 4) >> 8) >> -5);
  switch ( v6 )
  {
    case 2:
      if ( !advManager::CombatMonsterEvent(
              (advManager *)this,
              (hero *)a2,
              47,
              25,
              (mapCell *)a3,
              a5,
              SHIDWORD(a5),
              0,
              a5,
              SHIDWORD(a5),
              -1,
              0,
              0,
              -1,
              0,
              0) )
      {
        advManager::EventWindow(-1, 1, a4, 6, 500, -1, 0, -1);
        advManager::GiveResource((advManager *)thisa, (hero *)a2, 6, 500);
        hero::CheckLevel((hero *)a2);
        return 1;
      }
      break;
    case 3:
      if ( !advManager::CombatMonsterEvent(
              (advManager *)this,
              (hero *)a2,
              47,
              50,
              (mapCell *)a3,
              a5,
              SHIDWORD(a5),
              0,
              a5,
              SHIDWORD(a5),
              -1,
              0,
              0,
              -1,
              0,
              0) )
      {
        advManager::EventWindow(-1, 1, a4, 6, 1000, -1, 0, -1);
        advManager::GiveResource((advManager *)thisa, (hero *)a2, 6, 1000);
        hero::CheckLevel((hero *)a2);
        return 1;
      }
      break;
    case 4:
      if ( !advManager::CombatMonsterEvent(
              (advManager *)this,
              (hero *)a2,
              47,
              100,
              (mapCell *)a3,
              a5,
              SHIDWORD(a5),
              0,
              a5,
              SHIDWORD(a5),
              -1,
              0,
              0,
              -1,
              0,
              0) )
      {
        advManager::EventWindow(-1, 1, a4, 6, 2000, -1, 0, -1);
        advManager::GiveResource((advManager *)thisa, (hero *)a2, 6, 2000);
        hero::CheckLevel((hero *)a2);
        return 1;
      }
      break;
    default:
      if ( !advManager::CombatMonsterEvent(
              (advManager *)this,
              (hero *)a2,
              47,
              200,
              (mapCell *)a3,
              a5,
              SHIDWORD(a5),
              0,
              a5,
              SHIDWORD(a5),
              -1,
              0,
              0,
              -1,
              0,
              0) )
      {
        advManager::EventWindow(-1, 1, a4, 6, 5000, -1, 0, -1);
        advManager::GiveResource((advManager *)thisa, (hero *)a2, 6, 5000);
        hero::CheckLevel((hero *)a2);
        return 1;
      }
      break;
  }
  return 0;
}

//----- (0048E000) --------------------------------------------------------
signed int __thiscall advManager::ZombieEvent(advManager *this, hero *h, mapCell *a3, const char *a4, int a5, int a6)
{
  int v7; // [sp+Ch] [bp-Ch]@1
  advManager *thisa; // [sp+10h] [bp-8h]@1
  int resource2Amt; // [sp+14h] [bp-4h]@12

  thisa = this;
  v7 = (unsigned __int8)((unsigned __int8)(a3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  if ( v7 == 2 )
  {
    if ( !advManager::CombatMonsterEvent(this, h, CREATURE_ZOMBIE, 6, a3, a5, a6, 0, a5, a6, 49, 4, 2, -1, 0, 0) )
    {
      advManager::EventWindow(-1, 1, a4, 6, 500, -1, 0, -1);
      advManager::GiveResource(thisa, h, 6, 500);
      hero::CheckLevel(h);
      return 1;
    }
    return 0;
  }
  if ( v7 == 3 )
  {
    if ( !advManager::CombatMonsterEvent(
            this,
            h,
            CREATURE_MUTANT_ZOMBIE,
            15,
            a3,
            a5,
            a6,
            0,
            a5,
            a6,
            49,
            10,
            2,
            -1,
            0,
            0) )
    {
      advManager::EventWindow(-1, 1, a4, 6, 1000, -1, 0, -1);
      advManager::GiveResource(thisa, h, 6, 1000);
      hero::CheckLevel(h);
      return 1;
    }
    return 0;
  }
  if ( v7 == 4 )
  {
    if ( !advManager::CombatMonsterEvent(this, h, 49, 30, a3, a5, a6, 0, a5, a6, 49, 20, 2, -1, 0, 0) )
    {
      advManager::EventWindow(-1, 1, a4, 6, 3000, -1, 0, -1);
      advManager::GiveResource(thisa, h, 6, 3000);
      hero::CheckLevel(h);
      return 1;
    }
    return 0;
  }
  if ( advManager::CombatMonsterEvent(this, h, 49, 60, a3, a5, a6, 0, a5, a6, 49, 40, 2, -1, 0, 0) )
    return 0;
  resource2Amt = advManager::GiveRandomArtifact(thisa, h);
  if ( resource2Amt == -1 )
    advManager::EventWindow(-1, 1, a4, 6, 1000, -1, 0, -1);
  else
    advManager::EventWindow(-1, 1, a4, 6, 1000, 7, resource2Amt, -1);
  advManager::GiveResource(thisa, h, 6, 1000);
  hero::CheckLevel(h);
  return 1;
}

//----- (0048E2A0) --------------------------------------------------------
signed int __thiscall advManager::GhostEvent(advManager *this, hero *hro, mapCell *a5, char *a4, __int64 a8)
{
  int v6; // [sp+Ch] [bp-Ch]@1
  int resource2Amt; // [sp+14h] [bp-4h]@12

  v6 = (unsigned __int8)((unsigned __int8)(a5->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  if ( v6 == 2 )
  {
    if ( !advManager::CombatMonsterEvent(
            this,
            hro,
            59,
            10,
            a5,
            a8,
            SHIDWORD(a8),
            0,
            a8,
            SHIDWORD(a8),
            -1,
            0,
            0,
            -1,
            0,
            0) )
    {
      sprintf(gText, "%s", a4);
      advManager::EventWindow(-1, 1, gText, 6, 1000, -1, 0, -1);
      advManager::GiveResource(this, hro, 6, 1000);
      hero::CheckLevel(hro);
      return 1;
    }
    return 0;
  }
  if ( v6 == 3 )
  {
    if ( !advManager::CombatMonsterEvent(
            this,
            hro,
            59,
            15,
            a5,
            a8,
            SHIDWORD(a8),
            0,
            a8,
            SHIDWORD(a8),
            -1,
            0,
            0,
            -1,
            0,
            0) )
    {
      sprintf(gText, "%s", a4);
      advManager::EventWindow(-1, 1, gText, 6, 2000, -1, 0, -1);
      advManager::GiveResource(this, hro, 6, 2000);
      hero::CheckLevel(hro);
      return 1;
    }
    return 0;
  }
  if ( v6 == 4 )
  {
    if ( !advManager::CombatMonsterEvent(
            this,
            hro,
            59,
            25,
            a5,
            a8,
            SHIDWORD(a8),
            0,
            a8,
            SHIDWORD(a8),
            -1,
            0,
            0,
            -1,
            0,
            0) )
    {
      sprintf(gText, "%s", a4);
      advManager::EventWindow(-1, 1, gText, 6, 5000, -1, 0, -1);
      advManager::GiveResource(this, hro, 6, 5000);
      hero::CheckLevel(hro);
      return 1;
    }
    return 0;
  }
  if ( advManager::CombatMonsterEvent(this, hro, 59, 50, a5, a8, SHIDWORD(a8), 0, a8, SHIDWORD(a8), -1, 0, 0, -1, 0, 0) )
    return 0;
  resource2Amt = advManager::GiveRandomArtifact(this, hro);
  sprintf(gText, "%s", a4);
  if ( resource2Amt == -1 )
    advManager::EventWindow(-1, 1, gText, 6, 2000, -1, 0, -1);
  else
    advManager::EventWindow(-1, 1, gText, 6, 2000, 7, resource2Amt, -1);
  advManager::GiveResource(this, hro, 6, 2000);
  hero::CheckLevel(hro);
  return 1;
}

//----- (0048E5A0) --------------------------------------------------------
void __stdcall advManager::HouseEvent(int a1, int a2)
{
  int creatureType; // [sp+14h] [bp-2Ch]@15
  int v3; // [sp+18h] [bp-28h]@15
  int v4; // [sp+1Ch] [bp-24h]@15
  int v5; // [sp+20h] [bp-20h]@15
  int v6; // [sp+24h] [bp-1Ch]@15
  int v7; // [sp+28h] [bp-18h]@15
  int v8; // [sp+2Ch] [bp-14h]@15
  int v9; // [sp+30h] [bp-10h]@15
  int v10; // [sp+34h] [bp-Ch]@15
  int v11; // [sp+38h] [bp-8h]@15
  int v12; // [sp+3Ch] [bp-4h]@1

  v12 = 0;
  switch ( *(_BYTE *)(a2 + 9) & 0x7F )
  {
    case 0xD:
      v12 = 0;
      break;
    case 0xE:
      v12 = 1;
      break;
    case 0x10:
      v12 = 2;
      break;
    case 0xF:
    case 0x41:
      v12 = 3;
      break;
    case 0x11:
      v12 = 4;
      break;
    case 0x3B:
      v12 = 5;
      break;
    case 0x48:
      v12 = 6;
      break;
    case 0x3A:
      v12 = 7;
      break;
    case 0x57:
      v12 = 8;
      break;
    case 0x4E:
      v12 = 9;
      break;
    default:
      break;
  }
  if ( (unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5 )
  {
    creatureType = 1;
    v3 = 11;
    v4 = 0;
    v5 = 21;
    v6 = 21;
    v7 = 20;
    v8 = 38;
    v9 = 12;
    v10 = 29;
    v11 = 47;
    advManager::EventWindow(3 * v12 + 23, 2, byte_51854C, -1, 0, -1, 0, -1);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      if ( armyGroup::CanJoin((armyGroup *)(a1 + 101), *(&creatureType + v12)) )
      {
        armyGroup::Add(
          (armyGroup *)(a1 + 101),
          *(&creatureType + v12),
          (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5),
          -1);
        *(_WORD *)(a2 + 4) &= 7u;
      }
      else
      {
        advManager::EventWindow(3 * v12 + 24, 1, byte_518550, -1, 0, -1, 0, -1);
      }
    }
  }
  else
  {
    advManager::EventWindow(3 * v12 + 25, 1, byte_518548, -1, 0, -1, 0, -1);
  }
}

//----- (0048E820) --------------------------------------------------------
int __thiscall advManager::CombatMonsterEvent(advManager *this, hero *a2, int creat, signed int a4, mapCell *cell, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16)
{
  int v18; // [sp+10h] [bp-5Ch]@13
  int i; // [sp+18h] [bp-54h]@17
  int j; // [sp+18h] [bp-54h]@48
  int k; // [sp+18h] [bp-54h]@52
  signed int l; // [sp+18h] [bp-54h]@55
  int m; // [sp+18h] [bp-54h]@60
  signed int n; // [sp+18h] [bp-54h]@77
  signed int ii; // [sp+18h] [bp-54h]@80
  int v26[5]; // [sp+1Ch] [bp-50h]@79
  int v27; // [sp+30h] [bp-3Ch]@84
  int v28[5]; // [sp+34h] [bp-38h]@79
  int stacks; // [sp+48h] [bp-24h]@9 MAPDST
  int o; // [sp+4Ch] [bp-20h]@11
  int v32[5]; // [sp+58h] [bp-14h]@62

  advManager::DemobilizeCurrHero(this);
  if ( a9 == -1 )
  {
    a9 = a6;
    a10 = a7;
  }
  else
  {
    this->field_2B2 = a9;
    this->field_2B6 = a10;
    this->field_2BA = a2->x < a9;
    if ( advManager::ComboDraw(this, 0) )
      advManager::UpdateScreen(this, 0, 0);
    this->field_2B2 = -1;
  }
  memset(gpMonGroup, 0xFFu, 5u);
  memset(gpMonGroup->quantities, 0, 0xAu);
  stacks = 5 - a13 - a16;
  if ( stacks < 1 )
    stacks = 1;
  o = 0;
  SRand(a9 + a10);
  if ( stacks == 5 && !(gMonsterDatabase[creat].creature_flags & SHOOTER) )
  {
    v18 = SRandom(0, 100);
    if ( v18 >= 25 )
    {
      if ( v18 < 50 )
        stacks = 4;
    }
    else
    {
      stacks = 3;
    }
  }
  for ( i = 0; i < stacks; ++i )
  {
    if ( stacks >> 1 != i
      || creat != CREATURE_ARCHER
      && creat != CREATURE_PIKEMAN
      && creat != CREATURE_SWORDSMAN
      && creat != CREATURE_CAVALRY
      && creat != CREATURE_PALADIN
      && creat != CREATURE_ORC
      && creat != CREATURE_OGRE
      && creat != CREATURE_TROLL
      && creat != CREATURE_DWARF
      && creat != CREATURE_ELF
      && creat != CREATURE_DRUID
      && creat != CREATURE_MINOTAUR
      && creat != CREATURE_GREEN_DRAGON
      && creat != CREATURE_RED_DRAGON
      && creat != CREATURE_IRON_GOLEM
      && creat != CREATURE_MAGE
      && creat != CREATURE_GIANT
      && creat != CREATURE_ZOMBIE
      && creat != CREATURE_MUMMY
      && creat != CREATURE_VAMPIRE
      && creat != CREATURE_LICH
      || SRandom(0, 100) >= 50
      || a12
      || a15 )
      *(&gpMonGroup->creatureTypes[i] + o) = creat;
    else
      *(&gpMonGroup->creatureTypes[i] + o) = creat + 1;
    gpMonGroup->quantities[i + o] = (unsigned int)(a4 / stacks) + (a4 % stacks > i);
  }
  o += stacks;
  if ( a13 )
  {
    stacks = a13;
    for ( j = 0; j < stacks; ++j )
    {
      *(&gpMonGroup->creatureTypes[j] + o) = a11;
      gpMonGroup->quantities[j + o] = (unsigned int)(a12 / stacks) + (a12 % stacks > j);
    }
  }
  o += stacks;
  if ( a16 )
  {
    stacks = a16;
    for ( k = 0; k < stacks; ++k )
    {
      *(&gpMonGroup->creatureTypes[k] + o) = a14;
      gpMonGroup->quantities[k + o] = (unsigned int)(a15 / stacks) + (a12 % stacks > k);
    }
  }
  for ( l = 0; l < 5; ++l )
  {
    if ( gpMonGroup->quantities[l] <= 0 )
      gpMonGroup->creatureTypes[l] = -1;
  }
  for ( m = 0; m < 5; ++m )
    v32[m] = m;
  switch ( stacks )
  {
    case 1:
      v32[2] = 0;
      v32[0] = 2;
      break;
    case 2:
      v32[1] = 1;
      v32[3] = 0;
      v32[0] = 3;
      break;
    case 3:
      v32[0] = 3;
      v32[1] = 0;
      v32[2] = 1;
      v32[3] = 2;
      break;
    default:
      if ( a16 != 1 || a13 != 1 )
      {
        if ( a16 != 1 || a13 != 2 )
        {
          if ( a13 == 2 )
          {
            v32[1] = 4;
            v32[4] = 1;
          }
        }
        else
        {
          v32[1] = 2;
          v32[2] = 4;
          v32[3] = 3;
          v32[4] = 1;
        }
      }
      else
      {
        v32[1] = 4;
        v32[4] = 1;
      }
      break;
  }
  for ( n = 0; n < 5; ++n )
  {
    v28[n] = gpMonGroup->creatureTypes[n];
    v26[n] = gpMonGroup->quantities[n];
  }
  for ( ii = 0; ii < 5; ++ii )
  {
    gpMonGroup->creatureTypes[ii] = LOBYTE(v28[v32[ii]]);
    gpMonGroup->quantities[ii] = v26[v32[ii]];
  }
  if ( a8 )
    v27 = advManager::DoCombat(this, __PAIR__(a10, a9), 0, gpMonGroup, 0, (int)a2, &a2->army, a6, a7, a9 + a10, 1);
  else
    v27 = advManager::DoCombat(this, __PAIR__(a10, a9), (int)a2, &a2->army, 0, 0, gpMonGroup, a6, a7, a9 + a10, 1);
  advManager::MobilizeCurrHero(this, 0);
  return v27;
}
// 48E820: using guessed type int var_38[5];
// 48E820: using guessed type int var_50[5];

//----- (0048EE50) --------------------------------------------------------
void __fastcall GiveTakeArtifactStat(hero *this, ARTIFACT a2, int losing)
{
  int newSPMax; // [sp+18h] [bp-18h]@45
  signed int i; // [sp+1Ch] [bp-14h]@41
  int primSkillDiffs[4]; // [sp+20h] [bp-10h]@2

  if ( a2 != -1 )
  {
    primSkillDiffs[0] = 0;
    primSkillDiffs[1] = 0;
    primSkillDiffs[2] = 0;
    primSkillDiffs[3] = 0;
    switch ( a2 )
    {
      case ARTIFACT_ULTIMATE_BOOK_OF_KNOWLEDGE:
        primSkillDiffs[3] = 12;
        break;
      case ARTIFACT_ULTIMATE_SWORD_OF_DOMINION:
        primSkillDiffs[0] = 12;
        break;
      case ARTIFACT_ULTIMATE_CLOAK_OF_PROTECTION:
        primSkillDiffs[1] = 12;
        break;
      case ARTIFACT_ULTIMATE_WAND_OF_MAGIC:
        primSkillDiffs[2] = 12;
        break;
      case ARTIFACT_ULTIMATE_SHIELD:
        primSkillDiffs[0] = 6;
        primSkillDiffs[1] = 6;
        break;
      case ARTIFACT_ULTIMATE_STAFF:
        primSkillDiffs[2] = 6;
        primSkillDiffs[3] = 6;
        break;
      case ARTIFACT_ULTIMATE_CROWN:
        primSkillDiffs[0] = 4;
        primSkillDiffs[1] = 4;
        primSkillDiffs[2] = 4;
        primSkillDiffs[3] = 4;
        break;
      case ARTIFACT_ARCANE_NECKLACE_OF_MAGIC:
        primSkillDiffs[2] = 4;
        break;
      case ARTIFACT_CASTERS_BRACELET_OF_MAGIC:
        primSkillDiffs[2] = 2;
        break;
      case ARTIFACT_MAGES_RING_OF_POWER:
        primSkillDiffs[2] = 2;
        break;
      case ARTIFACT_WITCHS_BROACH_OF_MAGIC:
        primSkillDiffs[2] = 3;
        break;
      case ARTIFACT_THUNDER_MACE_OF_DOMINION:
        primSkillDiffs[0] = 1;
        break;
      case ARTIFACT_ARMORED_GAUNTLETS_OF_PROTECTION:
        primSkillDiffs[1] = 1;
        break;
      case ARTIFACT_DEFENDER_HELM_OF_PROTECTION:
        primSkillDiffs[1] = 1;
        break;
      case ARTIFACT_GIANT_FLAIL_OF_DOMINION:
        primSkillDiffs[0] = 1;
        break;
      case ARTIFACT_STEALTH_SHIELD_OF_PROTECTION:
        primSkillDiffs[1] = 2;
        break;
      case ARTIFACT_DRAGON_SWORD_OF_DOMINION:
        primSkillDiffs[0] = 3;
        break;
      case ARTIFACT_POWER_AXE_OF_DOMINION:
        primSkillDiffs[0] = 2;
        break;
      case ARTIFACT_DIVINE_BREASTPLATE_OF_PROTECTION:
        primSkillDiffs[1] = 3;
        break;
      case ARTIFACT_MINOR_SCROLL_OF_KNOWLEDGE:
        primSkillDiffs[3] = 2;
        break;
      case ARTIFACT_MAJOR_SCROLL_OF_KNOWLEDGE:
        primSkillDiffs[3] = 3;
        break;
      case ARTIFACT_SUPERIOR_SCROLL_OF_KNOWLEDGE:
        primSkillDiffs[3] = 4;
        break;
      case ARTIFACT_FOREMOST_SCROLL_OF_KNOWLEDGE:
        primSkillDiffs[3] = 5;
        break;
      case ARTIFACT_SPIKED_HELM:
        primSkillDiffs[0] = 1;
        primSkillDiffs[1] = 1;
        break;
      case ARTIFACT_SPIKED_SHIELD:
        primSkillDiffs[0] = 2;
        primSkillDiffs[1] = 2;
        break;
      case ARTIFACT_WHITE_PEARL:
        primSkillDiffs[2] = 1;
        primSkillDiffs[3] = 1;
        break;
      case ARTIFACT_BLACK_PEARL:
        primSkillDiffs[2] = 2;
        primSkillDiffs[3] = 2;
        break;
      case ARTIFACT_ARM_OF_THE_MARTYR:
        primSkillDiffs[2] = 3;
        break;
      case ARTIFACT_BREASTPLATE_OF_ANDURAN:
        primSkillDiffs[1] = 5;
        break;
      case ARTIFACT_BROACH_OF_SHIELDING:
        primSkillDiffs[2] = -2;
        break;
      case ARTIFACT_BATTLE_GARB_OF_ANDURAN:
        primSkillDiffs[2] = 5;
        primSkillDiffs[1] = 5;
        primSkillDiffs[0] = 5;
        break;
      case ARTIFACT_HELMET_OF_ANDURAN:
        primSkillDiffs[2] = 5;
        break;
      case ARTIFACT_HOLY_HAMMER:
        primSkillDiffs[0] = 5;
        break;
      case ARTIFACT_LEGENDARY_SCEPTER:
        primSkillDiffs[2] = 2;
        primSkillDiffs[0] = 2;
        primSkillDiffs[1] = 2;
        primSkillDiffs[3] = 2;
        break;
      case ARTIFACT_STAFF_OF_WIZARDRY:
        primSkillDiffs[2] = 5;
        break;
      case ARTIFACT_SWORD_BREAKER:
        primSkillDiffs[1] = 4;
        primSkillDiffs[0] = 1;
        break;
      case ARTIFACT_SWORD_OF_ANDURAN:
        primSkillDiffs[0] = 5;
        break;
      case ARTIFACT_GOLDEN_GOOSE:
      case ARTIFACT_MEDAL_OF_VALOR:
      case ARTIFACT_MEDAL_OF_COURAGE:
      case ARTIFACT_MEDAL_OF_HONOR:
      case ARTIFACT_MEDAL_OF_DISTINCTION:
      case ARTIFACT_FIZBIN_OF_MISFOURTUNE:
      case ARTIFACT_BALLISTA_OF_QUICKNESS:
      case ARTIFACT_ENDLESS_SACK_OF_GOLD:
      case ARTIFACT_ENDLESS_BAG_OF_GOLD:
      case ARTIFACT_ENDLESS_PURSE_OF_GOLD:
      case ARTIFACT_NOMAD_BOOTS_OF_MOBILITY:
      case ARTIFACT_TRAVELERS_BOOTS_OF_MOBILITY:
      case ARTIFACT_LUCKY_RABBITS_FOOT:
      case ARTIFACT_GOLDEN_HORSESHOE:
      case ARTIFACT_GAMBLERS_LUCKY_COIN:
      case ARTIFACT_FOUR_LEAF_CLOVER:
      case ARTIFACT_TRUE_COMPASS_OF_MOBILITY:
      case ARTIFACT_SAILORS_ASTROLABE_OF_MOBILITY:
      case ARTIFACT_EVIL_EYE:
      case ARTIFACT_ENCHANTED_HOURGLASS:
      case ARTIFACT_GOLD_WATCH:
      case ARTIFACT_SKULLCAP:
      case ARTIFACT_ICE_CLOAK:
      case ARTIFACT_FIRE_CLOAK:
      case ARTIFACT_LIGHTNING_HELM:
      case ARTIFACT_EVERCOLD_ICICLE:
      case ARTIFACT_EVERHOT_LAVA_ROCK:
      case ARTIFACT_LIGHTNING_ROD:
      case ARTIFACT_SNAKE_RING:
      case ARTIFACT_ANKH:
      case ARTIFACT_BOOK_OF_ELEMENTS:
      case ARTIFACT_ELEMENTAL_RING:
      case ARTIFACT_HOLY_PENDANT:
      case ARTIFACT_PENDANT_OF_FREE_WILL:
      case ARTIFACT_PENDANT_OF_LIFE:
      case ARTIFACT_SERENITY_PENDANT:
      case ARTIFACT_SEEING_EYE_PENDANT:
      case ARTIFACT_KINETIC_PENDANT:
      case ARTIFACT_PENDANT_OF_DEATH:
      case ARTIFACT_WAND_OF_NEGATION:
      case ARTIFACT_GOLDEN_BOW:
      case ARTIFACT_TELESCOPE:
      case ARTIFACT_STATESMANS_QUILL:
      case ARTIFACT_WIZARDS_HAT:
      case ARTIFACT_POWER_RING:
      case ARTIFACT_AMMO_CART:
      case ARTIFACT_TAX_LIEN:
      case ARTIFACT_HIDEOUS_MASK:
      case ARTIFACT_ENDLESS_POUCH_OF_SULFUR:
      case ARTIFACT_ENDLESS_VIAL_OF_MERCURY:
      case ARTIFACT_ENDLESS_POUCH_OF_GEMS:
      case ARTIFACT_ENDLESS_CORD_OF_WOOD:
      case ARTIFACT_ENDLESS_CART_OF_ORE:
      case ARTIFACT_ENDLESS_POUCH_OF_CRYSTAL:
      case ARTIFACT_MAGIC_BOOK:
      case ARTIFACT_SPELL_SCROLL:
      case ARTIFACT_CRYSTAL_BALL:
      case ARTIFACT_HEART_OF_FIRE:
      case ARTIFACT_HEART_OF_ICE:
      case ARTIFACT_MASTHEAD:
      case ARTIFACT_SPHERE_OF_NEGATION:
      case ARTIFACT_SPADE_OF_NECROMANCY:
      case ARTIFACT_NONE1:
      case ARTIFACT_NONE2:
      case ARTIFACT_NONE3:
      case ARTIFACT_NONE4:
        break;
    }
    for ( i = 0; i < 4; ++i )
    {
      this->primarySkills[i] += ((unsigned int)(losing - 1) < 1 ? -1 : 1) * LOBYTE(primSkillDiffs[i]);
      if ( i == PRIMARY_SKILL_KNOWLEDGE && losing == 1 )
      {
        newSPMax = 10 * hero::Stats(this, PRIMARY_SKILL_KNOWLEDGE);
        if ( this->spellpoints > newSPMax )
          this->spellpoints = newSPMax;
      }
    }
  }
}

//----- (0048F450) --------------------------------------------------------
void __stdcall advManager::TransferArtifacts(int a1, int a2)
{
  signed int j; // [sp+10h] [bp-8h]@7
  signed int i; // [sp+14h] [bp-4h]@4

  if ( a1 && a2 )
  {
    for ( i = 0; i < 14; ++i )
    {
      if ( *(_BYTE *)(i + a2 + 213) == -1 )
      {
        for ( j = 0; j < 14; ++j )
        {
          if ( *(_BYTE *)(j + a1 + 213) != -1 && *(_BYTE *)(j + a1 + 213) != 81 )
          {
            if ( (signed int)*(_BYTE *)(j + a1 + 213) > 7 )
            {
              GiveTakeArtifactStat((hero *)a2, (ARTIFACT)*(_BYTE *)(j + a1 + 213), 0);
              *(_BYTE *)(i + a2 + 213) = *(_BYTE *)(j + a1 + 213);
              *(_BYTE *)(i + a2 + 236) = *(_BYTE *)(j + a1 + 236);
            }
            else if ( gbThisNetHumanPlayer[*(_BYTE *)(a1 + 3)] || gbThisNetHumanPlayer[*(_BYTE *)(a2 + 3)] )
            {
              sprintf(
                gText,
                "As you reach for the %s, it mysteriously disappears.",
                gArtifactNames[*(_BYTE *)(j + a1 + 213)]);
              NormalDialog(gText, 1, -1, -1, 7, *(_BYTE *)(j + a1 + 213), -1, 0, -1, 0);
            }
            GiveTakeArtifactStat((hero *)a1, (ARTIFACT)*(_BYTE *)(j + a1 + 213), 1);
            *(_BYTE *)(j + a1 + 213) = -1;
            *(_BYTE *)(j + a1 + 236) = -1;
            break;
          }
        }
      }
    }
    hero::CheckAnduranPieces((hero *)a2, 0);
  }
}

//----- (0048F630) --------------------------------------------------------
void __thiscall advManager::HeroLoses(int this, int a2)
{
  int ecx0; // [sp+Ch] [bp-4h]@1

  ecx0 = this;
  if ( a2 )
  {
    advManager::CompleteDraw((advManager *)this, *(_DWORD *)(this + 470), *(_DWORD *)(this + 474), 0, 1);
    advManager::UpdateScreen((advManager *)ecx0, 0, 0);
    hero::Deallocate((hero *)a2, 1);
    advManager::FizzleCenter((void *)ecx0, 0);
    advManager::UpdateRadar((advManager *)ecx0, 1, 0);
    advManager::UpdateHeroLocators((advManager *)ecx0, 1, 1);
  }
}

//----- (0048F6B0) --------------------------------------------------------
int __thiscall advManager::DoWhirlpool(advManager *a1, hero *hro)
{
  int result; // eax@1
  int v3; // [sp+10h] [bp-24h]@3
  signed int i; // [sp+18h] [bp-1Ch]@3
  int v5; // [sp+30h] [bp-4h]@3

  result = hro->ownerIdx;
  if ( gbHumanPlayer[result] )
  {
    result = Random(1, 3);
    if ( result == 1 )
    {
      v3 = 99999999;
      v5 = -1;
      for ( i = 0; i < 5; ++i )
      {
        if ( hro->army.quantities[i] > 0 )
        {
          if ( v3 > hro->army.quantities[i] * gMonsterDatabase[hro->army.creatureTypes[i]].fight_value )
          {
            v3 = hro->army.quantities[i] * gMonsterDatabase[hro->army.creatureTypes[i]].fight_value;
            v5 = i;
          }
        }
      }
      if ( armyGroup::GetNumArmies(&hro->army) <= 1 )
      {
        result = hro->army.quantities[v5];
        if ( result > 1 )
        {
          result = v5;
          hro->army.quantities[result] >>= 1;
        }
      }
      else
      {
        hro->army.quantities[v5] >>= 1;
        result = hro->army.quantities[v5];
        if ( !hro->army.quantities[v5] )
        {
          result = v5;
          hro->army.creatureTypes[v5] = -1;
        }
      }
    }
  }
  return result;
}

//----- (0048F7F0) --------------------------------------------------------
void __thiscall advManager::FizzleCenter(void *this, int a2)
{
  int v2; // eax@4
  __int64 v3; // ST3C_8@8
  void *thisa; // [sp+10h] [bp-18h]@1

  thisa = this;
  if ( bShowIt )
  {
    if ( a2 )
    {
      if ( a2 != 1 )
        return;
      v2 = Random(1, 7);
      sprintf(gText, "pickup%02d.82M", v2);
    }
    else
    {
      sprintf(gText, "killfade.82M");
    }
    v3 = LoadPlaySample(gText);
    mouseManager::HideColorPointer(gpMouseManager);
    heroWindowManager::SaveFizzleSource(gpWindowManager, 168, 160, 132, 132);
    advManager::CompleteDraw((advManager *)thisa, 0);
    heroWindowManager::FizzleForward(gpWindowManager, 168, 160, 132, 132, 65, 0, 0);
    mouseManager::ShowColorPointer(gpMouseManager);
    WaitEndSample((void *)0xFFFFFFFF, (resource *)v3, HIDWORD(v3));
  }
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 524C14: using guessed type int bShowIt;

//----- (0048F940) --------------------------------------------------------
void __thiscall advManager::DoAIEvent(int this, mapCell *cell, hero *hro, __int64 x)
{
  unsigned __int16 v4; // ax@26
  __int16 v5; // ax@27
  unsigned __int16 v6; // ax@53
  __int16 v7; // ax@60
  int v8; // ST28_4@60
  __int16 v9; // ax@60
  __int16 v10; // ax@65
  __int16 v11; // ax@67
  int v12; // ST28_4@67
  __int16 v13; // ax@67
  __int16 v14; // ax@71
  __int16 v15; // ax@80
  int v16; // ebx@144
  char v17; // al@161
  int v18; // ebx@171
  int v19; // ebx@184
  __int16 v20; // ax@190
  __int16 v21; // ax@190
  __int16 v22; // ax@199
  int v23; // eax@214
  int v24; // eax@217
  __int64 v25; // ST14_8@226
  unsigned __int16 v26; // ax@248
  char v27; // al@262
  char v28; // al@279
  signed int v29; // [sp+20h] [bp-13Ch]@144
  int thisa; // [sp+30h] [bp-12Ch]@1
  float v31; // [sp+34h] [bp-128h]@256
  float v32; // [sp+38h] [bp-124h]@258
  int amt; // [sp+3Ch] [bp-120h]@104
  int v34; // [sp+50h] [bp-10Ch]@283
  char v35; // [sp+58h] [bp-104h]@226
  char v36; // [sp+5Ch] [bp-100h]@226
  signed int level; // [sp+60h] [bp-FCh]@144
  int xp; // [sp+64h] [bp-F8h]@144
  int arr[7]; // [sp+68h] [bp-F4h]@135
  int v40; // [sp+84h] [bp-D8h]@17
  char v41; // [sp+88h] [bp-D4h]@5
  int v42; // [sp+8Ch] [bp-D0h]@221
  boat *v43; // [sp+90h] [bp-CCh]@7
  int v44; // [sp+94h] [bp-C8h]@165
  signed int type; // [sp+CCh] [bp-90h]@103
  int v46; // [sp+D0h] [bp-8Ch]@195
  int y; // [sp+D4h] [bp-88h]@165
  int i; // [sp+D8h] [bp-84h]@167
  ARTIFACT a2; // [sp+DCh] [bp-80h]@190
  int v50; // [sp+E0h] [bp-7Ch]@190
  void *v51; // [sp+E4h] [bp-78h]@221
  int v52; // [sp+E8h] [bp-74h]@232
  char v53; // [sp+ECh] [bp-70h]@222
  int v54; // [sp+F0h] [bp-6Ch]@190
  int v55; // [sp+F4h] [bp-68h]@269
  void *v56; // [sp+F8h] [bp-64h]@289
  int v57; // [sp+FCh] [bp-60h]@1
  bool v58; // [sp+11Ch] [bp-40h]@1
  char v59; // [sp+120h] [bp-3Ch]@260
  int v60; // [sp+124h] [bp-38h]@112
  int v61; // [sp+128h] [bp-34h]@1
  char v62; // [sp+12Ch] [bp-30h]@133
  int v63; // [sp+130h] [bp-2Ch]@260
  int v64; // [sp+134h] [bp-28h]@260
  int v65; // [sp+138h] [bp-24h]@1
  Spell spell; // [sp+13Ch] [bp-20h]@10
  int a3a; // [sp+140h] [bp-1Ch]@133
  int mon; // [sp+144h] [bp-18h]@112
  signed int slot; // [sp+148h] [bp-14h]@133
  int v70; // [sp+14Ch] [bp-10h]@268
  void *v71; // [sp+150h] [bp-Ch]@1
  playerData *v72; // [sp+154h] [bp-8h]@1
  int v73; // [sp+158h] [bp-4h]@10

  thisa = this;
  v71 = 0;
  v57 = cell->objType & 0x7F;
  v58 = 0;
  v65 = 0;
  v61 = giCurPlayer;
  v72 = gpCurPlayer;
  if ( *(_QWORD *)&hro->field_21 == x )
  {
    *(_DWORD *)&hro->field_25 = -1;
    *(_DWORD *)&hro->field_21 = *(_DWORD *)&hro->field_25;
  }
  --hro->remainingMobility;
  switch ( v57 )
  {
    case 28:
      if ( hro->flags & 0x80 )
      {
        hro->flags &= 0xFFFFFF7Fu;
        hro->remainingMobility = 0;
        HIBYTE(hro->field_2B) = *(_BYTE *)(this + 638);
        *(_DWORD *)(this + 634) = hro->factionID;
        *(_DWORD *)(this + 642) = advManager::GetCursorBaseFrame(*(_DWORD *)(this + 638));
        *(_DWORD *)(thisa + 626) = 1;
        advManager::CheckAdjacentMon((void *)thisa, (signed int)&v41);
      }
      goto LABEL_308;
    case 43:
      v43 = &gpGame->boats[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      game::RestoreCell(-1, -1, v43->underlyingObjType, v43->underlyingObjExtra, (int)cell, 3);
      hro->flags |= 0x80u;
      hro->remainingMobility = 0;
      v43->field_6 = hro->idx;
      v43->owner = hro->ownerIdx;
      *(_DWORD *)(thisa + 634) = 6;
      *(_DWORD *)(thisa + 638) = v43->field_3;
      *(_DWORD *)(thisa + 642) = advManager::GetCursorBaseFrame(*(_DWORD *)(thisa + 638));
      *(_DWORD *)(thisa + 626) = 1;
      goto LABEL_308;
    case 1:
    case 23:
    case 29:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == giCurPlayer )
        goto LABEL_308;
      if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType == -1 )
        goto LABEL_12;
      spell = gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty;
      v73 = philAI::CombatMonsterEvent(
              (int)hro,
              gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType,
              (int)&spell,
              (int)cell);
      if ( v73 )
      {
        gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = -1;
        gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = 0;
        hero::CheckLevel(hro);
LABEL_12:
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          giCurPlayer);
        if ( v57 == 23 )
        {
          for ( spell = 61; (signed int)spell < 64; ++spell )
          {
            if ( hero::HasSpell(hro, spell) && GetManaCost(spell, hro) < hro->spellpoints )
            {
              hro->spellpoints -= GetManaCost(spell, hro);
              gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = spell + 1;
              v40 = hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER);
              if ( v40 > 51 )
                v40 = 51;
              gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = 5 * v40;
              spell = 999;
            }
          }
        }
      }
      goto LABEL_308;
    case 21:
      if ( gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != giCurPlayer )
        game::ClaimMine(
          gpGame,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          giCurPlayer);
      goto LABEL_308;
    case 6:
      if ( !(((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1) )
        goto LABEL_28;
      if ( hero::NumArtifacts(hro) < 14 )
      {
        v5 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        GiveArtifact(hro, (ARTIFACT)(unsigned __int8)v5, 1, -1);
      }
      else
      {
        v4 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
        LOBYTE(v4) = v4 | 0x10;
        cell->field_4_1_1_isShadow_1_13_extraInfo = v4;
LABEL_28:
        if ( philAI::ChooseGoldOrExperience(
               500 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
               125
             * (4 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 4)) )
        {
          advManager::GiveResource(
            (advManager *)thisa,
            hro,
            6,
            500 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
        }
        else
        {
          advManager::GiveExperience(
            hro,
            125 * (4 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 4),
            1);
          hero::CheckLevel(hro);
        }
      }
      v58 = 1;
      goto LABEL_308;
    case 84:
      if ( !(BYTE1(hro->flags) & 2) )
      {
        hro->mobility += 400;
        hro->remainingMobility += 400;
        hro->flags |= 0x200u;
        ++hro->tempMoraleBonuses;
      }
      goto LABEL_308;
    case 3:
      if ( !(hro->flags & 2) )
      {
        hro->flags |= 2u;
        ++hro->tempMoraleBonuses;
      }
      goto LABEL_308;
    case 7:
      if ( !(hro->flags & 0x10) )
      {
        hro->flags |= 0x10u;
        ++hro->tempLuckBonuses;
      }
      goto LABEL_308;
    case 67:
      if ( !(BYTE1(hro->flags) & 0x20) )
      {
        hro->flags |= 0x2000u;
        ++hro->tempLuckBonuses;
      }
      goto LABEL_308;
    case 9:
      if ( !(hro->flags & 4) )
      {
        hro->flags |= 4u;
        ++hro->tempLuckBonuses;
      }
      goto LABEL_308;
    case 26:
      if ( !(hro->flags & 8) )
      {
        hro->flags |= 8u;
        ++hro->tempMoraleBonuses;
        hro->mobility += 800;
        hro->remainingMobility += 800;
      }
      goto LABEL_308;
    case 70:
      if ( !(BYTE1(hro->flags) & 1) )
      {
        hro->flags |= 0x100u;
        hro->tempMoraleBonuses += 2;
      }
      goto LABEL_308;
    case 4:
      if ( (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) != 1 )
      {
        GiveArtifact(
          hro,
          (ARTIFACT)((unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 2),
          1,
          -1);
        v6 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
        LOBYTE(v6) = v6 | 8;
        cell->field_4_1_1_isShadow_1_13_extraInfo = v6;
      }
      goto LABEL_308;
    case 95:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::GiveResource(
          (advManager *)this,
          hro,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
          (unsigned int)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 7 < 1 ? 500 : 5);
        cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      goto LABEL_308;
    case 88:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        v7 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        v8 = (v7 & 0xF0u) >> 4;
        v9 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        advManager::GiveResource((advManager *)this, hro, (v9 & 0xF) - 1, v8);
        cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      goto LABEL_308;
    case 80:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        if ( (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x80 )
        {
          if ( hero::NumArtifacts(hro) != 14 )
          {
            v10 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
            spell = v10 & 0x7F;
            GiveArtifact(hro, (ARTIFACT)(v10 & 0x7F), 1, -1);
          }
          cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        }
        else
        {
          v11 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
          v12 = (v11 & 0xF0u) >> 4;
          v13 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
          advManager::GiveResource((advManager *)this, hro, (v13 & 0xF) - 1, v12);
          cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        }
      }
      goto LABEL_308;
    case 33:
      if ( ((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 && hero::NumArtifacts(hro) < 14 )
      {
        v14 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        GiveArtifact(hro, (ARTIFACT)(unsigned __int8)v14, 1, -1);
        advManager::GiveResource((advManager *)thisa, hro, 6, 1000);
      }
      else if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::GiveResource((advManager *)thisa, hro, 6, 1500);
      }
      v58 = 1;
      goto LABEL_308;
    case 90:
      switch ( (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        case 1u:
          advManager::GiveResource((advManager *)this, hro, 0, 5);
          break;
        case 2u:
          advManager::GiveResource((advManager *)this, hro, 0, 5);
          advManager::GiveResource((advManager *)thisa, hro, 6, 200);
          break;
        case 3u:
          advManager::GiveResource((advManager *)this, hro, 0, 10);
          advManager::GiveResource((advManager *)thisa, hro, 6, 500);
          break;
        case 0u:
          break;
      }
      v58 = 1;
      goto LABEL_308;
    case 8:
      advManager::GiveResource(
        (advManager *)this,
        hro,
        6,
        100
      * ((signed int)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4));
      v15 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      advManager::GiveResource(
        (advManager *)thisa,
        hro,
        v15 & 0xF,
        (signed int)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 4);
      v58 = 1;
      goto LABEL_308;
    case 62:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->fortsVisited) )
      {
        ++hro->primarySkills[1];
        hro->fortsVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_308;
    case 86:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->xanadusVisited)
        && hro->oldLevel + 2 * hro->secondarySkillLevel[4] >= 10 )
      {
        ++hro->primarySkills[0];
        ++hro->primarySkills[1];
        ++hro->primarySkills[3];
        ++hro->primarySkills[2];
        hro->xanadusVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_308;
    case 66:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->standingStonesVisited) )
      {
        ++hro->primarySkills[2];
        hro->standingStonesVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_308;
    case 69:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->witchDoctorHutsVisited) )
      {
        ++hro->primarySkills[3];
        hro->witchDoctorHutsVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_308;
    case 73:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->mercenaryCampsVisited) )
      {
        ++hro->primarySkills[0];
        hro->mercenaryCampsVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
      }
      goto LABEL_308;
    case 10:
      if ( !((1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3)) & hro->gazeboesVisited) )
      {
        advManager::GiveExperience(hro, 1000, 1);
        hro->gazeboesVisited |= 1 << (cell->field_4_1_1_isShadow_1_13_extraInfo >> 3);
        hero::CheckLevel(hro);
      }
      goto LABEL_308;
    case 22:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        advManager::GiveResource(
          (advManager *)this,
          hro,
          6,
          500 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5));
        cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
      }
      goto LABEL_308;
    case 27:
      type = cell->objectIndex >> 1;
      if ( type == 6 )
        amt = 100 * (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      else
        amt = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
      advManager::GiveResource((advManager *)this, hro, type, amt);
      v58 = 1;
      goto LABEL_308;
    case 40:
      if ( (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) != 99 )
      {
        advManager::GiveResource(
          (advManager *)this,
          hro,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          2);
        cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 0x318;
      }
      goto LABEL_308;
    case 71:
      hero::UpgradeCreatures(hro, 15, 16);
      hero::UpgradeCreatures(hro, 12, 13);
      hero::UpgradeCreatures(hro, 21, 22);
      goto LABEL_308;
    case 97:
      hero::UpgradeCreatures(hro, 40, 41);
      hero::UpgradeCreatures(hro, 3, 4);
      hero::UpgradeCreatures(hro, 5, 6);
      goto LABEL_308;
    case 60:
      mon = 20;
      v60 = 0;
      goto LABEL_132;
    case 61:
      mon = 61;
      v60 = 0;
      goto LABEL_132;
    case 83:
      if ( ((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
        goto LABEL_308;
      mon = 17;
      v60 = 0;
      goto LABEL_132;
    case 77:
      if ( ((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
        goto LABEL_308;
      mon = 55;
      v60 = 0;
      goto LABEL_132;
    case 20:
      if ( ((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
        goto LABEL_308;
      mon = 36;
      v60 = 0;
      goto LABEL_132;
    case 72:
      mon = 38;
      v60 = 1;
      goto LABEL_132;
    case 11:
      mon = 60;
      v60 = 0;
      goto LABEL_132;
    case 37:
      mon = 57;
      v60 = 0;
      goto LABEL_132;
    case 34:
      mon = 58;
      v60 = 0;
      goto LABEL_132;
    case 58:
      mon = 12;
      v60 = 1;
      goto LABEL_132;
    case 59:
      mon = 20;
      v60 = 1;
      goto LABEL_132;
    case 13:
      mon = 1;
      v60 = 1;
      goto LABEL_132;
    case 14:
      mon = 11;
      v60 = 1;
      goto LABEL_132;
    case 16:
      mon = 0;
      v60 = 1;
      goto LABEL_132;
    case 15:
    case 65:
      mon = 21;
      v60 = 1;
      goto LABEL_132;
    case 87:
      mon = 29;
      v60 = 1;
      goto LABEL_132;
    case 78:
      mon = 47;
      v60 = 1;
LABEL_132:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        philAI::EvaluateOneTimeCreaturePurchase(
          mon,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          v60,
          (int)&a3a,
          (int)&v62,
          (int)&slot);
        if ( a3a > 0 )
        {
          game::GiveArmy(&hro->army, mon, a3a, slot);
          cell->field_4_1_1_isShadow_1_13_extraInfo = cell->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * ((unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - (_WORD)a3a);
          if ( !v60 )
          {
            GetMonsterCost(mon, arr);
            for ( spell = 0; (signed int)spell < 7; ++spell )
              gpCurPlayer->resources[spell] -= a3a * arr[spell];
          }
        }
      }
      if ( !((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) && v57 == 11 )
        v58 = 1;
      goto LABEL_308;
    case 24:
      advManager::ComputerMonsterInteract((int)cell, (int)hro, (int)&v58);
      goto LABEL_308;
    case 68:
      if ( !((1 << ((cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) & 0x1F)) & hro->treesOfKnowledgeVisited) )
      {
        level = hero::GetLevel(hro->experience);
        v16 = hero::GetExperience(level + 1);
        xp = v16 - hero::GetExperience(level);
        v29 = (signed int)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) >> 6;
        if ( v29 == 1 )
        {
          advManager::GiveExperience(hro, xp, 1);
          hro->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
          hero::CheckLevel(hro);
        }
        else if ( v29 == 2 )
        {
          if ( gpCurPlayer->resources[6] > 2000 )
          {
            gpCurPlayer->resources[6] -= 2000;
            advManager::GiveExperience(hro, xp, 1);
            hro->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
            hero::CheckLevel(hro);
          }
        }
        else if ( v29 == 3 && gpCurPlayer->resources[5] > 10 )
        {
          gpCurPlayer->resources[5] -= 10;
          advManager::GiveExperience(hro, xp, 1);
          hro->treesOfKnowledgeVisited |= 1 << (((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0x1F);
          hero::CheckLevel(hro);
        }
      }
      goto LABEL_308;
    case 25:
      if ( !(gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                             + 47] & (unsigned __int8)giCurPlayerBit) )
      {
        gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)
                        + 47] |= giCurPlayerBit;
        ComputeUALoc(giCurPlayer);
      }
      goto LABEL_308;
    case 31:
    case 74:
    case 75:
      if ( hero::HasArtifact(hro, 81)
        && gsSpellInfo[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1].level <= hro->secondarySkillLevel[7] + 2 )
      {
        v17 = hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
        hero::AddSpell(
          hro,
          (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
          v17);
      }
      goto LABEL_308;
    case 35:
      philAI::TownEvent((int)cell, (int)hro, x);
      goto LABEL_308;
    case 39:
      advManager::DoWhirlpool((advManager *)this, hro);
      goto LABEL_165;
    case 36:
LABEL_165:
      v44 = 0;
      for ( y = 0; y < MAP_HEIGHT; ++y )
      {
        for ( i = 0; i < MAP_WIDTH; ++i )
        {
          if ( *(&gpGame->map.tiles[i].objType + 12 * y * gpGame->map.width) == (unsigned __int8)((unsigned __int8)v57 | 0x80) )
          {
            if ( *(&gpGame->map.tiles[i].objectIndex + 12 * y * gpGame->map.width) == cell->objectIndex )
            {
              v18 = abs(y - HIDWORD(x));
              if ( abs(i - x) + v18 > ((unsigned int)(v57 - 36) < 1 ? 1 : 3) )
                ++v44;
            }
          }
        }
      }
      if ( v44 < 1 )
        goto LABEL_308;
      if ( v44 > 1 )
        v44 = Random(1, v44);
      y = 0;
LABEL_179:
      if ( y < MAP_HEIGHT )
      {
        for ( i = 0; ; ++i )
        {
          if ( i >= MAP_WIDTH )
          {
            ++y;
            goto LABEL_179;
          }
          if ( *(&gpGame->map.tiles[i].objType + 12 * y * gpGame->map.width) == (unsigned __int8)((unsigned __int8)v57 | 0x80) )
          {
            if ( *(&gpGame->map.tiles[i].objectIndex + 12 * y * gpGame->map.width) == cell->objectIndex )
            {
              v19 = abs(y - HIDWORD(x));
              if ( abs(i - x) + v19 > ((unsigned int)(v57 - 36) < 1 ? 1 : 3) )
              {
                --v44;
                if ( v44 <= 0 )
                  break;
              }
            }
          }
        }
      }
      advManager::StopCursor((advManager *)thisa, 1);
      advManager::TeleportTo(gpAdvManager, hro, i, y, 0, 0);
      goto LABEL_308;
    case 41:
      v20 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      v50 = (v20 & 0xF0u) >> 4;
      a2 = cell->objectIndex >> 1;
      v21 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
      v54 = v21 & 0x7F;
      if ( hero::NumArtifacts(hro) == 14 )
        goto LABEL_308;
      if ( a2 == 86 )
      {
        GiveArtifact(
          hro,
          ARTIFACT_SPELL_SCROLL,
          1,
          (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
        v58 = 1;
        goto LABEL_308;
      }
      if ( ((unsigned __int16)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 3) >> 8) & 1 )
      {
        if ( v54 == 57 )
        {
          v46 = 50;
        }
        else
        {
          v46 = 1;
          if ( !philAI::ChooseToFightForArtifact(a2, v54, 1) )
            goto LABEL_308;
        }
        if ( philAI::CombatMonsterEvent((int)hro, v54, (int)&v46, (int)cell) )
        {
LABEL_204:
          for ( spell = 0; (signed int)spell < 7; ++spell )
          {
            if ( gpCurPlayer->resources[spell] < 0 )
              gpCurPlayer->resources[spell] = 0;
          }
          GiveArtifact(hro, a2, 1, -1);
          v58 = 1;
        }
      }
      else
      {
        v22 = cell->field_4_1_1_isShadow_1_13_extraInfo >> 3;
        switch ( v22 & 0xF )
        {
          case 4:
            if ( hro->secondarySkillLevel[7] )
              goto LABEL_204;
            goto LABEL_308;
          case 5:
            if ( hro->secondarySkillLevel[6] )
              goto LABEL_204;
            goto LABEL_308;
          case 1:
            goto LABEL_204;
          case 3:
            if ( !(unsigned int)philAI::NetValueOfArtifact(a2, 2000, 0, 0) )
              goto LABEL_308;
            gpGame->players[hro->ownerIdx].resources[6] -= 2000;
            goto LABEL_204;
          case 6:
            if ( !(unsigned int)philAI::NetValueOfArtifact(a2, 2500, v50, 3) )
              goto LABEL_308;
            gpGame->players[hro->ownerIdx].resources[6] -= 2500;
            v23 = 283 * hro->ownerIdx + 4 * v50;
            *(int *)((char *)gpGame->players[0].resources + v23) -= 3;
            goto LABEL_204;
          case 7:
            if ( !(unsigned int)philAI::NetValueOfArtifact(a2, 3000, v50, 5) )
              goto LABEL_308;
            gpGame->players[hro->ownerIdx].resources[6] -= 3000;
            v24 = 283 * hro->ownerIdx + 4 * v50;
            *(int *)((char *)gpGame->players[0].resources + v24) -= 5;
            goto LABEL_204;
          default:
            goto LABEL_308;
        }
      }
      goto LABEL_308;
    case 42:
      v51 = &gpGame->heroes[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      v42 = bShowIt;
      if ( *((_BYTE *)v51 + 3) == giCurPlayer )
      {
        philAI::HeroInteractionAtHero((int)hro, (int)v51, 0, (int)&v53);
      }
      else
      {
        if ( *(_WORD *)((char *)v51 + 45) == 163 )
          v71 = &gpGame->castles[*(_WORD *)((char *)v51 + 47)];
        if ( gbHumanPlayer[*((_BYTE *)v51 + 3)] )
        {
          if ( v71 )
            *((_BYTE *)v71 + 23) = *((_BYTE *)v51 + 2);
          v52 = advManager::DoCombat(
                  (void *)this,
                  x,
                  (int)hro,
                  &hro->army,
                  (int)v71,
                  (int)v51,
                  (char *)v51 + 101,
                  x,
                  SBYTE4(x),
                  -1,
                  1);
          if ( !v52 && v71 )
            game::ClaimTown(gpGame, *(_BYTE *)v71, giCurPlayer, 0);
        }
        else
        {
          HIDWORD(v25) = v51;
          LODWORD(v25) = (char *)v51 + 101;
          v73 = philAI::QuickCombat((int)&hro->army, (int)hro, v25, 0, 0, (float *)&v36, (float *)&v35);
          if ( v73 && v71 )
            v73 = philAI::QuickCombat(
                    (int)&hro->army,
                    (int)hro,
                    (unsigned int)((char *)v71 + 8),
                    1,
                    *(_BYTE *)v71,
                    (float *)&v36,
                    (float *)&v35);
        }
        advManager::CompleteDraw((advManager *)thisa, 0);
LABEL_308:
        if ( v58 )
          advManager::EraseObj((advManager *)thisa, cell, x, SHIDWORD(x));
        giCurPlayer = v61;
        gpCurPlayer = v72;
        if ( hro->ownerIdx != -1 )
          hero::CheckLevel(hro);
        CheckEndGame(0, 0);
      }
      return;
    case 93:
      v58 = 1;
      goto LABEL_308;
    case 5:
      switch ( (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) )
      {
        case 2u:
          advManager::GiveExperience(hro, 1000, 1);
          break;
        case 3u:
          advManager::GiveExperience(hro, 1000, 1);
          advManager::GiveRandomArtifact((void *)thisa, hro);
          break;
        case 4u:
          advManager::GiveExperience(hro, 1000, 1);
          advManager::GiveResource((advManager *)thisa, hro, 6, 2500);
          break;
        case 5u:
          if ( gpGame->players[hro->ownerIdx].resources[6] < 2500 )
          {
            advManager::HeroLoses(this, (int)hro);
          }
          else if ( philAI::ChooseToPayRansomOnHero(2500u) )
          {
            gpGame->players[hro->ownerIdx].resources[6] -= 2500;
          }
          else
          {
            advManager::HeroLoses(thisa, (int)hro);
          }
          break;
        case 1u:
          break;
      }
      v26 = cell->field_4_1_1_isShadow_1_13_extraInfo & 7;
      LOBYTE(v26) = v26 | 8;
      cell->field_4_1_1_isShadow_1_13_extraInfo = v26;
      goto LABEL_308;
    case 76:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5
        && !hero::HasSpell(
              hro,
              (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1) )
      {
        for ( spell = 0; (signed int)spell < 5; ++spell )
        {
          gpMonGroup->creatureTypes[spell] = 51;
          gpMonGroup->quantities[spell] = 10;
        }
        spell = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1;
        if ( gsSpellInfo[spell].attributes & 1 )
        {
          v31 = hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER) <= 40 ? gfBattleStat[hero::Stats(
                                                                                  hro,
                                                                                  PRIMARY_SKILL_SPELLPOWER)] : gfBattleStat[40];
          v32 = v31;
        }
        else
        {
          v32 = 1.0;
        }
        v64 = (signed __int64)((double)gsSpellInfo[spell].appearingChance * gpCurPlayer->field_10F * v32);
        philAI::ChooseEvaluateBattle(
          (int)&hro->army,
          (int)hro,
          (unsigned int)gpMonGroup,
          0,
          0,
          v64,
          (int)&v63,
          (int)&v59);
        if ( v63 )
        {
          spell = 50;
          v73 = philAI::CombatMonsterEvent((int)hro, 51, (int)&spell, (int)cell);
          if ( v73 )
          {
            v27 = hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
            hero::AddSpell(
              hro,
              (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) - 1,
              v27);
            cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
          }
        }
      }
      goto LABEL_308;
    case 12:
    case 32:
    case 91:
      philAI::FightEvent((int)hro, (int)cell, 0);
      goto LABEL_308;
    case 64:
      for ( spell = 0; (signed int)spell < 5; ++spell )
      {
        gpMonGroup->creatureTypes[spell] = gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType;
        gpMonGroup->quantities[spell] = gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty
                                      / 5;
      }
      v70 = (signed __int64)((double)*((_BYTE *)gaiTurnValueOfMine + x + HIDWORD(x) * MAP_WIDTH)
                           * (double)dword_4F1F38
                           * flt_530730);
      philAI::ChooseEvaluateBattle((int)&hro->army, (int)hro, (unsigned int)gpMonGroup, 0, 0, v70, (int)&v63, (int)&v59);
      if ( v63 )
      {
        v55 = gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty;
        v73 = philAI::CombatMonsterEvent(
                (int)hro,
                gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType,
                (int)&v55,
                (int)cell);
        if ( v55 > 255 )
          v55 = 255;
        gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = v55;
        if ( v73 )
        {
          hero::CheckLevel(hro);
          game::ConvertObject(gpGame, x - 2, HIDWORD(x) - 1, x + 1, HIDWORD(x) - 1, 56, 0, 4, 26, 104, 64, 23);
          game::ConvertObject(gpGame, x - 2, SHIDWORD(x), x + 1, SHIDWORD(x), 56, 5, 9, 26, 109, 64, 23);
          game::ConvertObject(gpGame, x - 2, HIDWORD(x) - 1, x + 1, HIDWORD(x) - 1, 51, 0, 3, 32, 75, 64, 23);
          game::ConvertObject(gpGame, x - 2, SHIDWORD(x), x + 1, SHIDWORD(x), 51, 4, 7, 32, 80, 64, 23);
          game::ConvertObject(gpGame, x, SHIDWORD(x), x, SHIDWORD(x), 29, 5, 5, 29, 4, 64, 23);
          gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type = 6;
          gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guardianType = -1;
          gpGame->mines[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].guadianQty = 0;
          game::ClaimMine(
            gpGame,
            (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
            giCurPlayer);
        }
      }
      goto LABEL_308;
    case 96:
      game::SetVisibility(gpGame, x, SHIDWORD(x), giCurPlayer, 20);
      goto LABEL_308;
    case 92:
      if ( hero::NumArtifacts(hro) < 14 )
        GiveArtifact(
          hro,
          (ARTIFACT)(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
          1,
          -1);
      v58 = 1;
      goto LABEL_308;
    case 82:
      if ( (unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5 )
      {
        cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        v28 = hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
        if ( hro->spellpoints < 20 * v28 )
          hro->spellpoints = 20 * v28;
      }
      goto LABEL_308;
    case 94:
      if ( !(BYTE1(hro->flags) & 0x10) )
      {
        cell->field_4_1_1_isShadow_1_13_extraInfo &= 7u;
        v34 = 10 * hero::Stats(hro, PRIMARY_SKILL_KNOWLEDGE);
        if ( hro->spellpoints < v34 )
        {
          hro->flags |= 0x1000u;
          hro->spellpoints = v34;
        }
      }
      goto LABEL_308;
    case 85:
      if ( !hro->secondarySkillLevel[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] )
        hero::GiveSS(hro, (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5), 1);
      goto LABEL_308;
    case 79:
      v56 = ppMapExtra[(unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
      if ( *(_BYTE *)v56 )
      {
        if ( Random(0, 100) >= 40 )
        {
          advManager::HeroLoses(thisa, (int)hro);
        }
        else
        {
          for ( spell = 0; (signed int)spell < 7; ++spell )
          {
            gpGame->players[giCurPlayer].resources[spell] += *(_DWORD *)((char *)v56 + 4 * spell + 1);
            if ( gpGame->players[giCurPlayer].resources[spell] < 0 )
              gpGame->players[giCurPlayer].resources[spell] = 0;
          }
          if ( *(_WORD *)((char *)v56 + 29) != -1 && hero::NumArtifacts(hro) < 14 )
            GiveArtifact(hro, (ARTIFACT)*(_WORD *)((char *)v56 + 29), 1, -1);
          *(_BYTE *)v56 = 0;
        }
      }
      goto LABEL_308;
    case 119:
      v58 = advManager::BarrierAIEvent((int)cell, (int)hro);
      goto LABEL_308;
    case 120:
      advManager::PasswordAIEvent((int)cell, (int)hro);
      goto LABEL_308;
    case 122:
      advManager::GenericSiteAIEvent((int)cell, (int)hro);
      goto LABEL_308;
    case 121:
      advManager::RecruitSiteAIEvent((int)cell, (int)hro);
      goto LABEL_308;
    case 123:
      advManager::JailAIEvent(this, (int)cell, (int)hro, x, SHIDWORD(x));
      goto LABEL_308;
    case 30:
    case 2:
    case 81:
    case 89:
    case 63:
    case 17:
    case 18:
    case 19:
    case 38:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
      goto LABEL_308;
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F1F38: using guessed type int dword_4F1F38;
// 524C14: using guessed type int bShowIt;
// 530730: using guessed type float flt_530730;
// 532C5C: using guessed type char giCurPlayerBit;
// 48F940: using guessed type int arr[7];

//----- (00492310) --------------------------------------------------------
bool __stdcall advManager::BarrierAIEvent(int a1, int a2)
{
  return (gpCurPlayer->barrierTentsVisited & (1 << (((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7))) != 0;
}

//----- (00492380) --------------------------------------------------------
char __stdcall advManager::PasswordAIEvent(int a1, int a2)
{
  char result; // al@1

  result = (1 << (((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7)) | gpCurPlayer->barrierTentsVisited;
  gpCurPlayer->barrierTentsVisited = result;
  return result;
}

//----- (004923E0) --------------------------------------------------------
char __stdcall advManager::GenericSiteAIEvent(int a1, int a2)
{
  playerData *v2; // eax@4
  int xp; // [sp+1Ch] [bp-34h]@29
  int v5; // [sp+20h] [bp-30h]@31
  signed int v6; // [sp+24h] [bp-2Ch]@32
  signed int i; // [sp+34h] [bp-1Ch]@2
  signed int j; // [sp+34h] [bp-1Ch]@9
  signed int k; // [sp+34h] [bp-1Ch]@29
  int v10; // [sp+44h] [bp-Ch]@1
  signed int v11; // [sp+4Ch] [bp-4h]@18

  v10 = 0;
  LOBYTE(v2) = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 0x3F;
  switch ( ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 0x3F )
  {
    case 0:
      for ( i = 0; i < 14; ++i )
      {
        v2 = (playerData *)IsCursedItem(*(_BYTE *)(i + a2 + 213));
        if ( v2 )
          ++v10;
      }
      if ( v10 )
      {
        LOBYTE(v2) = (_BYTE)gpCurPlayer;
        if ( gpCurPlayer->resources[6] >= 1500 )
        {
          for ( j = 0; j < 14; ++j )
          {
            if ( IsCursedItem(*(_BYTE *)(j + a2 + 213)) )
              *(_BYTE *)(j + a2 + 213) = -1;
          }
          v2 = gpCurPlayer;
          v2->resources[6] -= 750;
        }
      }
      break;
    case 1:
      LOBYTE(v2) = a2;
      if ( !(*(_BYTE *)(a2 + 229) & 0x40) )
      {
        *(_DWORD *)(a2 + 227) |= 0x400000u;
        switch ( *(_BYTE *)(a2 + 23) )
        {
          case 2:
          case 3:
          case 4:
          case 5:
            v11 = 2;
            break;
          case 1:
            v11 = 0;
            break;
          case 0:
            v11 = 1;
            break;
          default:
            v11 = 0;
            break;
        }
        v2 = (playerData *)v11;
        ++v2->_3[a2 + 44];
      }
      break;
    case 5:
      LOBYTE(v2) = a2;
      if ( !(*(_BYTE *)(a2 + 229) & 0x10) )
      {
        *(_DWORD *)(a2 + 227) |= 0x100000u;
        LOBYTE(v2) = *(_BYTE *)(a2 + 69) + 1;
        *(_BYTE *)(a2 + 69) = (_BYTE)v2;
      }
      break;
    case 6:
      LOBYTE(v2) = a2;
      if ( !(*(_BYTE *)(a2 + 229) & 0x20) )
      {
        xp = 0;
        for ( k = 0; k < 5; ++k )
        {
          v5 = *(_BYTE *)(k + a2 + 101);
          if ( v5 != -1 )
          {
            v6 = *(_WORD *)(a2 + 2 * k + 106);
            if ( v6 > 1 )
            {
              *(_WORD *)(a2 + 2 * k + 106) = (signed __int64)((double)v6 * 0.7);
              xp += gMonsterDatabase[v5].hp * (v6 - *(_WORD *)(a2 + 2 * k + 106));
            }
          }
        }
        if ( xp )
          advManager::GiveExperience((hero *)a2, xp, 1);
        v2 = (playerData *)(*(_DWORD *)(a2 + 227) | 0x200000);
        *(_DWORD *)(a2 + 227) = v2;
      }
      break;
    case 4:
      if ( !(*(_BYTE *)(a2 + 229) & 0x80) )
      {
        *(_DWORD *)(a2 + 227) |= 0x800000u;
        *(_DWORD *)(a2 + 49) += 400;
        *(_DWORD *)(a2 + 53) += 400;
      }
      v2 = (playerData *)hero::CreatureTypeCount((hero *)a2, 7);
      if ( v2 )
        LOBYTE(v2) = hero::UpgradeCreatures((hero *)a2, 7, 8);
      break;
    case 2:
    case 3:
      return (char)v2;
  }
  return (char)v2;
}

//----- (00492750) --------------------------------------------------------
void __stdcall advManager::RecruitSiteAIEvent(int a1, int a2)
{
  int arr[7]; // [sp+14h] [bp-3Ch]@10
  char v3; // [sp+30h] [bp-20h]@9
  __int16 v4; // [sp+34h] [bp-1Ch]@1
  int i; // [sp+38h] [bp-18h]@10
  int v6; // [sp+3Ch] [bp-14h]@1
  int amt; // [sp+40h] [bp-10h]@9
  int v8; // [sp+44h] [bp-Ch]@10
  signed int slot; // [sp+48h] [bp-8h]@9
  int mon; // [sp+4Ch] [bp-4h]@2

  v6 = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7;
  v4 = (signed __int16)(unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) >> 3;
  switch ( v6 )
  {
    case 0:
      mon = 59;
      break;
    case 1:
      mon = 62;
      break;
    case 2:
      mon = 63;
      break;
    case 3:
      mon = 64;
      break;
    case 4:
      mon = 65;
      break;
    default:
      break;
  }
  if ( v4 )
  {
    philAI::EvaluateOneTimeCreaturePurchase(mon, v4, 0, (int)&amt, (int)&v3, (int)&slot);
    if ( amt > 0 )
    {
      game::GiveArmy((armyGroup *)(a2 + 101), mon, amt, slot);
      v4 -= amt;
      v8 = v6 | 8 * v4;
      *(_WORD *)(a1 + 4) = 8 * (v6 | (unsigned __int16)(8 * v4)) | *(_WORD *)(a1 + 4) & 7;
      GetMonsterCost(mon, arr);
      for ( i = 0; i < 7; ++i )
        gpCurPlayer->resources[i] -= amt * arr[i];
    }
  }
}
// 492750: using guessed type int arr[7];

//----- (004928E0) --------------------------------------------------------
void __thiscall advManager::JailAIEvent(int this, int a2, int a3, int a4, int a5)
{
  char *v5; // ST24_4@4
  int v6; // [sp+14h] [bp-4h]@1

  v6 = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5);
  if ( gpGame->relatedToHeroForHireStatus[v6] == 65 )
  {
    if ( gpCurPlayer->numHeroes < 8 )
    {
      gpGame->heroes[v6].ownerIdx = *(_BYTE *)(a3 + 3);
      gpGame->relatedToHeroForHireStatus[v6] = *(_BYTE *)(a3 + 3);
      v5 = (char *)&gpGame->heroes[v6];
      advManager::EraseObj((advManager *)this, (mapCell *)a2, a4, a5);
      gpCurPlayer->heroesOwned[gpCurPlayer->numHeroes++] = v6;
      *(_DWORD *)(v5 + 25) = a4;
      *(_DWORD *)(v5 + 29) = a5;
      *(_DWORD *)(v5 + 227) = 0;
      v5[44] = 2;
      *(_DWORD *)(v5 + 53) = hero::CalcMobility((hero *)v5);
      *(_DWORD *)(v5 + 49) = *(_DWORD *)(v5 + 53);
      *(_WORD *)(v5 + 45) = *(_BYTE *)(a2 + 9);
      *(_WORD *)(v5 + 47) = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5);
      *(_BYTE *)(a2 + 9) = -86;
      *(_WORD *)(a2 + 4) = 8 * v6 | *(_WORD *)(a2 + 4) & 7;
      SendMapChange(3, v6, a4, a5, -999, 0, 0);
    }
  }
  else
  {
    advManager::EraseObj((advManager *)this, (mapCell *)a2, a4, a5);
  }
}

//----- (00492A90) --------------------------------------------------------
heroWindow *__thiscall advManager::PlayerMonsterInteract(void *this, mapCell *cell, mapCell *a5, hero *a2, heroWindow *argC, __int64 a6, int a8, __int64 a9)
{
  heroWindow *result; // eax@20
  void *thisa; // [sp+14h] [bp-14Ch]@1
  char v10; // [sp+18h] [bp-148h]@69
  int quantity; // [sp+144h] [bp-1Ch]@57
  signed int img1Arg; // [sp+148h] [bp-18h]@63
  int willJoin; // [sp+14Ch] [bp-14h]@1
  float v14; // [sp+150h] [bp-10h]@1
  int creat; // [sp+154h] [bp-Ch]@1
  heroWindow *v16; // [sp+158h] [bp-8h]@78
  int qty; // [sp+15Ch] [bp-4h]@1

  thisa = this;
  mouseManager::ShowColorPointer(gpMouseManager);
  creat = cell->objectIndex;
  willJoin = ((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) & 0;
  qty = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
  v14 = (double)philAI::FightValueOfStack(&a2->army, a2, 0, 0, 0, 0)
      / (double)(qty * gMonsterDatabase[creat].fight_value);
  if ( gbInCampaign
    && (gpGame->hasDwarfAlliance && (creat == CREATURE_DWARF || creat == CREATURE_BATTLE_DWARF)
     || gpGame->isDwarfbane && (creat == CREATURE_OGRE || creat == CREATURE_OGRE_LORD)
     || gpGame->hasDragonAlliance
     && (creat == CREATURE_GREEN_DRAGON || creat == CREATURE_RED_DRAGON || creat == CREATURE_BLACK_DRAGON)) )
  {
    if ( armyGroup::CanJoin(&a2->army, creat) )
    {
      if ( creat != 21 && creat != 22 )
      {
        if ( creat != 15 && creat != 16 )
          NormalDialog(
            "The dragons, snarling and growling, agree to join forces with you, their 'Ally'.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
        else
          NormalDialog(
            "The ogres recognize you as the Dwarfbane and lumber over to join you.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
      }
      else
      {
        NormalDialog("The dwarves recognize their allies and gladly join your forces.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
      }
      armyGroup::Add(&a2->army, creat, qty, -1);
      result = argC;
      argC->idx = 1;
    }
    else
    {
      if ( creat != 21 && creat != 22 )
      {
        if ( creat != 15 && creat != 16 )
          NormalDialog(
            "The dragons see you and call out.  \"Our alliance with Archibald compels us to join you.  Unfortunately you have no room.  A pity!\"  They quickly scatter.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
        else
          NormalDialog(
            "The ogres give you a grunt of recognition, \"Archibald's allies may pass.\"",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
      }
      else
      {
        NormalDialog(
          "The dwarves hail you, \"Any friend of Roland is a friend of ours.  You may pass.\"",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
      }
      result = argC;
      argC->idx = 1;
    }
    return result;
  }
  if ( gbInCampaign && gpGame->field_85 && (creat == 21 || creat == 22) )
  {
    NormalDialog("\"The Dwarfbane!!!!, run for your lives.\"", 1, -1, -1, -1, 0, -1, 0, -1, 0);
    result = argC;
    argC->idx = 1;
    return result;
  }
  if ( xIsPlayingExpansionCampaign && ExpCampaign::HasAward(&xCampaign, 0) && (creat == 23 || creat == 24) )
  {
    argC->idx = 1;
    if ( armyGroup::CanJoin(&a2->army, creat) )
    {
      NormalDialog(
        "As you approach the group of elves, their leader calls them all to attention.  He shouts to them, \"Who of you is brave enough to join this fearless ally of ours?\"  The group explodes with cheers as they run to join your ranks.",
        1,
        -1,
        -1,
        -1,
        0,
        -1,
        0,
        -1,
        0);
      result = (heroWindow *)armyGroup::Add(&a2->army, creat, qty, -1);
    }
    else
    {
      result = NormalDialog(
                 "The elves stand at attention as you approach.  Their leader calls to you and says, \"Let us not impede your progress, ally!  Move on, and may victory be yours.\"",
                 1,
                 -1,
                 -1,
                 -1,
                 0,
                 -1,
                 0,
                 -1,
                 0);
    }
    return result;
  }
  if ( !armyGroup::CanJoin(&a2->army, creat)
    || v14 <= 2.0
    || hero::HasArtifact(a2, 70)
    || creat == 59
    || creat == 62
    || creat == 63
    || creat == 64
    || creat == 65 )
    goto LABEL_86;
  if ( willJoin )
  {
    sprintf(gText, gEventText[66], gArmyNamesPlural[creat]);
    advManager::EventWindow(-1, 2, gText, -1, 0, -1, 0, -1);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      armyGroup::Add(&a2->army, creat, qty, -1);
      result = argC;
      argC->idx = 1;
      return result;
    }
    advManager::EventWindow(67, 1, byte_518974, -1, 0, -1, 0, -1);
    goto LABEL_78;
  }
  if ( !a2->secondarySkillLevel[4] )
  {
LABEL_86:
    if ( v14 <= 5.0 )
      goto LABEL_78;
LABEL_76:
    sprintf(
      gText,
      "The %s, awed by the power of your forces, begin to scatter.  Do you wish to pursue and engage them?",
      gArmyNamesPlural[creat]);
    advManager::EventWindow(-1, 2, gText, -1, 0, -1, 0, -1);
    if ( gpWindowManager->buttonPressedCode != 30725 )
    {
      result = argC;
      argC->idx = 1;
      return result;
    }
    goto LABEL_78;
  }
  if ( a2->secondarySkillLevel[4] == 3 )
  {
    quantity = qty;
  }
  else if ( a2->secondarySkillLevel[4] == 2 )
  {
    quantity = qty / 2;
  }
  else
  {
    quantity = qty / 4;
  }
  if ( !quantity )
    quantity = 1;
  img1Arg = qty * gMonsterDatabase[creat].cost;
  if ( gpGame->players[a2->ownerIdx].resources[6] >= img1Arg )
  {
    if ( qty == 1 )
    {
      sprintf(
        gText,
        "The %s is swayed by your diplomatic tongue, and offers to join your army for the sum of %d gold.  Do you accept?",
        gArmyNames[creat],
        img1Arg);
    }
    else
    {
      sprintf(gText, "The creatures are swayed by your diplomatic tongue, and make you an offer:\n\n");
      if ( qty == quantity )
        sprintf(
          &v10,
          "All %d of the %s will join your army for the sum of %d gold.  Do you accept?",
          qty,
          gArmyNamesPlural[creat],
          img1Arg);
      else
        sprintf(
          &v10,
          "%d of the %d %s will join your army, and the rest will leave you alone, for the sum of %d gold.  Do you accept?",
          quantity,
          qty,
          gArmyNamesPlural[creat],
          img1Arg);
      strcat(gText, &v10);
    }
    NormalDialog(gText, 2, -1, -1, 6, img1Arg, -1, 0, -1, 0);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      armyGroup::Add(&a2->army, creat, quantity, -1);
      argC->idx = 1;
      result = (heroWindow *)img1Arg;
      gpGame->players[a2->ownerIdx].resources[6] -= img1Arg;
      return result;
    }
    advManager::EventWindow(67, 1, byte_518AFC, -1, 0, -1, 0, -1);
    goto LABEL_78;
  }
  if ( v14 > 5.0 )
    goto LABEL_76;
LABEL_78:
  result = (heroWindow *)advManager::CombatMonsterEvent(
                           (advManager *)thisa,
                           a2,
                           creat,
                           qty,
                           a5,
                           a6,
                           SHIDWORD(a6),
                           0,
                           a9,
                           SHIDWORD(a9),
                           -1,
                           0,
                           0,
                           -1,
                           0,
                           0);
  v16 = result;
  if ( !result || v16 == (heroWindow *)-1 )
  {
    result = argC;
    argC->idx = 1;
  }
  return result;
}
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (004932B0) --------------------------------------------------------
__int16 __stdcall advManager::ComputerMonsterInteract(int a1, int a2, int a3)
{
  signed int v3; // ST28_4@31
  __int16 result; // ax@32
  signed int v5; // [sp+24h] [bp-28h]@16
  int v6; // [sp+28h] [bp-24h]@22
  char v7; // [sp+2Ch] [bp-20h]@10
  int v8; // [sp+30h] [bp-1Ch]@1
  float v9; // [sp+34h] [bp-18h]@1
  int v10; // [sp+38h] [bp-14h]@10
  int creatureType; // [sp+3Ch] [bp-10h]@1
  signed int slot; // [sp+40h] [bp-Ch]@10
  int amt; // [sp+44h] [bp-8h]@1
  bool v14; // [sp+48h] [bp-4h]@33

  creatureType = *(_BYTE *)(a1 + 3);
  amt = (unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5);
  v8 = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 0;
  v9 = (double)philAI::FightValueOfStack((armyGroup *)(a2 + 101), (hero *)a2, 0, 0, 0, 0)
     / (double)(amt * gMonsterDatabase[creatureType].fight_value);
  if ( armyGroup::CanJoin((armyGroup *)(a2 + 101), creatureType)
    && !hero::HasArtifact((hero *)a2, 70)
    && v9 > 2.0
    && creatureType != 59
    && creatureType != 62
    && creatureType != 63
    && creatureType != 64
    && creatureType != 65 )
  {
    if ( !v8 )
    {
      if ( !*(_BYTE *)(a2 + 120) )
        goto LABEL_28;
      if ( *(_BYTE *)(a2 + 120) == 3 )
      {
        v5 = amt;
      }
      else if ( *(_BYTE *)(a2 + 120) == 2 )
      {
        v5 = amt / 2;
      }
      else
      {
        v5 = amt / 4;
      }
      if ( !v5 )
        v5 = 1;
      v6 = (signed __int64)((double)(amt * (signed int)gMonsterDatabase[creatureType].cost) * 0.75);
      if ( gpGame->players[*(_BYTE *)(a2 + 3)].resources[6] >= v6 )
      {
        philAI::EvaluateOneTimeCreaturePurchase(creatureType, amt, 1, (int)&v10, (int)&v7, (int)&slot);
        if ( v10 > 0 )
        {
          gpGame->players[*(_BYTE *)(a2 + 3)].resources[6] -= v6;
          game::GiveArmy((armyGroup *)(a2 + 101), creatureType, v5, slot);
          *(_DWORD *)a3 = 1;
          goto LABEL_28;
        }
      }
      else if ( v9 > 5.0 )
      {
        goto LABEL_29;
      }
LABEL_33:
      v14 = philAI::CombatMonsterEvent(a2, creatureType, (int)&amt, a1);
      if ( v14 )
      {
        result = a3;
        *(_DWORD *)a3 = 1;
      }
      else
      {
        result = *(_WORD *)(a1 + 4) & 7 | 8 * ((amt & 0xFFF) + (((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 0));
        *(_WORD *)(a1 + 4) = result;
      }
      return result;
    }
    philAI::EvaluateOneTimeCreaturePurchase(creatureType, amt, 1, (int)&v10, (int)&v7, (int)&slot);
    if ( v10 <= 0 )
    {
      *(_DWORD *)a3 = 1;
    }
    else
    {
      game::GiveArmy((armyGroup *)(a2 + 101), creatureType, amt, slot);
      *(_DWORD *)a3 = 1;
    }
  }
LABEL_28:
  if ( v9 <= 5.0 )
    goto LABEL_33;
LABEL_29:
  advManager::GiveExperience((hero *)a2, amt * gMonsterDatabase[creatureType].hp, 1);
  hero::CheckLevel((hero *)a2);
  if ( hero::GetSSLevel((hero *)a2, SECONDARY_SKILL_NECROMANCY) )
  {
    if ( armyGroup::CanJoin((armyGroup *)(a2 + 101), 47) )
    {
      v3 = hero::GetSSLevel((hero *)a2, SECONDARY_SKILL_NECROMANCY);
      game::GiveArmy((armyGroup *)(a2 + 101), 47, (signed __int64)((double)v3 * (double)amt * 0.1), -1);
    }
  }
  result = a3;
  *(_DWORD *)a3 = 1;
  return result;
}

//----- (004936E0) --------------------------------------------------------
signed int __thiscall advManager::DoNetCombat(advManager *this, int a1)
{
  int v4; // [sp+14h] [bp-38h]@1
  int v5; // [sp+18h] [bp-34h]@1
  void *a1a; // [sp+1Ch] [bp-30h]@1
  int v7; // [sp+20h] [bp-2Ch]@1
  int v8; // [sp+24h] [bp-28h]@1
  void *v9; // [sp+28h] [bp-24h]@1
  int v10; // [sp+2Ch] [bp-20h]@1
  void *v11; // [sp+34h] [bp-18h]@1
  char v12; // [sp+38h] [bp-14h]@1
  void *v13; // [sp+3Ch] [bp-10h]@1
  int v14; // [sp+40h] [bp-Ch]@1
  void *v15; // [sp+44h] [bp-8h]@1
  int v16; // [sp+48h] [bp-4h]@1

  v9 = 0;
  a1a = 0;
  v13 = 0;
  v15 = 0;
  v11 = 0;
  advManager::ReceiveHeroTownData(
    a1,
    (int)&v7,
    (int)&v5,
    (int)&v4,
    &v9,
    &a1a,
    &v13,
    &v15,
    &v11,
    (int)&v10,
    (int)&v8,
    (int)&v16,
    (int)&v12,
    (int)&gbRetreatWin,
    (int)&gbCombatSurrender);
  v14 = *((_BYTE *)v9 + 3);
  v12 = advManager::DoCombat(this, __PAIR__(v4, v5), (int)v9, a1a, (int)v13, (int)v15, v11, v10, v8, v16, 0);
  if ( !gbHumanPlayer[v14] )
    advManager::SendHeroTownData(
      v5,
      v4,
      (int)v9,
      a1a,
      v13,
      (int)v15,
      v11,
      v10,
      v8,
      v16,
      v7,
      v12,
      gbRetreatWin,
      gbCombatSurrender);
  if ( a1a )
    BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518B64 + 70);
  if ( v11 )
    BaseFree(v11, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518B64 + 73);
  if ( v13 )
    BaseFree(v13, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518B64 + 76);
  if ( v15 )
    BaseFree(v15, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518B64 + 79);
  if ( v9 )
    BaseFree(v9, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518B64 + 82);
  gbRetreatWin = 0;
  return 1;
}
// 518B64: using guessed type __int16 word_518B64;
// 523450: using guessed type char gbCombatSurrender;
// 524210: using guessed type char gbRetreatWin;

//----- (004938B0) --------------------------------------------------------
int __thiscall advManager::DoCombat(void *this, __int64 a2, int a3, const void *a4, int a5, int a6, const void *a7, char a8, char a9, int a10, int a11)
{
  int v12; // edx@18
  void *thisa; // [sp+14h] [bp-70h]@1
  tag_message a2a; // [sp+18h] [bp-6Ch]@32
  void *v15; // [sp+34h] [bp-50h]@20
  void *a1; // [sp+38h] [bp-4Ch]@20
  void *v17; // [sp+3Ch] [bp-48h]@20
  void *v18; // [sp+40h] [bp-44h]@20
  void *v19; // [sp+44h] [bp-40h]@20
  int v20; // [sp+48h] [bp-3Ch]@18
  char v21; // [sp+4Ch] [bp-38h]@20
  char v22; // [sp+50h] [bp-34h]@32
  char v23; // [sp+6Ch] [bp-18h]@20
  int v24; // [sp+70h] [bp-14h]@13
  int v25; // [sp+74h] [bp-10h]@7
  int v26; // [sp+78h] [bp-Ch]@13
  int v27; // [sp+80h] [bp-4h]@4

  thisa = this;
  if ( giDebugLevel == 4 )
    return advManager::AutoResolveCombat(this, a2, a3, (int)a4, a5, a6, (int)a7, a8, a9, a10, a11);
  dword_4F7474 = 1;
  if ( a3 )
    v27 = *(_BYTE *)(a3 + 3);
  else
    v27 = -1;
  if ( a6 )
  {
    v25 = *(_BYTE *)(a6 + 3);
  }
  else if ( a5 )
  {
    v25 = *(_BYTE *)(a5 + 1);
  }
  else
  {
    v25 = -1;
  }
  if ( a10 == -1 )
    a10 = Random(1, 1000);
  advManager::DemobilizeCurrHero((advManager *)thisa);
  v26 = giCurPlayer;
  v24 = bShowIt;
  if ( v27 < 0 || v25 < 0 || !gbHumanPlayer[v25] )
    goto LABEL_36;
  if ( gbThisNetHumanPlayer[v25] )
  {
    if ( !gbThisNetHumanPlayer[v27] )
    {
      bShowIt = 1;
      game::TurnOffAIMusic();
      sprintf(gText, "%s's %s is under attack!", cPlayerNames[v25], &aTown_1[("Hero" - "Town") & ((a5 != 0) - 1)]);
      game::WaitForPlayer(gText, v25);
    }
    goto LABEL_36;
  }
  iCombatControlNetPos = giThisNetPos;
  dword_523434 = gbGamePosToNetPos[v25];
  advManager::SendHeroTownData(
    a2,
    SBYTE4(a2),
    a3,
    a4,
    (const void *)a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    gbGamePosToNetPos[v25],
    0,
    0,
    0);
  if ( gbHumanPlayer[v27] )
  {
LABEL_36:
    bShowIt = 1;
    combatManager::SetupCombat(gpCombatManager, a2, a3, (int)a4, a5, a6, (int)a7, a2, SHIDWORD(a2), a10);
    if ( giHighMemBuffer <= 2900 )
    {
      if ( giHighMemBuffer > 900 )
        gAdvDisposeLevel = 1;
    }
    else
    {
      gAdvDisposeLevel = 2;
    }
    executive::CallManager(gpExec, (baseManager *)gpCombatManager);
    mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
    gAdvDisposeLevel = 0;
    goto LABEL_41;
  }
  while ( 1 )
  {
    PollSound();
    FillBitmapArea(gpWindowManager->screenBuffer, 30, 30, 4u, 4, 0);
    v20 = advManager::CheckHandleNet((advManager *)thisa, v12);
    if ( v20 )
    {
      if ( *(_BYTE *)(v20 + 6) == 21 )
        break;
    }
    Process1WindowsMessage();
    memcpy(&v22, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2a), 0x1Cu);
    advManager::CheckHandleNetPlayerWait(thisa, (int)&v22, 1);
  }
  advManager::ReceiveHeroTownData(
    v20,
    (int)&v21,
    (int)&a2,
    (int)((char *)&a2 + 4),
    &v18,
    &a1,
    &v19,
    &v17,
    &v15,
    (int)&a8,
    (int)&a9,
    (int)&a10,
    (int)&v23,
    (int)&gbRetreatWin,
    (int)&gbCombatSurrender);
  if ( a1 )
  {
    memcpy((void *)a4, a1, 0xFu);
    BaseFree(a1, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518BF4 + 113);
  }
  if ( v15 )
  {
    memcpy((void *)a7, v15, 0xFu);
    BaseFree(v15, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518BF4 + 119);
  }
  if ( v19 )
  {
    memcpy((void *)a5, v19, 0x64u);
    BaseFree(v19, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518BF4 + 125);
  }
  if ( v17 )
  {
    memcpy((void *)a6, v17, 0xFAu);
    BaseFree(v17, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518BF4 + 131);
  }
  if ( v18 )
  {
    memcpy((void *)a3, v18, 0xFAu);
    BaseFree(v18, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518BF4 + 137);
  }
  gpCombatManager->winningSide = v23;
LABEL_41:
  if ( a3 )
    hero::CheckLevel((hero *)a3);
  if ( a6 )
    hero::CheckLevel((hero *)a6);
  if ( a11 )
  {
    switch ( gpCombatManager->winningSide + 1 )
    {
      case 1:
        if ( !gbRetreatWin )
          advManager::TransferArtifacts(a6, a3);
        advManager::HeroLoses((int)thisa, a6);
        break;
      case 2:
        if ( !gbRetreatWin )
          advManager::TransferArtifacts(a3, a6);
        advManager::HeroLoses((int)thisa, a3);
        break;
      case 0:
        advManager::HeroLoses((int)thisa, a3);
        advManager::HeroLoses((int)thisa, a6);
        break;
      case 4:
        break;
    }
  }
  bShowIt = v24;
  giCurPlayer = v26;
  if ( gbHumanPlayer[v26] )
  {
    SetNoDialogMenus(1);
  }
  else
  {
    game::ShowComputerScreen();
    game::TurnOnAIMusic();
    SetNoDialogMenus(0);
  }
  advManager::MobilizeCurrHero((advManager *)thisa, 0);
  if ( a11 )
    gbRetreatWin = 0;
  dword_4F7474 = 0;
  while ( gpMouseManager->cursorDisabled )
    mouseManager::ShowColorPointer(gpMouseManager);
  return gpCombatManager->winningSide;
}
// 4F21F0: using guessed type int giDebugLevel;
// 4F7474: using guessed type int dword_4F7474;
// 4F7490: using guessed type int gAdvDisposeLevel;
// 4F74AC: using guessed type int giHighMemBuffer;
// 518BF4: using guessed type __int16 word_518BF4;
// 523434: using guessed type int dword_523434;
// 523450: using guessed type char gbCombatSurrender;
// 524210: using guessed type char gbRetreatWin;
// 524C14: using guessed type int bShowIt;

//----- (00493F00) --------------------------------------------------------
void __stdcall advManager::SendHeroTownData(char a1, char a2, int a3, const void *a4, const void *a5, int a6, const void *a7, char a8, char a9, int a10, int a11, char a12, char a13, char a14)
{
  LPVOID a1a; // [sp+10h] [bp-Ch]@1
  int v15; // [sp+14h] [bp-8h]@1
  int v16; // [sp+18h] [bp-4h]@24

  a1a = BaseAlloc(0xFFu, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CBC + 3);
  v15 = 0;
  *(_BYTE *)a1a = 0;
  *((_BYTE *)a1a + 1) = a1;
  *((_BYTE *)a1a + 2) = a2;
  if ( a3 )
    *((_BYTE *)a1a + 3) = 1;
  else
    *((_BYTE *)a1a + 3) = 0;
  if ( a5 )
    *((_BYTE *)a1a + 4) = 1;
  else
    *((_BYTE *)a1a + 4) = 0;
  if ( a6 )
    *((_BYTE *)a1a + 5) = 1;
  else
    *((_BYTE *)a1a + 5) = 0;
  *((_BYTE *)a1a + 6) = a8;
  *((_BYTE *)a1a + 7) = a9;
  *((_DWORD *)a1a + 2) = a10;
  *((_BYTE *)a1a + 12) = a12;
  *((_BYTE *)a1a + 13) = a13;
  *((_BYTE *)a1a + 14) = a14;
  if ( a3 )
    *((_BYTE *)a1a + 15) = *(_BYTE *)(a3 + 3);
  else
    *((_BYTE *)a1a + 15) = -1;
  if ( a3 )
    *((_DWORD *)a1a + 4) = gpGame->players[*(_BYTE *)(a3 + 3)].resources[6];
  else
    *((_DWORD *)a1a + 4) = 0;
  if ( a6 )
    *((_BYTE *)a1a + 20) = *(_BYTE *)(a6 + 3);
  else
    *((_BYTE *)a1a + 20) = -1;
  if ( a6 )
    *(_DWORD *)((char *)a1a + 21) = gpGame->players[*(_BYTE *)(a6 + 3)].resources[6];
  else
    *(_DWORD *)((char *)a1a + 21) = 0;
  memcpy((char *)a1a + 25, a4, 0xFu);
  memcpy((char *)a1a + 40, a7, 0xFu);
  if ( a5 )
    memcpy((char *)a1a + 55, a5, 0x64u);
  v16 = TransmitAndWait(a1a, a11, 0x9Bu, 21, 22, (int)&v15);
  if ( !v16 )
    ShutDown(0);
  if ( a3 )
  {
    *(_BYTE *)a1a = 1;
    memcpy((char *)a1a + 1, (const void *)a3, 0xC8u);
    v16 = TransmitRemoteData(a1a, a11, 0xC9u, 21, 1, 1, -1);
    if ( !v16 )
      ShutDown(0);
    *(_BYTE *)a1a = 2;
    memcpy((char *)a1a + 1, (const void *)(a3 + 200), 0x32u);
    v16 = TransmitRemoteData(a1a, a11, 0x33u, 21, 1, 1, -1);
    if ( !v16 )
      ShutDown(0);
  }
  if ( a6 )
  {
    *(_BYTE *)a1a = 3;
    memcpy((char *)a1a + 1, (const void *)a6, 0xC8u);
    v16 = TransmitRemoteData(a1a, a11, 0xC9u, 21, 1, 1, -1);
    if ( !v16 )
      ShutDown(0);
    *(_BYTE *)a1a = 4;
    memcpy((char *)a1a + 1, (const void *)(a6 + 200), 0x32u);
    v16 = TransmitRemoteData(a1a, a11, 0x33u, 21, 1, 1, -1);
    if ( !v16 )
      ShutDown(0);
  }
  BaseFree(a1a, (int)"F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CBC + 92);
}
// 518CBC: using guessed type __int16 word_518CBC;

//----- (00494270) --------------------------------------------------------
void *__stdcall advManager::ReceiveHeroTownData(int a1, int a2, int a3, int a4, void **a5, void **a6, void **a7, void **a8, void **a9, int a10, int a11, int a12, int a13, int a14, int a15)
{
  void *result; // eax@9
  int v16; // edx@17
  int v17; // [sp+10h] [bp-2Ch]@9
  int v18; // [sp+14h] [bp-28h]@3
  signed int v19; // [sp+18h] [bp-24h]@9
  int v20; // [sp+1Ch] [bp-20h]@1
  signed int v21; // [sp+20h] [bp-1Ch]@9
  int v22; // [sp+28h] [bp-14h]@1
  signed int v23; // [sp+2Ch] [bp-10h]@9
  int v24; // [sp+30h] [bp-Ch]@1
  signed int v25; // [sp+34h] [bp-8h]@9
  int v26; // [sp+38h] [bp-4h]@1
  void *v27; // [sp+44h] [bp+8h]@21

  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  *a9 = 0;
  *(_DWORD *)a2 = *(_BYTE *)a1;
  *(_DWORD *)a3 = *(_BYTE *)(a1 + 10);
  *(_DWORD *)a4 = *(_BYTE *)(a1 + 11);
  v26 = *(_BYTE *)(a1 + 12);
  v22 = *(_BYTE *)(a1 + 13);
  v20 = *(_BYTE *)(a1 + 14);
  *(_DWORD *)a10 = *(_BYTE *)(a1 + 15);
  *(_DWORD *)a11 = *(_BYTE *)(a1 + 16);
  *(_DWORD *)a12 = *(_DWORD *)(a1 + 17);
  *(_BYTE *)a13 = *(_BYTE *)(a1 + 21);
  *(_BYTE *)a14 = *(_BYTE *)(a1 + 22);
  *(_BYTE *)a15 = *(_BYTE *)(a1 + 23);
  v24 = *(_BYTE *)(a1 + 24);
  if ( v24 > 0 )
    gpGame->players[v24].resources[6] = *(_DWORD *)(a1 + 25);
  v18 = *(_BYTE *)(a1 + 29);
  if ( v18 > 0 )
    gpGame->players[v18].resources[6] = *(_DWORD *)(a1 + 30);
  *a6 = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CF8 + 38);
  memcpy(*a6, (const void *)(a1 + 34), 0xFu);
  *a9 = BaseAlloc(0xFu, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CF8 + 41);
  memcpy(*a9, (const void *)(a1 + 49), 0xFu);
  if ( v22 )
  {
    *a7 = BaseAlloc(0x64u, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CF8 + 46);
    memcpy(*a7, (const void *)(a1 + 64), 0x64u);
  }
  iCombatControlNetPos = *(_DWORD *)a2;
  dword_523434 = giThisNetPos;
  if ( !TransmitRemoteData(0, *(_DWORD *)a2, 0, 22, 1, 1, -1) )
    ShutDown(0);
  result = (void *)KBTickCount();
  v17 = (int)result;
  v19 = 1;
  v23 = 1;
  v25 = 1;
  v21 = 1;
  if ( v26 )
  {
    result = BaseAlloc(0xFAu, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CF8 + 71);
    *a5 = result;
    v19 = 0;
    v23 = 0;
  }
  if ( v20 )
  {
    result = BaseAlloc(0xFAu, "F:\\h2xsrc\\Source\\EVENTS.CPP", word_518CF8 + 77);
    *a8 = result;
    v25 = 0;
    v21 = 0;
  }
  while ( !v19 || !v23 || !v25 || !v21 )
  {
    PollSound();
    if ( KBTickCount() > v17 + 90000 )
    {
      NormalDialog("Error receiving data.  Keep trying?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
      if ( gpWindowManager->buttonPressedCode == 30725 )
        v17 = KBTickCount();
      else
        ShutDown("Game canceled.");
    }
    result = GetRemoteData(1, v16);
    v27 = result;
    if ( result )
    {
      result = (void *)*((_BYTE *)result + 5);
      if ( result == (void *)2 )
      {
        result = (void *)*((_BYTE *)v27 + 6);
        if ( result == (void *)21 )
        {
          v17 = KBTickCount();
          if ( *((_BYTE *)v27 + 9) == 1 )
          {
            memcpy(*a5, (char *)v27 + 10, 0xC8u);
            v19 = 1;
          }
          if ( *((_BYTE *)v27 + 9) == 2 )
          {
            memcpy((char *)*a5 + 200, (char *)v27 + 10, 0x32u);
            v23 = 1;
          }
          if ( *((_BYTE *)v27 + 9) == 3 )
          {
            memcpy(*a8, (char *)v27 + 10, 0xC8u);
            v25 = 1;
          }
          result = (void *)*((_BYTE *)v27 + 9);
          if ( result == (void *)4 )
          {
            result = memcpy((char *)*a8 + 200, (char *)v27 + 10, 0x32u);
            v21 = 1;
          }
        }
      }
    }
  }
  return result;
}
// 518CF8: using guessed type __int16 word_518CF8;
// 523434: using guessed type int dword_523434;

//----- (004946E0) --------------------------------------------------------
int __thiscall advManager::AutoResolveCombat(void *this, __int64 a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  void *thisa; // [sp+10h] [bp-24h]@1
  int v13; // [sp+14h] [bp-20h]@1
  tag_message v14; // [sp+18h] [bp-1Ch]@1

  thisa = this;
  gbNoShowCombat = 1;
  v13 = bShowIt;
  bShowIt = 0;
  mouseManager::SetPointer(gpMouseManager, 0);
  gpMouseManager->field_7E = 1;
  v14.eventCode = 0;
  advManager::DemobilizeCurrHero((advManager *)thisa);
  combatManager::SetupCombat(gpCombatManager, a2, a3, a4, a5, a6, a7, a2, SHIDWORD(a2), a10);
  combatManager::InitNonVisualVars(gpCombatManager);
  gpCombatManager->field_F2B3 = 1;
  while ( !gpCombatManager->field_F357 )
    ((void (__thiscall *)(baseManager *, tag_message *))gpCombatManager->vtable->Main)(
      (baseManager *)gpCombatManager,
      &v14);
  gbNoShowCombat = 0;
  if ( a3 )
    hero::CheckLevel((hero *)a3);
  if ( a6 )
    hero::CheckLevel((hero *)a6);
  if ( a11 )
  {
    switch ( gpCombatManager->winningSide + 1 )
    {
      case 1:
        if ( !gbRetreatWin )
          advManager::TransferArtifacts(a6, a3);
        advManager::HeroLoses((int)thisa, a6);
        break;
      case 2:
        if ( !gbRetreatWin )
          advManager::TransferArtifacts(a3, a6);
        advManager::HeroLoses((int)thisa, a3);
        break;
      case 0:
        advManager::HeroLoses((int)thisa, a3);
        advManager::HeroLoses((int)thisa, a6);
        break;
      case 4:
        break;
    }
  }
  bShowIt = v13;
  if ( gbHumanPlayer[giCurPlayer] )
  {
    SetNoDialogMenus(1);
  }
  else
  {
    game::ShowComputerScreen();
    game::TurnOnAIMusic();
    SetNoDialogMenus(0);
  }
  advManager::MobilizeCurrHero((advManager *)thisa, 0);
  if ( a11 )
    gbRetreatWin = 0;
  dword_4F7474 = 0;
  gpMouseManager->field_7E = 0;
  return gpCombatManager->winningSide;
}
// 4F7474: using guessed type int dword_4F7474;
// 518CFC: using guessed type int gbNoShowCombat;
// 524210: using guessed type char gbRetreatWin;
// 524C14: using guessed type int bShowIt;

//----- (00494940) --------------------------------------------------------
bool __fastcall RiddleStringsEqual(const char *a1, const char *a2)
{
  int v2; // eax@6
  const char *v4; // [sp+10h] [bp-1Ch]@1
  signed int i; // [sp+18h] [bp-14h]@1
  char a1a; // [sp+1Ch] [bp-10h]@1
  char v7[3]; // [sp+1Dh] [bp-Fh]@4
  char v8; // [sp+20h] [bp-Ch]@1
  char a2a[8]; // [sp+24h] [bp-8h]@6

  v4 = a1;
  strncpy(&a1a, a2, 4u);
  v8 = 0;
  for ( i = 3; i >= 0; --i )
  {
    if ( *(&a1a + i) != 32 )
    {
      v7[i] = 0;
      break;
    }
  }
  strncpy(a2a, v4, 4u);
  a2a[strlen(&a1a)] = 0;
  LOBYTE(v2) = stricmp(&a1a, a2a);
  return v2 == 0;
}
// 494940: using guessed type char var_F[3];
// 494940: using guessed type char a2[8];

//----- (00494A00) --------------------------------------------------------
hero *__thiscall hero::hero(hero *this)
{
  armyGroup::armyGroup(&this->army);
  this->idx = 0;
  this->ownerIdx = 0;
  this->x = 0;
  this->y = 0;
  this->factionID = 0;
  this->heroID = 0;
  this->name[0] = 0;
  heroWin = 0;
  giHeroScreenSrcIndex = -1;
  return this;
}
// 523428: using guessed type int giHeroScreenSrcIndex;

//----- (00494A70) --------------------------------------------------------
signed int __thiscall hero::Read(hero *this, int fd, char expansion)
{
  signed int result; // eax@2

  if ( expansion )
    result = _read(fd, this, 250u);
  else
    result = _read(fd, this, 236u);
  return result;
}

//----- (00494AD0) --------------------------------------------------------
void __thiscall hero::Write(hero *this, int fd, signed __int8 expansion)
{
  if ( expansion )
    _write(fd, this, sizeof(hero));
  else
    _write(fd, this, offsetof(hero, scrollSpell));
}

//----- (00494B30) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
void __stdcall sub_494B30(int a1)
{
  ;
}

//----- (00494B50) --------------------------------------------------------
int __thiscall hero::HasArtifact(hero *this, int artifact)
{
  int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < MAX_ARTIFACTS; ++i )
  {
    if ( this->artifacts[i] == artifact )
      return 1;
  }
  return 0;
}

//----- (00494BB0) --------------------------------------------------------
int __thiscall hero::CalcMobility(hero *this)
{
  signed int minSpeed; // [sp+18h] [bp-34h]@7
  __int16 speedToMovementPoints[9]; // [sp+1Ch] [bp-30h]@1
  int i; // [sp+30h] [bp-1Ch]@7
  __int16 v6; // [sp+34h] [bp-18h]@1
  __int16 v7; // [sp+38h] [bp-14h]@1
  __int16 v8; // [sp+3Ch] [bp-10h]@1
  __int16 v9; // [sp+40h] [bp-Ch]@1
  int points; // [sp+44h] [bp-8h]@2
  __int16 v11; // [sp+48h] [bp-4h]@1

  speedToMovementPoints[0] = 1000;
  speedToMovementPoints[1] = 1000;
  speedToMovementPoints[2] = 1000;
  speedToMovementPoints[3] = 1100;
  speedToMovementPoints[4] = 1200;
  speedToMovementPoints[5] = 1300;
  speedToMovementPoints[6] = 1400;
  speedToMovementPoints[7] = 1500;
  speedToMovementPoints[8] = 1500;
  v8 = 500;
  v9 = 1000;
  v11 = 500;
  v7 = 600;
  v6 = 300;
  if ( this->flags & 0x80 )
  {
    points = 1500;
    points = (signed __int64)((double)1500 * gfSSNavigationMod[this->secondarySkillLevel[5]]);
    if ( this->ownerIdx != -1 )
      points += 500 * game::MineTypesOwned(gpGame, this->ownerIdx, 100);
    if ( hero::HasArtifact(this, 40) )
      points += 1000;
  }
  else
  {
    minSpeed = 7;
    for ( i = 0; i < 5; ++i )
    {
      if ( this->army.creatureTypes[i] != -1 && gMonsterDatabase[this->army.creatureTypes[i]].speed < minSpeed )
        minSpeed = gMonsterDatabase[this->army.creatureTypes[i]].speed;
    }
    points = speedToMovementPoints[minSpeed];
    points = (signed __int64)((double)points * gfSSLogisticsMod[this->secondarySkillLevel[2]]);
    if ( hero::HasArtifact(this, 33) )
      points += 600;
    if ( hero::HasArtifact(this, 34) )
      points += 300;
    if ( BYTE2(this->flags) & 0x80 )
      points += 400;
  }
  if ( hero::HasArtifact(this, ARTIFACT_TRUE_COMPASS_OF_MOBILITY) )
    points += 500;
  if ( this->ownerIdx >= 0 )
  {
    if ( this->ownerIdx < 6 )
    {
      if ( !gbHumanPlayer[this->ownerIdx] )
      {
        if ( gpGame->difficulty >= 2 )
        {
          points += 75;
          if ( gpGame->players[this->ownerIdx].personality == 2 )
            points += 50;
        }
      }
    }
  }
  return points;
}

//----- (00494E30) --------------------------------------------------------
int __thiscall hero::HasSpell(hero *this, int spell)
{
  int result; // eax@2
  int i; // [sp+10h] [bp-4h]@5

  if ( hero::HasArtifact(this, ARTIFACT_MAGIC_BOOK) )
  {
    if ( this->spellsLearned[spell] )
    {
      result = 1;
    }
    else
    {
      for ( i = 0; i < MAX_ARTIFACTS; ++i )
      {
        if ( this->artifacts[i] == ARTIFACT_SPELL_SCROLL && this->scrollSpell[i] == spell )
          return 1;
      }
      result = hero::HasArtifact(this, ARTIFACT_BATTLE_GARB_OF_ANDURAN) && spell == SPELL_TOWN_PORTAL;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00494F00) --------------------------------------------------------
int __thiscall hero::GetNthSpell(hero *this, int type, int n)
{
  int i; // [sp+10h] [bp-8h]@1
  int nSeen; // [sp+14h] [bp-4h]@1

  nSeen = 0;
  for ( i = 0; i < NUM_SPELLS; ++i )
  {
    if ( hero::HasSpell(this, i) )
    {
      if ( type == ATTR_COMBAT_SPELL
        || !type && gsSpellInfo[i].attributes & ATTR_COMBAT_SPELL
        || type == SPELL_CATEGORY_ADVENTURE && !(gsSpellInfo[i].attributes & ATTR_COMBAT_SPELL) )
        ++nSeen;
      if ( n == nSeen )
        return i;
    }
  }
  return SPELL_NONE;
}

//----- (00494FD0) --------------------------------------------------------
int __thiscall hero::GetNumSpells(hero *this, int type)
{
  int result; // eax@9
  int numCombat; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  int numAdventure; // [sp+1Ch] [bp-4h]@1

  numCombat = 0;
  numAdventure = 0;
  for ( i = 0; i < NUM_SPELLS; ++i )
  {
    if ( hero::HasSpell(this, i) )
    {
      if ( gsSpellInfo[i].attributes & ATTR_COMBAT_SPELL )
        ++numCombat;
      else
        ++numAdventure;
    }
  }
  if ( type )
  {
    if ( type == SPELL_CATEGORY_ADVENTURE )
    {
      result = numAdventure;
    }
    else if ( type == SPELL_CATEGORY_ALL )
    {
      result = numAdventure + numCombat;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = numCombat;
  }
  return result;
}

//----- (004950A0) --------------------------------------------------------
void __thiscall hero::UseSpell(hero *this, int spell)
{
  if ( spell != -1 )
  {
    this->spellpoints -= GetManaCost(spell, this);
    if ( this->spellpoints < 0 )
      this->spellpoints = 0;
    if ( gpAdvManager->ready == 1 )
    {
      if ( gbThisNetHumanPlayer[giCurPlayer] )
        advManager::UpdateHeroLocator(gpAdvManager, -1, 1, 1);
    }
  }
}

//----- (00495130) --------------------------------------------------------
void __thiscall hero::AddSpell(hero *this, int spell, int knowledge)
{
  this->spellsLearned[spell] = 1;
}

//----- (00495160) --------------------------------------------------------
void __thiscall HeroMessageUpdate(char *this)
{
  Event evt; // [sp+10h] [bp-1Ch]@2

  if ( gheroWin )
  {
    *(_QWORD *)&evt.guiMsg.eventCode = INPUT_GUI_MESSAGE_CODE;
    evt.guiMsg.fieldID = 303;
    evt.guiMsg.payload = this;
    heroWindow::BroadcastMessage(gheroWin, &evt.inputEvt);
    heroWindow::DrawWindow(gheroWin, 0, 300, 303);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 459, 0x280u, 20);
  }
}

//----- (004951F0) --------------------------------------------------------
void __thiscall hero::HeroScreenUpdate(hero *this)
{
  int evt; // [sp+10h] [bp-20h]@1
  int v2; // [sp+14h] [bp-1Ch]@4
  int v3; // [sp+18h] [bp-18h]@6
  int v4; // [sp+28h] [bp-8h]@6
  int i; // [sp+2Ch] [bp-4h]@1

  evt = 512;
  hero::UpdateArmies(this);
  for ( i = 0; i < 5; ++i )
  {
    if ( giHeroScreenSrcIndex == i )
      v2 = 5;
    else
      v2 = 6;
    v4 = 4;
    v3 = i + 102;
    heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
  }
  heroWindow::DrawWindow(heroWin);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 0x280u, 480);
}
// 523428: using guessed type int giHeroScreenSrcIndex;

//----- (004952A0) --------------------------------------------------------
int __thiscall hero::UpdateArmies(hero *this)
{
  int result; // eax@4
  hero *v2; // [sp+Ch] [bp-24h]@1
  int evt; // [sp+10h] [bp-20h]@1
  int v4; // [sp+14h] [bp-1Ch]@4
  int v5; // [sp+18h] [bp-18h]@4
  int v6; // [sp+28h] [bp-8h]@4
  int i; // [sp+2Ch] [bp-4h]@1

  v2 = this;
  evt = 512;
  for ( i = 0; i < 5; ++i )
  {
    if ( v2->army.creatureTypes[i] == -1 )
    {
      v4 = 4;
      v5 = i + 87;
      v6 = 2;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v4 = 6;
      v5 = i + 92;
      v6 = 4;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v5 = i + 97;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v5 = i + 102;
      result = heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
    }
    else
    {
      v4 = 4;
      v5 = i + 87;
      v6 = gMonsterDatabase[v2->army.creatureTypes[i]].faction + 4;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v4 = 9;
      sprintf(gText, "monh%04d.icn", v2->army.creatureTypes[i]);
      v5 = i + 92;
      v6 = (int)gText;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v4 = 5;
      v6 = 4;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      sprintf(gText, "%d", v2->army.quantities[i]);
      v4 = 3;
      v5 = i + 97;
      v6 = (int)gText;
      heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
      v4 = 5;
      v6 = 4;
      result = heroWindow::BroadcastMessage(heroWin, (tag_message *)&evt);
    }
  }
  return result;
}

//----- (00495480) --------------------------------------------------------
void __thiscall hero::ViewStat(hero *hro, int skill, int a2)
{
  NormalDialog(gStatDesc[skill], (unsigned int)a2 < 1 ? 1 : 4, -1, -1, -1, 0, -1, 0, -1, 0);
}

//----- (004954D0) --------------------------------------------------------
heroWindow *__stdcall hero::ViewArtifact(int art, unsigned int a2, int spell)
{
  heroWindow *result; // eax@2

  if ( art == ARTIFACT_SPELL_SCROLL )
  {
    sprintf(gText, gArtifactDesc[86], gSpellNames[spell]);
    result = NormalDialog(gText, a2 < 1 ? 1 : 4, -1, 28, -1, 0, -1, 0, -1, 0);
  }
  else
  {
    result = NormalDialog(gArtifactDesc[art], a2 < 1 ? 1 : 4, -1, 28, -1, 0, -1, 0, -1, 0);
  }
  return result;
}

//----- (00495570) --------------------------------------------------------
signed int __thiscall hero::Dismiss(hero *this)
{
  signed int result; // eax@2
  hero *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  NormalDialog(byte_518DDC, 2, -1, -1, -1, 0, -1, 0, -1, 0);
  if ( gpWindowManager->buttonPressedCode == 30725 )
  {
    hero::Deallocate(thisa, 1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004955D0) --------------------------------------------------------
void __thiscall hero::Deallocate(hero *this, int a2)
{
  mapCell *v2; // eax@33
  int v4; // [sp+14h] [bp-18h]@37
  playerData *player; // [sp+1Ch] [bp-10h]@3
  signed int v6; // [sp+20h] [bp-Ch]@23
  HERO_CONSTANTS idx; // [sp+24h] [bp-8h]@8
  int idxa; // [sp+24h] [bp-8h]@20
  signed int idxb; // [sp+24h] [bp-8h]@23
  int idxc; // [sp+24h] [bp-8h]@28
  int v11; // [sp+28h] [bp-4h]@3

  if ( a2 )
    SendMapChange(6, this->idx, this->x, this->y, -999, 0, 0);
  v11 = this->ownerIdx;
  player = &gpGame->players[this->ownerIdx];
  if ( a2 )
    advManager::MobilizeCurrHero(gpAdvManager, 0);
  if ( a2 )
    advManager::HideRoute(gpAdvManager, 0, 0, 0);
  if ( this->flags & HERO_AT_SEA )
  {
    for ( idx = 0; idx < MAX_TOTAL_HEROES; ++idx )
    {
      if ( gpGame->boats[idx].field_6 == this->idx )
      {
        gpGame->boats[idx].field_6 = -1;
        gpGame->boatBuilt[idx] = -1;
      }
    }
  }
  if ( this->occupiedObjType == 163 )
    gpGame->castles[this->occupiedObjVal].visitingHeroIdx = -1;
  if ( this->ownerIdx != giCurPlayer
    || gpGame->players[this->ownerIdx].curHeroIdx != this->idx
    || !gpAdvManager->heroMobilized )
    game::RestoreCell(this->x, this->y, this->occupiedObjType, this->occupiedObjVal, 0, 1);
  if ( !gbCombatSurrender )
  {
    for ( idxa = 0; idxa < 5; ++idxa )
      armyGroup::Dismiss(&this->army, idxa);
  }
  v6 = -1;
  for ( idxb = 0; player->numHeroes > idxb; ++idxb )
  {
    if ( player->heroesOwned[idxb] == this->idx )
      v6 = idxb;
  }
  for ( idxc = v6; player->numHeroes - 1 > idxc; ++idxc )
    player->heroesOwned[idxc] = player->heroesOwned[idxc + 1];
  *(&player->field_3 + player->numHeroes) = -1;
  if ( player->curHeroIdx == this->idx )
  {
    player->curHeroIdx = -1;
    if ( this->ownerIdx == giCurPlayer )
    {
      gpAdvManager->field_272 = 0;
      v2 = &gpGame->map.tiles[this->x] + this->y * gpGame->map.width;
      v2->displayFlags &= 0xBFu;
    }
    if ( giCurPlayer == v11 )
      gpAdvManager->heroMobilized = 0;
  }
  --player->numHeroes;
  player->field_3 = 0;
  gpGame->relatedToHeroForHireStatus[this->idx] = -1;
  if ( gbRetreatWin )
  {
    v4 = Random(0, 1);
    if ( BYTE2(gpGame->heroes[gpGame->players[this->ownerIdx].heroesForPurchase[v4]].flags) & 1 )
      v4 = 1 - v4;
    if ( gpGame->relatedToHeroForHireStatus[gpGame->players[this->ownerIdx].heroesForPurchase[v4]] == 64 )
      gpGame->relatedToHeroForHireStatus[gpGame->players[this->ownerIdx].heroesForPurchase[v4]] = -1;
    gpGame->players[this->ownerIdx].heroesForPurchase[v4] = this->idx;
    gpGame->relatedToHeroForHireStatus[this->idx] = 64;
    this->flags |= 0x10000u;
  }
  this->flags &= 0xFFFF7FFFu;
  this->ownerIdx = -1;
  *(_DWORD *)&this->field_25 = -1;
  *(_DWORD *)&this->field_21 = *(_DWORD *)&this->field_25;
  if ( !gbCombatSurrender )
    game::SetRandomHeroArmies(gpGame, this->idx, 0);
  if ( gbInCampaign
    && this->heroID == 55
    && !gpGame->field_2
    && gpGame->field_4 == 8
    && !gbRetreatWin
    && !gbCombatSurrender )
    gpGame->field_82 = 1;
  if ( a2 )
    CheckEndGame(0, 0);
}
// 523450: using guessed type char gbCombatSurrender;
// 524210: using guessed type char gbRetreatWin;

//----- (00495B60) --------------------------------------------------------
int __stdcall hero::GetExperience(signed int level)
{
  int result; // eax@2
  signed int v2; // [sp+18h] [bp-Ch]@3
  int exp; // [sp+1Ch] [bp-8h]@3
  signed int v4; // [sp+20h] [bp-4h]@3

  if ( level > 12 )
  {
    v2 = 13;
    v4 = (signed __int64)((double)((signed int)experienceForLevelTable[12] - (signed int)experienceForLevelTable[11])
                        * 1.2);
    exp = v4 + experienceForLevelTable[12];
    while ( v2 < level )
    {
      v4 = (signed __int64)((double)v4 * 1.2);
      exp += v4;
      ++v2;
    }
    result = exp;
  }
  else
  {
    result = experienceForLevelTable[level];
  }
  return result;
}

//----- (00495C00) --------------------------------------------------------
int __stdcall hero::GetLevel(signed int a1)
{
  signed int i; // [sp+18h] [bp-Ch]@1
  signed int nextLevel; // [sp+18h] [bp-Ch]@6
  signed int v4; // [sp+1Ch] [bp-8h]@6
  signed int v5; // [sp+20h] [bp-4h]@6

  for ( i = 1; i <= 12; ++i )
  {
    if ( experienceForLevelTable[i] > a1 )
      return i - 1;
  }
  v5 = (signed __int64)((double)((signed int)experienceForLevelTable[12] - (signed int)experienceForLevelTable[11]) * 1.2);
  v4 = v5 + experienceForLevelTable[12];
  nextLevel = 13;
  while ( v4 < a1 )
  {
    v5 = (signed __int64)((double)v5 * 1.2);
    v4 += v5;
    ++nextLevel;
  }
  return nextLevel - 1;
}

//----- (00495CC0) --------------------------------------------------------
int __thiscall hero::ApplyBattleWinTemps(hero *this)
{
  int result; // eax@23

  *(_WORD *)&this->field_7 = -99;
  *(_WORD *)&this->field_4 = -99;
  if ( this->flags & 0x20 )
  {
    ++this->tempMoraleBonuses;
    this->flags -= 32;
  }
  if ( this->flags & 0x40 )
  {
    ++this->tempMoraleBonuses;
    this->flags -= 64;
  }
  if ( this->flags & 2 )
  {
    --this->tempMoraleBonuses;
    this->flags -= 2;
  }
  if ( this->flags & 8 )
  {
    --this->tempMoraleBonuses;
    this->flags -= 8;
  }
  if ( BYTE1(this->flags) & 1 )
  {
    this->tempMoraleBonuses -= 2;
    this->flags -= 256;
  }
  if ( this->flags & 0x10 )
  {
    --this->tempLuckBonuses;
    this->flags -= 16;
  }
  if ( BYTE1(this->flags) & 0x20 )
  {
    --this->tempLuckBonuses;
    this->flags -= 8192;
  }
  if ( this->flags & 4 )
  {
    --this->tempLuckBonuses;
    this->flags -= 4;
  }
  if ( BYTE1(this->flags) & 2 )
  {
    --this->tempMoraleBonuses;
    this->flags -= 512;
  }
  if ( BYTE1(this->flags) & 4 )
  {
    ++this->tempMoraleBonuses;
    this->flags -= 1024;
  }
  if ( BYTE1(this->flags) & 0x40 )
  {
    this->tempLuckBonuses += 2;
    this->flags -= 16384;
  }
  result = (int)this;
  if ( BYTE2(this->flags) & 0x10 )
  {
    --this->tempLuckBonuses;
    result = this->flags - 1048576;
    this->flags = result;
  }
  return result;
}

//----- (00495F20) --------------------------------------------------------
int __thiscall hero::ApplyBattleLossTemps(hero *this)
{
  return hero::ApplyBattleWinTemps(this);
}

//----- (00495F40) --------------------------------------------------------
void __thiscall hero::CheckLevel(hero *this)
{
  int nextSkill; // [sp+18h] [bp-10Ch]@25
  signed int tries; // [sp+1Ch] [bp-108h]@25
  signed int randNum; // [sp+20h] [bp-104h]@4
  int randNuma; // [sp+20h] [bp-104h]@6
  int v6; // [sp+24h] [bp-100h]@25
  char a2; // [sp+28h] [bp-FCh]@4
  int secSkillOptions[2]; // [sp+F0h] [bp-34h]@19
  bool lvl10Plus; // [sp+F8h] [bp-2Ch]@4
  int j; // [sp+FCh] [bp-28h]@11
  int newLevel; // [sp+100h] [bp-24h]@1
  int levelsGained; // [sp+104h] [bp-20h]@2
  int i; // [sp+108h] [bp-1Ch]@2
  SAMPLE2 res; // [sp+10Ch] [bp-18h]@2
  int skillsLearned[4]; // [sp+114h] [bp-10h]@4

  newLevel = hero::GetLevel(this->experience);
  if ( this->oldLevel != newLevel )
  {
    res = NULL_SAMPLE2;
    levelsGained = newLevel - this->oldLevel;
    for ( i = this->oldLevel + 1; i <= newLevel; ++i )
    {
      sprintf(gText, cHeroLevel, this->name);
      sprintf(&a2, off_4F65E4);
      strcat(gText, &a2);
      skillsLearned[0] = 0;
      skillsLearned[1] = 0;
      skillsLearned[2] = 0;
      skillsLearned[3] = 0;
      lvl10Plus = i > 9;
      SRand(30 * i + this->randomSeed);
      randNum = SRandom(1, 100);
      if ( gHeroSkillBonus[this->factionID][lvl10Plus][0] <= randNum )
      {
        randNuma = randNum - gHeroSkillBonus[this->factionID][lvl10Plus][0];
        if ( gHeroSkillBonus[this->factionID][lvl10Plus][1] <= randNuma )
        {
          if ( gHeroSkillBonus[this->factionID][lvl10Plus][2] <= randNuma
                                                               - gHeroSkillBonus[this->factionID][lvl10Plus][1] )
            ++skillsLearned[3];
          else
            ++skillsLearned[2];
        }
        else
        {
          ++skillsLearned[1];
        }
      }
      else
      {
        ++skillsLearned[0];
      }
      for ( j = 0; j < 4; ++j )
      {
        if ( skillsLearned[j] > 0 )
        {
          this->primarySkills[j] += LOBYTE(skillsLearned[j]);
          sprintf(&a2, "\n%s +%d", gStatNames[j], skillsLearned[j]);
          strcat(gText, &a2);
        }
      }
      for ( j = 0; j < 2; ++j )
      {
        secSkillOptions[j] = -1;
        if ( j
          || this->factionID == 1
          || !this->factionID
          || this->secondarySkillLevel[7] >= 3
          || i - this->wisdomLastOffered < 3 )
        {
          tries = 0;
          v6 = Random(0, 200);
          nextSkill = 0;
          while ( tries < 5000 )
          {
            ++tries;
            if ( (!j || secSkillOptions[0] != nextSkill)
              && (this->secondarySkillLevel[nextSkill] && this->secondarySkillLevel[nextSkill] < 3
               || !this->secondarySkillLevel[nextSkill] && this->numSecSkillsKnown < 8) )
            {
              v6 -= iGetSSByAlignment[nextSkill].skill_chances[this->factionID];
              if ( v6 <= 0 )
              {
                secSkillOptions[j] = nextSkill;
                break;
              }
            }
            nextSkill = (nextSkill + 1) % 14;
          }
        }
        else
        {
          secSkillOptions[j] = SECONDARY_SKILL_WISDOM;
        }
      }
      if ( secSkillOptions[0] == SECONDARY_SKILL_WISDOM || secSkillOptions[1] == SECONDARY_SKILL_WISDOM )
        this->wisdomLastOffered = i;
      if ( gbInNewGameSetup || this->ownerIdx < 0 || !gbThisNetHumanPlayer[this->ownerIdx] )
      {
        if ( secSkillOptions[0] != -1 )
        {
          if ( secSkillOptions[1] == -1 )
          {
            hero::GiveSS(this, secSkillOptions[0], 1);
          }
          else if ( gSSValues[3 * secSkillOptions[1]] >= gSSValues[3 * secSkillOptions[0]] )
          {
            hero::GiveSS(this, secSkillOptions[1], 1);
          }
          else
          {
            hero::GiveSS(this, secSkillOptions[0], 1);
          }
        }
      }
      else
      {
        res = (SAMPLE2)LoadPlaySample("nwherolv.82m");
        if ( secSkillOptions[0] == -1 )
        {
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        }
        else if ( secSkillOptions[1] == -1 )
        {
          sprintf(
            &a2,
            "\n\nYou have learned %s %s.",
            secondarySkillLevels[this->secondarySkillLevel[secSkillOptions[0]] + 1],
            gSecondarySkills[secSkillOptions[0]]);
          strcat(gText, &a2);
          NormalDialog(
            gText,
            1,
            -1,
            -1,
            17,
            3 * secSkillOptions[0] + this->secondarySkillLevel[secSkillOptions[0]],
            -1,
            0,
            -1,
            0);
          hero::GiveSS(this, secSkillOptions[0], 1);
        }
        else
        {
          sprintf(
            &a2,
            "\n\nYou may learn either %s %s or %s %s.",
            secondarySkillLevels[this->secondarySkillLevel[secSkillOptions[0]] + 1],
            gSecondarySkills[secSkillOptions[0]],
            secondarySkillLevels[this->secondarySkillLevel[secSkillOptions[1]] + 1],
            gSecondarySkills[secSkillOptions[1]]);
          strcat(gText, &a2);
          NormalDialog(
            gText,
            7,
            -1,
            -1,
            17,
            3 * secSkillOptions[0] + this->secondarySkillLevel[secSkillOptions[0]],
            17,
            3 * secSkillOptions[1] + this->secondarySkillLevel[secSkillOptions[1]],
            -1,
            0);
          if ( gpWindowManager->buttonPressedCode == 30727 )
            hero::GiveSS(this, secSkillOptions[0], 1);
          else
            hero::GiveSS(this, secSkillOptions[1], 1);
        }
      }
    }
    this->oldLevel = newLevel;
    WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
  }
}
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 523F1C: using guessed type int gbInNewGameSetup;

//----- (00496670) --------------------------------------------------------
int __thiscall hero::NumArtifacts(hero *this)
{
  HERO_CONSTANTS i; // [sp+10h] [bp-8h]@1
  int numArtifacts; // [sp+14h] [bp-4h]@1

  numArtifacts = 0;
  for ( i = 0; i < MAX_ARTIFACTS; ++i )
  {
    if ( this->artifacts[i] >= 0 )
      ++numArtifacts;
  }
  return numArtifacts;
}

//----- (004966D0) --------------------------------------------------------
void __thiscall UpdateHeroScreenStatusBar(tag_message *this)
{
  town *v1; // eax@4
  town *v2; // eax@6
  town *v3; // eax@10
  town *v4; // eax@12
  char *v5; // ST0C_4@59
  signed int v6; // eax@59
  int v7; // [sp+Ch] [bp-10h]@1
  int a2; // [sp+14h] [bp-8h]@51
  int v9; // [sp+18h] [bp-4h]@20

  v7 = this->yCoordOrFieldID;
  if ( v7 > 84 )
  {
    if ( v7 > 106 )
    {
      if ( v7 > 205 )
      {
        if ( v7 > 212 )
        {
          if ( v7 > 30720 )
          {
            if ( v7 != 30723 )
              goto LABEL_49;
            sprintf(gText, off_4F63B8, gpHVHero->name, gAlignmentNames[gpHVHero->factionID]);
          }
          else if ( v7 == 30720 )
          {
            strcpy(gText, off_4F63BC);
          }
          else if ( v7 == 214 )
          {
            sprintf(gText, off_4F63D4);
          }
          else
          {
            if ( v7 != 216 )
              goto LABEL_49;
            sprintf(gText, off_4F63D8);
          }
          goto LABEL_87;
        }
        if ( v7 >= 211 )
        {
          sprintf(gText, off_4F63D0);
          goto LABEL_87;
        }
        if ( v7 >= 206 && v7 <= 207 )
        {
          sprintf(gText, off_4F639C);
          goto LABEL_87;
        }
      }
      else
      {
        if ( v7 >= 203 )
        {
          v3 = hero::GetOccupiedTown(gpHVHero);
          if ( game::GetLuck(gpHVHero, 0, v3) <= 0 )
          {
            v4 = hero::GetOccupiedTown(gpHVHero);
            if ( game::GetLuck(gpHVHero, 0, v4) )
              sprintf(gText, off_4F6398);
            else
              sprintf(gText, off_4F6394);
          }
          else
          {
            sprintf(gText, off_4F6390);
          }
          goto LABEL_87;
        }
        if ( v7 >= 200 && v7 <= 202 )
        {
          v1 = hero::GetOccupiedTown(gpHVHero);
          if ( armyGroup::GetMorale(&gpHVHero->army, gpHVHero, v1, 0) <= 0 )
          {
            v2 = hero::GetOccupiedTown(gpHVHero);
            if ( armyGroup::GetMorale(&gpHVHero->army, gpHVHero, v2, 0) )
              sprintf(gText, off_4F638C);
            else
              sprintf(gText, off_4F6388);
          }
          else
          {
            sprintf(gText, off_4F6384);
          }
          goto LABEL_87;
        }
      }
LABEL_49:
      if ( this->yCoordOrFieldID < 400 || this->yCoordOrFieldID >= 408 )
      {
        if ( this->yCoordOrFieldID < 408 || this->yCoordOrFieldID >= 416 )
        {
          if ( this->yCoordOrFieldID < 416 || this->yCoordOrFieldID >= 424 )
            goto LABEL_60;
          a2 = this->yCoordOrFieldID - 416;
        }
        else
        {
          a2 = this->yCoordOrFieldID - 408;
        }
      }
      else
      {
        a2 = this->yCoordOrFieldID - 400;
      }
      if ( gpHVHero->numSecSkillsKnown > a2 )
      {
        v5 = gSecondarySkills[hero::GetNthSS(gpHVHero, a2)];
        v6 = hero::GetNthSS(gpHVHero, a2);
        sprintf(gText, off_4F63CC, secondarySkillLevels[gpHVHero->secondarySkillLevel[v6]], v5);
        goto LABEL_87;
      }
LABEL_60:
      strcpy(gText, off_4F63C0);
      goto LABEL_87;
    }
    if ( v7 >= 102 )
    {
      v9 = this->yCoordOrFieldID - 102;
      if ( giHeroScreenSrcIndex == -1 )
      {
        if ( gpHVHero->army.creatureTypes[v9] == -1 )
          strcpy(gText, off_4F63A4);
        else
          sprintf(gText, off_4F63A0, gArmyNames[gpHVHero->army.creatureTypes[v9]]);
      }
      else if ( giHeroScreenSrcIndex == v9 )
      {
        sprintf(gText, off_4F63A0, gArmyNames[gpHVHero->army.creatureTypes[v9]]);
      }
      else if ( gpTownManager->field_15A )
      {
        if ( gpHVHero->army.creatureTypes[v9] == -1 )
          strcpy(gText, off_4F63A4);
        else
          sprintf(gText, off_4F63A0, gArmyNames[gpHVHero->army.creatureTypes[v9]]);
      }
      else if ( gpHVHero->army.creatureTypes[v9] == -1 )
      {
        if ( this->inputTypeBitmask & 3 )
          sprintf(gText, off_4F63C8, gArmyNamesPlural[gpHVHero->army.creatureTypes[giHeroScreenSrcIndex]]);
        else
          sprintf(gText, off_4F63A8, gArmyNames[gpHVHero->army.creatureTypes[giHeroScreenSrcIndex]]);
      }
      else if ( gpHVHero->army.creatureTypes[v9] == gpHVHero->army.creatureTypes[giHeroScreenSrcIndex] )
      {
        sprintf(gText, off_4F63C4, gArmyNamesPlural[gpHVHero->army.creatureTypes[v9]]);
      }
      else
      {
        sprintf(
          gText,
          off_4F63AC,
          gArmyNames[gpHVHero->army.creatureTypes[giHeroScreenSrcIndex]],
          gArmyNames[gpHVHero->army.creatureTypes[v9]]);
      }
    }
    else
    {
      if ( v7 != 85 )
        goto LABEL_49;
      sprintf(gText, off_4F6380);
    }
  }
  else if ( v7 >= 81 )
  {
    sprintf(gText, off_4F637C, gStatNames[this->yCoordOrFieldID - 81]);
  }
  else
  {
    if ( v7 < 20 || v7 > 33 )
      goto LABEL_49;
    if ( gpHVHero->spellsLearned[this->yCoordOrFieldID + 45] == -1 )
    {
      sprintf(gText, off_4F63A4);
    }
    else if ( gpHVHero->spellsLearned[this->yCoordOrFieldID + 45] == 81 )
    {
      strcpy(gText, off_4F63B0);
    }
    else
    {
      sprintf(gText, off_4F63B4, gArtifactNames[gpHVHero->spellsLearned[this->yCoordOrFieldID + 45]]);
    }
  }
LABEL_87:
  HeroMessageUpdate(gText);
}
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 523428: using guessed type int giHeroScreenSrcIndex;

//----- (00496E30) --------------------------------------------------------
signed int __fastcall HeroHandler(tag_message *msg)
{
  signed int result; // eax@3
  char v2; // al@45
  int v3; // ST7C_4@46
  int v4; // ST2C_4@46
  __int16 v5; // ST94_2@76
  int v6; // eax@97
  int v7; // [sp+10h] [bp-5Ch]@18
  int v8; // [sp+14h] [bp-58h]@16
  int v9; // [sp+18h] [bp-54h]@11
  int v10; // [sp+1Ch] [bp-50h]@6
  int a7; // [sp+24h] [bp-48h]@59
  int v13; // [sp+54h] [bp-18h]@89
  int a13; // [sp+58h] [bp-14h]@47
  signed int v15; // [sp+60h] [bp-Ch]@1
  char v16; // [sp+64h] [bp-8h]@70
  bool a2; // [sp+68h] [bp-4h]@1

  v15 = 0;
  a2 = (BYTE1(msg->inputTypeBitmask) & 2) != 0;
  if ( msg->eventCode == INPUT_MOUSEMOVE_EVENT_CODE )
  {
    heroWindowManager::ConvertToHover(gpWindowManager, msg);
    if ( gpWindowManager->hoveredFieldID == msg->yCoordOrFieldID )
    {
      result = 1;
    }
    else
    {
      gpWindowManager->hoveredFieldID = msg->yCoordOrFieldID;
      UpdateHeroScreenStatusBar(msg);
      result = 1;
    }
    return result;
  }
  if ( msg->eventCode == INPUT_KEYUP_EVENT_CODE )
  {
    v10 = msg->xCoordOrKeycode;
    if ( v10 == 42 || v10 == 54 )
    {
      gpWindowManager->hoveredFieldID = -1;
      inputManager::ForceMouseMove();
    }
  }
  if ( msg->eventCode == 1 )
  {
    v9 = msg->xCoordOrKeycode;
    if ( v9 == 42 || v9 == 54 )
    {
      gpWindowManager->hoveredFieldID = -1;
      inputManager::ForceMouseMove();
    }
  }
  if ( msg->eventCode == 512 )
  {
    v8 = msg->xCoordOrKeycode;
    if ( v8 == 12 )
      goto LABEL_109;
    if ( v8 == 13 )
    {
      if ( !a2 )
      {
        v7 = msg->yCoordOrFieldID;
        if ( v7 > 30720 )
        {
          if ( v7 == 30723 && hero::Dismiss(gpHVHero) )
            v15 = 1;
        }
        else if ( v7 == 30720 )
        {
          v15 = 1;
        }
        else if ( v7 >= 300 && v7 <= 301 && gpHVHero->ownerIdx == giCurPlayer && gpCurPlayer->numHeroes > 1 )
        {
          gpHVHero = &gpGame->heroes[gpCurPlayer->heroesOwned[(game::HeroIDToHeroPos((int)gpCurPlayer, gpHVHero->idx)
                                                             + gpCurPlayer->numHeroes
                                                             + ((unsigned int)(msg->yCoordOrFieldID - 300) < 1 ? -1 : 1))
                                                            % gpCurPlayer->numHeroes]];
          SetupHeroView();
          RedrawHeroScreen();
        }
      }
      goto LABEL_104;
    }
    if ( v8 == 14 )
    {
LABEL_109:
      switch ( msg->yCoordOrFieldID )
      {
        case 0x51:
        case 0x52:
        case 0x53:
        case 0x54:
          hero::ViewStat(gpHVHero, msg->yCoordOrFieldID - 81, a2);
          break;
        case 0xC8:
        case 0xC9:
        case 0xCA:
          game::ShowMoraleInfo((int)gpHVHero, (unsigned int)a2 < 1 ? 1 : 4);
          break;
        case 0xCB:
        case 0xCC:
        case 0xCD:
          game::ShowLuckInfo((int)gpHVHero, (unsigned int)a2 < 1 ? 1 : 4);
          break;
        case 0xD6:
          if ( a2 )
          {
            NormalDialog(
              "{Spread Formation}\n\n'Spread' combat formation spreads your armies from the top to the bottom of the battlefield, with at least one empty space between each army.",
              4,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
          }
          else
          {
            gpHVHero->flags &= 0xFFFF7FFFu;
            SetupHeroView();
            RedrawHeroScreen();
          }
          break;
        case 0xD8:
          if ( a2 )
          {
            NormalDialog(
              "{Grouped Formation}\n\n'Grouped' combat formation bunches your army together in the center of your side of the battlefield.",
              4,
              -1,
              -1,
              -1,
              0,
              -1,
              0,
              -1,
              0);
          }
          else
          {
            gpHVHero->flags |= 0x8000u;
            SetupHeroView();
            RedrawHeroScreen();
          }
          break;
        case 0xD3:
        case 0xD4:
          v2 = hero::Stats(gpHVHero, PRIMARY_SKILL_KNOWLEDGE);
          sprintf(
            gText,
            "{Spell Points}\n\n%s currently has %d spell points out of a maximum of %d.  The maximum number of spell points is 10 times your knowledge.  It is occasionally possible to have more than your maximum spell points via special events.",
            gpHVHero->name,
            gpHVHero->spellpoints,
            10 * v2);
          NormalDialog(gText, (unsigned int)a2 < 1 ? 1 : 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 0xCE:
        case 0xCF:
          v3 = hero::GetLevel(gpHVHero->experience);
          v4 = hero::GetExperience(v3 + 1);
          sprintf(gText, "{Level %d}\n\nCurrent experience %d\nNext level %d", v3, gpHVHero->experience, v4);
          NormalDialog(gText, (unsigned int)a2 < 1 ? 1 : 4, -1, -1, -1, 0, -1, 0, -1, 0);
          break;
        case 0x66:
        case 0x67:
        case 0x68:
        case 0x69:
        case 0x6A:
          a13 = msg->yCoordOrFieldID - 102;
          if ( a2 || giHeroScreenSrcIndex != -1 )
          {
            if ( (!a2 || gpHVHero->army.creatureTypes[a13] == -1)
              && (a2 || msg->yCoordOrFieldID - 102 != giHeroScreenSrcIndex) )
            {
              if ( a2 || !gpTownManager->field_15A )
              {
                if ( !a2 )
                {
                  v16 = gpHVHero->army.creatureTypes[a13];
                  if ( msg->inputTypeBitmask & 3
                    && (gpHVHero->army.creatureTypes[a13] == -1
                     || gpHVHero->army.creatureTypes[giHeroScreenSrcIndex] == gpHVHero->army.creatureTypes[a13]) )
                  {
                    DoHeroSplit(a13, giHeroScreenSrcIndex);
                  }
                  else if ( gpHVHero->army.creatureTypes[giHeroScreenSrcIndex] == gpHVHero->army.creatureTypes[a13] )
                  {
                    gpHVHero->army.quantities[a13] += gpHVHero->army.quantities[giHeroScreenSrcIndex];
                    gpHVHero->army.quantities[giHeroScreenSrcIndex] = 0;
                    gpHVHero->army.creatureTypes[giHeroScreenSrcIndex] = -1;
                  }
                  else
                  {
                    gpHVHero->army.creatureTypes[a13] = gpHVHero->army.creatureTypes[giHeroScreenSrcIndex];
                    gpHVHero->army.creatureTypes[giHeroScreenSrcIndex] = v16;
                    v5 = gpHVHero->army.quantities[a13];
                    gpHVHero->army.quantities[a13] = gpHVHero->army.quantities[giHeroScreenSrcIndex];
                    gpHVHero->army.quantities[giHeroScreenSrcIndex] = v5;
                  }
                  giHeroScreenSrcIndex = -1;
                  hero::HeroScreenUpdate(gpHVHero);
                }
              }
              else if ( gpHVHero->army.creatureTypes[a13] != -1 )
              {
                giHeroScreenSrcIndex = msg->yCoordOrFieldID - 102;
                hero::HeroScreenUpdate(gpHVHero);
              }
            }
            else
            {
              a7 = a2 || gpTownManager->field_15A == 1 || armyGroup::GetNumArmies(&gpHVHero->army) == 1;
              game::ViewArmy(
                gpGame,
                119,
                20,
                (CREATURES)gpHVHero->army.creatureTypes[a13],
                gpHVHero->army.quantities[a13],
                0,
                a7,
                1u,
                a2,
                gpHVHero,
                0,
                &gpHVHero->army,
                a13);
              if ( !a2 )
                giHeroScreenSrcIndex = -1;
              SetupHeroView();
              RedrawHeroScreen();
            }
          }
          else if ( gpHVHero->army.creatureTypes[a13] != -1 )
          {
            giHeroScreenSrcIndex = msg->yCoordOrFieldID - 102;
            hero::HeroScreenUpdate(gpHVHero);
          }
          if ( !a2 )
          {
            gpWindowManager->hoveredFieldID = -1;
            UpdateHeroScreenStatusBar(msg);
          }
          break;
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1A:
        case 0x1B:
        case 0x1C:
        case 0x1D:
        case 0x1E:
        case 0x1F:
        case 0x20:
        case 0x21:
          if ( gpHVHero->spellsLearned[msg->yCoordOrFieldID + 45] != -1 )
          {
            if ( a2 || gpHVHero->spellsLearned[msg->yCoordOrFieldID + 45] != 81 )
              hero::ViewArtifact(
                gpHVHero->spellsLearned[msg->yCoordOrFieldID + 45],
                a2,
                gpHVHero->artifacts[msg->yCoordOrFieldID + 3]);
            else
              game::ViewSpells(gpGame, gpHVHero, 2, (int (__fastcall *)(struct tag_message *))ViewSpecialHandler, 1);
          }
          break;
        default:
          if ( msg->yCoordOrFieldID < 400 || msg->yCoordOrFieldID >= 408 )
          {
            if ( msg->yCoordOrFieldID < 408 || msg->yCoordOrFieldID >= 416 )
            {
              if ( msg->yCoordOrFieldID < 416 || msg->yCoordOrFieldID >= 424 )
                break;
              v13 = msg->yCoordOrFieldID - 416;
            }
            else
            {
              v13 = msg->yCoordOrFieldID - 408;
            }
          }
          else
          {
            v13 = msg->yCoordOrFieldID - 400;
          }
          if ( gpHVHero->numSecSkillsKnown > v13 )
          {
            v6 = hero::GetNthSS(gpHVHero, v13);
            hero::DoSSLevelDialog(gpHVHero, v6, a2);
          }
          break;
      }
    }
  }
LABEL_104:
  if ( v15 )
  {
    gpWindowManager->buttonPressedCode = msg->yCoordOrFieldID;
    msg->yCoordOrFieldID = 10;
    msg->xCoordOrKeycode = msg->yCoordOrFieldID;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 523428: using guessed type int giHeroScreenSrcIndex;

//----- (00497920) --------------------------------------------------------
void __cdecl RedrawHeroScreen()
{
  resourceManager::GetBackdrop(gpResourceManager, "herobkg.icn", gpWindowManager->screenBuffer, 1);
  heroWindow::DrawWindow(heroWin);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 640u, 480);
}

//----- (00497970) --------------------------------------------------------
signed int __fastcall HeroView(int heroIdx, int noDismiss, int dontFade)
{
  signed int result; // eax@12
  heroWindow *wind; // [sp+1Ch] [bp-8h]@3
  mapCell *cell; // [sp+20h] [bp-4h]@9

  gbNoDismiss = noDismiss;
  iOrigHeroViewID = heroIdx;
  advManager::TrimLoopingSounds(gpAdvManager, 4);
  gpHVHero = &gpGame->heroes[heroIdx];
  gbHeroWindShowing = 1;
  if ( !dontFade )
    heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  wind = (heroWindow *)operator new(sizeof(heroWindow));
  if ( wind )
    heroWin = heroWindow::heroWindow(wind, 0, 0, "herowind.bin");
  else
    heroWin = 0;
  if ( !heroWin )
    MemError();
  SetWinText(heroWin, HERO_VIEW_WINDOW);
  gheroWin = heroWin;
  if ( gpHVHero->idx == gpCurPlayer->curHeroIdx )
  {
    cell = advManager::GetCell(gpAdvManager, gpHVHero->x, gpHVHero->y);
    if ( cell->objType != 170 )
    {
      gpHVHero->occupiedObjType = cell->objType;
      gpHVHero->occupiedObjVal = (unsigned __int8)((unsigned __int8)(cell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5);
    }
  }
  SetupHeroView();
  RedrawHeroScreen();
  heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
  heroWindowManager::DoDialog(gpWindowManager, heroWin, HeroHandler, 0);
  heroWindowManager::FadeScreen(gpWindowManager, 1, 8, 0);
  operator delete(heroWin);
  gheroWin = NULL;
  if ( gpWindowManager->buttonPressedCode == 30723 )
  {
    result = 1;
  }
  else
  {
    gpHVHero->mobility = hero::CalcMobility(gpHVHero);
    gbHeroWindShowing = 0;
    gpHVHero = NULL;
    result = 0;
  }
  return result;
}
// 4F7458: using guessed type int gbHeroWindShowing;
// 52FF30: using guessed type int iOrigHeroViewID;
// 52FF34: using guessed type int gbNoDismiss;

//----- (00497B90) --------------------------------------------------------
void __cdecl SetupHeroView()
{
  char v0; // al@17
  town *v1; // eax@18
  town *v2; // eax@41
  char v3; // al@70
  char v4; // al@73
  int v5; // [sp+Ch] [bp-58h]@73
  signed int noDismiss; // [sp+10h] [bp-54h]@1
  tag_message evt; // [sp+14h] [bp-50h]@3
  SECONDARY_SKILL skill; // [sp+30h] [bp-34h]@73
  PRIMARY_SKILL v9; // [sp+34h] [bp-30h]@27
  PRIMARY_SKILL a2; // [sp+38h] [bp-2Ch]@6
  int v11; // [sp+3Ch] [bp-28h]@18
  PRIMARY_SKILL v12; // [sp+40h] [bp-24h]@18
  int v13; // [sp+44h] [bp-20h]@41
  int this; // [sp+48h] [bp-1Ch]@85
  int v15; // [sp+50h] [bp-14h]@85

  noDismiss = gbNoDismiss;
  if ( gpHVHero->occupiedObjType == 163 )
    noDismiss = 1;
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  sprintf(gText, "%s the %s", gpHVHero->name, gAlignmentNames[gpHVHero->factionID]);
  evt.xCoordOrKeycode = GUI_MESSAGE_SET_TEXT;
  evt.yCoordOrFieldID = FIELD_TOP_BANNER;
  evt.payload = gText;
  heroWindow::BroadcastMessage(heroWin, &evt);
  if ( gpHVHero->ownerIdx != giCurPlayer || gpCurPlayer->numHeroes == 1 )
  {
    evt.xCoordOrKeycode = 5;
    evt.payload = (void *)4096;
    evt.yCoordOrFieldID = 300;
    heroWindow::BroadcastMessage(heroWin, &evt);
    evt.yCoordOrFieldID = 301;
    heroWindow::BroadcastMessage(heroWin, &evt);
    evt.xCoordOrKeycode = 6;
    evt.payload = (void *)2;
    evt.yCoordOrFieldID = 300;
    heroWindow::BroadcastMessage(heroWin, &evt);
    evt.yCoordOrFieldID = 301;
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  evt.xCoordOrKeycode = 6;
  evt.payload = (void *)4;
  for ( a2 = 0; (signed int)a2 < 5; ++a2 )
  {
    evt.yCoordOrFieldID = a2 + 81;
    heroWindow::BroadcastMessage(heroWin, &evt);
    evt.yCoordOrFieldID = a2 + 102;
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  if ( noDismiss || gpTownManager->field_15A || !gpCurPlayer->numCastles && gpCurPlayer->numHeroes == 1 )
    evt.xCoordOrKeycode = 6;
  else
    evt.xCoordOrKeycode = 5;
  evt.yCoordOrFieldID = 30723;
  evt.payload = (void *)6;
  heroWindow::BroadcastMessage(heroWin, &evt);
  sprintf(gText, "port%04d.icn", gpHVHero->heroID);
  evt.xCoordOrKeycode = 9;
  evt.yCoordOrFieldID = 65;
  evt.payload = gText;
  heroWindow::BroadcastMessage(heroWin, &evt);
  evt.xCoordOrKeycode = 3;
  for ( a2 = 0; (signed int)a2 < 4; ++a2 )
  {
    v0 = hero::Stats(gpHVHero, a2);
    sprintf(gText, "%d", v0);
    evt.yCoordOrFieldID = a2 + 76;
    evt.payload = gText;
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  v1 = hero::GetOccupiedTown(gpHVHero);
  v11 = game::GetLuck(gpHVHero, 0, v1);
  v12 = abs(v11);
  if ( (signed int)v12 <= 0 )
    v12 = 1;
  for ( a2 = 0; (signed int)a2 < 3; ++a2 )
  {
    if ( a2 < v12 )
      evt.xCoordOrKeycode = 5;
    else
      evt.xCoordOrKeycode = 6;
    if ( a2 == 1 && v11 )
    {
      v9 = 0;
    }
    else if ( a2 || !v11 )
    {
      v9 = a2;
    }
    else
    {
      v9 = 1;
    }
    evt.yCoordOrFieldID = v9 + 203;
    evt.payload = (void *)6;
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  for ( a2 = 0; (signed int)a2 < 3; ++a2 )
  {
    evt.xCoordOrKeycode = 4;
    evt.yCoordOrFieldID = a2 + 203;
    if ( v11 >= 0 )
    {
      if ( v11 )
        evt.payload = (void *)2;
      else
        evt.payload = (void *)6;
    }
    else
    {
      evt.payload = (void *)3;
    }
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  v2 = hero::GetOccupiedTown(gpHVHero);
  v13 = armyGroup::GetMorale(&gpHVHero->army, gpHVHero, v2, 0);
  v12 = abs(v13);
  if ( (signed int)v12 <= 0 )
    v12 = 1;
  for ( a2 = 0; (signed int)a2 < 3; ++a2 )
  {
    if ( a2 < v12 )
      evt.xCoordOrKeycode = 5;
    else
      evt.xCoordOrKeycode = 6;
    if ( a2 == 1 && v13 )
    {
      v9 = 0;
    }
    else if ( a2 || !v13 )
    {
      v9 = a2;
    }
    else
    {
      v9 = 1;
    }
    evt.yCoordOrFieldID = v9 + 200;
    evt.payload = (void *)6;
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  for ( a2 = 0; (signed int)a2 < 3; ++a2 )
  {
    evt.xCoordOrKeycode = 4;
    evt.yCoordOrFieldID = a2 + 200;
    if ( v13 >= 0 )
    {
      if ( v13 )
        evt.payload = (void *)4;
      else
        evt.payload = (void *)7;
    }
    else
    {
      evt.payload = (void *)5;
    }
    heroWindow::BroadcastMessage(heroWin, &evt);
  }
  sprintf(gText, "%d", gpHVHero->experience);
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 207;
  evt.payload = gText;
  heroWindow::BroadcastMessage(heroWin, &evt);
  if ( BYTE1(gpHVHero->flags) & 0x80 )
    evt.xCoordOrKeycode = 6;
  else
    evt.xCoordOrKeycode = 5;
  evt.yCoordOrFieldID = 213;
  evt.payload = (void *)4;
  heroWindow::BroadcastMessage(heroWin, &evt);
  if ( BYTE1(gpHVHero->flags) & 0x80 )
    evt.xCoordOrKeycode = 5;
  else
    evt.xCoordOrKeycode = 6;
  evt.yCoordOrFieldID = 215;
  evt.payload = (void *)4;
  heroWindow::BroadcastMessage(heroWin, &evt);
  v3 = hero::Stats(gpHVHero, PRIMARY_SKILL_KNOWLEDGE);
  sprintf(gText, "%d/%d", gpHVHero->spellpoints, 10 * v3);
  evt.xCoordOrKeycode = 3;
  evt.yCoordOrFieldID = 212;
  evt.payload = gText;
  heroWindow::BroadcastMessage(heroWin, &evt);
  sprintf(gText, "crest.icn");
  evt.xCoordOrKeycode = 9;
  evt.yCoordOrFieldID = 86;
  heroWindow::BroadcastMessage(heroWin, &evt);
  evt.xCoordOrKeycode = 4;
  evt.yCoordOrFieldID = 86;
  evt.payload = (void *)gpCurPlayer->color;
  heroWindow::BroadcastMessage(heroWin, &evt);
  hero::UpdateArmies(gpHVHero);
  for ( a2 = 0; (signed int)a2 < 8; ++a2 )
  {
    if ( gpHVHero->numSecSkillsKnown <= a2 )
    {
      evt.yCoordOrFieldID = a2 + 400;
      evt.xCoordOrKeycode = 4;
      evt.payload = 0;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 6;
      evt.yCoordOrFieldID = a2 + 408;
      evt.payload = (void *)6;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 6;
      evt.yCoordOrFieldID = a2 + 416;
      evt.payload = (void *)6;
      heroWindow::BroadcastMessage(heroWin, &evt);
    }
    else
    {
      skill = hero::GetNthSS(gpHVHero, a2);
      evt.yCoordOrFieldID = a2 + 400;
      evt.xCoordOrKeycode = 4;
      evt.payload = (void *)(skill + 1);
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 5;
      evt.yCoordOrFieldID = a2 + 408;
      evt.payload = (void *)6;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 5;
      evt.yCoordOrFieldID = a2 + 416;
      evt.payload = (void *)6;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 3;
      evt.yCoordOrFieldID = a2 + 408;
      evt.payload = gSecondarySkills[skill];
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 3;
      evt.yCoordOrFieldID = a2 + 416;
      v4 = hero::GetSSLevel(gpHVHero, skill);
      v5 = v4 - gpHVHero->secondarySkillLevel[skill];
      if ( v5 <= 0 )
        sprintf(gText, "%s", secondarySkillLevels[gpHVHero->secondarySkillLevel[skill]]);
      else
        sprintf(gText, "%s+%d", secondarySkillLevels[gpHVHero->secondarySkillLevel[skill]], v5);
      evt.payload = gText;
      heroWindow::BroadcastMessage(heroWin, &evt);
    }
  }
  for ( a2 = 0; (signed int)a2 < 14; ++a2 )
  {
    evt.yCoordOrFieldID = a2 + 20;
    if ( gpHVHero->artifacts[a2] == -1 )
    {
      evt.xCoordOrKeycode = GUI_MESSAGE_SET_IMG_IDX;
      evt.payload = 0;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)2;
      heroWindow::BroadcastMessage(heroWin, &evt);
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)2;
      heroWindow::BroadcastMessage(heroWin, &evt);
      evt.xCoordOrKeycode = GUI_MESSAGE_SET_IMG_IDX;
      evt.payload = (void *)(gpHVHero->artifacts[a2] + 1);
      heroWindow::BroadcastMessage(heroWin, &evt);
    }
  }
  this = 512;
  v15 = -1;
  UpdateHeroScreenStatusBar((tag_message *)&this);
}
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 52FF34: using guessed type int gbNoDismiss;

//----- (00498560) --------------------------------------------------------
void *__fastcall DoHeroSplit(int a1, int a2)
{
  void *result; // eax@6
  int v3; // [sp+Ch] [bp-38h]@1
  int v4; // [sp+10h] [bp-34h]@1
  heroWindow *this; // [sp+1Ch] [bp-28h]@1
  int evt; // [sp+20h] [bp-24h]@6
  int v7; // [sp+24h] [bp-20h]@6
  int v8; // [sp+28h] [bp-1Ch]@6
  char *v9; // [sp+38h] [bp-Ch]@6
  __int16 v10; // [sp+3Ch] [bp-8h]@1
  __int16 v11; // [sp+40h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  v11 = 1;
  v10 = 68;
  this = (heroWindow *)operator new(68);
  if ( this )
    gpTownManager->dialog = heroWindow::heroWindow(this, 177, 20, "splitwin.bin");
  else
    gpTownManager->dialog = 0;
  if ( !gpTownManager->dialog )
    MemError();
  gpTownManager->field_16A = 0;
  gpTownManager->field_16E = gpHVHero->army.quantities[v3];
  evt = 512;
  sprintf(gText, "Move how many troops?");
  v7 = 3;
  v8 = 1;
  v9 = gText;
  heroWindow::BroadcastMessage(gpTownManager->dialog, (tag_message *)&evt);
  sprintf(gText, "%d", gpTownManager->field_16A);
  v8 = 68;
  v9 = gText;
  heroWindow::BroadcastMessage(gpTownManager->dialog, (tag_message *)&evt);
  heroWindowManager::DoDialog(
    gpWindowManager,
    gpTownManager->dialog,
    (int (__fastcall *)(tag_message *))SplitArmyHandler,
    0);
  operator delete(gpTownManager->dialog);
  result = gpWindowManager;
  if ( gpWindowManager->buttonPressedCode == 30722 )
  {
    result = gpTownManager;
    if ( gpTownManager->field_16A )
    {
      if ( gpHVHero->army.creatureTypes[v3] == gpHVHero->army.creatureTypes[v4] )
      {
        gpHVHero->army.quantities[v3] -= LOWORD(gpTownManager->field_16A);
        gpHVHero->army.quantities[v4] += LOWORD(gpTownManager->field_16A);
        result = (void *)gpHVHero->army.quantities[v3];
        if ( !gpHVHero->army.quantities[v3] )
        {
          result = (void *)v3;
          gpHVHero->army.creatureTypes[v3] = -1;
        }
      }
      else
      {
        gpHVHero->army.quantities[v3] -= LOWORD(gpTownManager->field_16A);
        gpHVHero->army.quantities[v4] = gpTownManager->field_16A;
        gpHVHero->army.creatureTypes[v4] = gpHVHero->army.creatureTypes[v3];
        result = (void *)gpHVHero->army.quantities[v3];
        if ( !gpHVHero->army.quantities[v3] )
        {
          result = (void *)v3;
          gpHVHero->army.creatureTypes[v3] = -1;
        }
      }
    }
  }
  return result;
}

//----- (00498810) --------------------------------------------------------
void __thiscall hero::SetSS(hero *this, int skill, int level)
{
  if ( level )
  {
    if ( this->secondarySkillLevel[skill] )
      this->secondarySkillLevel[skill] = level;
    else
      hero::GiveSS(this, skill, level);
  }
  else
  {
    hero::TakeSS(this, skill, 3);
  }
}

//----- (00498880) --------------------------------------------------------
int __thiscall hero::TakeSS(hero *this, int skill, char levelsLost)
{
  signed int i; // [sp+10h] [bp-8h]@5
  int oldLevel; // [sp+14h] [bp-4h]@1

  oldLevel = this->secondarySkillLevel[skill];
  if ( this->secondarySkillLevel[skill] )
  {
    this->secondarySkillLevel[skill] -= levelsLost;
    if ( this->secondarySkillLevel[skill] < 0 )
      this->secondarySkillLevel[skill] = 0;
    if ( !this->secondarySkillLevel[skill] )
    {
      for ( i = 0; i < 14; ++i )
      {
        if ( this->skillIndex[i] > this->skillIndex[skill] )
          --this->skillIndex[i];
      }
      this->skillIndex[skill] = 0;
      --this->numSecSkillsKnown;
    }
  }
  return oldLevel - this->secondarySkillLevel[skill];
}

//----- (00498980) --------------------------------------------------------
int __thiscall hero::GiveSS(hero *this, int skill, int levels)
{
  int oldLevel; // [sp+10h] [bp-4h]@1

  oldLevel = this->secondarySkillLevel[skill];
  if ( this->secondarySkillLevel[skill] )
  {
    this->secondarySkillLevel[skill] += levels;
  }
  else if ( this->numSecSkillsKnown < MAX_KNOWABLE_SECONDARY_SPILLS )
  {
    this->secondarySkillLevel[skill] = levels;
    ++this->numSecSkillsKnown;
    this->skillIndex[skill] = LOBYTE(this->numSecSkillsKnown);
  }
  if ( this->secondarySkillLevel[skill] > (signed int)MAX_SECONDARY_SKILL_LEVELS )
    this->secondarySkillLevel[skill] = MAX_SECONDARY_SKILL_LEVELS;
  return this->secondarySkillLevel[skill] - oldLevel;
}

//----- (00498A40) --------------------------------------------------------
int __thiscall hero::CreatureTypeCount(hero *this, int type)
{
  signed int i; // [sp+10h] [bp-8h]@1
  int numOfType; // [sp+14h] [bp-4h]@1

  numOfType = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( this->army.creatureTypes[i] == type )
    {
      if ( this->army.quantities[i] > 0 )
        ++numOfType;
    }
  }
  return numOfType;
}

//----- (00498AB0) --------------------------------------------------------
char __thiscall hero::UpgradeCreatures(hero *this, int fromType, char toType)
{
  int v3; // eax@3
  signed int i; // [sp+10h] [bp-8h]@1

  for ( i = 0; i < 5; ++i )
  {
    v3 = this->army.creatureTypes[i];
    if ( v3 == fromType )
    {
      LOBYTE(v3) = toType;
      this->army.creatureTypes[i] = toType;
    }
  }
  return v3;
}

//----- (00498B10) --------------------------------------------------------
signed int __thiscall hero::GetNthSS(hero *this, int a2)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 14; ++i )
  {
    if ( this->skillIndex[i] == a2 + 1 )
      return i;
  }
  return -1;
}

//----- (00498B70) --------------------------------------------------------
town *__thiscall hero::GetOccupiedTown(hero *this)
{
  town *result; // eax@2

  if ( this->occupiedObjType == 163 )
    result = &gpGame->castles[this->occupiedObjVal];
  else
    result = 0;
  return result;
}

//----- (00498BD0) --------------------------------------------------------
char __thiscall hero::Stats(hero *this, PRIMARY_SKILL skill)
{
  char result; // al@3

  if ( skill != PRIMARY_SKILL_SPELLPOWER || this->primarySkills[2] >= 1 )
    result = this->primarySkills[skill];
  else
    result = 1;
  return result;
}

//----- (00498C20) --------------------------------------------------------
char __thiscall hero::GetSSLevel(hero *ecx0, SECONDARY_SKILL skill)
{
  char result; // al@2
  char skillLevel; // [sp+10h] [bp-8h]@1
  char skillLevela; // [sp+10h] [bp-8h]@11
  char v6; // [sp+14h] [bp-4h]@1

  v6 = 0;
  skillLevel = ecx0->secondarySkillLevel[skill];
  if ( skill == SECONDARY_SKILL_NECROMANCY )
  {
    if ( skillLevel )
    {
      if ( hero::HasArtifact(ecx0, 102) )
        v6 = 1;
      if ( ecx0->factionID == FACTION_NECROMANCER )
        v6 += game::CountShrines(gpGame, ecx0->ownerIdx);
      if ( v6 > 6 )
        v6 = 6;
      skillLevela = skillLevel + v6;
      if ( skillLevela > 9 )
        skillLevela = 9;
      result = skillLevela;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = ecx0->secondarySkillLevel[skill];
  }
  return result;
}

//----- (00498CF0) --------------------------------------------------------
void __thiscall hero::DoSSLevelDialog(hero *this, int skill, unsigned int rightClick)
{
  int v3; // ST34_4@2
  int v4; // ST1C_4@2
  int level; // [sp+10h] [bp-8h]@1

  level = hero::GetSSLevel(this, (SECONDARY_SKILL)skill) - this->secondarySkillLevel[skill];
  if ( level <= 0 )
  {
    sprintf(gText, (&gDwellingNames[3 * skill + 71])[4 * this->secondarySkillLevel[skill]]);
  }
  else
  {
    v3 = secondarySkillLevels[this->secondarySkillLevel[skill]];
    v4 = 10 * hero::GetSSLevel(this, (SECONDARY_SKILL)skill);
    sprintf(
      gText,
      "{%s Necromancy (+%d)}\n\n%s Necromancy (+%d) allows %d percent of the creatures killed in combat to be brought back from the dead as Skeletons.",
      v3,
      level,
      v3,
      level,
      v4);
  }
  NormalDialog(
    gText,
    rightClick < 1 ? 1 : 4,
    -1,
    -1,
    17,
    3 * skill + this->secondarySkillLevel[skill] - 1,
    -1,
    0,
    -1,
    0);
}
// 4F6CA0: using guessed type char *gDwellingNames[72];

//----- (00498DF0) --------------------------------------------------------
void __thiscall hero::CheckAnduranPieces(hero *this, int a2)
{
  signed int i; // [sp+18h] [bp-4h]@4

  if ( hero::HasArtifact(this, 88) && hero::HasArtifact(this, 94) && hero::HasArtifact(this, 101) )
  {
    for ( i = 0; i < 14; ++i )
    {
      if ( this->artifacts[i] == ARTIFACT_BREASTPLATE_OF_ANDURAN
        || this->artifacts[i] == ARTIFACT_HELMET_OF_ANDURAN
        || this->artifacts[i] == ARTIFACT_SWORD_OF_ANDURAN )
      {
        GiveTakeArtifactStat(this, (ARTIFACT)this->artifacts[i], 1);
        this->artifacts[i] = -1;
      }
    }
    GiveArtifact(this, ARTIFACT_BATTLE_GARB_OF_ANDURAN, a2, -1);
    if ( gbThisNetHumanPlayer[this->ownerIdx] )
    {
      LoadPlaySample("treasure.82m");
      NormalDialog("The three Anduran artifacts magically combine into one.", 1, -1, -1, 7, 90, -1, 0, -1, 0);
    }
  }
}

//----- (00498F20) --------------------------------------------------------
void __fastcall advManager::ViewWorld(advManager *this, int edx0, int a2, int a3, int a4)
{
  int var348; // [sp+14h] [bp-348h]@9
  heroWindow *v6; // [sp+1Ch] [bp-340h]@1
  int evt; // [sp+20h] [bp-33Ch]@11
  int v9; // [sp+24h] [bp-338h]@11
  int v10; // [sp+28h] [bp-334h]@11
  char *v11; // [sp+38h] [bp-324h]@11
  int v12; // [sp+3Ch] [bp-320h]@6
  int v13; // [sp+40h] [bp-31Ch]@6
  int v14; // [sp+44h] [bp-318h]@6
  int v15; // [sp+48h] [bp-314h]@6
  int v16; // [sp+4Ch] [bp-310h]@6
  int v17; // [sp+50h] [bp-30Ch]@6
  int v18; // [sp+54h] [bp-308h]@6
  int thisb; // [sp+58h] [bp-304h]@2
  RGB a1; // [sp+5Ch] [bp-300h]@1

  memcpy(&a1, gpBufferPalette->contents, 0x300u);
  gbInViewWorld = 1;
  iVWWhatToDraw = a2;
  iVWDrawAllObjs = a3;
  iVWDrawAllTerrains = a4;
  gpWindowManager->cycleColors = 0;
  giCycleType = 2;
  advManager::VWInit(this, this->viewX + 7, this->viewY + 7);
  advManager::VWCompleteDraw(this);
  gpWindowManager->cycleColors = 1;
  sprintf(gText, "viewlgnd.bin");
  v6 = (heroWindow *)operator new(68);
  if ( v6 )
    thisb = (int)heroWindow::heroWindow(v6, 480, 16, gText);
  else
    thisb = 0;
  if ( !thisb )
    MemError();
  v12 = (int)"MINE";
  v13 = (int)"RSRC";
  v14 = (int)"RTFX";
  v15 = (int)"TWNS";
  v16 = (int)"HROS";
  v17 = (int)"_ALL";
  v18 = (int)"WRLD";
  if ( a2 != 53 || a3 || a4 )
    var348 = a2 - 48;
  else
    var348 = 6;
  sprintf(gText, "view%s.icn", *(&v12 + var348));
  evt = 512;
  v9 = 9;
  v10 = 3;
  v11 = gText;
  heroWindow::BroadcastMessage((heroWindow *)thisb, (tag_message *)&evt);
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)thisb,
    (int (__fastcall *)(tag_message *))ViewWorldDialogHandler,
    0);
  operator delete((void *)thisb);
  advManager::UpdateRadar(this, 1, 0);
  advManager::VWCleanup();
  gbInViewWorld = 0;
  gpWindowManager->cycleColors = 0;
  advManager::RedrawAdvScreen(this, 1, 0);
  giCycleType = 0;
  gpWindowManager->cycleColors = 1;
  SetPalette(&a1.red, 1);
}
// 4F19A0: using guessed type int giCycleType;
// 519244: using guessed type int gbInViewWorld;
// 52FF3C: using guessed type int iVWWhatToDraw;
// 52FF40: using guessed type int iVWDrawAllObjs;
// 52FF44: using guessed type int iVWDrawAllTerrains;

//----- (004991C0) --------------------------------------------------------
void __cdecl advManager::VWCleanup()
{
  resourceManager::Dispose(gpResourceManager, (resource *)pVWGround);
  resourceManager::Dispose(gpResourceManager, (resource *)pVWFlags);
  resourceManager::Dispose(gpResourceManager, (resource *)pVWMisc);
  resourceManager::Dispose(gpResourceManager, (resource *)pVWLetters);
}

//----- (00499220) --------------------------------------------------------
void __thiscall advManager::VWInit(void *this, int a2, int a3)
{
  void *v3; // [sp+Ch] [bp-4h]@1

  v3 = this;
  if ( giViewWorldScale == 4 )
  {
    giViewWorldScaleLookup = 0;
  }
  else if ( giViewWorldScale == 6 )
  {
    giViewWorldScaleLookup = 1;
  }
  else
  {
    giViewWorldScaleLookup = 2;
  }
  iVWViewableCells = 448 / giViewWorldScale;
  if ( MAP_WIDTH < 448 / giViewWorldScale )
    iVWViewableCells = MAP_WIDTH;
  iVWCenterOffset = iVWViewableCells >> 1;
  iVWMapOriginY = 0;
  iVWMapOriginX = 0;
  if ( MAP_WIDTH != iVWViewableCells )
  {
    iVWMapOriginX = a2 - (iVWViewableCells >> 1);
    if ( iVWMapOriginX < 0 )
      iVWMapOriginX = 0;
    if ( iVWViewableCells + iVWMapOriginX >= MAP_WIDTH )
      iVWMapOriginX = MAP_WIDTH - iVWViewableCells;
    iVWMapOriginY = a3 - (iVWViewableCells >> 1);
    if ( iVWMapOriginY < 0 )
      iVWMapOriginY = 0;
    if ( iVWMapOriginY + iVWViewableCells >= MAP_HEIGHT )
      iVWMapOriginY = MAP_HEIGHT - iVWViewableCells;
  }
  iVWXPixelOffset = (480 - iVWViewableCells * giViewWorldScale) >> 1;
  iVWYPixelOffset = (480 - iVWViewableCells * giViewWorldScale) >> 1;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  sprintf(gText, "ground%d.icn", giViewWorldScale);
  pVWGround = resourceManager::GetIcon(gpResourceManager, gText);
  sprintf(gText, "vwflag%d.icn", giViewWorldScale);
  pVWFlags = resourceManager::GetIcon(gpResourceManager, gText);
  sprintf(gText, "misc%d.icn", giViewWorldScale);
  pVWMisc = resourceManager::GetIcon(gpResourceManager, gText);
  sprintf(gText, "letter%d.icn", giViewWorldScale);
  pVWLetters = resourceManager::GetIcon(gpResourceManager, gText);
  advManager::UpdateRadar((advManager *)v3, 1, 0);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 519240: using guessed type int giViewWorldScaleLookup;
// 52FF4C: using guessed type int iVWXPixelOffset;
// 52FF50: using guessed type int iVWYPixelOffset;
// 52FF5C: using guessed type int iVWMapOriginX;
// 52FF60: using guessed type int iVWMapOriginY;
// 52FF64: using guessed type int iVWCenterOffset;
// 52FF68: using guessed type int iVWViewableCells;

//----- (00499480) --------------------------------------------------------
void __thiscall advManager::VWCompleteDraw(void *this)
{
  void *thisa; // [sp+10h] [bp-A4h]@1
  int v2; // [sp+14h] [bp-A0h]@155
  int v3; // [sp+18h] [bp-9Ch]@137
  int v4; // [sp+1Ch] [bp-98h]@119
  int a11; // [sp+20h] [bp-94h]@116
  int v6; // [sp+24h] [bp-90h]@32
  char v7; // [sp+28h] [bp-8Ch]@157
  char v8; // [sp+29h] [bp-8Bh]@157
  char v9; // [sp+2Ah] [bp-8Ah]@157
  char v10; // [sp+2Ch] [bp-88h]@115
  char v11; // [sp+2Dh] [bp-87h]@115
  char v12; // [sp+2Eh] [bp-86h]@115
  char v13; // [sp+30h] [bp-84h]@115
  char v14; // [sp+31h] [bp-83h]@115
  char v15; // [sp+32h] [bp-82h]@115
  int mirror; // [sp+34h] [bp-80h]@11
  int v17; // [sp+38h] [bp-7Ch]@110
  mapCell *v18; // [sp+3Ch] [bp-78h]@5
  int a4; // [sp+40h] [bp-74h]@11
  int a3; // [sp+44h] [bp-70h]@11
  int v21; // [sp+48h] [bp-6Ch]@157
  int v22; // [sp+4Ch] [bp-68h]@11
  int spriteIdx; // [sp+50h] [bp-64h]@1
  int row; // [sp+58h] [bp-5Ch]@1
  int col; // [sp+5Ch] [bp-58h]@3
  bool v26; // [sp+60h] [bp-54h]@125
  int v27; // [sp+64h] [bp-50h]@41
  unsigned int v28; // [sp+6Ch] [bp-48h]@90
  unsigned int v29; // [sp+70h] [bp-44h]@90
  char v30[11]; // [sp+74h] [bp-40h]@1
  char v31; // [sp+7Fh] [bp-35h]@1
  char v32; // [sp+81h] [bp-33h]@1
  char v33; // [sp+82h] [bp-32h]@1

  thisa = this;
  spriteIdx = 0;
  FillBitmapArea(gpWindowManager->screenBuffer, 16, 16, 0x1C0u, 448, 36);
  memset(v30, 1u, 0x40u);
  v31 = 0;
  v32 = 0;
  v33 = 0;
  for ( row = iVWMapOriginY; iVWMapOriginY + iVWViewableCells > row; ++row )
  {
    for ( col = iVWMapOriginX; iVWViewableCells + iVWMapOriginX > col; ++col )
    {
      v18 = advManager::GetCell((advManager *)thisa, col, row);
      if ( (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
        || iVWDrawAllTerrains
        || iVWWhatToDraw == 51
        && ((v18->objType & 0x7F) == 35
         || v18->objType == 170
         && gpGame->heroes[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjType == 163) )
      {
        mirror = 0;
        a3 = iVWXPixelOffset + giViewWorldScale * (col - iVWMapOriginX);
        a4 = iVWYPixelOffset + giViewWorldScale * (row - iVWMapOriginY);
        v22 = giGroundShape[v18->groundIndex] & 0x7F;
        switch ( v22 )
        {
          case 0:
          case 9:
          case 18:
          case 19:
          case 20:
          case 21:
            spriteIdx = 0;
            break;
          case 1:
          case 12:
          case 15:
          case 16:
            spriteIdx = 1;
            break;
          case 2:
          case 10:
          case 11:
            spriteIdx = 2;
            break;
          case 3:
          case 13:
          case 14:
          case 17:
            spriteIdx = 3;
            break;
          case 4:
            spriteIdx = 4;
            break;
          case 5:
            spriteIdx = 5;
            break;
          case 6:
            spriteIdx = 6;
            break;
          case 7:
            spriteIdx = 7;
            break;
          case 8:
            spriteIdx = 8;
            break;
          default:
            break;
        }
        if ( v18->displayFlags & 2 )
          mirror = 1;
        if ( v18->displayFlags & 1 )
          spriteIdx += 9;
        if ( spriteIdx )
          spriteIdx += 3;
        else
          spriteIdx = ((_BYTE)col + 2 * (_BYTE)row) & 3;
        spriteIdx += 21 * (unsigned __int8)giGroundToTerrain[v18->groundIndex];
        if ( (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit) || iVWDrawAllTerrains )
        {
          if ( mirror == 1 )
            v6 = giViewWorldScale - 1;
          else
            v6 = 0;
          icon::DrawToBuffer(pVWGround, v6 + a3, a4, spriteIdx, mirror);
        }
        if ( v18->field_4_1_1_isShadow_1_13_extraInfo & 1
          && v18->objectIndex != 255
          && v30[((unsigned __int8)v18->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F] )
          IconToBitmapScale(
            *(icon **)((char *)thisa
                     + 4 * (((unsigned __int8)v18->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F)
                     + 206),
            gpWindowManager->screenBuffer,
            a3,
            a4,
            v18->objectIndex,
            0,
            0,
            0,
            0x280u,
            480,
            giViewWorldScale);
        if ( v18->extraIdx
          && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx + 3) != 255 )
          v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx;
        else
          v27 = 0;
        while ( v27 )
        {
          if ( *(_BYTE *)(v27 + 4) & 1 && *(_BYTE *)(v27 + 3) != 255 && v30[(*(_BYTE *)(v27 + 2) >> 1) & 0x7F] )
            IconToBitmapScale(
              *(icon **)((char *)thisa + 4 * ((*(_BYTE *)(v27 + 2) >> 1) & 0x7F) + 206),
              gpWindowManager->screenBuffer,
              a3,
              a4,
              *(_BYTE *)(v27 + 3),
              0,
              0,
              0,
              0x280u,
              480,
              giViewWorldScale);
          if ( *(_WORD *)v27
            && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27 + 3) != 255 )
            v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27;
          else
            v27 = 0;
        }
        if ( !(v18->field_4_1_1_isShadow_1_13_extraInfo & 1)
          && v18->objectIndex != 255
          && v30[((unsigned __int8)v18->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F] )
          IconToBitmapScale(
            *(icon **)((char *)thisa
                     + 4 * (((unsigned __int8)v18->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F)
                     + 206),
            gpWindowManager->screenBuffer,
            a3,
            a4,
            v18->objectIndex,
            0,
            0,
            0,
            0x280u,
            480,
            giViewWorldScale);
        if ( v18->extraIdx
          && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx + 3) != 255 )
          v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx;
        else
          v27 = 0;
        while ( v27 )
        {
          if ( !(*(_BYTE *)(v27 + 4) & 1) && *(_BYTE *)(v27 + 3) != 255 && v30[(*(_BYTE *)(v27 + 2) >> 1) & 0x7F] )
            IconToBitmapScale(
              *(icon **)((char *)thisa + 4 * ((*(_BYTE *)(v27 + 2) >> 1) & 0x7F) + 206),
              gpWindowManager->screenBuffer,
              a3,
              a4,
              *(_BYTE *)(v27 + 3),
              0,
              0,
              0,
              0x280u,
              480,
              giViewWorldScale);
          if ( *(_WORD *)v27
            && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27 + 3) != 255 )
            v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27;
          else
            v27 = 0;
        }
        if ( v18->overlayIndex != 255
          && v30[((unsigned __int8)v18->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F] )
          IconToBitmapScale(
            *(icon **)((char *)thisa
                     + 4 * (((unsigned __int8)v18->field__1_hasOverlay_1_hasLateOverlay_6_overlayTileset >> 2) & 0x3F)
                     + 206),
            gpWindowManager->screenBuffer,
            a3,
            a4,
            v18->overlayIndex,
            0,
            0,
            0,
            0x280u,
            480,
            giViewWorldScale);
        if ( v18->extraIdx
          && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx + 6) != 255 )
          v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - v18->extraIdx + 8 * v18->extraIdx;
        else
          v27 = 0;
        while ( v27 )
        {
          if ( v30[(*(_BYTE *)(v27 + 5) >> 2) & 0x3F] )
            IconToBitmapScale(
              *(icon **)((char *)thisa + 4 * ((*(_BYTE *)(v27 + 5) >> 2) & 0x3F) + 206),
              gpWindowManager->screenBuffer,
              a3,
              a4,
              *(_BYTE *)(v27 + 6),
              0,
              0,
              0,
              0x280u,
              480,
              giViewWorldScale);
          if ( *(_WORD *)v27
            && *(_BYTE *)(*(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27 + 6) != 255 )
            v27 = *(_DWORD *)(*(_DWORD *)((char *)thisa + 174) + 4) - *(_WORD *)v27 + 8 * *(_WORD *)v27;
          else
            v27 = 0;
        }
      }
    }
  }
  for ( row = 16; row < 464; ++row )
  {
    v28 = (unsigned int)&gpWindowManager->screenBuffer->contents[640 * row + 16];
    v29 = v28 + 448;
    while ( v28 < v29 )
    {
      *(_BYTE *)v28 = gColorTableNoCycle[*(_BYTE *)v28];
      ++v28;
    }
  }
  for ( row = iVWMapOriginY; iVWMapOriginY + iVWViewableCells > row; ++row )
  {
    for ( col = iVWMapOriginX; iVWViewableCells + iVWMapOriginX > col; ++col )
    {
      v18 = advManager::GetCell((advManager *)thisa, col, row);
      a3 = iVWXPixelOffset + (giViewWorldScale >> 1) + giViewWorldScale * (col - iVWMapOriginX);
      a4 = iVWYPixelOffset + (giViewWorldScale >> 1) + giViewWorldScale * (row - iVWMapOriginY);
      if ( v18->objType == 169
        && (iVWDrawAllObjs
         || (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
         || iVWWhatToDraw == 50) )
        IconToBitmap(
          pVWMisc,
          gpWindowManager->screenBuffer,
          a3 - byte_51921C[12 * giViewWorldScaleLookup],
          a4 - byte_51921D[12 * giViewWorldScaleLookup],
          14,
          1,
          16,
          16,
          0x1C0u,
          448,
          (unsigned int)(iVWWhatToDraw - 50) < 1 ? 0xD6 : 0);
      if ( (v18->objType == 163
         || v18->objType == 170
         && gpGame->heroes[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjType == 163)
        && (iVWDrawAllObjs
         || (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
         || iVWWhatToDraw == 51) )
      {
        if ( v18->objType == 163 )
          v17 = gpGame->field_2773[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
        else
          v17 = gpGame->field_2773[gpGame->heroes[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjVal];
        if ( v17 >= 0 )
          v17 = gpGame->players[v17].color;
        else
          v17 = 6;
        v13 = -2;
        v14 = -3;
        v15 = -6;
        v10 = 5;
        v11 = 7;
        v12 = 10;
        if ( iVWWhatToDraw == 51 )
          a11 = v17 + 215;
        else
          a11 = 0;
        FlipIconToBitmap(
          pVWFlags,
          gpWindowManager->screenBuffer,
          a3 + *(&v13 + giViewWorldScaleLookup) - byte_519220[12 * giViewWorldScaleLookup],
          a4 - byte_519221[12 * giViewWorldScaleLookup],
          v17,
          1,
          16,
          16,
          448,
          448,
          a11);
        if ( iVWWhatToDraw == 51 )
          v4 = v17 + 215;
        else
          v4 = 0;
        IconToBitmap(
          pVWFlags,
          gpWindowManager->screenBuffer,
          a3 + *(&v10 + giViewWorldScaleLookup) - byte_519220[12 * giViewWorldScaleLookup],
          a4 - byte_519221[12 * giViewWorldScaleLookup],
          v17,
          1,
          16,
          16,
          0x1C0u,
          448,
          v4);
      }
      v26 = gpCurPlayer->curHeroIdx != -1
         && gpGame->heroes[gpCurPlayer->curHeroIdx].x == col
         && gpGame->heroes[gpCurPlayer->curHeroIdx].y == row;
      if ( v18->objType == 170 || v26 )
      {
        if ( iVWDrawAllObjs
          || (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
          || iVWWhatToDraw == 52 )
        {
          v17 = v26 ? gpGame->relatedToHeroForHireStatus[gpCurPlayer->curHeroIdx] : gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
          if ( v17 >= 0 )
          {
            spriteIdx = gpGame->players[v17].color;
            if ( iVWWhatToDraw == 52 )
              v3 = spriteIdx + 215;
            else
              v3 = 0;
            IconToBitmap(
              pVWMisc,
              gpWindowManager->screenBuffer,
              a3 - byte_519218[12 * giViewWorldScaleLookup],
              a4 - byte_519219[12 * giViewWorldScaleLookup],
              spriteIdx + 7,
              1,
              16,
              16,
              0x1C0u,
              448,
              v3);
          }
        }
      }
      if ( v18->objType == 155
        && (iVWDrawAllObjs
         || (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
         || iVWWhatToDraw == 49) )
      {
        spriteIdx = v18->objectIndex >> 1;
        IconToBitmap(
          pVWMisc,
          gpWindowManager->screenBuffer,
          a3 - byte_51921A[12 * giViewWorldScaleLookup],
          a4 - byte_51921B[12 * giViewWorldScaleLookup],
          13,
          1,
          16,
          16,
          0x1C0u,
          448,
          (unsigned int)(iVWWhatToDraw - 49) < 1 ? 0xDD : 0);
        IconToBitmap(
          pVWLetters,
          gpWindowManager->screenBuffer,
          a3 - byte_519222[12 * giViewWorldScaleLookup],
          a4 - byte_519223[12 * giViewWorldScaleLookup],
          spriteIdx,
          1,
          16,
          16,
          0x1C0u,
          448,
          0);
      }
      if ( (v18->objType == 151 || v18->objType == 157 || v18->objType == 129)
        && (iVWDrawAllObjs
         || (unsigned __int8)(*(&mapRevealed[col] + row * MAP_WIDTH) & giCurPlayerBit)
         || iVWWhatToDraw == 48) )
      {
        v17 = gpGame->field_60A6[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
        if ( v17 < 0 )
          spriteIdx = 6;
        else
          spriteIdx = gpGame->players[v17].color;
        if ( iVWWhatToDraw == 48 )
          v2 = spriteIdx + 215;
        else
          v2 = 0;
        IconToBitmap(
          pVWMisc,
          gpWindowManager->screenBuffer,
          a3 - byte_51921E[12 * giViewWorldScaleLookup],
          a4 - byte_51921F[12 * giViewWorldScaleLookup],
          spriteIdx,
          1,
          16,
          16,
          0x1C0u,
          448,
          v2);
        v7 = 0;
        v8 = 0;
        v9 = 2;
        v21 = gpGame->mines[(unsigned __int8)((unsigned __int8)(v18->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].type;
        IconToBitmap(
          pVWLetters,
          gpWindowManager->screenBuffer,
          a3 - byte_519222[12 * giViewWorldScaleLookup],
          a4 + *(&v7 + giViewWorldScaleLookup) - byte_519223[12 * giViewWorldScaleLookup],
          v21,
          1,
          16,
          16,
          0x1C0u,
          448,
          0);
      }
    }
  }
  heroWindowManager::UpdateScreenRegion(gpWindowManager, 16, 16, 0x1C0u, 448);
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 519240: using guessed type int giViewWorldScaleLookup;
// 52FF3C: using guessed type int iVWWhatToDraw;
// 52FF40: using guessed type int iVWDrawAllObjs;
// 52FF44: using guessed type int iVWDrawAllTerrains;
// 52FF4C: using guessed type int iVWXPixelOffset;
// 52FF50: using guessed type int iVWYPixelOffset;
// 52FF5C: using guessed type int iVWMapOriginX;
// 52FF60: using guessed type int iVWMapOriginY;
// 52FF68: using guessed type int iVWViewableCells;
// 532C5C: using guessed type char giCurPlayerBit;
// 499480: using guessed type char var_40[11];

//----- (0049A7D0) --------------------------------------------------------
signed int __thiscall ViewWorldDialogHandler(void *this)
{
  signed int v2; // [sp+1Ch] [bp-8Ch]@57
  int v3; // [sp+24h] [bp-84h]@4
  void *v4; // [sp+28h] [bp-80h]@1
  char v5; // [sp+2Ch] [bp-7Ch]@36
  tag_message a2; // [sp+48h] [bp-60h]@31
  int v7; // [sp+64h] [bp-44h]@21
  int v8; // [sp+68h] [bp-40h]@21
  int v9; // [sp+6Ch] [bp-3Ch]@29
  float v10; // [sp+88h] [bp-20h]@14
  int v11; // [sp+8Ch] [bp-1Ch]@31
  int v12; // [sp+90h] [bp-18h]@38
  int v13; // [sp+94h] [bp-14h]@42

  v4 = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( *(_DWORD *)v4 != 512 )
    return 1;
  v3 = *((_DWORD *)v4 + 1);
  if ( v3 == 12 )
  {
    if ( *((_DWORD *)v4 + 2) == 9
      && (giViewWorldScale != 12 || MAP_WIDTH > 36)
      && (giViewWorldScale != 6 || MAP_WIDTH > 72)
      && (giViewWorldScale != 4 || MAP_WIDTH > 108) )
    {
      switch ( MAP_HEIGHT )
      {
        case 36:
          v10 = 4.0;
          break;
        case 72:
          v10 = 2.0;
          break;
        case 108:
          v10 = 1.3333;
          break;
        default:
          v10 = 1.0;
          break;
      }
      v8 = *((_DWORD *)v4 + 4);
      v7 = *((_DWORD *)v4 + 5);
      v8 = (signed __int64)((double)(v8 - 480) / v10);
      v7 = (signed __int64)((double)(v7 - 16) / v10);
      iVWMapOriginX = v8 - iVWCenterOffset;
      iVWMapOriginY = v7 - iVWCenterOffset;
      if ( v8 - iVWCenterOffset < 0 )
        iVWMapOriginX = 0;
      if ( iVWMapOriginY < 0 )
        iVWMapOriginY = 0;
      if ( iVWViewableCells + iVWMapOriginX >= MAP_WIDTH )
        iVWMapOriginY = MAP_WIDTH - iVWViewableCells;
      if ( iVWMapOriginY + iVWViewableCells >= MAP_HEIGHT )
        iVWMapOriginY = MAP_HEIGHT - iVWViewableCells;
      advManager::UpdateRadar(gpAdvManager, 1, 0);
      advManager::VWCompleteDraw(gpAdvManager);
      v9 = 0;
      while ( v9 != 16 )
      {
        Process1WindowsMessage();
        memcpy(&v9, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
        memcpy(&v11, &v9, 0x1Cu);
        while ( v9 != 16 && v9 )
        {
          if ( v9 == 4 )
            memcpy(&v11, &v9, 0x1Cu);
          Process1WindowsMessage();
          memcpy(&v9, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&v5), 0x1Cu);
        }
        if ( v11 == 4 )
        {
          if ( v12 < 480 )
            v12 = 480;
          if ( v12 >= 624 )
            v12 = 2 * MAP_WIDTH + 479;
          if ( v13 < 16 )
            v13 = 16;
          if ( v13 >= 160 )
            v13 = 2 * MAP_HEIGHT + 15;
          (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
          v8 = (signed __int64)((double)(v12 - 480) / v10);
          v7 = (signed __int64)((double)(v13 - 16) / v10);
          iVWMapOriginX = v8 - iVWCenterOffset;
          iVWMapOriginY = v7 - iVWCenterOffset;
          if ( v8 - iVWCenterOffset < 0 )
            iVWMapOriginX = 0;
          if ( iVWMapOriginY < 0 )
            iVWMapOriginY = 0;
          if ( iVWViewableCells + iVWMapOriginX >= MAP_WIDTH )
            iVWMapOriginX = MAP_WIDTH - iVWViewableCells;
          if ( iVWMapOriginY + iVWViewableCells >= MAP_HEIGHT )
            iVWMapOriginY = MAP_HEIGHT - iVWViewableCells;
          advManager::UpdateRadar(gpAdvManager, 1, 0);
          advManager::VWCompleteDraw(gpAdvManager);
          v11 = 0;
        }
      }
    }
    return 1;
  }
  if ( v3 == 13 )
  {
    v2 = *((_DWORD *)v4 + 2);
    if ( v2 > 30723 )
    {
      if ( v2 < 30725 || v2 > 30726 )
        return 1;
    }
    else if ( v2 < 30720 )
    {
      if ( v2 == 2 )
      {
        advManager::VWCleanup();
        if ( giViewWorldScale == 12 )
        {
          giViewWorldScale = 6;
        }
        else if ( giViewWorldScale == 6 )
        {
          giViewWorldScale = 4;
        }
        else
        {
          giViewWorldScale = 12;
        }
        advManager::VWInit(gpAdvManager, iVWCenterOffset + iVWMapOriginX, iVWMapOriginY + iVWCenterOffset);
        advManager::VWCompleteDraw(gpAdvManager);
      }
      return 1;
    }
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    return 2;
  }
  return 1;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5240A8: using guessed type int gpSoundManager;
// 52FF5C: using guessed type int iVWMapOriginX;
// 52FF60: using guessed type int iVWMapOriginY;
// 52FF64: using guessed type int iVWCenterOffset;
// 52FF68: using guessed type int iVWViewableCells;

//----- (0049AD70) --------------------------------------------------------
void __cdecl DDRestoreDisplayMode()
{
  MACRO_DDERR errorCode; // [sp+Ch] [bp-4h]@2

  if ( lpDD )
  {
    errorCode = ((int (__cdecl *)(_DWORD))(*lpDD)[19].lpVtbl)(lpDD);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519724 + 7);
  }
}
// 519724: using guessed type __int16 word_519724;

//----- (0049ADD0) --------------------------------------------------------
signed int __cdecl DDQueryNewPalette()
{
  signed int result; // eax@2

  if ( gbWinGraphBusy )
  {
    result = 1;
  }
  else if ( gbForegroundApp )
  {
    result = SetPalette();
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F0A10: using guessed type int gbForegroundApp;
// 519708: using guessed type int gbWinGraphBusy;

//----- (0049AE20) --------------------------------------------------------
int __cdecl CreatePrimary()
{
  int result; // eax@1
  MACRO_DDERR errorCode; // [sp+Ch] [bp-4h]@2

  result = DDCreateSurface(640, 480, 1);
  lpDDSPrimary = result;
  if ( lpClipper )
  {
    errorCode = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)lpDDSPrimary + 112))(lpDDSPrimary, 0);
    if ( errorCode )
    {
      if ( errorCode != -2005532104 )
        DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519748 + 10);
    }
    result = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)lpClipper + 8))(lpClipper);
    lpClipper = 0;
  }
  return result;
}
// 519714: using guessed type int lpDDSPrimary;
// 51971C: using guessed type int lpClipper;
// 519748: using guessed type __int16 word_519748;

//----- (0049AEC0) --------------------------------------------------------
void __cdecl SetupClipper()
{
  MACRO_DDERR errorCode; // [sp+Ch] [bp-4h]@2
  MACRO_DDERR errorCodea; // [sp+Ch] [bp-4h]@4
  MACRO_DDERR errorCodeb; // [sp+Ch] [bp-4h]@6

  if ( !*(&bMenu + 7 * giCurExe + 5) )
  {
    errorCode = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*lpDD)[4].lpVtbl)(lpDD, 0, &lpClipper, 0);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_51976C + 8);
    errorCodea = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)lpClipper + 32))(lpClipper, 0, hwndApp);
    if ( errorCodea )
      DDSD(errorCodea, "F:\\h2xsrc\\Source\\wingraph.cpp", word_51976C + 13);
    errorCodeb = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)lpDDSPrimary + 112))(lpDDSPrimary, lpClipper);
    if ( errorCodeb )
      DDSD(errorCodeb, "F:\\h2xsrc\\Source\\wingraph.cpp", word_51976C + 18);
  }
}
// 4F2E88: using guessed type int giCurExe;
// 519714: using guessed type int lpDDSPrimary;
// 51971C: using guessed type int lpClipper;
// 51976C: using guessed type __int16 word_51976C;

//----- (0049AFB0) --------------------------------------------------------
void __cdecl DDInitGraphics()
{
  MACRO_DDERR errorCode; // [sp+Ch] [bp-4h]@2
  MACRO_DDERR errorCodea; // [sp+Ch] [bp-4h]@5
  MACRO_DDERR errorCodeb; // [sp+Ch] [bp-4h]@7
  MACRO_DDERR errorCodec; // [sp+Ch] [bp-4h]@10

  if ( !gbWinGraphBusy )
  {
    errorCode = lpDirectDrawCreate(NULL, &lpDD, NULL);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_5197D0 + 8);
    if ( *(&bMenu + 7 * giCurExe + 5) )
    {
      SetMenuStatus(0);
      errorCodea = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*lpDD)[20].lpVtbl)(lpDD, hwndApp, 19);
      if ( errorCodea )
        DDSD(errorCodea, "F:\\h2xsrc\\Source\\wingraph.cpp", word_5197D0 + 20);
      errorCodeb = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*lpDD)[21].lpVtbl)(lpDD, 640, 480, 8);
      if ( errorCodeb )
        DDSD(errorCodeb, "F:\\h2xsrc\\Source\\wingraph.cpp", word_5197D0 + 24);
    }
    else
    {
      errorCodec = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*lpDD)[20].lpVtbl)(lpDD, hwndApp, 8);
      if ( errorCodec )
        DDSD(errorCodec, "F:\\h2xsrc\\Source\\wingraph.cpp", word_5197D0 + 31);
    }
    CreatePrimary();
    SetupClipper();
    lpDDSOne = DDCreateSurface(640, 480, 0);
    InitializePalette();
  }
}
// 4F2E88: using guessed type int giCurExe;
// 519708: using guessed type int gbWinGraphBusy;
// 51970C: using guessed type int (__cdecl *lpDirectDrawCreate)(_DWORD, _DWORD, _DWORD);
// 519718: using guessed type int lpDDSOne;
// 5197D0: using guessed type __int16 word_5197D0;

//----- (0049B110) --------------------------------------------------------
signed int __thiscall DDAppPaint(HWND this)
{
  signed int result; // eax@2
  int v2; // eax@44
  HWND hWnd; // [sp+10h] [bp-5Ch]@1
  struct tagPOINT Point; // [sp+14h] [bp-58h]@18
  struct tagPAINTSTRUCT Paint; // [sp+1Ch] [bp-50h]@7
  __int32 v6; // [sp+5Ch] [bp-10h]@14
  int v7; // [sp+60h] [bp-Ch]@14
  int v8; // [sp+64h] [bp-8h]@14
  __int32 v9; // [sp+68h] [bp-4h]@14

  hWnd = this;
  if ( gbWinGraphBusy )
  {
    result = 1;
  }
  else if ( gbMinimized )
  {
    result = 1;
  }
  else if ( lpDD )
  {
    gbWinGraphBusy = 1;
    BeginPaint(this, &Paint);
    GetClientRect(hWnd, &Rect);
    if ( !Paint.rcPaint.right || !Paint.rcPaint.bottom )
    {
      Paint.rcPaint.left = Rect.left;
      Paint.rcPaint.top = Rect.top;
      Paint.rcPaint.right = Rect.right;
      Paint.rcPaint.bottom = Rect.bottom;
    }
    if ( Paint.rcPaint.right < 640 )
      ++Paint.rcPaint.right;
    if ( Paint.rcPaint.bottom < 480 )
      ++Paint.rcPaint.bottom;
    rc.left = Paint.rcPaint.left;
    rc.top = Paint.rcPaint.top;
    rc.right = Paint.rcPaint.right;
    rc.bottom = Paint.rcPaint.bottom;
    v9 = ((5 * (dword_530438 - rc.left) + 5) << 7) / iMainWinScreenWidth;
    v8 = 160 * (3 * (dword_53043C - dword_530434) + 3) / iMainWinScreenHeight;
    v6 = 640 * rc.left / iMainWinScreenWidth;
    v7 = 480 * dword_530434 / iMainWinScreenHeight;
    if ( giScrollX )
    {
      v6 = giScrollX + 16;
      v9 = 448;
    }
    if ( giScrollY )
    {
      v7 = giScrollY + 16;
      v8 = 448;
    }
    dword_530420 = v6;
    dword_530428 = v6 + v9 - 1;
    dword_530424 = v7;
    dword_53042C = v7 + v8 - 1;
    Point.y = 0;
    Point.x = 0;
    ClientToScreen(hwndApp, &Point);
    OffsetRect(&rc, Point.x, Point.y);
    errorCode = (*(int (__cdecl **)(int, _DWORD))(*(_DWORD *)lpDDSOne + 128))(lpDDSOne, 0);
    if ( errorCode )
      DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 71);
    if ( dword_530420 < 0 )
      dword_530420 = 0;
    if ( dword_530424 < 0 )
      dword_530424 = 0;
    if ( dword_530428 > 640 )
      dword_530428 = 640;
    if ( dword_53042C > 480 )
      dword_53042C = 480;
    lPaintStart = KBTickCount();
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          errorCode = (*(int (__cdecl **)(int, struct tagRECT *, int, int *, signed int, _DWORD))(*(_DWORD *)lpDDSPrimary
                                                                                                + 20))(
                        lpDDSPrimary,
                        &rc,
                        lpDDSOne,
                        &dword_530420,
                        16777216,
                        0);
          if ( errorCode != -2005532222 )
            break;
          errorCode = (*(int (__cdecl **)(int))(*(_DWORD *)lpDDSPrimary + 108))(lpDDSPrimary);
          if ( errorCode == -2005532085 )
          {
            LogStr("ResetDisplayMode");
            errorCode = ((int (__cdecl *)(LPDIRECTDRAW *, signed int, signed int, signed int))(*lpDD)[21].lpVtbl)(
                          lpDD,
                          640,
                          480,
                          8);
            if ( errorCode )
              DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 91);
            errorCode = (*(int (__cdecl **)(int))(*(_DWORD *)lpDDSPrimary + 108))(lpDDSPrimary);
            if ( errorCode )
              DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 95);
            rc.left = dword_530420;
            rc.top = *(&dword_530420 + 1);
            rc.right = *(&dword_530420 + 2);
            rc.bottom = *(&dword_530420 + 3);
          }
          if ( errorCode )
            DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 103);
        }
        if ( errorCode != -2005532242 || KBTickCount() >= lPaintStart + 10000 )
          break;
        ++iBusyRetry;
      }
      if ( !errorCode )
        break;
      DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 108);
    }
    memset(&dword_52FF80, 0, 0x6Cu);
    *(_DWORD *)&dword_52FF80 = 108;
    v2 = (*(int (__cdecl **)(int, _DWORD, void *, signed int, _DWORD))(*(_DWORD *)lpDDSOne + 100))(
           lpDDSOne,
           0,
           &dword_52FF80,
           1,
           0);
    errorCode = v2;
    if ( v2 )
      DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 118);
    if ( gpWindowManager->screenBuffer )
    {
      gpWindowManager->screenBuffer->contents = (signed __int8 *)dword_52FFA4;
      lpInitWin = (bitmap *)dword_52FFA4;
    }
    else
    {
      lpInitWin = (bitmap *)dword_52FFA4;
    }
    if ( errorCode )
      DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519858 + 129);
    EndPaint(hWnd, &Paint);
    gbWinGraphBusy = 0;
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F2E78: using guessed type int giScrollX;
// 4F2E7C: using guessed type int giScrollY;
// 4F3080: using guessed type int gbMinimized;
// 519708: using guessed type int gbWinGraphBusy;
// 519714: using guessed type int lpDDSPrimary;
// 519718: using guessed type int lpDDSOne;
// 5197D4: using guessed type int iBusyRetry;
// 519858: using guessed type __int16 word_519858;
// 52FFA4: using guessed type int dword_52FFA4;
// 530420: using guessed type int dword_530420;
// 530424: using guessed type int dword_530424;
// 530428: using guessed type int dword_530428;
// 53042C: using guessed type int dword_53042C;
// 530434: using guessed type int dword_530434;
// 530438: using guessed type int dword_530438;
// 53043C: using guessed type int dword_53043C;
// 530440: using guessed type int lPaintStart;

//----- (0049B640) --------------------------------------------------------
void __cdecl DDInitializePalette()
{
  HDC dc; // ST24_4@2
  MACRO_DDERR errorCode; // [sp+10h] [bp-8h]@8
  signed int i; // [sp+14h] [bp-4h]@2
  signed int j; // [sp+14h] [bp-4h]@5

  if ( !gbWinGraphBusy )
  {
    dc = GetDC(0);
    GetSystemPaletteEntries(dc, 0, 10u, LogicalPalette.palPalEntry);
    GetSystemPaletteEntries(dc, SPECIAL_PALETTE_INDICES_2, 10u, (LPPALETTEENTRY)&LogicalPalette + 247);
    ReleaseDC(0, dc);
    for ( i = 0; i < 10; ++i )
    {
      LogicalPalette.palPalEntry[i].peFlags = 0;
      byte_5196D7[4 * i] = 0;
    }
    for ( j = 10; j < 246; ++j )
    {
      LogicalPalette.palPalEntry[j].peRed = 0;
      LogicalPalette.palPalEntry[j].peGreen = 0;
      LogicalPalette.palPalEntry[j].peBlue = 0;
      LogicalPalette.palPalEntry[j].peFlags = PC_NOCOLLAPSE;
    }
    errorCode = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*lpDD)[5].lpVtbl)(
                  lpDD,
                  4,
                  LogicalPalette.palPalEntry,
                  &lpDDPal,
                  0);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519950 + 63);
    SetPalette();
  }
}
// 519708: using guessed type int gbWinGraphBusy;
// 519950: using guessed type __int16 word_519950;

//----- (0049B780) --------------------------------------------------------
signed int __cdecl DDSetPalette()
{
  signed int result; // eax@2
  MACRO_DDERR errorCode; // [sp+Ch] [bp-4h]@9

  if ( gbWinGraphBusy )
  {
    result = 1;
  }
  else if ( gbForegroundApp )
  {
    if ( lpDDPal && lpDDSPrimary && lpDD )
    {
      errorCode = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)lpDDSPrimary + 124))(lpDDSPrimary, lpDDPal);
      if ( errorCode )
        DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519974 + 15);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 4F0A10: using guessed type int gbForegroundApp;
// 519708: using guessed type int gbWinGraphBusy;
// 519714: using guessed type int lpDDSPrimary;
// 519974: using guessed type __int16 word_519974;

//----- (0049B830) --------------------------------------------------------
int __fastcall DDCreateSurface(int a1, int a2, int a3)
{
  int v4; // [sp+Ch] [bp-84h]@1
  int v5; // [sp+10h] [bp-80h]@1
  int v6; // [sp+14h] [bp-7Ch]@4
  signed int errorCode; // [sp+18h] [bp-78h]@4
  int v8; // [sp+24h] [bp-6Ch]@1
  int v9; // [sp+28h] [bp-68h]@2
  int v10; // [sp+2Ch] [bp-64h]@3
  int v11; // [sp+30h] [bp-60h]@3
  signed __int8 *v12; // [sp+48h] [bp-48h]@10
  int v13; // [sp+8Ch] [bp-4h]@2

  v4 = a2;
  v5 = a1;
  memset(&v8, 0, 0x6Cu);
  v8 = 108;
  if ( a3 )
  {
    v9 = 1;
    v13 = 512;
  }
  else
  {
    v9 = 7;
    v13 = 2112;
    v10 = v4;
    v11 = v5;
  }
  errorCode = ((int (__cdecl *)(LPDIRECTDRAW *, int *, int *, _DWORD))(*lpDD)[6].lpVtbl)(lpDD, &v8, &v6, 0);
  if ( errorCode )
    DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519998 + 28);
  if ( !a3 )
  {
    errorCode = (*(int (__cdecl **)(int, _DWORD, int *, signed int, _DWORD))(*(_DWORD *)v6 + 100))(v6, 0, &v8, 1, 0);
    if ( errorCode )
      DDSD((MACRO_DDERR)errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519998 + 36);
    if ( gpWindowManager->screenBuffer )
    {
      gpWindowManager->screenBuffer->contents = v12;
      lpInitWin = (bitmap *)v12;
    }
    else
    {
      lpInitWin = (bitmap *)v12;
    }
  }
  return v6;
}
// 519998: using guessed type __int16 word_519998;

//----- (0049B970) --------------------------------------------------------
void __fastcall DDSD(MACRO_DDERR errorCode, char *file, int lineno)
{
  char *filea; // [sp+10h] [bp-D8h]@1
  MACRO_DDERR errorCodea; // [sp+14h] [bp-D4h]@1
  char errorStr[200]; // [sp+18h] [bp-D0h]@3
  int v6; // [sp+E0h] [bp-8h]@2
  int v7; // [sp+E4h] [bp-4h]@2

  filea = file;
  errorCodea = errorCode;
  if ( !bInDDSD )
  {
    bInDDSD = 1;
    v6 = ((int (__cdecl *)(LPDIRECTDRAW *))(*lpDD)[19].lpVtbl)(lpDD);
    v7 = 0;
    if ( errorCodea > DDERR_GENERIC )
    {
      if ( errorCodea > DDERR_INVALIDPARAMS )
      {
        if ( errorCodea > DDERR_INVALIDCLIPLIST )
        {
          if ( errorCodea > DDERR_INVALIDRECT )
          {
            if ( errorCodea > DDERR_NOALPHAHW )
            {
              if ( errorCodea > DDERR_NOEXCLUSIVEMODE )
              {
                if ( errorCodea > DDERR_NORASTEROPHW )
                {
                  if ( errorCodea > DDERR_NOSTRETCHHW )
                  {
                    if ( errorCodea > DDERR_NOZBUFFERHW )
                    {
                      if ( errorCodea > DDERR_SURFACELOST )
                      {
                        if ( errorCodea <= DDERR_WRONGMODE )
                        {
                          if ( errorCodea == DDERR_WRONGMODE )
                          {
                            strcpy(errorStr, "DDERR_WRONGMODE          ");
                          }
                          else
                          {
                            switch ( errorCodea + 2005532105 )
                            {
                              case 8:
                                strcpy(errorStr, "DDERR_NOBLTHW\t         ");
                                break;
                              case 9:
                                strcpy(errorStr, "DDERR_NODDROPSHW\t      ");
                                break;
                              case 0:
                                strcpy(errorStr, "DDERR_CLIPPERISUSINGHWND ");
                                break;
                              case 5:
                                strcpy(errorStr, "DDERR_NOPALETTEATTACHED  ");
                                break;
                              case 6:
                                strcpy(errorStr, "DDERR_NOPALETTEHW\t      ");
                                break;
                              case 1:
                                strcpy(errorStr, "DDERR_NOCLIPPERATTACHED  ");
                                break;
                              default:
                                goto LABEL_31;
                            }
                          }
                          goto LABEL_78;
                        }
                        if ( errorCodea != -2005532084 )
                        {
                          if ( errorCodea == 0 )
                            return;
                          goto LABEL_31;
                        }
                        strcpy(errorStr, "DDERR_IMPLICITLYCREATED  ");
                      }
                      else if ( errorCodea == DDERR_SURFACELOST )
                      {
                        strcpy(errorStr, "DDERR_SURFACELOST        ");
                      }
                      else
                      {
                        if ( errorCodea != DDERR_SURFACEBUSY )
                          goto LABEL_31;
                        strcpy(errorStr, "DDERR_SURFACEBUSY        ");
                      }
                    }
                    else if ( errorCodea == DDERR_NOZBUFFERHW )
                    {
                      strcpy(errorStr, "DDERR_NOZBUFFERHW        ");
                    }
                    else
                    {
                      if ( errorCodea != -2005532352 )
                        goto LABEL_31;
                      strcpy(errorStr, "DDERR_NOT8BITCOLOR       ");
                    }
                  }
                  else if ( errorCodea == DDERR_NOSTRETCHHW )
                  {
                    strcpy(errorStr, "DDERR_NOSTRETCHHW\t      ");
                  }
                  else
                  {
                    if ( errorCodea != -2005532382 )
                      goto LABEL_31;
                    strcpy(errorStr, "DDERR_NOROTATIONHW       ");
                  }
                }
                else if ( errorCodea == DDERR_NORASTEROPHW )
                {
                  strcpy(errorStr, "DDERR_NORASTEROPHW\t      ");
                }
                else
                {
                  if ( errorCodea != -2005532422 )
                    goto LABEL_31;
                  strcpy(errorStr, "DDERR_NOMIRRORHW         ");
                }
              }
              else if ( errorCodea == DDERR_NOEXCLUSIVEMODE )
              {
                strcpy(errorStr, "DDERR_NOEXCLUSIVEMODE\t   ");
              }
              else
              {
                if ( errorCodea != -2005532467 )
                  goto LABEL_31;
                strcpy(errorStr, "DDERR_NOCLIPLIST         ");
              }
            }
            else if ( errorCodea == DDERR_NOALPHAHW )
            {
              strcpy(errorStr, "DDERR_NOALPHAHW          ");
            }
            else
            {
              if ( errorCodea != DDERR_LOCKEDSURFACES )
                goto LABEL_31;
              strcpy(errorStr, "DDERR_LOCKEDSURFACES     ");
            }
          }
          else if ( errorCodea == DDERR_INVALIDRECT )
          {
            strcpy(errorStr, "DDERR_INVALIDRECT\t      ");
          }
          else
          {
            if ( errorCodea != DDERR_INVALIDOBJECT )
              goto LABEL_31;
            strcpy(errorStr, "DDERR_INVALIDOBJECT      ");
          }
        }
        else if ( errorCodea == DDERR_INVALIDCLIPLIST )
        {
          strcpy(errorStr, "DDERR_INVALIDCLIPLIST\t   ");
        }
        else
        {
          if ( errorCodea != DDERR_INCOMPATIBLEPRIMARY )
            goto LABEL_31;
          strcpy(errorStr, "DDERR_INCOMPATIBLEPRIMARY");
        }
      }
      else if ( errorCodea == DDERR_INVALIDPARAMS )
      {
        strcpy(errorStr, "DDERR_INVALIDPARAMS\t   ");
      }
      else
      {
        if ( errorCodea != DDERR_OUTOFMEMORY )
          goto LABEL_31;
        strcpy(errorStr, "DDERR_OUTOFMEMORY\t      ");
      }
    }
    else if ( errorCodea == DDERR_GENERIC )
    {
      strcpy(errorStr, "DDERR_GENERIC            ");
    }
    else
    {
      if ( errorCodea != -2147467263 )
      {
LABEL_31:
        strcpy(errorStr, "Error type unknown");
        goto LABEL_78;
      }
      strcpy(errorStr, "DDERR_UNSUPPORTED\t      ");
    }
LABEL_78:
    MessageBeep(MB_OK);
    MessageBeep(MB_OK);
    MessageBeep(MB_OK);
    sprintf(gText, "DirectDraw Error:\n\n  '%s'\n\n  File: '%s'\n  Line: %d", errorStr, filea, lineno);
    LogStr(gText);
    ShutDown(gText);
  }
}
// 51999C: using guessed type int bInDDSD;

//----- (0049BF40) --------------------------------------------------------
void __thiscall DDUpdatePalette(RGB *this)
{
  MACRO_DDERR errorCode; // [sp+10h] [bp-8h]@6
  signed int i; // [sp+14h] [bp-4h]@3

  if ( !gbWinGraphBusy && gbForegroundApp )
  {
    for ( i = 10; i < SPECIAL_PALETTE_INDICES_2; ++i )
    {
      LogicalPalette.palPalEntry[i].peRed = 4 * this[i].red;
      LogicalPalette.palPalEntry[i].peGreen = 4 * this[i].green;
      LogicalPalette.palPalEntry[i].peBlue = 4 * this[i].blue;
      LogicalPalette.palPalEntry[i].peFlags = PC_NOCOLLAPSE;
    }
    ProcessAssert(lpDDPal, "F:\\h2xsrc\\Source\\wingraph.cpp", fiveHundred + 18);
    errorCode = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)lpDDPal + 24))(
                  lpDDPal,
                  0,
                  10,
                  236,
                  (char *)&LogicalPalette + 44);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", fiveHundred + 22);
  }
}
// 4F0A10: using guessed type int gbForegroundApp;
// 519708: using guessed type int gbWinGraphBusy;

//----- (0049C060) --------------------------------------------------------
void __cdecl DDCleanUpWinGraphics()
{
  MACRO_DDERR errorCode; // [sp+10h] [bp-4h]@4
  MACRO_DDERR errorCodea; // [sp+10h] [bp-4h]@14

  if ( lpDD )
  {
    ((void (__cdecl *)(_DWORD))(*lpDD)[19].lpVtbl)(lpDD);
    if ( lpClipper )
    {
      if ( lpDDSPrimary )
      {
        errorCode = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)lpDDSPrimary + 112))(lpDDSPrimary, 0);
        if ( errorCode )
        {
          if ( errorCode != -2005532104 )
            DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519D70 + 14);
        }
      }
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)lpClipper + 8))(lpClipper);
      lpClipper = 0;
    }
    if ( lpDDSPrimary )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)lpDDSPrimary + 8))(lpDDSPrimary);
      lpDDSPrimary = 0;
    }
    if ( lpDDSOne )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)lpDDSOne + 8))(lpDDSOne);
      lpDDSOne = 0;
    }
    if ( lpDDPal )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)lpDDPal + 8))(lpDDPal);
      lpDDPal = 0;
    }
    errorCodea = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*lpDD)[20].lpVtbl)(lpDD, hwndApp, 8);
    if ( errorCodea )
      DDSD(errorCodea, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519D70 + 38);
    ((void (__cdecl *)(_DWORD))(*lpDD)[2].lpVtbl)(lpDD);
    lpDD = 0;
  }
}
// 519714: using guessed type int lpDDSPrimary;
// 519718: using guessed type int lpDDSOne;
// 51971C: using guessed type int lpClipper;
// 519D70: using guessed type __int16 word_519D70;

//----- (0049C1E0) --------------------------------------------------------
void __thiscall DDSetFullScreenStatus(void *this)
{
  int y; // [sp+10h] [bp-14h]@3
  MACRO_DDERR errorCode; // [sp+14h] [bp-10h]@5
  MACRO_DDERR errorCodea; // [sp+14h] [bp-10h]@8
  MACRO_DDERR errorCodeb; // [sp+14h] [bp-10h]@11
  MACRO_DDERR errorCodec; // [sp+14h] [bp-10h]@13
  MACRO_DDERR errorCoded; // [sp+14h] [bp-10h]@17
  int x; // [sp+18h] [bp-Ch]@3
  unsigned int heightNeededToDisplay; // [sp+1Ch] [bp-8h]@3
  unsigned int width; // [sp+20h] [bp-4h]@3

  if ( !gbWinGraphBusy && (void *)*(&bMenu + 7 * giCurExe + 5) != this )
  {
    x = *(&bMenu + 7 * giCurExe + 1);
    y = *(&bMenu + 7 * giCurExe + 2);
    width = *(&bMenu + 7 * giCurExe + 3);
    heightNeededToDisplay = *(&bMenu + 7 * giCurExe + 4);
    gbWinGraphBusy = 1;
    *(&bMenu + 7 * giCurExe + 5) = (BOOL)this;
    if ( *(&bMenu + 7 * giCurExe + 5) )
      SetMenuStatus(0);
    errorCode = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*lpDD)[20].lpVtbl)(lpDD, hwndApp, 19);
    if ( errorCode )
      DDSD(errorCode, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519DB4 + 21);
    if ( *(&bMenu + 7 * giCurExe + 5) )
    {
      errorCodea = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))(*lpDD)[21].lpVtbl)(lpDD, 640, 480, 8);
      if ( errorCodea )
        DDSD(errorCodea, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519DB4 + 27);
    }
    else
    {
      errorCodeb = ((int (__cdecl *)(_DWORD))(*lpDD)[19].lpVtbl)(lpDD);
      if ( errorCodeb )
        DDSD(errorCodeb, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519DB4 + 34);
      errorCodec = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*lpDD)[20].lpVtbl)(lpDD, hwndApp, 8);
      if ( errorCodec )
        DDSD(errorCodec, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519DB4 + 39);
    }
    if ( lpDDSPrimary )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)lpDDSPrimary + 8))(lpDDSPrimary);
      lpDDSPrimary = 0;
    }
    CreatePrimary();
    errorCoded = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)lpDDSPrimary + 124))(lpDDSPrimary, lpDDPal);
    if ( errorCoded )
      DDSD(errorCoded, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519DB4 + 51);
    WritePrefs();
    gbWinGraphBusy = 0;
    if ( *(&bMenu + 7 * giCurExe + 5) )
    {
      *(&bMenu + 7 * giCurExe + 1) = x;
      *(&bMenu + 7 * giCurExe + 2) = y;
      *(&bMenu + 7 * giCurExe + 3) = width;
      *(&bMenu + 7 * giCurExe + 4) = heightNeededToDisplay;
    }
    else
    {
      SetMenuStatus(1);
      ResizeWindow(x, y, width, heightNeededToDisplay);
    }
    SetupClipper();
  }
}
// 4F2E88: using guessed type int giCurExe;
// 519708: using guessed type int gbWinGraphBusy;
// 519714: using guessed type int lpDDSPrimary;
// 519DB4: using guessed type __int16 word_519DB4;

//----- (0049C4F0) --------------------------------------------------------
signed int __cdecl WGQueryNewPalette()
{
  UINT v0; // ST1C_4@3
  signed int result; // eax@4
  HDC hDC; // [sp+Ch] [bp-8h]@1

  hDC = GetDC(hwndApp);
  if ( hpalApp )
    SelectPalette(hDC, hpalApp, 0);
  v0 = RealizePalette(hDC);
  ReleaseDC(hwndApp, hDC);
  if ( (signed int)v0 <= 0 )
  {
    result = 0;
  }
  else
  {
    InvalidateRect(hwndApp, 0, 1);
    result = 1;
  }
  return result;
}

//----- (0049C580) --------------------------------------------------------
void __cdecl WGInitGraphics()
{
  int v0; // ST24_4@5

  if ( !hdcImage )
  {
    if ( thunk_WinGRecommendDIBFormat((int)&screenImage) )
    {
      word_52FFFE = 8;
      dword_530000 = 0;
      Orientation = dword_52FFF8;
    }
    else
    {
      screenImage = 40;
      word_52FFFC = 1;
      word_52FFFE = 8;
      dword_530000 = 0;
      dword_530004 = 0;
      dword_530010 = 0;
      dword_530014 = 0;
    }
    dword_52FFF4 = 640;
    dword_52FFF8 = -480;
    InitializePalette();
    hdcImage = (HDC)thunk_WinGCreateDC();
    dword_52FFF4 = 640;
    dword_52FFF8 = -480;
    v0 = thunk_WinGCreateBitmap((int)hdcImage, (int)&screenImage, (int)(&screenImage + 266));
    dword_530004 = Orientation * dword_52FFF8 * dword_52FFF4;
    gbmOldMonoBitmap = SelectObject(hdcImage, (HGDIOBJ)v0);
    lpInitWin = (bitmap *)dword_530418;
    PatBlt(hdcImage, 0, 0, iMainWinScreenWidth, iMainWinScreenHeight, 0x42u);
  }
}
// 5192F4: using guessed type int Orientation;
// 52FFF0: using guessed type int screenImage;
// 52FFF4: using guessed type int dword_52FFF4;
// 52FFF8: using guessed type int dword_52FFF8;
// 52FFFC: using guessed type __int16 word_52FFFC;
// 52FFFE: using guessed type __int16 word_52FFFE;
// 530000: using guessed type int dword_530000;
// 530004: using guessed type int dword_530004;
// 530010: using guessed type int dword_530010;
// 530014: using guessed type int dword_530014;
// 530418: using guessed type int dword_530418;

//----- (0049C6E0) --------------------------------------------------------
#error "49C6E0: undefined or illegal type '#72' (funcsize=125)"

//----- (0049C8D0) --------------------------------------------------------
void __cdecl WGInitializePalette()
{
  HDC v0; // ST1C_4@2
  signed int i; // [sp+10h] [bp-4h]@2
  signed int j; // [sp+10h] [bp-4h]@5

  if ( !hpalApp )
  {
    v0 = GetDC(0);
    GetSystemPaletteEntries(v0, 0, 0xAu, LogicalPalette.palPalEntry);
    GetSystemPaletteEntries(v0, 0xF6u, 0xAu, (LPPALETTEENTRY)&LogicalPalette + 247);
    ReleaseDC(0, v0);
    for ( i = 0; i < 10; ++i )
    {
      redBlueSwappedGlobalPaletteEntries[i].peBlue = LogicalPalette.palPalEntry[i].peRed;
      redBlueSwappedGlobalPaletteEntries[i].peGreen = LogicalPalette.palPalEntry[i].peGreen;
      redBlueSwappedGlobalPaletteEntries[i].peRed = LogicalPalette.palPalEntry[i].peBlue;
      redBlueSwappedGlobalPaletteEntries[i].peFlags = 0;
      LogicalPalette.palPalEntry[i].peFlags = 0;
      byte_5303F2[4 * i] = byte_5196D4[4 * i];
      byte_5303F1[4 * i] = byte_5196D5[4 * i];
      byte_5303F0[4 * i] = byte_5196D6[4 * i];
      byte_5303F3[4 * i] = 0;
      byte_5196D7[4 * i] = 0;
    }
    for ( j = 10; j < 246; ++j )
    {
      LogicalPalette.palPalEntry[j].peRed = 0;
      redBlueSwappedGlobalPaletteEntries[j].peBlue = LogicalPalette.palPalEntry[j].peRed;
      LogicalPalette.palPalEntry[j].peGreen = 0;
      redBlueSwappedGlobalPaletteEntries[j].peGreen = LogicalPalette.palPalEntry[j].peGreen;
      LogicalPalette.palPalEntry[j].peBlue = 0;
      redBlueSwappedGlobalPaletteEntries[j].peRed = LogicalPalette.palPalEntry[j].peBlue;
      redBlueSwappedGlobalPaletteEntries[j].peFlags = 0;
      LogicalPalette.palPalEntry[j].peFlags = 4;
    }
    hpalApp = CreatePalette(&LogicalPalette);
  }
}

//----- (0049CAB0) --------------------------------------------------------
signed int __thiscall WGAppPaint(HWND this)
{
  HDC v2; // [sp+Ch] [bp-78h]@2
  HWND hWnd; // [sp+10h] [bp-74h]@1
  struct tagPAINTSTRUCT Paint; // [sp+20h] [bp-64h]@2
  int v5; // [sp+60h] [bp-24h]@2
  int v6; // [sp+64h] [bp-20h]@2
  int v7; // [sp+68h] [bp-1Ch]@2
  char v8; // [sp+70h] [bp-14h]@1
  struct tagRECT Rect; // [sp+74h] [bp-10h]@2

  hWnd = this;
  v8 = 0;
  if ( dword_530418 )
  {
    v2 = BeginPaint(this, &Paint);
    SelectPalette(v2, hpalApp, 0);
    RealizePalette(v2);
    GetClientRect(hWnd, &Rect);
    v7 = Rect.right - Rect.left;
    v5 = 0 / iMainWinScreenWidth;
    v6 = 0 / iMainWinScreenHeight;
    if ( giScrollX )
      v5 += giScrollX;
    if ( giScrollY )
      v6 += giScrollY;
    ++dword_519704;
    if ( iMainWinScreenWidth != 640 || iMainWinScreenHeight != 480 )
    {
      thunk_WinGStretchBlt(
        (int)v2,
        0,
        0,
        v7,
        Rect.bottom - Rect.top,
        (int)hdcImage,
        v5,
        v6,
        640 * v7 / iMainWinScreenWidth,
        480 * (Rect.bottom - Rect.top) / iMainWinScreenHeight);
    }
    else
    {
      v7 = Paint.rcPaint.right - (unsigned __int16)(Paint.rcPaint.left & 0xFFFC) + 1;
      thunk_WinGBitBlt(
        (int)v2,
        Paint.rcPaint.left & 0xFFFC,
        Paint.rcPaint.top,
        v7,
        Paint.rcPaint.bottom - Paint.rcPaint.top + 1,
        (int)hdcImage,
        giScrollX + (unsigned __int16)(Paint.rcPaint.left & 0xFFFC),
        giScrollY + Paint.rcPaint.top);
    }
    EndPaint(hWnd, &Paint);
  }
  return 1;
}
// 4F2E78: using guessed type int giScrollX;
// 4F2E7C: using guessed type int giScrollY;
// 519704: using guessed type int dword_519704;
// 530418: using guessed type int dword_530418;

//----- (0049CC80) --------------------------------------------------------
void __cdecl WGCleanUpWinGraphics()
{
  HGDIOBJ v0; // ST14_4@2

  if ( hdcImage )
  {
    v0 = SelectObject(hdcImage, gbmOldMonoBitmap);
    DeleteObject(v0);
    DeleteDC(hdcImage);
    hdcImage = 0;
  }
  if ( hpalApp )
  {
    DeleteObject(hpalApp);
    hpalApp = 0;
  }
}

//----- (0049CD00) --------------------------------------------------------
void __cdecl ConnectToDLLs()
{
  hDDrawLibrary = LoadLibraryA("DDRAW.DLL");
  if ( (unsigned int)hDDrawLibrary >= 0x20 )
    lpDirectDrawCreate = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcAddress(hDDrawLibrary, "DirectDrawCreate");
  if ( lpDirectDrawCreate )
  {
    gbDDrawAttached = 1;
  }
  else
  {
    *(&bMenu + 7 * giCurExe + 5) = 0;
    SetMenuStatus(1);
  }
}
// 4F2E88: using guessed type int giCurExe;
// 5192EC: using guessed type int gbDDrawAttached;
// 51970C: using guessed type int (__cdecl *lpDirectDrawCreate)(_DWORD, _DWORD, _DWORD);

//----- (0049CD80) --------------------------------------------------------
BOOL __cdecl DisconnectDLLs()
{
  BOOL result; // eax@2

  if ( (unsigned int)hDDrawLibrary >= 0x20 )
    result = FreeLibrary(hDDrawLibrary);
  return result;
}

//----- (0049CDB0) --------------------------------------------------------
void __cdecl RestoreDisplayMode()
{
  if ( giGraphicsType != 1 )
    DDRestoreDisplayMode();
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CDE0) --------------------------------------------------------
signed int __cdecl SetPalette()
{
  signed int result; // eax@2

  if ( giGraphicsType == 1 )
    result = 0;
  else
    result = DDSetPalette();
  return result;
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CE10) --------------------------------------------------------
void __cdecl GetGraphicsInfo()
{
  HDC hDC; // [sp+Ch] [bp-4h]@1

  hDC = GetDC(0);
  if ( hDC )
  {
    giMainVideoModeColorDepth = GetDeviceCaps(hDC, BITSPIXEL);
    giMainVideoModeWidth = GetDeviceCaps(hDC, HORZRES);
    giMainVideoModeHeight = GetDeviceCaps(hDC, VERTRES);
    ReleaseDC(0, hDC);
    if ( giMainVideoModeColorDepth < 8 )
      ShutDown("Heroes II requires 256 color mode or higher.\n\nTo change color mode, right click in an open area on the Windows 95 background, choose 'Properties', then the 'Settings' tab, then change the entry in the 'Color Palette Box'.");
  }
}
// 4F0A14: using guessed type int giMainVideoModeColorDepth;
// 4F0A18: using guessed type int giMainVideoModeWidth;
// 4F0A1C: using guessed type int giMainVideoModeHeight;

//----- (0049CE90) --------------------------------------------------------
void __cdecl InitGraphics()
{
  LogStr("IG1");
  ConnectToDLLs();
  LogStr("IG2");
  if ( *(&bMenu + 7 * giCurExe + 5) )
    giGraphicsType = 2;
  else
    giGraphicsType = 1;
  if ( giGraphicsType == 1 )
  {
    LogStr("IG3");
    WGInitGraphics();
    LogStr("IG4");
  }
  else
  {
    LogStr("IG5");
    DDInitGraphics();
    LogStr("IG6");
  }
}
// 4F2E88: using guessed type int giCurExe;
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CF30) --------------------------------------------------------
signed int __thiscall AppPaint(HWND this)
{
  signed int result; // eax@2

  if ( giGraphicsType == 1 )
    result = WGAppPaint(this);
  else
    result = DDAppPaint(this);
  return result;
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CF80) --------------------------------------------------------
void __cdecl InitializePalette()
{
  if ( giGraphicsType == 1 )
    WGInitializePalette();
  else
    DDInitializePalette();
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CFB0) --------------------------------------------------------
void __thiscall UpdatePalette(#72 *this)
{
  if ( giGraphicsType == 1 )
    WGUpdatePalette(this);
  else
    DDUpdatePalette((RGB *)this);
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049CFF0) --------------------------------------------------------
BOOL __cdecl CleanUpWinGraphics()
{
  if ( giGraphicsType == 1 )
    WGCleanUpWinGraphics();
  else
    DDCleanUpWinGraphics();
  return DisconnectDLLs();
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049D030) --------------------------------------------------------
void __thiscall SetFullScreenStatus(void *this)
{
  void *v1; // [sp+Ch] [bp-4h]@1

  v1 = this;
  if ( !gbInSmackMgr && (void *)*(&bMenu + 7 * giCurExe + 5) != this )
  {
    if ( giGraphicsType == 1 )
    {
      if ( !gbDDrawAttached )
        return;
      *(&bMenu + 7 * giCurExe + 5) = 1;
      if ( SetGraphicsType((void *)2) )
        DDSetFullScreenStatus(v1);
    }
    else if ( this )
    {
      DDSetFullScreenStatus(this);
    }
    else if ( gbWinGAttached )
    {
      SetGraphicsType((void *)1);
    }
    if ( v1 )
      CheckChangeCursor(0, 0, 1);
  }
}
// 4F2E88: using guessed type int giCurExe;
// 4F3088: using guessed type int gbInSmackMgr;
// 5192E8: using guessed type int gbWinGAttached;
// 5192EC: using guessed type int gbDDrawAttached;
// 5192F0: using guessed type int giGraphicsType;

//----- (0049D120) --------------------------------------------------------
signed int __cdecl QueryNewPalette()
{
  signed int result; // eax@2

  if ( giGraphicsType == 1 )
    result = WGQueryNewPalette();
  else
    result = DDQueryNewPalette();
  return result;
}
// 5192F0: using guessed type int giGraphicsType;

//----- (0049D160) --------------------------------------------------------
signed int __thiscall SetGraphicsType(void *this)
{
  signed int result; // eax@2
  void *v2; // [sp+Ch] [bp-1Ch]@1
  void *a1; // [sp+10h] [bp-18h]@9
  int y; // [sp+14h] [bp-14h]@9
  int x; // [sp+18h] [bp-10h]@9
  unsigned int heightNeededToDisplay; // [sp+1Ch] [bp-Ch]@9
  unsigned int width; // [sp+20h] [bp-8h]@9
  int v8; // [sp+24h] [bp-4h]@9

  v2 = this;
  if ( (void *)giGraphicsType == this )
  {
    result = 1;
  }
  else if ( this != (void *)1 || gbWinGAttached )
  {
    if ( this != (void *)2 || gbDDrawAttached )
    {
      v8 = *(&bMenu + 7 * giCurExe + 5);
      x = *(&bMenu + 7 * giCurExe + 1);
      y = *(&bMenu + 7 * giCurExe + 2);
      width = *(&bMenu + 7 * giCurExe + 3);
      heightNeededToDisplay = *(&bMenu + 7 * giCurExe + 4);
      a1 = BaseAlloc(0x4B000u, "F:\\h2xsrc\\Source\\wingraph.cpp", word_519F88 + 18);
      memcpy(a1, gpWindowManager->screenBuffer->contents, 0x4B000u);
      if ( v2 == (void *)1 )
      {
        *(&bMenu + 7 * giCurExe + 5) = 0;
        DDCleanUpWinGraphics();
        giGraphicsType = 1;
        WGInitGraphics();
        gpWindowManager->screenBuffer->contents = (signed __int8 *)lpInitWin;
      }
      else
      {
        WGCleanUpWinGraphics();
        giGraphicsType = 2;
        DDInitGraphics();
        gpWindowManager->screenBuffer->contents = (signed __int8 *)lpInitWin;
      }
      memcpy(gpWindowManager->screenBuffer->contents, a1, 0x4B000u);
      BaseFree(a1, (int)"F:\\h2xsrc\\Source\\wingraph.cpp", word_519F88 + 39);
      if ( v8 )
      {
        if ( v2 == (void *)1 )
        {
          SetMenuStatus(1);
          ResizeWindow(x, y, width, heightNeededToDisplay);
        }
      }
      BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 640u, 480, 0, 0);
      UpdatePalette((#72 *)gpBufferPalette->contents);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F2E88: using guessed type int giCurExe;
// 5192E8: using guessed type int gbWinGAttached;
// 5192EC: using guessed type int gbDDrawAttached;
// 5192F0: using guessed type int giGraphicsType;
// 519F88: using guessed type __int16 word_519F88;

//----- (0049D380) --------------------------------------------------------
signed int __thiscall combatManager::HasValidSpellTarget(combatManager *this, Spell spellID)
{
  int hexIdx; // [sp+10h] [bp-4h]@1

  for ( hexIdx = 0; hexIdx < HEX_GRID_SIZE; ++hexIdx )
  {
    if ( hexIdx % 13 && hexIdx % 13 != 12 && combatManager::ValidSpellTarget(this, spellID, hexIdx) )
      return 1;
  }
  return 0;
}

//----- (0049D410) --------------------------------------------------------
signed int __thiscall combatManager::ViewSpells(combatManager *this, int a2)
{
  signed int result; // eax@12
  combatManager *thisa; // [sp+10h] [bp-8h]@1
  CREATURES elemental_type; // [sp+14h] [bp-4h]@6

  thisa = this;
  thisa->current_spell_id = game::ViewSpells(
                              gpGame,
                              thisa->heroes[giCurGeneral],
                              SPELL_CATEGORY_COMBAT,
                              (int (__fastcall *)(struct tag_message *))CombatSpecialHandler,
                              0);
  if ( thisa->current_spell_id == -1 )
  {
LABEL_29:
    result = 0;
  }
  else
  {
    switch ( thisa->current_spell_id )
    {
      case SPELL_EARTHQUAKE:
        if ( thisa->castles[1] )
          goto LABEL_20;
        NormalDialog(
          "An earthquake will do you no good unless there are town walls to damage.",
          1,
          -1,
          -1,
          -1,
          0,
          -1,
          0,
          -1,
          0);
        goto LABEL_27;
      case SPELL_SUMMON_EARTH_ELEMENTAL:
        elemental_type = CREATURE_EARTH_ELEMENTAL;
        goto LABEL_10;
      case SPELL_SUMMON_AIR_ELEMENTAL:
        elemental_type = CREATURE_AIR_ELEMENTAL;
        goto LABEL_10;
      case SPELL_SUMMON_FIRE_ELEMENTAL:
        elemental_type = CREATURE_FIRE_ELEMENTAL;
        goto LABEL_10;
      case SPELL_SUMMON_WATER_ELEMENTAL:
        elemental_type = CREATURE_WATER_ELEMENTAL;
LABEL_10:
        if ( thisa->summonedCreatureType[thisa->currentActionSide]
          && thisa->summonedCreatureType[thisa->currentActionSide] != elemental_type )
        {
          NormalDialog("You may only summon one type of elemental per combat.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          return 0;
        }
        if ( thisa->numCreatures[thisa->currentActionSide] >= 20 )
        {
          sprintf(
            gText,
            "You already have %d creatures groups in combat and cannot add any more.",
            thisa->numCreatures[thisa->currentActionSide]);
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          return 0;
        }
        if ( !combatManager::SpaceForElementalExists(thisa) )
        {
          sprintf(gText, "There is no open space adjacent to your hero to summon an Elemental to.");
          NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
          return 0;
        }
LABEL_20:
        giNextAction = 1;
        giNextActionExtra = thisa->current_spell_id;
        goto LABEL_27;
      case SPELL_MASS_CURE:
      case SPELL_MASS_HASTE:
      case SPELL_MASS_SLOW:
      case SPELL_MASS_BLESS:
      case SPELL_MASS_CURSE:
      case SPELL_HOLY_WORD:
      case SPELL_HOLY_SHOUT:
      case SPELL_MASS_DISPEL:
      case SPELL_ARMAGEDDON:
      case SPELL_ELEMENTAL_STORM:
      case SPELL_DEATH_RIPPLE:
      case SPELL_DEATH_WAVE:
      case SPELL_MASS_SHIELD:
        if ( combatManager::HasValidSpellTarget(thisa, (Spell)thisa->current_spell_id) )
          goto LABEL_20;
        NormalDialog("That spell will affect no one!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
        return 0;
      case SPELL_MIRROR_IMAGE:
        if ( thisa->numCreatures[thisa->currentActionSide] < 20 )
          goto LABEL_23;
        sprintf(
          gText,
          "You already have %d creatures groups in combat and cannot add any more.",
          thisa->numCreatures[thisa->currentActionSide]);
        NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
        return 0;
      default:
LABEL_23:
        if ( !combatManager::HasValidSpellTarget(thisa, (Spell)thisa->current_spell_id) )
        {
          NormalDialog("That spell will affect no one!", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          return 0;
        }
        giNextAction = 1;
        giNextActionExtra = thisa->current_spell_id;
        mouseManager::SetPointer(gpMouseManager, "spelmous.mse", gsSpellInfo[thisa->current_spell_id].spriteIdx, -999);
        heroWindowManager::DoDialog(gpWindowManager, 0, (int (__fastcall *)(tag_message *))HandleCastSpell, 0);
LABEL_27:
        mouseManager::SetPointer(gpMouseManager, "cmbtmous.mse", 0, -999);
        if ( thisa->current_spell_id == -1 )
          goto LABEL_29;
        result = 1;
        break;
    }
  }
  return result;
}
// 524BE4: using guessed type int giCurGeneral;

//----- (0049D860) --------------------------------------------------------
signed int __thiscall CombatSpecialHandler(Event *this)
{
  signed int result; // eax@3
  int v2; // [sp+Ch] [bp-8h]@4

  if ( this->guiMsg.eventCode == 4 )
  {
    heroWindowManager::ConvertToHover(gpWindowManager, &this->inputEvt);
    if ( gpWindowManager->hoveredFieldID == this->inputEvt.yCoordOrFieldID )
    {
      result = 1;
    }
    else
    {
      gpWindowManager->hoveredFieldID = this->inputEvt.yCoordOrFieldID;
      v2 = this->guiMsg.fieldID;
      if ( v2 > 30720 )
      {
LABEL_9:
        combatManager::CombatMessage(gpCombatManager, off_4F64AC, 1, 0, 0);
      }
      else if ( v2 == 30720 )
      {
        combatManager::CombatMessage(gpCombatManager, off_4F64A0, 1, 0, 0);
      }
      else
      {
        switch ( v2 )
        {
          case 2:
            combatManager::CombatMessage(gpCombatManager, cSpellHelp, 1, 0, 0);
            break;
          case 3:
            combatManager::CombatMessage(gpCombatManager, off_4F6494, 1, 0, 0);
            break;
          case 6:
          case 7:
          case 8:
          case 9:
            combatManager::CombatMessage(gpCombatManager, off_4F64A8, 1, 0, 0);
            break;
          default:
            goto LABEL_9;
        }
      }
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (0049D9C0) --------------------------------------------------------
signed int __thiscall HandleCastSpell(Event *this)
{
  int hex; // [sp+14h] [bp-4h]@2

  switch ( this->inputEvt.eventCode )
  {
    case 4:
      hex = combatManager::GetGridIndex(gpCombatManager, this->inputEvt.xCoordOrKeycode, this->inputEvt.yCoordOrFieldID);
      if ( indexToCastOn != hex )
      {
        if ( combatManager::ValidSpellTarget(gpCombatManager, (Spell)gpCombatManager->current_spell_id, hex) )
        {
          indexToCastOn = hex;
          mouseManager::SetPointer(gpMouseManager, gsSpellInfo[gpCombatManager->current_spell_id].spriteIdx);
          combatManager::SpellMessage(gpCombatManager, gpCombatManager->current_spell_id, hex);
        }
        else
        {
          indexToCastOn = -1;
          mouseManager::SetPointer(gpMouseManager, 0);
          if ( gpCombatManager->current_spell_id == SPELL_TELEPORT && bInTeleportGetDest )
            combatManager::CombatMessage(gpCombatManager, "Invalid Teleport Destination", 1, 0, 0);
          else
            combatManager::CombatMessage(gpCombatManager, "Select Spell Target", 1, 0, 0);
        }
      }
      return 1;
    case 8:
      if ( indexToCastOn == -1 )
        return 1;
      if ( bInTeleportGetDest )
      {
        giNextActionGridIndex2 = indexToCastOn;
      }
      else
      {
        giNextActionGridIndex = indexToCastOn;
        if ( gpCombatManager->current_spell_id == 4 )
        {
          bInTeleportGetDest = 1;
          indexToCastOn = -1;
          this->inputEvt.eventCode = 4;
          this->inputEvt.xCoordOrKeycode = this->inputEvt.altXCoord;
          this->inputEvt.yCoordOrFieldID = this->inputEvt.altYCoord;
          HandleCastSpell(this);
          combatManager::CombatMessage(gpCombatManager, "Select teleport destination.", 1, 0, 0);
          return 1;
        }
      }
      bInTeleportGetDest = 0;
      this->inputEvt.eventCode = 512;
      this->inputEvt.xCoordOrKeycode = 10;
      return 2;
    case 1:
      if ( this->guiMsg.messageType == 1 )
        goto LABEL_19;
      return 1;
    case 32:
LABEL_19:
      gpCombatManager->current_spell_id = -1;
      giNextAction = 0;
      this->inputEvt.eventCode = 512;
      this->inputEvt.xCoordOrKeycode = 10;
      bInTeleportGetDest = 0;
      return 2;
    default:
      return 1;
  }
}
// 519FD8: using guessed type int bInTeleportGetDest;
// 51A198: using guessed type int indexToCastOn;

//----- (0049DC70) --------------------------------------------------------
signed int __thiscall combatManager::FindResurrectArmyIndex(combatManager *this, int side, Spell spell, int hexIdx)
{
  signed int result; // eax@4
  combatManager *thisa; // [sp+Ch] [bp-Ch]@1
  int i; // [sp+14h] [bp-4h]@6

  thisa = this;
  if ( this->combatGrid[hexIdx].unitOwner == -1 )
  {
    for ( i = this->combatGrid[hexIdx].numCorpses - 1; i >= 0; --i )
    {
      if ( *(&thisa->combatGrid[0].corpseOwners[99 * hexIdx] + i - hexIdx) != -1
        && (*(&thisa->combatGrid[0].corpseOtherHexIsToLeft[99 * hexIdx] + i - hexIdx)
         || thisa->combatGrid[hexIdx + 1].unitOwner == -1)
        && (*(&thisa->combatGrid[0].corpseOtherHexIsToLeft[99 * hexIdx] + i - hexIdx) != 1
         || thisa->combatGrid[hexIdx - 1].unitOwner == -1)
        && *(&thisa->combatGrid[0].corpseOwners[99 * hexIdx] + i - hexIdx) == side
        && army::SpellCastWorkChance(
             &thisa->creatures[*(&thisa->combatGrid[0].corpseOwners[99 * hexIdx] + i - hexIdx)][*(&thisa->combatGrid[0].corpseStackIndices[99 * hexIdx]
                                                                                                + i
                                                                                                - hexIdx)],
             spell) > 0.0 )
        return *(&thisa->combatGrid[0].corpseStackIndices[99 * hexIdx] + i - hexIdx);
    }
    result = -1;
  }
  else if ( this->combatGrid[hexIdx].unitOwner != side
  || army::SpellCastWorkChance(
       &this->creatures[this->combatGrid[hexIdx].unitOwner][this->combatGrid[hexIdx].stackIdx],
       spell) <= 0.0 )
  {
    result = -1;
  }
  else
  {
    result = thisa->combatGrid[hexIdx].stackIdx;
  }
  return result;
}

//----- (0049DF60) --------------------------------------------------------
bool __thiscall combatManager::ValidSpellTarget(combatManager *this, Spell spell, int hexIdx)
{
  bool result; // eax@2
  combatManager *thisb; // [sp+10h] [bp-10h]@1
  army *stack; // [sp+1Ch] [bp-4h]@1

  thisb = this;
  stack = 0;
  if ( ValidHex(hexIdx) )
  {
    if ( spell                                  // a2 != SPELL_FIREBALL
      && spell != SPELL_FIREBLAST
      && spell != SPELL_METEOR_SHOWER
      && spell != SPELL_COLD_RING
      && spell != SPELL_RESURRECT
      && spell != SPELL_RESURRECT_TRUE
      && spell != SPELL_ANIMATE_DEAD
      && thisb->combatGrid[hexIdx].unitOwner != -1
      && ((stack = &thisb->creatures[thisb->combatGrid[hexIdx].unitOwner][thisb->combatGrid[hexIdx].stackIdx],
           thisb->creatures[thisb->combatGrid[hexIdx].unitOwner][thisb->combatGrid[hexIdx].stackIdx].effectStrengths[12])
       || thisb->creatures[thisb->combatGrid[hexIdx].unitOwner][thisb->combatGrid[hexIdx].stackIdx].creatureIdx == CREATURE_GREEN_DRAGON) )
    {
      result = 0;
    }
    else if ( stack && army::SpellCastWorkChance(stack, spell) <= 0.0 )
    {
      result = 0;
    }
    else
    {
      switch ( spell )
      {
        case SPELL_HOLY_WORD:
        case SPELL_HOLY_SHOUT:
        case SPELL_DISPEL_MAGIC:
        case SPELL_MASS_DISPEL:
        case SPELL_ARMAGEDDON:
        case SPELL_ELEMENTAL_STORM:
        case SPELL_DEATH_RIPPLE:
        case SPELL_DEATH_WAVE:
          if ( thisb->combatGrid[hexIdx].unitOwner != -1 )
            goto LABEL_48;
          result = 0;
          break;
        case SPELL_RESURRECT:
        case SPELL_RESURRECT_TRUE:
        case SPELL_ANIMATE_DEAD:
          result = combatManager::FindResurrectArmyIndex(thisb, thisb->currentActionSide, spell, hexIdx) != -1;
          break;
        case SPELL_CURE:
        case SPELL_MASS_CURE:
        case SPELL_HASTE:
        case SPELL_MASS_HASTE:
        case SPELL_BLESS:
        case SPELL_MASS_BLESS:
        case SPELL_STONESKIN:
        case SPELL_STEELSKIN:
        case SPELL_ANTI_MAGIC:
        case SPELL_DRAGON_SLAYER:
        case SPELL_BLOOD_LUST:
        case SPELL_SHIELD:
        case SPELL_MASS_SHIELD:
          if ( thisb->combatGrid[hexIdx].unitOwner == thisb->currentActionSide )
            goto LABEL_48;
          result = 0;
          break;
        case SPELL_MIRROR_IMAGE:
          if ( thisb->combatGrid[hexIdx].unitOwner == thisb->currentActionSide )
          {
            if ( thisb->creatures[thisb->combatGrid[hexIdx].unitOwner][thisb->combatGrid[hexIdx].stackIdx].mirrorIdx == -1
              && thisb->creatures[thisb->combatGrid[hexIdx].unitOwner][thisb->combatGrid[hexIdx].stackIdx].mirroredIdx == -1 )
              goto LABEL_48;
            result = 0;
          }
          else
          {
            result = 0;
          }
          break;
        case SPELL_LIGHTNING_BOLT:
        case SPELL_CHAIN_LIGHTNING:
        case SPELL_SLOW:
        case SPELL_MASS_SLOW:
        case SPELL_BLIND:
        case SPELL_CURSE:
        case SPELL_MASS_CURSE:
        case SPELL_MAGIC_ARROW:
        case SPELL_BERZERKER:
        case SPELL_PARALYZE:
        case SPELL_HYPNOTIZE:
        case SPELL_COLD_RAY:
        case SPELL_DISRUPTING_RAY:
          if ( thisb->combatGrid[hexIdx].unitOwner == 1 - thisb->currentActionSide )
            goto LABEL_48;
          result = 0;
          break;
        case SPELL_TELEPORT:
          if ( bInTeleportGetDest )
          {
            if ( hexIdx != giNextActionGridIndex
              && army::CanFit(
                   &thisb->creatures[gpCombatManager->combatGrid[giNextActionGridIndex].unitOwner][gpCombatManager->combatGrid[giNextActionGridIndex].stackIdx],
                   hexIdx,
                   0,
                   0) )
              goto LABEL_48;
            result = 0;
          }
          else
          {
            if ( thisb->combatGrid[hexIdx].unitOwner == thisb->currentActionSide )
              goto LABEL_48;
            result = 0;
          }
          break;
        case SPELL_FIREBALL:
        case SPELL_FIREBLAST:
        case SPELL_METEOR_SHOWER:
        case SPELL_COLD_RING:
          if ( hexIdx != -1 && hexIdx % 13 && hexIdx % 13 != 12 )
            goto LABEL_48;
          result = 0;
          break;
        default:
LABEL_48:
          result = 1;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 519FD8: using guessed type int bInTeleportGetDest;

//----- (0049E490) --------------------------------------------------------
void __thiscall combatManager::SpellMessage(combatManager *this, int spell, int hex)
{
  char *v4; // [sp+14h] [bp-8h]@10
  army *targ; // [sp+18h] [bp-4h]@7

  if ( !gbNoShowCombat )
  {
    switch ( spell )
    {
      case SPELL_FIREBALL:
      case SPELL_FIREBLAST:
      case SPELL_METEOR_SHOWER:
      case SPELL_COLD_RING:
        sprintf(gText, "Cast %s", gSpellNames[spell]);
        break;
      case SPELL_TELEPORT:
        if ( !bInTeleportGetDest )
          goto LABEL_8;
        sprintf(gText, "Teleport Here");
        break;
      case SPELL_RESURRECT:
      case SPELL_RESURRECT_TRUE:
      case SPELL_ANIMATE_DEAD:
        targ = &this->creatures[this->currentActionSide][combatManager::FindResurrectArmyIndex(
                                                           this,
                                                           this->currentActionSide,
                                                           (Spell)spell,
                                                           hex)];
        goto LABEL_9;
      default:
LABEL_8:
        targ = &this->creatures[this->combatGrid[hex].unitOwner][this->combatGrid[hex].stackIdx];
LABEL_9:
        if ( targ->quantity == 1 )
          v4 = gArmyNames[targ->creatureIdx];
        else
          v4 = gArmyNamesPlural[targ->creatureIdx];
        sprintf(gText, "Cast %s on %s", gSpellNames[spell], v4);
        break;
    }
    combatManager::CombatMessage(this, gText, 1, 0, 0);
  }
}
// 518CFC: using guessed type int gbNoShowCombat;
// 519FD8: using guessed type int bInTeleportGetDest;

//----- (0049E6C0) --------------------------------------------------------
void __thiscall combatManager::CastSpell(combatManager *this, Spell proto_spell, int hexIdx, int isCreatureAbility, int a5)
{
  int v5; // ebx@0
  double v6; // st6@0
  double v7; // st7@0
  int v8; // eax@12
  icon *v9; // ST84_4@135
  int v10; // ST38_4@135
  int v11; // eax@135
  int v12; // ST10_4@144
  int v13; // eax@144
  void *v14; // eax@186
  char *v15; // ST80_4@186
  int v16; // [sp+14h] [bp-ACh]@111
  combatManager *thisa; // [sp+1Ch] [bp-A4h]@1
  char *v18; // [sp+20h] [bp-A0h]@142
  char *v19; // [sp+24h] [bp-9Ch]@133
  char *v20; // [sp+28h] [bp-98h]@128
  float a7[9]; // [sp+44h] [bp-7Ch]@135
  int knownHex; // [sp+68h] [bp-58h]@97
  army *thisb; // [sp+6Ch] [bp-54h]@88
  int oldDefense; // [sp+70h] [bp-50h]@119
  int centX; // [sp+74h] [bp-4Ch]@54
  int centY; // [sp+78h] [bp-48h]@54
  army *stack; // [sp+7Ch] [bp-44h]@17
  int j; // [sp+84h] [bp-3Ch]@184
  STACK_MODIFYING_EFFECT effect; // [sp+8Ch] [bp-34h]@165
  int damage; // [sp+90h] [bp-30h]@122
  int owner; // [sp+94h] [bp-2Ch]@41
  char buf[8]; // [sp+98h] [bp-28h]@82
  int spellpower; // [sp+A8h] [bp-18h]@46
  SAMPLE2 res; // [sp+ACh] [bp-14h]@9
  Spell spell; // [sp+B4h] [bp-Ch]@77
  int stackidx; // [sp+B8h] [bp-8h]@41
  int i; // [sp+BCh] [bp-4h]@182
  int hexIdxa; // [sp+CCh] [bp+Ch]@88

  thisa = this;
  if ( !isCreatureAbility )
  {
    if ( this->eagleEyeSpellLearned[1 - this->currentActionSide] == SPELL_NONE )
    {
      if ( this->heroes[1 - this->currentActionSide] )
      {
        if ( !hero::HasSpell(this->heroes[1 - this->currentActionSide], proto_spell) )
        {
          if ( thisa->heroes[1 - thisa->currentActionSide]->secondarySkillLevel[11] )
          {
            if ( thisa->heroes[1 - thisa->currentActionSide]->secondarySkillLevel[11] + 1 >= gsSpellInfo[proto_spell].level )
            {
              v5 = thisa->heroes[1 - thisa->currentActionSide]->secondarySkillLevel[11];
              if ( v5 >= SRandom(0, 9) )
                thisa->eagleEyeSpellLearned[1 - thisa->currentActionSide] = proto_spell;
            }
          }
        }
      }
    }
  }
  res = NULL_SAMPLE2;
  if ( thisa->field_F2B7 )
  {
    combatManager::ResetLimitCreature(thisa);
    if ( ValidHex(thisa->field_F2BB) && thisa->combatGrid[thisa->field_F2BB].unitOwner >= 0 )
    {
      v8 = 80 * thisa->combatGrid[thisa->field_F2BB].unitOwner + 4 * thisa->combatGrid[thisa->field_F2BB].stackIdx;
      ++*(signed int *)((char *)thisa->limitCreature[0] + v8);
    }
    thisa->field_F2B7 = 0;
    thisa->field_F2BB = -1;
    combatManager::DrawFrame(gpCombatManager, 1, 1, 0, 0, 75, 1, 1);
  }
  if ( !isCreatureAbility && thisa->heroes[thisa->currentActionSide] )
    hero::UseSpell(thisa->heroes[thisa->currentActionSide], proto_spell);
  stack = 0;
  if ( proto_spell
    && proto_spell != SPELL_FIREBLAST
    && proto_spell != SPELL_COLD_RING
    && proto_spell != SPELL_METEOR_SHOWER
    && proto_spell != SPELL_SUMMON_EARTH_ELEMENTAL
    && proto_spell != SPELL_SUMMON_AIR_ELEMENTAL
    && proto_spell != SPELL_SUMMON_WATER_ELEMENTAL
    && proto_spell != SPELL_SUMMON_FIRE_ELEMENTAL
    && proto_spell != SPELL_MASS_BLESS
    && proto_spell != SPELL_MASS_HASTE
    && proto_spell != SPELL_EARTHQUAKE
    && proto_spell != SPELL_MASS_CURSE
    && proto_spell != SPELL_MASS_CURE
    && proto_spell != SPELL_HOLY_WORD
    && proto_spell != SPELL_HOLY_SHOUT
    && proto_spell != SPELL_DEATH_RIPPLE
    && proto_spell != SPELL_DEATH_WAVE
    && proto_spell != SPELL_MASS_SHIELD
    && proto_spell != SPELL_ARMAGEDDON
    && proto_spell != SPELL_ELEMENTAL_STORM
    && proto_spell != SPELL_MASS_DISPEL )
  {
    if ( ValidHex(hexIdx) && thisa->combatGrid[hexIdx].unitOwner >= 0 )
    {
      stack = &thisa->creatures[thisa->combatGrid[hexIdx].unitOwner][thisa->combatGrid[hexIdx].stackIdx];
      owner = thisa->combatGrid[hexIdx].unitOwner;
      stackidx = thisa->combatGrid[hexIdx].stackIdx;
    }
    else
    {
      stack = NULL;
    }
  }
  else
  {
    stack = NULL;
  }
  if ( !isCreatureAbility )
    *(&thisa->field_353F + thisa->currentActionSide) = 1;
  if ( isCreatureAbility )
  {
    spellpower = 3;
  }
  else
  {
    spellpower = thisa->heroSpellpowers[thisa->currentActionSide];
    if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 42)
      && gsSpellInfo[proto_spell].attributes & ATTR_DURATIONED_SPELL )
      spellpower += 2;
    if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 66)
      && gsSpellInfo[proto_spell].attributes & ATTR_DURATIONED_SPELL )
      spellpower += 10;
  }
  if ( !isCreatureAbility )
  {
    centX = -1;
    centY = -1;
    if ( stack )
    {
      centX = army::MidX(stack);
      centY = army::MidY(stack);
    }
    else if ( proto_spell == SPELL_FIREBALL
  || proto_spell == SPELL_FIREBLAST
  || proto_spell == SPELL_COLD_RING
  || proto_spell == SPELL_METEOR_SHOWER )
    {
      centX = thisa->combatGrid[hexIdx].centerX;
      centY = thisa->combatGrid[hexIdx].occupyingCreatureBottomY - 17;
    }
    if ( centX == -1 )
    {
      thisa->heroAnimationType[thisa->currentActionSide] = 3;
    }
    else
    {
      if ( thisa->currentActionSide )
      {
        castX = 610 - sCmbtHero[thisa->heroType[thisa->currentActionSide]].castXOff;
        castY = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castYOff + 148;
      }
      else
      {
        castX = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castXOff + 30;
        castY = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castYOff + 183;
      }
      if ( (centX - castX) * (thisa->currentActionSide < 1u ? 1 : -1) >= centY - castY )
      {
        thisa->heroAnimationType[thisa->currentActionSide] = 5;
      }
      else
      {
        thisa->heroAnimationType[thisa->currentActionSide] = 7;
        if ( thisa->currentActionSide )
        {
          castX = 610 - sCmbtHero[thisa->heroType[thisa->currentActionSide]].castLowXOff;
          castY = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castLowYOff + 148;
        }
        else
        {
          castX = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castLowXOff + 30;
          castY = sCmbtHero[thisa->heroType[thisa->currentActionSide]].castLowYOff + 183;
        }
      }
    }
    for ( thisa->heroAnimationFrameCount[thisa->currentActionSide] = 0;
          sCmbtHero[thisa->heroType[thisa->currentActionSide]].animationLength[thisa->heroAnimationType[thisa->currentActionSide]] > thisa->heroAnimationFrameCount[thisa->currentActionSide];
          ++thisa->heroAnimationFrameCount[thisa->currentActionSide] )
      combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
    --thisa->heroAnimationFrameCount[thisa->currentActionSide];
  }
  spell = proto_spell;
  if ( proto_spell == SPELL_MEDUSA_PETRIFY )
    spell = SPELL_PARALYZE;
  if ( proto_spell == SPELL_ARCHMAGI_DISPEL )
    spell = SPELL_DISPEL_MAGIC;
  if ( strlen(gsSpellInfo[spell].soundName) )
    sprintf(buf, "%s.82M", &gsSpellInfo[spell]);
  if ( isCreatureAbility || !stack || army::SpellCastWorks(stack, proto_spell) )
  {
    res = (SAMPLE2)LoadPlaySample(buf);
    switch ( proto_spell )
    {
      case SPELL_TELEPORT:
        thisb = stack;
        hexIdxa = a5;
        combatManager::RippleCreature(thisa, stack->owningSide, stack->stackIdx, 1);
        thisa->combatGrid[stack->occupiedHex].unitOwner = -1;
        thisa->combatGrid[thisb->occupiedHex].stackIdx = -1;
        if ( thisa->combatGrid[thisb->occupiedHex].occupiersOtherHexIsToLeft )
        {
          if ( thisa->combatGrid[thisb->occupiedHex].occupiersOtherHexIsToLeft == 1 )
          {
            thisa->combatGrid[thisb->occupiedHex - 1].unitOwner = -1;
            thisa->combatGrid[thisb->occupiedHex - 1].stackIdx = -1;
          }
        }
        else
        {
          thisa->combatGrid[thisb->occupiedHex + 1].unitOwner = -1;
          thisa->combatGrid[thisb->occupiedHex + 1].stackIdx = -1;
        }
        if ( !gbNoShowCombat )
          WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
        if ( !gbNoShowCombat )
        {
          sprintf(gText, "telptin.82m");
          res = (SAMPLE2)LoadPlaySample(gText);
        }
        if ( thisb->creature.creature_flags & TWO_HEXER )
        {
          knownHex = a5;
          if ( thisb->facingRight == 1 )
          {
            if ( (knownHex = army::GetAdjacentCellIndex(thisb, knownHex, 1), knownHex == -1)
              || thisa->combatGrid[knownHex].unitOwner != -1
              && (thisa->combatGrid[knownHex].unitOwner != owner || thisa->combatGrid[knownHex].stackIdx != stackidx)
              || thisa->combatGrid[knownHex].isBlocked )
              hexIdxa = a5 - 1;
          }
          if ( !thisb->facingRight )
          {
            if ( (knownHex = army::GetAdjacentCellIndex(thisb, knownHex, 4), knownHex == -1)
              || thisa->combatGrid[knownHex].unitOwner != -1
              && (thisa->combatGrid[knownHex].unitOwner != owner || thisa->combatGrid[knownHex].stackIdx != stackidx)
              || thisa->combatGrid[knownHex].isBlocked )
              ++hexIdxa;
          }
          thisb->occupiedHex = hexIdxa;
          v16 = thisb->facingRight;
          if ( v16 )
          {
            if ( v16 == 1 )
            {
              thisa->combatGrid[thisb->occupiedHex].unitOwner = owner;
              thisa->combatGrid[thisb->occupiedHex].stackIdx = stackidx;
              thisa->combatGrid[thisb->occupiedHex].occupiersOtherHexIsToLeft = 0;
              thisa->combatGrid[thisb->occupiedHex + 1].unitOwner = owner;
              thisa->combatGrid[thisb->occupiedHex + 1].stackIdx = stackidx;
              thisa->combatGrid[thisb->occupiedHex + 1].occupiersOtherHexIsToLeft = 1;
            }
          }
          else
          {
            thisa->combatGrid[thisb->occupiedHex].unitOwner = owner;
            thisa->combatGrid[thisb->occupiedHex].stackIdx = stackidx;
            thisa->combatGrid[thisb->occupiedHex].occupiersOtherHexIsToLeft = 1;
            thisa->combatGrid[thisb->occupiedHex - 1].unitOwner = owner;
            thisa->combatGrid[thisb->occupiedHex - 1].stackIdx = stackidx;
            thisa->combatGrid[thisb->occupiedHex - 1].occupiersOtherHexIsToLeft = 0;
          }
          combatManager::RippleCreature(thisa, thisb->owningSide, thisb->stackIdx, 2);
        }
        else
        {
          thisb->occupiedHex = a5;
          thisa->combatGrid[thisb->occupiedHex].unitOwner = owner;
          thisa->combatGrid[thisb->occupiedHex].stackIdx = stackidx;
          thisa->combatGrid[thisb->occupiedHex].occupiersOtherHexIsToLeft = -1;
          combatManager::RippleCreature(thisa, thisb->owningSide, thisb->stackIdx, 2);
        }
        break;
      case SPELL_DISRUPTING_RAY:
        oldDefense = stack->creature.defense;
        stack->creature.defense -= 3;
        if ( stack->creature.defense < 1 )
          stack->creature.defense = 1;
        sprintf(gText, "The disrupting ray reduces defense by %d.", oldDefense - stack->creature.defense);
        combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        combatManager::DoBlast(thisa, v5, hexIdx, proto_spell);
        combatManager::RippleCreature(thisa, stack->owningSide, stack->stackIdx, 0);
        break;
      case SPELL_COLD_RAY:
        DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 175.0));
        damage = 20 * spellpower;
        if ( stack->creatureIdx == CREATURE_FIRE_ELEMENTAL )
          damage *= 2;
        if ( stack->creatureIdx == CREATURE_IRON_GOLEM || stack->creatureIdx == CREATURE_STEEL_GOLEM )
          damage = (signed __int64)((double)damage * 0.5);
        combatManager::ModifyDamageForArtifacts(
          &damage,
          SPELL_COLD_RAY,
          thisa->heroes[thisa->currentActionSide],
          thisa->heroes[1 - thisa->currentActionSide]);
        if ( stack->quantity <= 1 )
          v20 = gArmyNames[stack->creatureIdx];
        else
          v20 = gArmyNamesPlural[stack->creatureIdx];
        sprintf(gText, "The cold ray does %d\n damage to the %s.", damage, v20);
        combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        combatManager::DoBlast(thisa, v5, hexIdx, proto_spell);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[32].creatureEffectAnimationIdx, 0, 0);
        army::Damage(stack, damage, SPELL_NONE);
        army::PowEffect(stack, -1, 1, -1, -1);
        break;
      case SPELL_CHAIN_LIGHTNING:
        combatManager::ChainLightning(thisa, hexIdx, spellpower);
        break;
      case SPELL_MAGIC_ARROW:
        DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 100.0));
        damage = 10 * spellpower;
        combatManager::ModifyDamageForArtifacts(
          &damage,
          SPELL_MAGIC_ARROW,
          thisa->heroes[thisa->currentActionSide],
          thisa->heroes[1 - thisa->currentActionSide]);
        if ( stack->quantity <= 1 )
          v19 = gArmyNames[stack->creatureIdx];
        else
          v19 = gArmyNamesPlural[stack->creatureIdx];
        sprintf(gText, "The magic arrow does %d\n damage to the %s.", damage, v19);
        combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        v9 = resourceManager::GetIcon(gpResourceManager, "keep.icn");
        LODWORD(a7[0]) = 0x42B40000u;
        LODWORD(a7[1]) = 0x42890000u;
        LODWORD(a7[2]) = 0x42340000u;
        LODWORD(a7[3]) = 0x41A66666u;
        LODWORD(a7[4]) = 0;
        LODWORD(a7[5]) = 0xC1A66666u;
        LODWORD(a7[6]) = 0xC2340000u;
        LODWORD(a7[7]) = 0xC2890000u;
        LODWORD(a7[8]) = 0xC2B40000u;
        v10 = army::MidY(stack);
        v11 = army::MidX(stack);
        combatManager::ShootMissile(castX, castY, v11, v10, a7, v9);
        resourceManager::Dispose(gpResourceManager, (resource *)v9);
        army::Damage(stack, damage, SPELL_NONE);
        army::PowEffect(stack, -1, 1, -1, -1);
        break;
      case SPELL_LIGHTNING_BOLT:
        damage = 25 * spellpower;
        if ( stack->creatureIdx == CREATURE_AIR_ELEMENTAL )
          damage *= 2;
        if ( stack->creatureIdx == CREATURE_IRON_GOLEM || stack->creatureIdx == CREATURE_STEEL_GOLEM )
        {
          v7 = (double)damage * 0.5;
          damage = (signed __int64)v7;
        }
        combatManager::ModifyDamageForArtifacts(
          &damage,
          SPELL_LIGHTNING_BOLT,
          thisa->heroes[thisa->currentActionSide],
          thisa->heroes[1 - thisa->currentActionSide]);
        if ( stack->quantity <= 1 )
          v18 = gArmyNames[stack->creatureIdx];
        else
          v18 = gArmyNamesPlural[stack->creatureIdx];
        sprintf(gText, "The lightning bolt does %d\n damage to the %s.", damage, v18);
        combatManager::CombatMessage(thisa, gText, 1, 1, 0);
        v12 = army::MidY(stack);
        v13 = army::MidX(stack);
        combatManager::DoBolt(
          thisa,
          (unsigned __int8)v5,
          v6,
          v7,
          1,
          castX,
          castY,
          v13,
          v12,
          150,
          100,
          9,
          2,
          301,
          -40,
          40,
          30,
          1,
          0,
          0,
          1);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[2].creatureEffectAnimationIdx, 0, 0);
        army::Damage(stack, damage, SPELL_NONE);
        army::PowEffect(stack, -1, 1, -1, -1);
        break;
      case SPELL_MASS_CURE:
      case SPELL_MASS_HASTE:
      case SPELL_MASS_SLOW:
      case SPELL_MASS_BLESS:
      case SPELL_MASS_CURSE:
      case SPELL_HOLY_WORD:
      case SPELL_HOLY_SHOUT:
      case SPELL_MASS_DISPEL:
      case SPELL_DEATH_RIPPLE:
      case SPELL_DEATH_WAVE:
      case SPELL_MASS_SHIELD:
        combatManager::CastMassSpell(thisa, proto_spell, spellpower);
        break;
      case SPELL_MIRROR_IMAGE:
        combatManager::MirrorImage(thisa, hexIdx);
        break;
      case SPELL_SUMMON_EARTH_ELEMENTAL:
        combatManager::SummonElemental(thisa, CREATURE_EARTH_ELEMENTAL, spellpower);
        break;
      case SPELL_SUMMON_AIR_ELEMENTAL:
        combatManager::SummonElemental(thisa, CREATURE_AIR_ELEMENTAL, spellpower);
        break;
      case SPELL_SUMMON_FIRE_ELEMENTAL:
        combatManager::SummonElemental(thisa, CREATURE_FIRE_ELEMENTAL, spellpower);
        break;
      case SPELL_SUMMON_WATER_ELEMENTAL:
        combatManager::SummonElemental(thisa, CREATURE_WATER_ELEMENTAL, spellpower);
        break;
      case SPELL_RESURRECT:
      case SPELL_RESURRECT_TRUE:
      case SPELL_ANIMATE_DEAD:
        combatManager::Resurrect(thisa, proto_spell, hexIdx, spellpower);
        break;
      case SPELL_CURE:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[5].creatureEffectAnimationIdx, 0, 0);
        army::Cure(stack, spellpower);
        combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
        break;
      case SPELL_SLOW:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_SLOW, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[11].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_HASTE:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, 0, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[9].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_SHIELD:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_SHIELD, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[41].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_DRAGON_SLAYER:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_DRAGON_SLAYER, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[37].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_BLESS:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_BLESS, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[14].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_STONESKIN:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_STONESKIN, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[16].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_STEELSKIN:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_STEELSKIN, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[17].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_CURSE:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_CURSE, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[18].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_BERZERKER:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_BERSERKER, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[26].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_HYPNOTIZE:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_HYPNOTIZE, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[31].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_PARALYZE:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_PARALYZE, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[30].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_ARCHMAGI_DISPEL:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::DispelGood(stack);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[23].creatureEffectAnimationIdx, 0, 1);
        break;
      case SPELL_DISPEL_MAGIC:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::DispelGood(stack);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[23].creatureEffectAnimationIdx, 0, 0);
        for ( effect = 0; (signed int)effect < 15; ++effect )
          army::CancelIndividualSpell(stack, effect);
        break;
      case SPELL_BLIND:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_BLIND, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[13].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_BLOOD_LUST:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        combatManager::BloodLustEffect(thisa, stack, CREATURE_RED);
        army::SetSpellInfluence(stack, EFFECT_BLOOD_LUST, 3);
        break;
      case SPELL_ANTI_MAGIC:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        army::SetSpellInfluence(stack, EFFECT_ANTI_MAGIC, spellpower);
        army::SpellEffect(stack, (unsigned __int8)gsSpellInfo[22].creatureEffectAnimationIdx, 0, 0);
        break;
      case SPELL_MEDUSA_PETRIFY:
        combatManager::ShowSpellMessage(thisa, isCreatureAbility, proto_spell, stack);
        combatManager::TurnToStone(thisa, stack);
        break;
      case SPELL_COLD_RING:
        combatManager::Fireball(thisa, hexIdx, SPELL_COLD_RING);
        break;
      case SPELL_FIREBALL:
        combatManager::Fireball(thisa, hexIdx, 0);
        break;
      case SPELL_FIREBLAST:
        combatManager::Fireball(thisa, hexIdx, SPELL_FIREBLAST);
        break;
      case SPELL_METEOR_SHOWER:
        combatManager::MeteorShower(thisa, (unsigned __int8)v5, hexIdx);
        break;
      case SPELL_ELEMENTAL_STORM:
        combatManager::ElementalStorm(thisa);
        break;
      case SPELL_ARMAGEDDON:
        combatManager::Armageddon(thisa, (unsigned __int8)v5);
        break;
      case SPELL_EARTHQUAKE:
        combatManager::Earthquake(thisa);
        break;
      default:
        combatManager::DefaultSpell(thisa, hexIdx);
        break;
    }
  }
  else
  {
    combatManager::ShowSpellCastFailure(stack, proto_spell);
  }
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; thisa->numCreatures[i] > j; ++j )
    {
      v14 = (char *)thisa + 24234 * i + 1154 * j;
      v15 = (char *)v14 + 13647;
      *(_DWORD *)((char *)v14 + 13865) = 0;
      *(_DWORD *)(v15 + 222) = *(_DWORD *)(v15 + 218);
      *(_DWORD *)(v15 + 214) = *(_DWORD *)(v15 + 222);
      *(_DWORD *)(v15 + 6) = 1;
      *v15 = 0;
      *(_DWORD *)(v15 + 154) = -1;
    }
  }
  if ( !isCreatureAbility )
  {
    ++thisa->heroAnimationType[thisa->currentActionSide];
    for ( thisa->heroAnimationFrameCount[thisa->currentActionSide] = 0;
          sCmbtHero[thisa->heroType[thisa->currentActionSide]].animationLength[thisa->heroAnimationType[thisa->currentActionSide]] > thisa->heroAnimationFrameCount[thisa->currentActionSide];
          ++thisa->heroAnimationFrameCount[thisa->currentActionSide] )
      combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
    thisa->heroAnimationType[thisa->currentActionSide] = 0;
    thisa->heroAnimationFrameCount[thisa->currentActionSide] = 0;
    combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
  }
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res.file, res.sample);
  combatManager::CheckChangeSelector(thisa);
}
// 518CFC: using guessed type int gbNoShowCombat;
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (004A0590) --------------------------------------------------------
void __thiscall combatManager::DefaultSpell(combatManager *this, int hexIdx)
{
  combatManager *v2; // [sp+Ch] [bp-8h]@1

  v2 = this;
  if ( ValidHex(hexIdx) )
  {
    if ( v2->combatGrid[hexIdx].unitOwner >= 0 )
      army::SpellEffect(
        &v2->creatures[v2->combatGrid[hexIdx].unitOwner][v2->combatGrid[hexIdx].stackIdx],
        gsSpellInfo[v2->current_spell_id].creatureEffectAnimationIdx,
        0,
        1);
  }
}

//----- (004A0670) --------------------------------------------------------
void __thiscall combatManager::Fireball(combatManager *this, int hexIdx, Spell spell)
{
  combatManager *thisa; // [sp+14h] [bp-54h]@1
  signed int v4; // [sp+18h] [bp-50h]@3
  army *stack; // [sp+20h] [bp-48h]@14
  signed int dam; // [sp+24h] [bp-44h]@37
  int y; // [sp+28h] [bp-40h]@2
  int neighborIdx; // [sp+2Ch] [bp-3Ch]@8
  signed int neighborIdxa; // [sp+2Ch] [bp-3Ch]@14
  signed int neighborIdxb; // [sp+2Ch] [bp-3Ch]@19
  signed int neighborIdxc; // [sp+2Ch] [bp-3Ch]@30
  __int16 affectedHexes[19]; // [sp+30h] [bp-38h]@16
  int damage; // [sp+58h] [bp-10h]@30
  int x; // [sp+5Ch] [bp-Ch]@2
  icon *res; // [sp+60h] [bp-8h]@4
  int anyoneDamaged; // [sp+64h] [bp-4h]@30

  thisa = this;
  if ( ValidHex(hexIdx) )
  {
    x = thisa->combatGrid[hexIdx].centerX;
    y = thisa->combatGrid[hexIdx].occupyingCreatureBottomY - 17;
    if ( !gbNoShowCombat )
    {
      v4 = 12;
      if ( spell )
      {
        if ( spell == SPELL_FIREBLAST )
        {
          res = resourceManager::GetIcon(gpResourceManager, "firebal2.icn");
        }
        else
        {
          res = resourceManager::GetIcon(gpResourceManager, "coldring.icn");
          v4 = 7;
        }
      }
      else
      {
        res = resourceManager::GetIcon(gpResourceManager, "fireball.icn");
      }
      for ( neighborIdx = 0; v4 > neighborIdx; ++neighborIdx )
      {
        glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
        IconToBitmap(res, gpWindowManager->screenBuffer, x, y, neighborIdx, 1, 0, 0, 0x280u, 443, 0);
        if ( spell == SPELL_COLD_RING )
          FlipIconToBitmap(res, gpWindowManager->screenBuffer, x, y, neighborIdx, 1, 0, 0, 640, 443, 0);
        combatManager::UpdateCombatArea(thisa);
        combatManager::DrawFrame(thisa, 0, 0, 0, 0, 75, 1, 1);
        DelayTil(&glTimers);
      }
      resourceManager::Dispose(gpResourceManager, (resource *)res);
    }
    combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
    stack = &thisa->creatures[thisa->currentActionSide][thisa->activeStack];
    for ( neighborIdxa = 0; neighborIdxa < 19; ++neighborIdxa )
      affectedHexes[neighborIdxa] = -1;
    if ( spell != SPELL_COLD_RING )
      affectedHexes[0] = hexIdx;
    for ( neighborIdxb = 0; neighborIdxb < 6; ++neighborIdxb )
    {
      affectedHexes[neighborIdxb + 1] = GetAdjacentCellIndexNoArmy(hexIdx, neighborIdxb);
      if ( spell == SPELL_FIREBLAST )
        affectedHexes[neighborIdxb + 7] = army::GetAdjacentCellIndex(
                                            stack,
                                            affectedHexes[neighborIdxb + 1],
                                            neighborIdxb);
    }
    if ( spell == SPELL_FIREBLAST )
    {
      affectedHexes[13] = hexIdx - 26;
      if ( (signed __int16)(hexIdx - 26) < 0 )
        affectedHexes[13] = -1;
      affectedHexes[14] = hexIdx + 26;
      if ( (signed __int16)(hexIdx + 26) >= 117 )
        affectedHexes[14] = -1;
      affectedHexes[15] = GetAdjacentCellIndexNoArmy(affectedHexes[2], 0);
      affectedHexes[16] = GetAdjacentCellIndexNoArmy(affectedHexes[2], 2);
      affectedHexes[17] = GetAdjacentCellIndexNoArmy(affectedHexes[5], 5);
      affectedHexes[18] = GetAdjacentCellIndexNoArmy(affectedHexes[5], 3);
    }
    damage = 10 * thisa->heroSpellpowers[thisa->currentActionSide];
    combatManager::ClearEffects();
    anyoneDamaged = 0;
    for ( neighborIdxc = 0; neighborIdxc < 19; ++neighborIdxc )
    {
      if ( affectedHexes[neighborIdxc] != -1 )
      {
        if ( thisa->combatGrid[affectedHexes[neighborIdxc]].unitOwner != -1 )
        {
          stack = &thisa->creatures[thisa->combatGrid[affectedHexes[neighborIdxc]].unitOwner][thisa->combatGrid[affectedHexes[neighborIdxc]].stackIdx];
          if ( army::SpellCastWorks(stack, spell) )
          {
            if ( !gArmyEffected[thisa->combatGrid[affectedHexes[neighborIdxc]].unitOwner][thisa->combatGrid[affectedHexes[neighborIdxc]].stackIdx] )
            {
              gArmyEffected[thisa->combatGrid[affectedHexes[neighborIdxc]].unitOwner][thisa->combatGrid[affectedHexes[neighborIdxc]].stackIdx] = 1;
              if ( !stack->damageTakenDuringSomeTimePeriod )
              {
                dam = damage;
                if ( spell == SPELL_COLD_RING && stack->creatureIdx == CREATURE_FIRE_ELEMENTAL )
                  dam = 2 * damage;
                if ( (spell == SPELL_FIREBALL || spell == 1) && stack->creatureIdx == CREATURE_WATER_ELEMENTAL )
                  dam *= 2;
                if ( stack->creatureIdx == CREATURE_IRON_GOLEM || stack->creatureIdx == CREATURE_STEEL_GOLEM )
                  dam = (signed __int64)((double)dam * 0.5);
                army::Damage(stack, dam, spell);
                anyoneDamaged = 1;
              }
            }
          }
        }
      }
    }
    if ( anyoneDamaged )
    {
      combatManager::ModifyDamageForArtifacts(
        &damage,
        spell,
        thisa->heroes[thisa->currentActionSide],
        thisa->heroes[1 - thisa->currentActionSide]);
      if ( spell == SPELL_COLD_RING )
        sprintf(gText, "The cold ring does %d damage.", damage);
      else
        sprintf(gText, "The fireball does %d damage.", damage);
      combatManager::CombatMessage(thisa, gText, 1, 1, 0);
      army::PowEffect(stack, -1, 1, -1, -1);
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004A0CA0) --------------------------------------------------------
void __userpurge combatManager::MeteorShower(combatManager *this<ecx>, int ebx0<ebx>, int hexIdx)
{
  combatManager *thisa; // [sp+10h] [bp-3Ch]@1
  icon *res; // [sp+14h] [bp-38h]@6
  army *stack; // [sp+18h] [bp-34h]@2
  int imageIdx; // [sp+1Ch] [bp-30h]@8
  signed int a2; // [sp+20h] [bp-2Ch]@20
  signed int neighborIdx; // [sp+24h] [bp-28h]@2
  signed int neighborIdxa; // [sp+24h] [bp-28h]@6
  signed int neighborIdxb; // [sp+24h] [bp-28h]@13
  int hexes[7]; // [sp+28h] [bp-24h]@2
  int baseDam; // [sp+44h] [bp-8h]@13
  int hurtAnyone; // [sp+48h] [bp-4h]@13

  thisa = this;
  if ( ValidHex(hexIdx) )
  {
    stack = &thisa->creatures[thisa->currentActionSide][thisa->activeStack];
    hexes[0] = hexIdx;
    for ( neighborIdx = 0; neighborIdx < 6; ++neighborIdx )
      hexes[neighborIdx + 1] = GetAdjacentCellIndexNoArmy(hexIdx, neighborIdx);
    if ( !gbNoShowCombat )
    {
      res = resourceManager::GetIcon(gpResourceManager, "meteor.icn");
      for ( neighborIdxa = 0; neighborIdxa < 2; ++neighborIdxa )
      {
        for ( imageIdx = 0; imageIdx < 10; ++imageIdx )
        {
          glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 112.5);
          combatManager::DrawFrame(thisa, 0, 0, 0, 0, 75, 1, 1);
          icon::CombatClipDrawToBuffer(
            res,
            thisa->combatGrid[hexIdx].centerX,
            thisa->combatGrid[hexIdx].occupyingCreatureBottomY - 17,
            imageIdx,
            0,
            0,
            0,
            0,
            0);
          combatManager::UpdateCombatArea(thisa);
          DelayTil(&glTimers);
        }
      }
      resourceManager::Dispose(gpResourceManager, (resource *)res);
    }
    baseDam = 25 * thisa->heroSpellpowers[thisa->currentActionSide];
    combatManager::ClearEffects();
    hurtAnyone = 0;
    for ( neighborIdxb = 0; neighborIdxb < 7; ++neighborIdxb )
    {
      if ( hexes[neighborIdxb] != -1 )
      {
        if ( thisa->combatGrid[hexes[neighborIdxb]].unitOwner != -1 )
        {
          stack = &thisa->creatures[thisa->combatGrid[hexes[neighborIdxb]].unitOwner][thisa->combatGrid[hexes[neighborIdxb]].stackIdx];
          if ( army::SpellCastWorks(stack, SPELL_METEOR_SHOWER) )
          {
            if ( !gArmyEffected[thisa->combatGrid[hexes[neighborIdxb]].unitOwner][thisa->combatGrid[hexes[neighborIdxb]].stackIdx] )
            {
              gArmyEffected[thisa->combatGrid[hexes[neighborIdxb]].unitOwner][thisa->combatGrid[hexes[neighborIdxb]].stackIdx] = 1;
              if ( !stack->damageTakenDuringSomeTimePeriod )
              {
                a2 = baseDam;
                if ( stack->creatureIdx == CREATURE_EARTH_ELEMENTAL )
                  a2 = 2 * baseDam;
                army::Damage(stack, a2, SPELL_METEOR_SHOWER);
                hurtAnyone = 1;
              }
            }
          }
        }
      }
    }
    if ( hurtAnyone )
    {
      sprintf(gText, "The meteor shower does %d damage.", baseDam);
      combatManager::CombatMessage(thisa, gText, 1, 1, 0);
      army::PowEffect(stack, -1, 1, -1, -1);
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004A1070) --------------------------------------------------------
void __thiscall combatManager::ElementalStorm(combatManager *this)
{
  combatManager *thisa; // [sp+18h] [bp-40h]@1
  H2RECT str; // [sp+1Ch] [bp-3Ch]@10
  icon *icn; // [sp+2Ch] [bp-2Ch]@2
  int l; // [sp+30h] [bp-28h]@17
  int i; // [sp+34h] [bp-24h]@2
  army *creat; // [sp+38h] [bp-20h]@19
  int a2; // [sp+3Ch] [bp-1Ch]@20
  int j; // [sp+40h] [bp-18h]@4
  int y; // [sp+44h] [bp-14h]@6
  int v10; // [sp+48h] [bp-10h]@15
  int x; // [sp+4Ch] [bp-Ch]@8
  int k; // [sp+50h] [bp-8h]@15
  int harmedAnyone; // [sp+54h] [bp-4h]@15

  thisa = this;
  if ( !gbNoShowCombat )
  {
    icn = resourceManager::GetIcon(gpResourceManager, "storm.icn");
    for ( i = 0; i < 6; ++i )
    {
      for ( j = 0; j < 10; ++j )
      {
        glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
        combatManager::DrawFrame(thisa, 0, 0, 0, 0, 75, 1, 1);
        for ( y = 0; y < 10; ++y )
        {
          for ( x = 0; x < 12; ++x )
            icon::CombatClipDrawToBuffer(icn, 54 * x, 54 * y, (y + j + 3 * x) % 10, &str, 0, 0, 0, 0);
        }
        combatManager::UpdateCombatArea(thisa);
        DelayTil(&glTimers);
      }
    }
    resourceManager::Dispose(gpResourceManager, (resource *)icn);
  }
  combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
  harmedAnyone = 0;
  v10 = 25 * thisa->heroSpellpowers[thisa->currentActionSide];
  for ( k = 0; k < 2; ++k )
  {
    for ( l = 0; thisa->numCreatures[k] > l; ++l )
    {
      creat = &thisa->creatures[k][l];
      if ( army::SpellCastWorks(&thisa->creatures[k][l], SPELL_ELEMENTAL_STORM) )
      {
        a2 = v10;
        if ( creat->creatureIdx == CREATURE_AIR_ELEMENTAL )
          a2 *= 2;
        if ( creat->creatureIdx == CREATURE_IRON_GOLEM || creat->creatureIdx == CREATURE_STEEL_GOLEM )
          a2 = (signed __int64)((double)a2 * 0.5);
        if ( thisa->heroes[k] && hero::HasArtifact(thisa->heroes[k], 89) )
          a2 = (signed __int64)((double)a2 * 0.5);
        army::Damage(creat, a2, SPELL_ELEMENTAL_STORM);
        harmedAnyone = 1;
      }
    }
  }
  if ( harmedAnyone )
  {
    sprintf(gText, "The elemental storm does %d damage.", v10);
    combatManager::CombatMessage(thisa, gText, 1, 1, 0);
    army::PowEffect(creat, -1, 1, -1, -1);
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004A1370) --------------------------------------------------------
#error "4A1370: undefined or illegal type '#72' (funcsize=572)"

//----- (004A1DE0) --------------------------------------------------------
void __thiscall combatManager::TurnToStone(combatManager *this, army *stack)
{
  combatManager *thisa; // ST28_4@1
  int v3; // eax@1

  thisa = this;
  combatManager::ResetLimitCreature(this);
  v3 = 80 * stack->owningSide + 4 * stack->stackIdx;
  ++*(signed int *)((char *)thisa->limitCreature[0] + v3);
  combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
  heroWindowManager::SaveFizzleSource(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1);
  combatManager::DrawFrame(thisa, 0, 1, 0, 1, 75, 1, 1);
  army::SetSpellInfluence(stack, EFFECT_PETRIFY, 3);
  combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 1, 1);
  heroWindowManager::FizzleForward(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1,
    75,
    0,
    0);
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004A1EF0) --------------------------------------------------------
void __thiscall combatManager::BloodLustEffect(combatManager *this, army *a2, int flagAdditions)
{
  int v4; // eax@1

  combatManager::ResetLimitCreature(this);
  v4 = 80 * a2->owningSide + 4 * a2->stackIdx;
  ++*(signed int *)((char *)this->limitCreature[0] + v4);
  combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
  heroWindowManager::SaveFizzleSource(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1);
  combatManager::DrawFrame(this, 0, 1, 0, 1, 75, 1, 1);
  *(_DWORD *)&a2->creature.creature_flags |= flagAdditions;
  combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 1, 1);
  heroWindowManager::FizzleForward(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1,
    110,
    0,
    0);
  heroWindowManager::SaveFizzleSource(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1);
  *(_DWORD *)&a2->creature.creature_flags -= flagAdditions;
  combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 75, 1, 1);
  heroWindowManager::FizzleForward(
    gpWindowManager,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1,
    110,
    0,
    0);
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004A2090) --------------------------------------------------------
void __fastcall combatManager::Ripple(combatManager *a1, int a2, int strength)
{
  combatManager *thisa; // ST28_4@1

  thisa = a1;
  memcpy(a1->probablyBitmapForCombatScreen->contents, gpWindowManager->screenBuffer->contents, 0x45380u);
  DoRipple(thisa->probablyBitmapForCombatScreen, gpWindowManager->screenBuffer, 443, strength);
  thisa->zeroedAfterAnimatingDeathAndHolySpells = 0;
  combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
}

//----- (004A2110) --------------------------------------------------------
combatManager *__fastcall combatManager::Blur(combatManager *this, int edx0, char a2, char a3, char a4)
{
  combatManager *thisa; // ST1C_4@1
  combatManager *result; // eax@1

  thisa = this;
  memcpy(this->probablyBitmapForCombatScreen->contents, gpWindowManager->screenBuffer->contents, 0x45380u);
  DoBlur(thisa->probablyBitmapForCombatScreen, gpWindowManager->screenBuffer, 443, a2, a3, a4);
  result = thisa;
  thisa->zeroedAfterAnimatingDeathAndHolySpells = 0;
  return result;
}

//----- (004A2190) --------------------------------------------------------
void __userpurge combatManager::ResetBoltAngle(char bl0<bl>, double a2<st1>, int a1)
{
  int v3; // ebp@0
  int v4; // ST6C_4@2
  int v5; // eax@2
  int v6; // ST34_4@12
  double v7; // st6@12
  __int16 v8; // fps@12
  float v9; // ST68_4@12
  unsigned int v10; // [sp+10h] [bp-64h]@0
  unsigned int v11; // [sp+14h] [bp-60h]@0
  unsigned int v12; // [sp+18h] [bp-5Ch]@0
  float v13; // [sp+4Ch] [bp-28h]@17
  signed int v14; // [sp+54h] [bp-20h]@9
  int v15; // [sp+58h] [bp-1Ch]@6
  int v16; // [sp+58h] [bp-1Ch]@7
  signed int v17; // [sp+5Ch] [bp-18h]@2

  if ( !*(_DWORD *)(a1 + 68) )
  {
    v4 = abs(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 44));
    v5 = abs(*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 48));
    v17 = (signed __int64)sqrt((double)(v5 * v5 + v4 * v4));
    if ( *(_DWORD *)(a1 + 100) >= v17 )
      *(float *)(a1 + 112) = (double)(*(_DWORD *)(a1 + 100) - v17) / (double)*(signed int *)(a1 + 100);
    else
      *(_DWORD *)(a1 + 112) = 0;
    if ( *(_DWORD *)(a1 + 92) != *(_DWORD *)(a1 + 96) )
    {
      v15 = *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92);
      if ( v15 <= 0 )
        v16 = v15 - 1;
      else
        v16 = v15 + 1;
      v14 = (unsigned __int64)(signed __int64)((double)v16 * *(float *)(a1 + 112)) + *(_DWORD *)(a1 + 92);
      if ( v14 < 1 )
        v14 = 1;
      *(_DWORD *)(a1 + 20) = v14;
    }
    *(_DWORD *)(a1 + 76) = -(*(_DWORD *)(a1 + 20) >> 1);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 76) + *(_DWORD *)(a1 + 20) - 1;
    v6 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 48);
    v7 = (double)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 44));
    UNDEF(v8);
    atan2(
      v3,
      bl0,
      v8,
      v7,
      SLODWORD(v7),
      *(unsigned __int64 *)&v7 >> 32,
      COERCE_UNSIGNED_INT64((double)v6),
      COERCE_UNSIGNED_INT64((double)v6) >> 32,
      v10,
      v11,
      v12);
    *(float *)(a1 + 56) = v7;
    v9 = (double)((*(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 104)) / 200);
    *(float *)(a1 + 60) = (2.5 - *(float *)(a1 + 112)) / 2.0 * v9 + *(float *)(a1 + 56);
    if ( (*(_DWORD *)(a1 + 104) || *(_DWORD *)(a1 + 108))
      && ((double)v17 > (double)*(signed int *)(a1 + 32) * 1.5 || *(_DWORD *)(a1 + 116)) )
    {
      if ( *(_DWORD *)(a1 + 104) == *(_DWORD *)(a1 + 108) )
        v13 = (double)*(signed int *)(a1 + 104) / 100.0;
      else
        v13 = (double)Random(*(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108)) / 100.0;
      *(float *)(a1 + 56) = (2.0 - *(float *)(a1 + 112)) / 1.5 * v13 + *(float *)(a1 + 56);
    }
  }
}

//----- (004A2440) --------------------------------------------------------
int __stdcall combatManager::DrawBolt(int a1, int a2)
{
  int result; // eax@3
  int v3; // ebx@48
  int v4; // [sp+1Ch] [bp-38h]@1
  int j; // [sp+20h] [bp-34h]@14
  int v6; // [sp+24h] [bp-30h]@1
  int i; // [sp+28h] [bp-2Ch]@1
  int v8; // [sp+2Ch] [bp-28h]@12
  int v9; // [sp+34h] [bp-20h]@1
  int v10; // [sp+38h] [bp-1Ch]@12
  signed __int8 v11; // [sp+3Ch] [bp-18h]@34
  int v12; // [sp+48h] [bp-Ch]@1
  int v13; // [sp+4Ch] [bp-8h]@26
  int v14; // [sp+50h] [bp-4h]@48

  v9 = (signed __int64)*(float *)(a1 + 36);
  v4 = (signed __int64)*(float *)(a1 + 40);
  v6 = *(_DWORD *)(a1 + 76);
  v12 = *(_DWORD *)(a1 + 80);
  Random(7, 12);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( i >= a2 )
      break;
    *(float *)(a1 + 36) = sin(*(float *)(a1 + 56)) + *(float *)(a1 + 36);
    *(float *)(a1 + 40) = cos(*(float *)(a1 + 56)) + *(float *)(a1 + 40);
    *(_DWORD *)(a1 + 44) = (signed __int64)*(float *)(a1 + 36);
    *(_DWORD *)(a1 + 48) = (signed __int64)*(float *)(a1 + 40);
    if ( *(_DWORD *)(a1 + 44) < 0 )
    {
      *(_DWORD *)(a1 + 44) = 0;
      *(_DWORD *)(a1 + 36) = 0;
    }
    if ( *(_DWORD *)(a1 + 44) > 639 )
    {
      *(_DWORD *)(a1 + 44) = 639;
      *(_DWORD *)(a1 + 36) = 1142931456;
    }
    if ( *(_DWORD *)(a1 + 48) < 0 )
    {
      *(_DWORD *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 40) = 0;
    }
    if ( *(_DWORD *)(a1 + 48) > 442 )
    {
      *(_DWORD *)(a1 + 48) = 442;
      *(_DWORD *)(a1 + 40) = 1138556928;
    }
    v10 = *(_DWORD *)(a1 + 44);
    v8 = *(_DWORD *)(a1 + 48);
    if ( *(_DWORD *)(a1 + 44) != v9 || *(_DWORD *)(a1 + 48) != v4 )
    {
      v9 = *(_DWORD *)(a1 + 44);
      v4 = *(_DWORD *)(a1 + 48);
      for ( j = v6; v12 >= j; ++j )
      {
        if ( *(_DWORD *)(a1 + 52) )
          v8 = j + *(_DWORD *)(a1 + 48);
        else
          v10 = j + *(_DWORD *)(a1 + 44);
        if ( v10 >= 0 && v10 < 640 && v8 >= 0 && v8 < 443 )
        {
          if ( j >= 0 )
            v13 = v12 - j;
          else
            v13 = -(v6 - j);
          switch ( *(_DWORD *)(a1 + 24) )
          {
            case 0x101:
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = gColorTableRed[*(&gpWindowManager->screenBuffer->contents[640 * v8]
                                                                                           + v10)];
              break;
            case 0x12E:
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = uRedBeam[v13];
              break;
            case 0x12C:
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = uRainbow[j - v6];
              break;
            case 0x12F:
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = uRainbow[14 - (j - v6)];
              break;
            case 0x12D:
              if ( v13 )
              {
                switch ( v13 )
                {
                  case 1:
                    v11 = 116;
                    break;
                  case 2:
                    v11 = 117;
                    break;
                  case 3:
                    v11 = -52;
                    break;
                  case 4:
                    v11 = -50;
                    break;
                  default:
                    v11 = -42;
                    break;
                }
              }
              else
              {
                v11 = 114;
              }
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = v11;
              break;
            default:
              *(&gpWindowManager->screenBuffer->contents[640 * v8] + v10) = *(_BYTE *)(a1 + 24);
              break;
          }
        }
      }
      v3 = abs(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 44));
      v14 = abs(*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 48)) + v3;
      if ( *(_DWORD *)(a1 + 68) )
      {
        if ( *(_DWORD *)(a1 + 72) + 1 < v14 || v14 <= 2 )
        {
          result = a1;
          *(_DWORD *)(a1 + 64) = 1;
          return result;
        }
        if ( *(_DWORD *)(a1 + 72) > v14 )
          *(_DWORD *)(a1 + 72) = v14;
      }
      else if ( v14 < 15 )
      {
        *(_DWORD *)(a1 + 68) = 1;
        *(_DWORD *)(a1 + 72) = v14;
      }
    }
  }
  return result;
}

//----- (004A2930) --------------------------------------------------------
void __userpurge combatManager::AddBolt(int a1<ebx>, double a2<st1>, int *a3, int a4, signed int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15)
{
  int v15; // ST28_4@27
  int v16; // eax@27
  double v17; // st6@27

  if ( a4 < 0 )
    a4 = 0;
  if ( a4 > 639 )
    a4 = 639;
  if ( a5 < 0 )
    a5 = 0;
  if ( a5 > 442 )
    a5 = 442;
  if ( a6 < 0 )
    a6 = 0;
  if ( a6 > 639 )
    a6 = 639;
  if ( a7 < 0 )
    a7 = 0;
  if ( a7 > 442 )
    a7 = 442;
  *a3 = a4;
  a3[1] = a5;
  a3[2] = a6;
  a3[3] = a7;
  a3[4] = a8;
  a3[5] = a9;
  a3[23] = a9;
  a3[24] = a10;
  a3[6] = a11;
  a3[26] = a12;
  a3[27] = a13;
  a3[8] = a14;
  *((float *)a3 + 9) = (double)a4;
  *((float *)a3 + 10) = (double)a5;
  a3[11] = a4;
  a3[12] = a5;
  a3[16] = 0;
  a3[17] = 0;
  a3[21] = a4;
  a3[22] = a5;
  a3[28] = 0;
  a3[29] = a15;
  if ( a11 != 0x12C && a11 != 0x12F )
  {
    a1 = abs(a7 - a5);
    a3[13] = a1 < abs(a6 - a4);
  }
  else
  {
    a3[13] = a4 <= 0 || a4 >= 639;
  }
  v15 = abs(a6 - a4);
  v16 = abs(a7 - a5);
  v17 = sqrt((double)(v16 * v16 + v15 * v15));
  a3[25] = (signed __int64)v17;
  combatManager::ResetBoltAngle(a1, v17, (int)a3);
}

//----- (004A2BA0) --------------------------------------------------------
heroWindowManager *__userpurge combatManager::DoBolt<eax>(combatManager *ecx0<ecx>, int a2<ebx>, double a3<st1>, double st7_0<st0>, int clearAfterwards, signed int startX, signed int startY, signed int endX, signed int endY, int forkControl1, int forkControl2, int startWidth, int endWidth, int colorController, int minRandomDiverge, int maxRandomDiverge, int divergeFreq, int a17, int a13, signed int a19, int a20)
{
  #72 *v21; // ST2C_4@9
  void *v22; // eax@9
  int v23; // STB8_4@18
  int v24; // eax@19
  int v25; // ST68_4@53
  int v26; // ebx@64
  int v27; // ebx@68
  char *v28; // eax@88
  heroWindowManager *result; // eax@90
  combatManager *v30; // [sp+40h] [bp-80h]@1
  palette *v31; // [sp+54h] [bp-6Ch]@4
  int a7; // [sp+5Ch] [bp-64h]@74
  signed int v33; // [sp+60h] [bp-60h]@71
  float v34; // [sp+64h] [bp-5Ch]@69
  int a5; // [sp+68h] [bp-58h]@73
  int a4; // [sp+6Ch] [bp-54h]@73
  float v37; // [sp+70h] [bp-50h]@71
  char *a1; // [sp+74h] [bp-4Ch]@9
  signed int v39; // [sp+78h] [bp-48h]@3
  palette *v40; // [sp+7Ch] [bp-44h]@3
  int *v41; // [sp+80h] [bp-40h]@19
  int v42; // [sp+84h] [bp-3Ch]@21
  int j; // [sp+88h] [bp-38h]@23
  signed int i; // [sp+8Ch] [bp-34h]@9
  int k; // [sp+8Ch] [bp-34h]@25
  int l; // [sp+8Ch] [bp-34h]@53
  int m; // [sp+8Ch] [bp-34h]@60
  int n; // [sp+8Ch] [bp-34h]@79
  signed int screenY; // [sp+98h] [bp-28h]@25
  int screenYa; // [sp+98h] [bp-28h]@45
  signed int v51; // [sp+9Ch] [bp-24h]@25
  int v52; // [sp+9Ch] [bp-24h]@45
  int thisa; // [sp+A0h] [bp-20h]@3
  int v54; // [sp+A4h] [bp-1Ch]@3
  int screenX; // [sp+A8h] [bp-18h]@25
  int v56; // [sp+ACh] [bp-14h]@25
  palette *pal; // [sp+B0h] [bp-10h]@3
  int v58; // [sp+B4h] [bp-Ch]@60
  int v59; // [sp+B8h] [bp-8h]@21
  int v60; // [sp+BCh] [bp-4h]@64

  v30 = ecx0;
  if ( clearAfterwards )
    mouseManager::HideColorPointer(gpMouseManager);
  v54 = divergeFreq;
  v39 = 0;
  thisa = KBTickCount();
  gpWindowManager->cycleColors = 0;
  pal = 0;
  v40 = 0;
  if ( a20 )
  {
    pal = (palette *)resourceManager::GetPalette(gpResourceManager, "kb.pal");
    v31 = (palette *)operator new(20);
    if ( v31 )
      v40 = palette::palette(v31);
    else
      v40 = 0;
    if ( !v40 )
      MemError();
    v21 = palette::Data(pal);
    v22 = (void *)palette::Data(v40);
    memcpy(v22, (const void *)v21, 0x300u);
    a1 = (char *)palette::Data(v40);
    for ( i = 0; i < 768; ++i )
    {
      a1[i] += 16;
      if ( a1[i] > 63 )
        a1[i] = 63;
    }
    SetPalette(a1, 1);
  }
  if ( endX < startX )
  {
    minRandomDiverge = -minRandomDiverge;
    maxRandomDiverge = -maxRandomDiverge;
  }
  if ( maxRandomDiverge < minRandomDiverge )
  {
    v23 = maxRandomDiverge;
    maxRandomDiverge = minRandomDiverge;
    minRandomDiverge = v23;
  }
  v41 = (int *)operator new(0xBB8u);
  v24 = endWidth;
  if ( endWidth <= startWidth )
    v24 = startWidth;
  v42 = v24 >> 1;
  combatManager::AddBolt(
    (unsigned __int8)a2,
    a3,
    v41,
    startX,
    startY,
    endX,
    endY,
    forkControl1,
    startWidth,
    endWidth,
    colorController,
    minRandomDiverge,
    maxRandomDiverge,
    divergeFreq,
    a13);
  v59 = 1;
  while ( !v39 )
  {
    for ( j = 0; (divergeFreq - 1) / divergeFreq + 1 > j; ++j )
    {
      v39 = 1;
      screenY = 9999;
      screenX = 9999;
      v56 = -1;
      v51 = -1;
      for ( k = 0; v59 > k; ++k )
      {
        if ( !v41[30 * k + 16] )
        {
          if ( v41[30 * k + 11] > v51 )
            v51 = v41[30 * k + 11];
          if ( v41[30 * k + 11] < screenX )
            screenX = v41[30 * k + 11];
          if ( v41[30 * k + 12] > v56 )
            v56 = v41[30 * k + 12];
          if ( v41[30 * k + 12] < screenY )
            screenY = v41[30 * k + 12];
          combatManager::DrawBolt((int)&v41[30 * k], v54);
          if ( v41[30 * k + 11] > v51 )
            v51 = v41[30 * k + 11];
          if ( v41[30 * k + 11] < screenX )
            screenX = v41[30 * k + 11];
          if ( v41[30 * k + 12] > v56 )
            v56 = v41[30 * k + 12];
          if ( v41[30 * k + 12] < screenY )
            screenY = v41[30 * k + 12];
        }
      }
      v52 = v42 + v51;
      screenX -= v42;
      v56 += v42;
      screenYa = screenY - v42;
      if ( screenX < 0 )
        screenX = 0;
      if ( screenYa < 0 )
        screenYa = 0;
      if ( v52 > 639 )
        v52 = 639;
      if ( v56 > 442 )
        v56 = 442;
      DelayTil(&thisa);
      v25 = KBTickCount();
      a3 = (double)a19 * gfCombatSpeedMod[giCombatSpeed];
      thisa = (signed __int64)((double)v25 + a3);
      BlitBitmapToScreen(
        gpWindowManager->screenBuffer,
        screenX,
        screenYa,
        v52 - screenX + 1,
        v56 - screenYa + 1,
        screenX,
        screenYa);
      PollSound();
      for ( l = 0; v59 > l; ++l )
      {
        if ( !v41[30 * l + 16] )
          v39 = 0;
      }
      if ( v39 )
        goto LABEL_85;
      if ( forkControl1 )
      {
        v58 = v59;
        for ( m = 0; v58 > m; ++m )
        {
          if ( !v41[30 * m + 16] )
          {
            v26 = abs(v41[30 * m + 2] - v41[30 * m + 11]);
            a2 = abs(v41[30 * m + 3] - v41[30 * m + 12]) + v26;
            v60 = a2;
            if ( v59 < 25 )
            {
              if ( 2 * divergeFreq < v60 )
              {
                if ( Random(0, 100 * forkControl1 / divergeFreq) < 100 )
                {
                  if ( !v41[30 * m + 21]
                    || (v27 = abs(v41[30 * m + 22] - v41[30 * m + 12]),
                        a2 = abs(v41[30 * m + 21] - v41[30 * m + 11]) + v27,
                        a3 = (double)forkControl1 * 0.75,
                        (double)a2 >= a3) )
                  {
                    v41[30 * m + 21] = v41[30 * m + 11];
                    v41[30 * m + 22] = v41[30 * m + 12];
                    v34 = (double)Random(50, 80) / 100.0;
                    if ( Random(0, 1) )
                      v34 = -v34;
                    v37 = v34 + *(float *)&v41[30 * m + 15];
                    v33 = Random(forkControl2 >> 1, forkControl2);
                    if ( v60 >> 1 < v33 )
                      v33 = v60 >> 1;
                    a4 = (signed __int64)(sin(v37) * (double)v33 + (double)v41[30 * m + 11]);
                    a5 = (signed __int64)(cos(v37) * (double)v33 + (double)v41[30 * m + 12]);
                    LOBYTE(a2) = (_BYTE)v41;
                    if ( v41[30 * m + 23] <= v41[30 * m + 24] )
                      a7 = v41[30 * m + 5];
                    else
                      a7 = v41[30 * m + 5] - 1;
                    a3 = (double)minRandomDiverge * 0.66 + -20.0;
                    combatManager::AddBolt(
                      (unsigned __int8)v41,
                      a3,
                      &v41[30 * v59++],
                      v41[30 * m + 11],
                      v41[30 * m + 12],
                      a4,
                      a5,
                      forkControl1,
                      a7,
                      1,
                      colorController,
                      (signed __int64)a3,
                      (signed __int64)((double)maxRandomDiverge * 0.66 + 20.0),
                      divergeFreq,
                      v41[30 * m + 29]);
                  }
                }
              }
            }
          }
        }
      }
    }
    for ( n = 0; v59 > n; ++n )
    {
      if ( !v41[30 * n + 16] )
        combatManager::ResetBoltAngle(a2, a3, (int)&v41[30 * n]);
    }
  }
LABEL_85:
  operator delete(v41);
  if ( clearAfterwards )
  {
    combatManager::DrawFrame(v30, 1, 0, 0, 0, 75, 1, 1);
    mouseManager::ShowColorPointer(gpMouseManager);
  }
  if ( a20 )
  {
    v28 = (char *)palette::Data(pal);
    SetPalette(v28, 1);
    resourceManager::Dispose(gpResourceManager, (resource *)pal);
    if ( v40 )
      ((void (__thiscall *)(palette *))v40->vtable->scalarDeletingDestructor)(v40);
  }
  result = gpWindowManager;
  gpWindowManager->cycleColors = 1;
  return result;
}

//----- (004A3610) --------------------------------------------------------
int __thiscall combatManager::GetNextChainLightningTarget(combatManager *ecx0, army *creat, int forChainLightning)
{
  int v3; // eax@10
  int v4; // ST40_4@10
  int v5; // eax@10
  int v6; // eax@10
  signed int i; // [sp+1Ch] [bp-28h]@1
  signed int v10; // [sp+20h] [bp-24h]@1
  army *this; // [sp+24h] [bp-20h]@5
  signed int v12; // [sp+28h] [bp-1Ch]@10
  int j; // [sp+30h] [bp-14h]@3
  int v14; // [sp+34h] [bp-10h]@1
  int v15; // [sp+38h] [bp-Ch]@1
  int v16; // [sp+3Ch] [bp-8h]@1

  v10 = 999999;
  v14 = -1;
  v16 = army::MidX(creat);
  v15 = army::MidY(creat);
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; ecx0->numCreatures[i] > j; ++j )
    {
      this = &ecx0->creatures[i][j];
      if ( !gArmyEffected[i][j]
        && (forChainLightning && army::SpellCastWorks(this, SPELL_CHAIN_LIGHTNING)
         || !forChainLightning && army::SpellCastWorkChance(this, SPELL_CHAIN_LIGHTNING) != 0.0) )
      {
        v3 = army::MidX(this);
        v4 = abs(v3 - v16);
        v5 = army::MidY(this);
        v6 = abs(v5 - v15);
        v12 = (signed __int64)sqrt((double)(v6 * v6 + v4 * v4));
        if ( v12 < v10 )
        {
          v10 = v12;
          v14 = ecx0->creatures[i][j].occupiedHex;
        }
      }
    }
  }
  return v14;
}

//----- (004A37A0) --------------------------------------------------------
void __thiscall combatManager::ChainLightning(combatManager *this, int targetHex, int power)
{
  int v3; // ebx@0
  double v4; // st6@0
  double v5; // st7@11
  int v6; // ST50_4@19
  army *stack; // [sp+2Ch] [bp-44h]@3
  signed int v9; // [sp+38h] [bp-38h]@1
  signed int baseDam; // [sp+3Ch] [bp-34h]@6
  int tick; // [sp+40h] [bp-30h]@1
  unsigned int i; // [sp+44h] [bp-2Ch]@1
  int divergeFreq; // [sp+48h] [bp-28h]@11
  int v14; // [sp+4Ch] [bp-24h]@11
  int a15; // [sp+50h] [bp-20h]@16
  int v16; // [sp+58h] [bp-18h]@18
  signed int endX; // [sp+5Ch] [bp-14h]@11
  signed int startY; // [sp+60h] [bp-10h]@1
  signed int startX; // [sp+64h] [bp-Ch]@1
  signed int endY; // [sp+68h] [bp-8h]@11
  int v21; // [sp+6Ch] [bp-4h]@11

  v9 = 40 * power;
  tick = KBTickCount();
  startX = castX;
  startY = castY;
  combatManager::ClearEffects();
  mouseManager::HideColorPointer(gpMouseManager);
  for ( i = 0; (signed int)i < 4; ++i )
  {
    stack = &this->creatures[this->combatGrid[targetHex].unitOwner][this->combatGrid[targetHex].stackIdx];
    if ( (signed int)i <= 2 && this->combatGrid[targetHex].unitOwner == this->currentActionSide )
      gpCombatManager->shouldDoHeroFidget1[this->currentActionSide] = 1;
    baseDam = v9;
    if ( stack->creatureIdx == CREATURE_AIR_ELEMENTAL )
      baseDam = 2 * v9;
    if ( stack->creatureIdx == CREATURE_IRON_GOLEM || stack->creatureIdx == CREATURE_STEEL_GOLEM )
      baseDam = (signed __int64)((double)baseDam * 0.5);
    army::Damage(stack, baseDam, SPELL_NONE);
    v9 >>= 1;
    gArmyEffected[stack->owningSide][stack->stackIdx] = 1;
    endX = army::MidX(stack);
    endY = army::MidY(stack);
    v21 = abs(endX - startX);
    v14 = abs(endY - startY);
    v5 = sqrt((double)(v21 * v21 + v14 * v14));
    divergeFreq = (signed int)(signed __int64)v5 / 10;
    if ( divergeFreq > 30 )
      divergeFreq = 30;
    if ( divergeFreq < 8 )
      divergeFreq = 8;
    a15 = divergeFreq <= 20 ? 2 : 3;
    combatManager::DoBolt(
      this,
      v3,
      v4,
      v5,
      0,
      startX,
      startY,
      endX,
      endY,
      0,
      80,
      9,
      2,
      0x12Du,
      10,
      80,
      divergeFreq,
      a15,
      0,
      0,
      i < 1);
    startX = endX;
    startY = endY;
    DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 100.0));
    v16 = combatManager::GetNextChainLightningTarget(this, stack, 1);
    if ( v16 == -1 )
      break;
    targetHex = v16;
    combatManager::DrawFrame(this, 1, 0, 0, 0, 0, 1, 1);
    DelayTil(&tick);
    v6 = KBTickCount();
    v4 = gfCombatSpeedMod[giCombatSpeed] * 100.0;
    tick = (signed __int64)((double)v6 + v4);
  }
  combatManager::ShowMassSpell(
    this,
    (char (*)[2][20])gArmyEffected,
    (unsigned __int8)gsSpellInfo[3].creatureEffectAnimationIdx,
    1);
  combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
  mouseManager::ShowColorPointer(gpMouseManager);
}

//----- (004A3B10) --------------------------------------------------------
void __thiscall combatManager::VaporizeCreature(combatManager *this, int a2, int a3)
{
  combatManager *thisa; // ST2C_4@1
  signed int i; // [sp+18h] [bp-24h]@1
  signed int v5; // [sp+1Ch] [bp-20h]@4
  int j; // [sp+20h] [bp-1Ch]@11
  int v7; // [sp+24h] [bp-18h]@1
  army *v8; // [sp+28h] [bp-14h]@1
  signed int v9; // [sp+2Ch] [bp-10h]@4
  int v10; // [sp+34h] [bp-8h]@1
  int v11; // [sp+38h] [bp-4h]@1

  thisa = this;
  v8 = &this->creatures[a2][a3];
  combatManager::ResetLimitCreature(this);
  ++thisa->limitCreature[a2][a3];
  combatManager::DrawFrame(gpCombatManager, 1, 1, 1, 0, 75, 1, 1);
  gyModify = BaseAlloc(0x1E0u, "F:\\h2xsrc\\Source\\SPELLS.CPP", word_51A404 + 9);
  memset(gyModify, 0, 480u);
  v8->field_125 = gyModify;
  LODWORD(v8->field_4E) = 0;
  v11 = 5 * (giMinExtentY / 5);
  v10 = 5 * (giMaxExtentY / 5);
  v7 = (5 * (giMaxExtentY / 5) - v11) / 5 + 1;
  for ( i = 0; i < 3; ++i )
  {
    if ( i )
    {
      if ( i == 1 )
      {
        v9 = 1;
        v5 = 3;
      }
      else
      {
        v9 = 3;
        v5 = 2;
      }
    }
    else
    {
      v9 = 0;
      v5 = 1;
    }
    if ( i == 2 )
      v7 = (v7 - 1) / 2 + 1;
    for ( j = 0; v7 > j; ++j )
    {
      *((_BYTE *)gyModify + 5 * j + v9 + v11) = 127;
      *((_BYTE *)gyModify + v10 - v5 + -5 * j) = 127;
      gbLimitToExtent = 1;
      combatManager::DrawFrame(gpCombatManager, 1, 0, 1, 0, 30, 1, 1);
    }
  }
  DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 500.0));
  v8->field_125 = 0;
  LODWORD(v8->field_4E) = 1;
  BaseFree(gyModify, (int)"F:\\h2xsrc\\Source\\SPELLS.CPP", word_51A404 + 56);
  gyModify = 0;
  combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
}
// 4F7488: using guessed type int gbLimitToExtent;
// 51A404: using guessed type __int16 word_51A404;
// 524738: using guessed type int giMaxExtentY;

//----- (004A3DB0) --------------------------------------------------------
void __thiscall combatManager::RippleCreature(combatManager *this, int side, int stackIdx, int a4)
{
  float v4; // ST40_4@39
  float v6; // [sp+28h] [bp-40h]@2
  signed int a6; // [sp+30h] [bp-38h]@2
  signed int i; // [sp+38h] [bp-30h]@15
  float v9; // [sp+3Ch] [bp-2Ch]@2
  signed int y; // [sp+40h] [bp-28h]@8
  int ya; // [sp+40h] [bp-28h]@32
  unsigned int v12; // [sp+4Ch] [bp-1Ch]@15
  int v13; // [sp+50h] [bp-18h]@35
  int v14; // [sp+50h] [bp-18h]@37
  army *v15; // [sp+54h] [bp-14h]@1
  float *buf; // [sp+58h] [bp-10h]@8
  signed int v17; // [sp+5Ch] [bp-Ch]@2
  int v18; // [sp+60h] [bp-8h]@18
  int v19; // [sp+64h] [bp-4h]@18

  v15 = &this->creatures[side][stackIdx];
  if ( a4 )
  {
    v17 = 1;
    a6 = 30;
    v9 = 0.2;
    v6 = 0.1;
  }
  else
  {
    v17 = 2;
    a6 = 20;
    v9 = 0.30000001;
    v6 = 0.050000001;
  }
  combatManager::ResetLimitCreature(this);
  ++this->limitCreature[side][stackIdx];
  if ( a4 == 2 )
    combatManager::DrawFrame(gpCombatManager, 0, 1, 1, 0, 75, 1, 1);
  else
    combatManager::DrawFrame(gpCombatManager, 1, 1, 1, 0, 75, 1, 1);
  gyModify = BaseAlloc(480u, "F:\\h2xsrc\\Source\\SPELLS.CPP", twoFiveEightSeven + 44);
  buf = (float *)BaseAlloc(0x780u, "F:\\h2xsrc\\Source\\SPELLS.CPP", twoFiveEightSeven + 45);
  memset(gyModify, 0u, 480u);
  for ( y = 0; y < 480; ++y )
    buf[y] = (sin((double)(y % 62) / 20.0) - 0.5) * 2.0;
  v15->field_125 = gyModify;
  LODWORD(v15->field_4E) = 0;
  giMinExtentX -= 10;
  giMaxExtentX += 10;
  if ( giMinExtentX < 0 )
    giMinExtentX = 0;
  if ( giMaxExtentX > 639 )
    giMaxExtentX = 639;
  v12 = giMaxExtentY - giMinExtentY + 1;
  for ( i = 10; i < 70; i += v17 )
  {
    v18 = abs(20 - i % 40) - 10;
    v19 = (i - 10) / 10 + 1;
    if ( a4 == 2 )
    {
      v19 = 7 - v19;
    }
    else if ( !a4 )
    {
      if ( (i - 10) / 10 == -1 )
        v19 = 5;
      else
        v19 = 8 - v19;
    }
    if ( i <= 20 || i >= 60 || v18 != -3 && v18 != -1 && v18 && v18 != 1 && v18 != 3 )
    {
      memset((char *)gyModify + giMinExtentY, 0, v12);
      for ( ya = giMinExtentY; giMaxExtentY > ya; ++ya )
      {
        if ( a4 == 2 )
          v13 = ya + 2 * i - giMaxExtentY - 20;
        else
          v13 = giMinExtentY + 2 * i - 20 - ya;
        v14 = v13 + 15;
        if ( v14 >= 0 )
        {
          if ( v14 < 480 )
          {
            v4 = ((double)v19 * v6 + v9) * (double)v18;
            *((_BYTE *)gyModify + ya) = (signed __int64)(buf[v14] * v4);
          }
        }
      }
      if ( a4 == 1 && i >= 50 )
        memset(
          (char *)gyModify + giMinExtentY - 1,
          0x7Fu,
          (signed int)(v12 * (21 - (70 - i))) / 20 + giMinExtentY + 1 - (giMinExtentY - 1) + 1);
      if ( a4 == 2 && i < 30 )
        memset(
          (char *)gyModify + giMinExtentY - 1,
          0x7Fu,
          giMaxExtentY - 1 - (signed int)(v12 * (i - 9)) / 20 - (giMinExtentY - 1) + 1);
      gbLimitToExtent = 1;
      combatManager::DrawFrame(gpCombatManager, 1, 0, 1, 0, a6, 1, 1);
    }
  }
  DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 500.0));
  v15->field_125 = NULL;
  LODWORD(v15->field_4E) = 1;
  BaseFree(gyModify, (int)"F:\\h2xsrc\\Source\\SPELLS.CPP", twoFiveEightSeven + 142);
  BaseFree(buf, (int)"F:\\h2xsrc\\Source\\SPELLS.CPP", twoFiveEightSeven + 143);
  gyModify = 0;
  if ( a4 != 1 )
    combatManager::DrawFrame(gpCombatManager, 1, 0, 0, 0, 75, 1, 1);
}
// 4F7488: using guessed type int gbLimitToExtent;
// 51A440: using guessed type __int16 twoFiveEightSeven;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004A4330) --------------------------------------------------------
void __thiscall combatManager::ShowMassSpell(combatManager *this, char (*stackAffected)[2][20], int animIdx, int isDamageSpell)
{
  signed int i; // [sp+14h] [bp-20h]@3
  signed int l; // [sp+14h] [bp-20h]@26
  signed int n; // [sp+14h] [bp-20h]@47
  signed int kk; // [sp+14h] [bp-20h]@55
  signed int mm; // [sp+14h] [bp-20h]@71
  signed int highestFromFrameIdx; // [sp+1Ch] [bp-18h]@1
  signed int v11; // [sp+20h] [bp-14h]@71
  int k; // [sp+24h] [bp-10h]@24
  int jj; // [sp+24h] [bp-10h]@53
  int highestToFrameIdx; // [sp+28h] [bp-Ch]@1
  int j; // [sp+2Ch] [bp-8h]@5
  int m; // [sp+2Ch] [bp-8h]@28
  int ii; // [sp+2Ch] [bp-8h]@49
  int ll; // [sp+2Ch] [bp-8h]@57
  int nn; // [sp+2Ch] [bp-8h]@73
  int fileID; // [sp+30h] [bp-4h]@1

  fileID = MAKEFILEID(gCombatFxNames[animIdx]);
  highestToFrameIdx = giNumPowFrames[animIdx] - 1;
  highestFromFrameIdx = 0;
  if ( gCurLoadedSpellEffect != animIdx )
  {
    resourceManager::Dispose(gpResourceManager, (resource *)gCurLoadedSpellIcon);
    gCurLoadedSpellIcon = resourceManager::GetIcon(gpResourceManager, fileID);
    gCurLoadedSpellEffect = animIdx;
  }
  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; this->numCreatures[i] > j; ++j )
    {
      if ( (*stackAffected)[i][j] )
        this->creatures[i][j].probablyIsNeedDrawSpellEffect = 1;
      if ( isDamageSpell
        && (*stackAffected)[i][j]
        && this->creatures[i][j].animationType != ANIMATION_TYPE_WINCE
        && this->creatures[i][j].animationType != ANIMATION_TYPE_WINCE_RETURN )
      {
        if ( this->creatures[i][j].quantity )
        {
          if ( this->creatures[i][j].frameInfo.animationLengths[14] > highestToFrameIdx )
            highestToFrameIdx = this->creatures[i][j].frameInfo.animationLengths[14];
          if ( this->creatures[i][j].frameInfo.animationLengths[15] > highestFromFrameIdx )
            highestFromFrameIdx = this->creatures[i][j].frameInfo.animationLengths[15];
          soundManager::MemorySample((soundManager *)gpSoundManager, this->creatures[i][j].combatSounds[2]);
        }
        else
        {
          if ( this->creatures[i][j].frameInfo.animationLengths[13] > highestToFrameIdx )
            highestToFrameIdx = this->creatures[i][j].frameInfo.animationLengths[13];
          soundManager::MemorySample((soundManager *)gpSoundManager, this->creatures[i][j].combatSounds[4]);
        }
      }
    }
  }
  for ( k = 0; highestToFrameIdx > k; ++k )
  {
    for ( l = 0; l < 2; ++l )
    {
      for ( m = 0; this->numCreatures[l] > m; ++m )
      {
        this->creatures[l][m].field_FA = 0;
        if ( isDamageSpell && (*stackAffected)[l][m] )
        {
          if ( this->creatures[l][m].quantity )
          {
            if ( this->creatures[l][m].animationType == ANIMATION_TYPE_WINCE )
            {
              if ( this->creatures[l][m].frameInfo.animationLengths[this->creatures[l][m].animationType] > this->creatures[l][m].animationFrame + 1 )
                ++this->creatures[l][m].animationFrame;
            }
            else
            {
              this->creatures[l][m].animationType = ANIMATION_TYPE_WINCE;
              this->creatures[l][m].animationFrame = 0;
            }
          }
          else if ( this->creatures[l][m].animationType == ANIMATION_TYPE_DYING )
          {
            if ( this->creatures[l][m].frameInfo.animationLengths[this->creatures[l][m].animationType] > this->creatures[l][m].animationFrame + 1 )
              ++this->creatures[l][m].animationFrame;
          }
          else
          {
            this->creatures[l][m].animationType = ANIMATION_TYPE_DYING;
            this->creatures[l][m].animationFrame = 0;
          }
        }
        if ( giNumPowFrames[animIdx] > k + 1 )
          gCurSpellEffectFrame = k;
      }
    }
    combatManager::DrawFrame(this, 1, 0, 0, 0, 110, 1, 1);
  }
  for ( n = 0; n < 2; ++n )
  {
    for ( ii = 0; this->numCreatures[n] > ii; ++ii )
      this->creatures[n][ii].probablyIsNeedDrawSpellEffect = 0;
  }
  for ( jj = 0; highestFromFrameIdx + 1 > jj; ++jj )
  {
    for ( kk = 0; kk < 2; ++kk )
    {
      for ( ll = 0; this->numCreatures[kk] > ll; ++ll )
      {
        if ( isDamageSpell && (*stackAffected)[kk][ll] && this->creatures[kk][ll].animationType != 7 )
        {
          if ( this->creatures[kk][ll].animationType == ANIMATION_TYPE_WINCE )
          {
            this->creatures[kk][ll].animationType = ANIMATION_TYPE_WINCE_RETURN;
            this->creatures[kk][ll].animationFrame = 0;
          }
          else if ( this->creatures[kk][ll].frameInfo.animationLengths[this->creatures[kk][ll].animationType] <= this->creatures[kk][ll].animationFrame
                                                                                                + 1 )
          {
            if ( this->creatures[kk][ll].animationType != ANIMATION_TYPE_DYING )
            {
              this->creatures[kk][ll].animationType = ANIMATION_TYPE_STANDING;
              this->creatures[kk][ll].animationFrame = 0;
            }
          }
          else
          {
            ++this->creatures[kk][ll].animationFrame;
          }
        }
      }
    }
    combatManager::DrawFrame(this, 1, 0, 0, 0, 110, 1, 1);
  }
  v11 = 0;
  memset(this->shouldVanish, 0, 0x28u);
  this->anyStacksShouldVanish = 0;
  for ( mm = 0; mm < 2; ++mm )
  {
    for ( nn = 0; this->numCreatures[mm] > nn; ++nn )
    {
      if ( (*stackAffected)[mm][nn] && !this->creatures[mm][nn].quantity )
      {
        army::ProcessDeath(&this->creatures[mm][nn], 0);
        v11 = 1;
      }
    }
  }
  if ( v11 )
    combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
  if ( this->anyStacksShouldVanish )
    combatManager::MakeCreaturesVanish(this);
}
// 5240A8: using guessed type int gpSoundManager;

//----- (004A49F0) --------------------------------------------------------
void __thiscall combatManager::CastMassSpell(combatManager *this, Spell spell, signed int spellpower)
{
  int v3; // edx@1
  combatManager *thisb; // [sp+14h] [bp-4Ch]@1
  int othSide; // [sp+18h] [bp-48h]@2
  int thisSide; // [sp+18h] [bp-48h]@8
  signed int side0; // [sp+18h] [bp-48h]@14
  signed int side1; // [sp+18h] [bp-48h]@23
  signed int side2; // [sp+18h] [bp-48h]@35
  signed int othSidee; // [sp+18h] [bp-48h]@44
  signed int othSidef; // [sp+18h] [bp-48h]@53
  signed int othSideg; // [sp+18h] [bp-48h]@64
  signed int affectedSide; // [sp+18h] [bp-48h]@74
  army *thisa; // [sp+1Ch] [bp-44h]@80
  int isDamageSpell; // [sp+20h] [bp-40h]@1
  signed int damage; // [sp+24h] [bp-3Ch]@23
  signed int damagea; // [sp+24h] [bp-3Ch]@53
  signed int anyoneAffected; // [sp+28h] [bp-38h]@64
  STACK_MODIFYING_EFFECT effect; // [sp+2Ch] [bp-34h]@87
  int animIdx; // [sp+30h] [bp-30h]@1
  int i; // [sp+34h] [bp-2Ch]@2
  int j; // [sp+34h] [bp-2Ch]@8
  int k; // [sp+34h] [bp-2Ch]@16
  int l; // [sp+34h] [bp-2Ch]@25
  int m; // [sp+34h] [bp-2Ch]@37
  int n; // [sp+34h] [bp-2Ch]@46
  int ii; // [sp+34h] [bp-2Ch]@55
  int jj; // [sp+34h] [bp-2Ch]@66
  int kk; // [sp+34h] [bp-2Ch]@76
  char stackAffected[2][20]; // [sp+38h] [bp-28h]@1

  thisb = this;
  animIdx = gsSpellInfo[spell].creatureEffectAnimationIdx;
  isDamageSpell = 0;
  gpWindowManager->cycleColors = 0;
  combatManager::ShowSpellMessage(this, 0, spell, 0);
  memset(stackAffected, 0, 40u);
  switch ( spell )
  {
    case SPELL_MASS_SLOW:
    case SPELL_MASS_CURSE:
      othSide = 1 - thisb->currentActionSide;
      for ( i = 0; thisb->numCreatures[othSide] > i; ++i )
      {
        if ( army::SpellCastWorks(&thisb->creatures[othSide][i], spell) )
          stackAffected[othSide][i] = 1;
      }
      break;
    case SPELL_MASS_CURE:
    case SPELL_MASS_HASTE:
    case SPELL_MASS_BLESS:
    case SPELL_MASS_SHIELD:
      thisSide = thisb->currentActionSide;
      for ( j = 0; thisb->numCreatures[thisSide] > j; ++j )
      {
        if ( army::SpellCastWorks(&thisb->creatures[thisSide][j], spell) )
          stackAffected[thisSide][j] = 1;
      }
      break;
    case SPELL_MASS_DISPEL:
      for ( side0 = 0; side0 < 2; ++side0 )
      {
        for ( k = 0; thisb->numCreatures[side0] > k; ++k )
        {
          if ( army::SpellCastWorks(&thisb->creatures[side0][k], spell) )
            stackAffected[side0][k] = 1;
        }
      }
      break;
    case SPELL_HOLY_WORD:
    case SPELL_HOLY_SHOUT:
      isDamageSpell = 1;
      damage = spellpower * ((unsigned int)(spell - SPELL_HOLY_WORD) < 1 ? 10 : 20);
      for ( side1 = 0; side1 < 2; ++side1 )
      {
        for ( l = 0; ; ++l )
        {
          v3 = l;
          if ( thisb->numCreatures[side1] <= l )
            break;
          if ( HIBYTE(thisb->creatures[side1][l].creature.creature_flags) & ATTR_UNDEAD
            && army::SpellCastWorks(&thisb->creatures[side1][l], spell) )
            stackAffected[side1][l] = 1;
        }
      }
      if ( spell == SPELL_HOLY_WORD )
        combatManager::Blur(thisb, v3, 0, -2, -2);
      else
        combatManager::Blur(thisb, v3, 0, -4, -4);
      for ( side2 = 0; side2 < 2; ++side2 )
      {
        for ( m = 0; thisb->numCreatures[side2] > m; ++m )
        {
          if ( stackAffected[side2][m] )
            army::Damage(&thisb->creatures[side2][m], damage, SPELL_NONE);
        }
      }
      sprintf(gText, "The %s spell does %d damage\nto all undead creatures.", gSpellNames[spell], damage);
      combatManager::CombatMessage(thisb, gText, 1, 1, 0);
      break;
    case SPELL_DEATH_RIPPLE:
    case SPELL_DEATH_WAVE:
      isDamageSpell = 1;
      for ( othSidee = 0; othSidee < 2; ++othSidee )
      {
        for ( n = 0; ; ++n )
        {
          v3 = n;
          if ( thisb->numCreatures[othSidee] <= n )
            break;
          if ( !(HIBYTE(thisb->creatures[othSidee][n].creature.creature_flags) & ATTR_UNDEAD)
            && army::SpellCastWorks(&thisb->creatures[othSidee][n], spell) )
            stackAffected[othSidee][n] = 1;
        }
      }
      combatManager::Ripple(thisb, v3, 2 - ((unsigned int)(spell - SPELL_DEATH_RIPPLE) < 1));
      damagea = spellpower * ((unsigned int)(spell - SPELL_DEATH_RIPPLE) < 1 ? 5 : 10);
      for ( othSidef = 0; othSidef < 2; ++othSidef )
      {
        for ( ii = 0; thisb->numCreatures[othSidef] > ii; ++ii )
        {
          if ( stackAffected[othSidef][ii] )
            army::Damage(&thisb->creatures[othSidef][ii], damagea, SPELL_NONE);
        }
      }
      sprintf(gText, "The Death spell does %d damage\nto all living creatures.", damagea);
      combatManager::CombatMessage(thisb, gText, 1, 1, 0);
      break;
    default:
      break;
  }
  if ( !gbNoShowCombat )
  {
    anyoneAffected = 0;
    for ( othSideg = 0; othSideg < 2; ++othSideg )
    {
      for ( jj = 0; thisb->numCreatures[othSideg] > jj; ++jj )
      {
        if ( stackAffected[othSideg][jj] )
          anyoneAffected = 1;
      }
    }
    if ( anyoneAffected )
      combatManager::ShowMassSpell(thisb, (char (*)[2][20])stackAffected, animIdx, isDamageSpell);
  }
  for ( affectedSide = 0; affectedSide < 2; ++affectedSide )
  {
    for ( kk = 0; thisb->numCreatures[affectedSide] > kk; ++kk )
    {
      if ( stackAffected[affectedSide][kk] )
      {
        thisa = &thisb->creatures[affectedSide][kk];
        switch ( spell )
        {
          case SPELL_MASS_CURSE:
            army::SetSpellInfluence(thisa, EFFECT_CURSE, spellpower);
            break;
          case SPELL_MASS_SLOW:
            army::SetSpellInfluence(thisa, EFFECT_SLOW, spellpower);
            break;
          case SPELL_MASS_HASTE:
            army::SetSpellInfluence(thisa, EFFECT_HASTE, spellpower);
            break;
          case SPELL_MASS_BLESS:
            army::SetSpellInfluence(thisa, EFFECT_BLESS, spellpower);
            break;
          case SPELL_MASS_SHIELD:
            army::SetSpellInfluence(thisa, EFFECT_SHIELD, spellpower);
            break;
          case SPELL_MASS_CURE:
            army::Cure(thisa, spellpower);
            break;
          case SPELL_MASS_DISPEL:
            for ( effect = 0; (signed int)effect < 15; ++effect )
              army::CancelIndividualSpell(thisa, effect);
            break;
          case SPELL_DEATH_RIPPLE:
          case SPELL_DEATH_WAVE:
            continue;
        }
      }
    }
  }
  combatManager::DrawFrame(thisb, 1, 0, 0, 0, 75, 1, 1);
  gpWindowManager->cycleColors = 1;
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004A52F0) --------------------------------------------------------
void __thiscall combatManager::MirrorImage(combatManager *this, int hex)
{
  int v2; // eax@62
  int v3; // eax@62
  signed __int64 v4; // qax@62
  combatManager *thisa; // [sp+14h] [bp-3Ch]@1
  int diffY; // [sp+18h] [bp-38h]@62
  int diffX; // [sp+1Ch] [bp-34h]@62
  int tick; // [sp+20h] [bp-30h]@62
  int v9; // [sp+24h] [bp-2Ch]@7
  int l; // [sp+28h] [bp-28h]@62
  int pow; // [sp+2Ch] [bp-24h]@58
  int j; // [sp+30h] [bp-20h]@14
  signed int neighborIdx; // [sp+34h] [bp-1Ch]@18
  int imageHex; // [sp+38h] [bp-18h]@44
  int k; // [sp+3Ch] [bp-14h]@44
  int i; // [sp+40h] [bp-10h]@3
  army *imageStack; // [sp+44h] [bp-Ch]@58
  int v18; // [sp+48h] [bp-8h]@1
  army *creat; // [sp+4Ch] [bp-4h]@1

  thisa = this;
  creat = &this->creatures[this->combatGrid[hex].unitOwner][this->combatGrid[hex].stackIdx];
  v18 = 1;
LABEL_2:
  if ( v18 < 10 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= 2 )
      {
        ++v18;
        goto LABEL_2;
      }
      if ( i )
      {
        if ( !(creat->creature.creature_flags & TWO_HEXER) )
          continue;
        if ( creat->facingRight == 1 )
          v9 = creat->occupiedHex + 1;
        else
          v9 = creat->occupiedHex - 1;
      }
      else
      {
        v9 = creat->occupiedHex;
      }
      for ( j = 0; j < 6; ++j )
      {
        if ( creat->facingRight == 1 )
          neighborIdx = j;
        else
          neighborIdx = 5 - j;
        if ( (creat->facingRight != 1 || neighborIdx != 1 || i || v18 != 1)
          && (creat->facingRight != 1 || neighborIdx != 4 || i || v18 != 1)
          && (creat->facingRight != 1 || neighborIdx != 4 || i != 1 || v18 > 2)
          && (creat->facingRight || neighborIdx != 4 || i || v18 != 1)
          && (creat->facingRight || neighborIdx != 1 || i || v18 != 1)
          && (creat->facingRight || neighborIdx != 1 || i != 1 || v18 > 2) )
        {
          imageHex = v9;
          for ( k = 0; k < v18; ++k )
          {
            imageHex = GetAdjacentCellIndexNoArmy(imageHex, neighborIdx);
            if ( imageHex >= 0
              && imageHex < 117
              && imageHex % 13
              && imageHex % 13 != 12
              && army::CanFit(creat, imageHex, 0, 0) )
            {
              combatManager::AddArmy(
                thisa,
                thisa->currentActionSide,
                creat->creatureIdx,
                creat->quantity,
                imageHex,
                MIRROR_IMAGE,
                0);
              imageStack = &thisa->creatures[thisa->combatGrid[imageHex].unitOwner][thisa->combatGrid[imageHex].stackIdx];
              *(_DWORD *)&imageStack->creature.creature_flags |= 0x800u;
              pow = thisa->heroSpellpowers[thisa->currentActionSide];
              if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 42) )
                pow += 2;
              if ( hero::HasArtifact(thisa->heroes[thisa->currentActionSide], 66) )
                pow += 10;
              imageStack->lifespan = pow;
              creat->mirrorIdx = imageStack->stackIdx;
              imageStack->mirroredIdx = creat->stackIdx;
              diffX = thisa->combatGrid[creat->occupiedHex].centerX - thisa->combatGrid[imageStack->occupiedHex].centerX;
              diffY = thisa->combatGrid[creat->occupiedHex].occupyingCreatureBottomY
                    - thisa->combatGrid[imageStack->occupiedHex].occupyingCreatureBottomY;
              combatManager::ResetLimitCreature(thisa);
              v2 = 80 * thisa->combatGrid[imageHex].unitOwner + 4 * thisa->combatGrid[imageHex].stackIdx;
              ++*(signed int *)((char *)thisa->limitCreature[0] + v2);
              v3 = 80 * thisa->combatGrid[hex].unitOwner + 4 * thisa->combatGrid[hex].stackIdx;
              ++*(signed int *)((char *)thisa->limitCreature[0] + v3);
              combatManager::DrawFrame(gpCombatManager, 0, 1, 0, 1, 75, 1, 1);
              v4 = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 50.0);
              tick = v4;
              for ( l = 0; l < 16; ++l )
              {
                imageStack->xDrawOffset = diffX * (16 - l) / 16;
                imageStack->yDrawOffset = diffY * (16 - l) / 16;
                gbLimitToExtent = 1;
                combatManager::DrawFrame(gpCombatManager, 0, 0, 0, 0, 0, 1, 0);
                heroWindowManager::UpdateScreenRegion(
                  gpWindowManager,
                  giMinExtentX,
                  giMinExtentY,
                  giMaxExtentX - giMinExtentX + 1,
                  giMaxExtentY - giMinExtentY + 1);
                gbLimitToExtent = 0;
                DelayTil(&tick);
                v4 = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 50.0);
                tick = v4;
              }
              imageStack->xDrawOffset = 0;
              imageStack->yDrawOffset = 0;
              combatManager::UpdateGrid(thisa, SHIDWORD(v4), 0, 1);
              combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
              return;
            }
          }
        }
      }
    }
  }
  sprintf(gText, "Mirror Image spell failed!");
  NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
}
// 4F7488: using guessed type int gbLimitToExtent;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004A59F0) --------------------------------------------------------
void __thiscall combatManager::SummonElemental(combatManager *this, CREATURES creatureId, int strength)
{
  char squaresAroundCaster[2][3]; // [sp+10h] [bp-18h]@1
  int hex; // [sp+18h] [bp-10h]@1
  int i; // [sp+1Ch] [bp-Ch]@4
  army *v7; // [sp+20h] [bp-8h]@9
  int tryFirst; // [sp+24h] [bp-4h]@1

  squaresAroundCaster[0][0] = 14;
  squaresAroundCaster[0][1] = 27;
  squaresAroundCaster[0][2] = 40;
  squaresAroundCaster[1][0] = 11;
  squaresAroundCaster[1][1] = 24;
  squaresAroundCaster[1][2] = 37;
  tryFirst = SRandom(0, 2);
  hex = -1;
  if ( this->heroes[this->currentActionSide]
    && hero::HasArtifact(this->heroes[this->currentActionSide], ARTIFACT_BOOK_OF_ELEMENTS) )
    strength *= 2;
  for ( i = 0; i < 3; ++i )
  {
    if ( this->combatGrid[squaresAroundCaster[this->currentActionSide][(i + tryFirst) % 3]].unitOwner == -1 )
      hex = squaresAroundCaster[this->currentActionSide][(i + tryFirst) % 3];
  }
  this->summonedCreatureType[this->currentActionSide] = creatureId;
  combatManager::AddArmy(this, this->currentActionSide, creatureId, 3 * strength, hex, 0, 1);
  v7 = &this->creatures[this->combatGrid[hex].unitOwner][this->combatGrid[hex].stackIdx];
  *(_DWORD *)&v7->creature.creature_flags |= 0x800u;
  hero::HasArtifact(this->heroes[this->currentActionSide], ARTIFACT_ENCHANTED_HOURGLASS);
  hero::HasArtifact(this->heroes[this->currentActionSide], ARTIFACT_WIZARDS_HAT);
}

//----- (004A5C10) --------------------------------------------------------
heroWindowManager *__userpurge combatManager::DoLuck<eax>(combatManager *this<ecx>, double a2<st1>, double a3<st0>, int side, int stackIdx)
{
  int v5; // ST64_4@1
  int v6; // ebx@1
  combatManager *thisa; // [sp+Ch] [bp-18h]@1
  army *stack; // [sp+10h] [bp-14h]@1
  int centX; // [sp+14h] [bp-10h]@1
  signed int startY; // [sp+18h] [bp-Ch]@3
  signed int startX; // [sp+1Ch] [bp-8h]@5
  int destY; // [sp+20h] [bp-4h]@1

  thisa = this;
  stack = &this->creatures[side][stackIdx];
  centX = army::MidX(&this->creatures[side][stackIdx]);
  v5 = thisa->combatGrid[stack->occupiedHex].occupyingCreatureBottomY;
  v6 = GetIconEntry(stack->creatureIcon, stack->frameInfo.animationFrameToImgIdx[7][0])->height + 5;
  destY = v5 - v6;
  if ( destY < 75 )
    destY = 75;
  startY = 0;
  if ( stack->facingRight == 1 )
  {
    if ( centX >= 480 )
      startX = centX - 150 - destY / 2;
    else
      startX = destY / 2 + centX + 150;
  }
  else if ( centX <= 200 )
  {
    startX = destY / 2 + centX + 150;
  }
  else
  {
    startX = centX - 150 - destY / 2;
  }
  if ( destY < 140 )
  {
    if ( side )
      startX = 639;
    else
      startX = 0;
    startY = destY + 75;
  }
  if ( startX < 0 )
    startX = 0;
  if ( startX > 639 )
    startX = 639;
  return combatManager::DoBolt(
           thisa,
           v6,
           a2,
           a3,
           0,
           startX,
           startY,
           centX,
           destY,
           0,
           0,
           15,
           15,
           centX >= startX ? 303 : 0x12Cu,
           40,
           40,
           10,
           1,
           1,
           30,
           0);
}

//----- (004A5E00) --------------------------------------------------------
void __userpurge combatManager::DoBlast(combatManager *this<ecx>, char a2<bl>, int hexIdx, Spell spell)
{
  combatManager *thisa; // [sp+34h] [bp-5Ch]@1
  H2RECT rect; // [sp+38h] [bp-58h]@6
  int v6; // [sp+48h] [bp-48h]@2
  int v7; // [sp+4Ch] [bp-44h]@4
  icon *icn; // [sp+50h] [bp-40h]@2
  army *stack; // [sp+54h] [bp-3Ch]@4
  int v10; // [sp+58h] [bp-38h]@4
  int v11; // [sp+5Ch] [bp-34h]@4
  int t; // [sp+60h] [bp-30h]@4
  int v13; // [sp+64h] [bp-2Ch]@4
  int i; // [sp+68h] [bp-28h]@4
  float v15; // [sp+6Ch] [bp-24h]@4
  float v16; // [sp+70h] [bp-20h]@4
  int yCent; // [sp+74h] [bp-1Ch]@4
  int imageIdx; // [sp+78h] [bp-18h]@6
  int xCent; // [sp+7Ch] [bp-14h]@4
  float v20; // [sp+80h] [bp-10h]@4
  int v21; // [sp+84h] [bp-Ch]@4
  float v22; // [sp+88h] [bp-8h]@4
  int yDiff; // [sp+8Ch] [bp-4h]@4

  thisa = this;
  if ( spell == SPELL_COLD_RAY )
  {
    icn = resourceManager::GetIcon(gpResourceManager, "coldray.icn");
    v6 = 18;
  }
  else
  {
    icn = resourceManager::GetIcon(gpResourceManager, "disrray.icn");
    v6 = 24;
  }
  stack = &thisa->creatures[thisa->combatGrid[hexIdx].unitOwner][thisa->combatGrid[hexIdx].stackIdx];
  xCent = army::MidX(stack);
  yCent = army::MidY(stack);
  v21 = castX;
  v10 = castY;
  v11 = xCent - castX;
  yDiff = yCent - castY;
  v7 = (signed __int64)sqrt((double)(yDiff * yDiff + (xCent - castX) * (xCent - castX)));
  v13 = v7 / v6;
  v16 = (double)v21;
  v15 = (double)v10;
  v22 = (double)v11 / (double)(v7 / v6);
  v20 = (double)yDiff / (double)(v7 / v6);
  t = 0;
  for ( i = 0; i < v13; ++i )
  {
    combatManager::ResetLimitCreature(thisa);
    gbComputeExtent = 1;
    gbSaveBiggestExtent = 1;
    v16 = v16 + v22;
    v15 = v15 + v20;
    imageIdx = (10 * i - 1) / v13;
    icon::CombatClipDrawToBuffer(
      icn,
      (signed __int64)v16,
      (signed __int64)v15,
      (10 * i - 1) / v13,
      &rect,
      v22 < 0.0,
      0,
      0,
      0);
    if ( giMinExtentX < 0 )
      giMinExtentX = 0;
    if ( giMinExtentY < 0 )
      giMinExtentY = 0;
    if ( giMaxExtentX > 639 )
      giMaxExtentX = 639;
    if ( giMaxExtentY > 442 )
      giMaxExtentY = 442;
    DelayTil(&t);
    t = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 10.0);
    heroWindowManager::UpdateScreenRegion(
      gpWindowManager,
      giMinExtentX,
      giMinExtentY,
      giMaxExtentX - giMinExtentX + 1,
      giMaxExtentY - giMinExtentY + 1);
  }
  gbComputeExtent = 0;
  gbSaveBiggestExtent = 0;
  combatManager::DrawFrame(thisa, 1, 0, 0, 0, 0, 1, 0);
  resourceManager::Dispose(gpResourceManager, (resource *)icn);
}
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004A6120) --------------------------------------------------------
void __thiscall combatManager::Resurrect(combatManager *this, int spell, int hex, int spellpower)
{
  int v4; // eax@40
  army *creat; // [sp+14h] [bp-3Ch]@4
  int nextCorpseHex; // [sp+18h] [bp-38h]@9
  int currentCorpseHex; // [sp+20h] [bp-30h]@9
  int i; // [sp+28h] [bp-28h]@11
  int spriteIdxa; // [sp+28h] [bp-28h]@35
  int a4; // [sp+2Ch] [bp-24h]@31
  int a3; // [sp+30h] [bp-20h]@31
  signed int v13; // [sp+34h] [bp-1Ch]@9
  int startingQuantity; // [sp+3Ch] [bp-14h]@4
  signed int notDone; // [sp+40h] [bp-10h]@9
  signed int stackIdx; // [sp+44h] [bp-Ch]@4
  icon *res; // [sp+48h] [bp-8h]@35
  signed int processedFirstHex; // [sp+4Ch] [bp-4h]@4

  if ( this->heroes[this->currentActionSide] && hero::HasArtifact(this->heroes[this->currentActionSide], ARTIFACT_ANKH) )
    spellpower *= 2;
  stackIdx = combatManager::FindResurrectArmyIndex(this, this->currentActionSide, (Spell)spell, hex);
  creat = &this->creatures[this->currentActionSide][stackIdx];
  processedFirstHex = 0;
  startingQuantity = this->creatures[this->currentActionSide][stackIdx].quantity;
  creat->quantity += 50 * spellpower / this->creatures[this->currentActionSide][stackIdx].creature.hp;
  if ( creat->initialQuantity < creat->quantity )
    creat->quantity = creat->initialQuantity;
  if ( spell == SPELL_RESURRECT )
    creat->temporaryQty += creat->quantity - startingQuantity;
  if ( startingQuantity <= 0 )
  {
    nextCorpseHex = -1;
    v13 = -1;
    notDone = 1;
    currentCorpseHex = hex;
    while ( notDone )
    {
      for ( i = 0; this->combatGrid[currentCorpseHex].numCorpses > i; ++i )
      {
        if ( *(&this->combatGrid[0].corpseOwners[99 * currentCorpseHex] + i - currentCorpseHex) == this->currentActionSide )
        {
          if ( *(&this->combatGrid[0].corpseStackIndices[99 * currentCorpseHex] + i - currentCorpseHex) == stackIdx )
          {
            v13 = i;
            if ( !processedFirstHex )
            {
              if ( *(&this->combatGrid[0].corpseOtherHexIsToLeft[99 * currentCorpseHex] + i - currentCorpseHex) == 1 )
              {
                nextCorpseHex = currentCorpseHex - 1;
              }
              else if ( !*(&this->combatGrid[0].corpseOtherHexIsToLeft[99 * currentCorpseHex] + i - currentCorpseHex) )
              {
                nextCorpseHex = currentCorpseHex + 1;
              }
            }
          }
        }
        if ( v13 != -1 )
        {
          this->combatGrid[currentCorpseHex].unitOwner = *(&this->combatGrid[0].corpseOwners[99 * currentCorpseHex]
                                                         + i
                                                         - currentCorpseHex);
          this->combatGrid[currentCorpseHex].stackIdx = *(&this->combatGrid[0].corpseStackIndices[99 * currentCorpseHex]
                                                        + i
                                                        - currentCorpseHex);
          this->combatGrid[currentCorpseHex].occupiersOtherHexIsToLeft = *(&this->combatGrid[0].corpseOtherHexIsToLeft[99 * currentCorpseHex]
                                                                         + i
                                                                         - currentCorpseHex);
          if ( this->combatGrid[currentCorpseHex].numCorpses == i + 1 )
          {
            *(&this->combatGrid[0].corpseOwners[99 * currentCorpseHex] + i - currentCorpseHex) = -1;
            *(&this->combatGrid[0].corpseStackIndices[99 * currentCorpseHex] + i - currentCorpseHex) = -1;
          }
          else
          {
            *(&this->combatGrid[0].corpseOwners[99 * currentCorpseHex] + i - currentCorpseHex) = *(&this->combatGrid[0].corpseOwners[99 * currentCorpseHex]
                                                                                                 + i
                                                                                                 + 1
                                                                                                 - currentCorpseHex);
            *(&this->combatGrid[0].corpseStackIndices[99 * currentCorpseHex] + i - currentCorpseHex) = *(&this->combatGrid[0].corpseStackIndices[99 * currentCorpseHex] + i + 1 - currentCorpseHex);
          }
        }
      }
      --this->combatGrid[currentCorpseHex].numCorpses;
      if ( processedFirstHex )
      {
        notDone = 0;
      }
      else if ( nextCorpseHex == -1 )
      {
        notDone = 0;
      }
      else
      {
        currentCorpseHex = nextCorpseHex;
        processedFirstHex = 1;
        v13 = -1;
      }
    }
  }
  a3 = army::MidX(creat);
  a4 = army::MidY(creat);
  if ( creat->quantity - startingQuantity <= 1 )
    sprintf(gText, "%d %s rises from the dead!", creat->quantity - startingQuantity, gArmyNames[creat->creatureIdx]);
  else
    sprintf(
      gText,
      "%d %s rise from the dead!",
      creat->quantity - startingQuantity,
      gArmyNamesPlural[creat->creatureIdx]);
  combatManager::CombatMessage(this, gText, 1, 1, 0);
  if ( !gbNoShowCombat )
  {
    res = resourceManager::GetIcon(gpResourceManager, "yinyang.icn");
    for ( spriteIdxa = 0; spriteIdxa < 22; ++spriteIdxa )
    {
      glTimers = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
      IconToBitmap(res, gpWindowManager->screenBuffer, a3, a4, spriteIdxa, 1, 0, 0, 0x280u, 443, 0);
      combatManager::UpdateCombatArea(this);
      creat->facingRight = 1 - creat->owningSide;
      if ( creat->animationType == 13 )
      {
        if ( spriteIdxa < 18 )
        {
          v4 = creat->frameInfo.animationLengths[13] - 1;
          if ( v4 >= 17 - spriteIdxa )
            v4 = 17 - spriteIdxa;
          creat->animationFrame = v4;
        }
        else
        {
          creat->animationType = 7;
          creat->animationFrame = 0;
        }
      }
      combatManager::DrawFrame(this, 0, 0, 0, 0, 75, 1, 1);
      DelayTil(&glTimers);
    }
    resourceManager::Dispose(gpResourceManager, (resource *)res);
  }
  combatManager::DrawFrame(this, 1, 0, 0, 0, 75, 1, 1);
  *(_DWORD *)&creat->creature.creature_flags &= 0xFFEFu;
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004A6780) --------------------------------------------------------
bool __thiscall combatManager::SpaceForElementalExists(combatManager *this)
{
  return (this->currentActionSide
       || this->combatGrid[14].unitOwner == -1
       || this->combatGrid[27].unitOwner == -1
       || this->combatGrid[40].unitOwner == -1)
      && (this->currentActionSide != 1
       || this->combatGrid[11].unitOwner == -1
       || this->combatGrid[24].unitOwner == -1
       || this->combatGrid[37].unitOwner == -1);
}

//----- (004A6840) --------------------------------------------------------
void __stdcall combatManager::ShowSpellCastFailure(army *a1, int a2)
{
  char *v2; // [sp+10h] [bp-14h]@2
  __int64 res; // [sp+1Ch] [bp-8h]@1

  res = LoadPlaySample("rsbryfzl.82m");
  if ( a1->quantity == 1 )
    v2 = gArmyNames[a1->creatureIdx];
  else
    v2 = gArmyNamesPlural[a1->creatureIdx];
  sprintf(gText, "The %s %s the spell!", v2, &aResists[("resist" - "resists") & ((a1->quantity == 1) - 1)]);
  combatManager::CombatMessage(gpCombatManager, gText, 1, 1, 0);
  WaitEndSample((void *)0xFFFFFFFF, (resource *)res, HIDWORD(res));
}
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;

//----- (004A6920) --------------------------------------------------------
void __stdcall combatManager::ModifyDamageForArtifacts(int *damage, Spell spell, hero *thisHero, hero *enemyHero)
{
  if ( thisHero )
  {
    if ( hero::HasArtifact(thisHero, 48) && (spell == SPELL_COLD_RAY || spell == SPELL_COLD_RING) )
      *damage = (signed __int64)((double)*damage * 1.5);
    if ( hero::HasArtifact(thisHero, 49) && (spell == SPELL_FIREBALL || spell == SPELL_FIREBLAST) )
      *damage = (signed __int64)((double)*damage * 1.5);
    if ( hero::HasArtifact(thisHero, 50) && (spell == SPELL_LIGHTNING_BOLT || spell == SPELL_CHAIN_LIGHTNING) )
      *damage = (signed __int64)((double)*damage * 1.5);
  }
  if ( enemyHero )
  {
    if ( hero::HasArtifact(enemyHero, 45) && (spell == SPELL_COLD_RAY || spell == SPELL_COLD_RING) )
      *damage = (signed __int64)((double)*damage * 0.5);
    if ( hero::HasArtifact(enemyHero, 46) && (spell == SPELL_FIREBALL || spell == SPELL_FIREBLAST) )
      *damage = (signed __int64)((double)*damage * 0.5);
    if ( hero::HasArtifact(enemyHero, 47) && (spell == SPELL_LIGHTNING_BOLT || spell == SPELL_CHAIN_LIGHTNING) )
      *damage = (signed __int64)((double)*damage * 0.5);
    if ( hero::HasArtifact(enemyHero, 92) )
    {
      if ( spell != SPELL_COLD_RAY && spell != SPELL_COLD_RING )
      {
        if ( spell == SPELL_FIREBALL || spell == SPELL_FIREBLAST )
          *damage = (signed __int64)((double)*damage * 0.5);
      }
      else
      {
        *damage *= 2;
      }
    }
    if ( hero::HasArtifact(enemyHero, 93) )
    {
      if ( spell != SPELL_COLD_RAY && spell != SPELL_COLD_RING )
      {
        if ( spell == SPELL_FIREBALL || spell == SPELL_FIREBLAST )
          *damage *= 2;
      }
      else
      {
        *damage = (signed __int64)((double)*damage * 0.5);
      }
    }
  }
}

//----- (004A6B90) --------------------------------------------------------
void __thiscall combatManager::Earthquake(combatManager *this)
{
  int v1; // eax@5
  int v2; // eax@7
  int v3; // ecx@7
  combatManager *thisa; // [sp+14h] [bp-158h]@1
  int v5; // [sp+18h] [bp-154h]@13
  int v6; // [sp+1Ch] [bp-150h]@10
  icon *res; // [sp+20h] [bp-14Ch]@45
  const void *v8; // [sp+24h] [bp-148h]@9
  void *v9; // [sp+28h] [bp-144h]@15
  int a3; // [sp+30h] [bp-13Ch]@31
  int a4[19]; // [sp+34h] [bp-138h]@31
  int v12; // [sp+80h] [bp-ECh]@20
  int i; // [sp+84h] [bp-E8h]@1
  int v14[4]; // [sp+88h] [bp-E4h]@34
  int m; // [sp+98h] [bp-D4h]@47
  int k; // [sp+9Ch] [bp-D0h]@15
  int l; // [sp+A0h] [bp-CCh]@20
  int v18; // [sp+A8h] [bp-C4h]@5
  int j; // [sp+ACh] [bp-C0h]@3
  int v20; // [sp+B0h] [bp-BCh]@5
  int v21[10]; // [sp+B4h] [bp-B8h]@43
  int v22; // [sp+DCh] [bp-90h]@38
  int v23[4]; // [sp+E0h] [bp-8Ch]@22
  size_t v24; // [sp+F0h] [bp-7Ch]@5
  int v25[30]; // [sp+F4h] [bp-78h]@1

  thisa = this;
  v25[0] = 2;
  v25[1] = 2;
  v25[2] = 4;
  v25[3] = 1;
  v25[4] = 3;
  v25[5] = -2;
  v25[6] = 0;
  v25[7] = -6;
  v25[8] = 2;
  v25[9] = -2;
  v25[10] = -1;
  v25[11] = 3;
  v25[12] = -5;
  v25[13] = 4;
  v25[14] = -8;
  v25[15] = 6;
  v25[16] = -4;
  v25[17] = 2;
  v25[18] = -1;
  v25[19] = 1;
  v25[20] = -3;
  v25[21] = -3;
  v25[22] = -7;
  v25[23] = -5;
  v25[24] = -5;
  v25[25] = -7;
  v25[26] = -2;
  v25[27] = -3;
  v25[28] = 0;
  v25[29] = 0;
  mouseManager::HideColorPointer(gpMouseManager);
  memcpy(thisa->probablyBitmapForCombatScreen->contents, gpWindowManager->screenBuffer->contents, 0x45380u);
  for ( i = 0; i < 3; ++i )
  {
    for ( j = 0; j < 15; ++j )
    {
      v20 = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 15.0);
      PollSound();
      v24 = 640 - abs(v25[2 * j]);
      v18 = 443 - abs(v25[2 * j + 1]) - 1;
      v1 = v25[2 * j + 1];
      if ( v1 <= 0 )
        v1 = 0;
      v2 = 640 * v1;
      v3 = v25[2 * j];
      if ( v3 <= 0 )
        v3 = 0;
      v8 = &thisa->probablyBitmapForCombatScreen->contents[v3] + v2;
      if ( v25[2 * j] <= 0 )
        v6 = -v25[2 * j];
      else
        v6 = 0;
      if ( v25[2 * j + 1] <= 0 )
        v5 = -v25[2 * j + 1];
      else
        v5 = 0;
      v9 = &gpWindowManager->screenBuffer->contents[640 * v5] + v6;
      for ( k = 0; v18 > k; ++k )
      {
        memcpy(v9, v8, v24);
        v8 = (char *)v8 + 640;
        v9 = (char *)v9 + 640;
      }
      BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 0, 0x280u, 443, 0, 0);
      DelayTil(&v20);
    }
  }
  thisa->zeroedAfterAnimatingDeathAndHolySpells = 0;
  combatManager::DrawFrame(thisa, 1, 0, 0, 0, 75, 1, 1);
  v12 = 0;
  for ( l = 0; l < 4; ++l )
  {
    v23[l] = thisa->wallStatus[l];
    if ( thisa->wallStatus[l] != 2 && thisa->wallStatus[l] != 6 && SRandom(0, 100) < 75 )
    {
      ++v23[l];
      if ( thisa->wallStatus[l] != 2
        && thisa->wallStatus[l] != 1
        && thisa->wallStatus[l] != 6
        && thisa->wallStatus[l] != 5
        && SRandom(0, 100) < 15 )
        ++v23[l];
      *(&a3 + 2 * v12) = wallPos[l].x;
      a4[2 * v12++] = wallPos[l].y + 25;
      if ( v23[l] == 2 || v23[l] == 6 )
        thisa->combatGrid[(unsigned __int8)byte_4F5234[l]].isBlocked = 0;
    }
    v14[l] = thisa->turretStatus[l];
    if ( thisa->turretStatus[l] != 2 && SRandom(0, 100) < 50 )
    {
      v14[l] = 2;
      *(&a3 + 2 * v12) = towerPos[l].x;
      a4[2 * v12++] = towerPos[l].y + 25;
    }
  }
  v22 = thisa->drawBridgePosition;
  if ( thisa->drawBridgePosition != 3 && SRandom(0, 100) < 25 )
  {
    v22 = 3;
    *(&a3 + 2 * v12) = towerPos[0].x;
    a4[2 * v12++] = (unsigned __int16)towerPos[0].y + 25;
    *(&a3 + 2 * v12) = towerPos[1].x;
    a4[2 * v12++] = (unsigned __int16)towerPos[1].y + 25;
  }
  for ( l = 0; l < 10; ++l )
    v21[l] = Random(0, 2);
  giMinExtentX = 252;
  giMinExtentY = 0;
  giMaxExtentX = 575;
  giMaxExtentY = 442;
  if ( v12 )
  {
    res = resourceManager::GetIcon(gpResourceManager, "lichclod.icn");
    for ( l = 0; l < 13; ++l )
    {
      animTimer = (signed __int64)((double)KBTickCount() + gfCombatSpeedMod[giCombatSpeed] * 75.0);
      combatManager::DrawFrame(thisa, 0, 0, 1, 0, 0, 1, 0);
      for ( m = 0; m < v12; ++m )
      {
        if ( v21[m] <= l && l - v21[m] < 10 )
          IconToBitmap(
            res,
            gpWindowManager->screenBuffer,
            *(&a3 + 2 * m),
            a4[2 * m],
            l - v21[m],
            1,
            0,
            0,
            0x280u,
            443,
            0);
      }
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      DelayTil(&animTimer);
      if ( l == 7 )
      {
        for ( m = 0; m < 4; ++m )
        {
          thisa->wallStatus[m] = LOBYTE(v23[m]);
          thisa->turretStatus[m] = LOBYTE(v14[m]);
        }
        thisa->drawBridgePosition = v22;
      }
    }
    resourceManager::Dispose(gpResourceManager, (resource *)res);
  }
  mouseManager::ShowColorPointer(gpMouseManager);
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;
// 4A6B90: using guessed type int var_8C[4];
// 4A6B90: using guessed type int a4[19];
// 4A6B90: using guessed type int var_E4[4];
// 4A6B90: using guessed type int var_B8[10];

//----- (004A74B0) --------------------------------------------------------
void __thiscall combatManager::ShowSpellMessage(combatManager *this, int a2, Spell spell, army *stack)
{
  combatManager *thisa; // [sp+Ch] [bp-1D8h]@1
  const char *v5; // [sp+10h] [bp-1D4h]@3
  char message[400]; // [sp+18h] [bp-1CCh]@8
  char creatureName[60]; // [sp+1A8h] [bp-3Ch]@5

  thisa = this;
  if ( stack )
  {
    if ( stack->quantity <= 1 )
      v5 = gArmyNames[stack->creatureIdx];
    else
      v5 = gArmyNamesPlural[stack->creatureIdx];
    sprintf(creatureName, v5);
  }
  if ( a2 )
  {
    switch ( spell )
    {
      case SPELL_PARALYZE:
        sprintf(message, "The %s are paralyzed by the Cyclopes!", creatureName);
        break;
      case SPELL_BLIND:
        sprintf(message, "The Unicorns' attack blinds the %s!", creatureName);
        break;
      case SPELL_MEDUSA_PETRIFY:
        sprintf(message, "The Medusas' gaze turns the %s to stone!", creatureName);
        break;
      case SPELL_CURSE:
        sprintf(message, "The Mummies' curse falls upon the %s!", creatureName);
        break;
      case SPELL_ARCHMAGI_DISPEL:
        sprintf(message, "The Archmagi dispel all good spells\non the %s!", creatureName);
        break;
    }
  }
  else if ( stack )
  {
    if ( thisa->heroes[thisa->currentActionSide]->isCaptain )
      sprintf(message, "The captain casts '%s' on the %s.", gSpellNames[spell], creatureName);
    else
      sprintf(
        message,
        "%s casts '%s' on the %s.",
        thisa->heroes[thisa->currentActionSide]->name,
        gSpellNames[spell],
        creatureName);
  }
  else if ( thisa->heroes[thisa->currentActionSide]->isCaptain )
  {
    sprintf(message, "The captain casts '%s'.", gSpellNames[spell]);
  }
  else
  {
    sprintf(message, "%s casts '%s'.", thisa->heroes[thisa->currentActionSide]->name, gSpellNames[spell]);
  }
  combatManager::CombatMessage(thisa, message, 1, 1, 0);
}

//----- (004A7750) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
int __cdecl sub_4A7750()
{
  unsigned __int32 v1; // [sp-Ch] [bp-Ch]@0
  char *v2; // [sp-8h] [bp-8h]@0
  int v3; // [sp-4h] [bp-4h]@0

  sub_4A77B0(v1, v2, v3);
  return sub_4A7770();
}

//----- (004A7770) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
int __cdecl sub_4A7770()
{
  return atexit((int)sub_4A7790);
}

//----- (004A7790) --------------------------------------------------------
// Microsoft VisualC 2-8/net runtime
int __cdecl sub_4A7790()
{
  return sub_470420((int)&xCampaign);
}

//----- (004A77B0) --------------------------------------------------------
char *__cdecl sub_4A77B0(unsigned __int32 a1, char *a2, int a3)
{
  return (char *)ExpCampaign::ExpCampaign((int)&xCampaign);
}

//----- (004A77D0) --------------------------------------------------------
void __fastcall DelayTil(int *tick)
{
  int *d; // [sp+Ch] [bp-4h]@1

  d = tick;
  while ( KBTickCount() < *d )
  {
    Process1WindowsMessage();
    PollSound();
  }
}

//----- (004A7810) --------------------------------------------------------
void __thiscall DelayMilli(int x)
{
  int v1; // ST0C_4@1
  int v2; // eax@1

  v1 = x;
  v2 = KBTickCount();
  DelayTilMilli(v2 + v1);
}

//----- (004A7840) --------------------------------------------------------
void __fastcall DelayTilMilli(int tick)
{
  int v1; // [sp+Ch] [bp-4h]@1

  v1 = tick;
  while ( KBTickCount() < v1 )
  {
    Process1WindowsMessage();
    PollSound();
  }
}

//----- (004A7880) --------------------------------------------------------
signed int __thiscall game::HandleCampaignWin(game *this)
{
  int v2; // [sp+Ch] [bp-18h]@48
  signed int i; // [sp+1Ch] [bp-8h]@39
  signed int j; // [sp+20h] [bp-4h]@41

  memset(&this->_11[25], 0, 0x18u);
  if ( this->field_2 )
  {
    switch ( this->field_4 + 1 )
    {
      case 0:
        PlaySmacker(19);
        this->_11[37] = 1;
        break;
      case 1:
        PlaySmacker(20);
        this->_11[38] = 1;
        break;
      case 2:
        PlaySmacker(21);
        this->_11[39] = 1;
        this->_11[40] = 1;
        break;
      case 3:
        PlaySmacker(23);
        PlaySmacker(25);
        this->_11[41] = 1;
        this->_11[48] = 1;
        this->field_84 = 1;
        break;
      case 4:
        PlaySmacker(24);
        PlaySmacker(25);
        this->_11[41] = 1;
        this->_11[48] = 1;
        this->field_85 = 1;
        this->isDwarfbane = 1;
        break;
      case 5:
        if ( this->field_3 == 1 )
          PlaySmacker(26);
        else
          PlaySmacker(27);
        this->_11[42] = 1;
        break;
      case 6:
        PlaySmacker(28);
        this->_11[43] = 1;
        this->_11[44] = 1;
        break;
      case 7:
        PlaySmacker(30);
        this->_11[44] = 1;
        this->hasDragonAlliance = 1;
        break;
      case 8:
        PlaySmacker(31);
        this->_11[45] = 1;
        this->_11[46] = 1;
        break;
      case 9:
        PlaySmacker(33);
        this->_11[47] = 1;
        this->field_88 = 1;
        break;
      case 10:
        PlaySmacker(33);
        this->_11[47] = 1;
        this->_11[0] = 1;
        break;
      case 11:
        PlaySmacker(34);
        this->field_88 = 0;
        this->_11[0] = 0;
        break;
      default:
        break;
    }
  }
  else
  {
    switch ( this->field_4 + 1 )
    {
      case 0:
        PlaySmacker(5);
        this->_11[25] = 1;
        break;
      case 1:
        PlaySmacker(6);
        this->_11[26] = 1;
        break;
      case 2:
        PlaySmacker(7);
        this->_11[27] = 1;
        this->_11[28] = 1;
        break;
      case 3:
        PlaySmacker(9);
        this->_11[28] = 1;
        this->hasDwarfAlliance = 1;
        break;
      case 4:
        PlaySmacker(10);
        this->_11[29] = 1;
        this->_11[36] = 1;
        break;
      case 5:
        if ( this->field_3 )
          PlaySmacker(12);
        else
          PlaySmacker(11);
        this->_11[30] = 1;
        break;
      case 6:
        PlaySmacker(13);
        this->_11[31] = 1;
        this->_11[32] = 1;
        this->field_7F = 1;
        break;
      case 7:
        PlaySmacker(15);
        this->_11[33] = 1;
        this->field_81 = 1;
        break;
      case 8:
        PlaySmacker(15);
        this->_11[33] = 1;
        this->field_83 = 1;
        break;
      case 9:
        PlaySmacker(16);
        this->_11[34] = 1;
        break;
      case 10:
        PlaySmacker(18);
        break;
      default:
        break;
    }
  }
  if ( this->field_4 != 10 && (gpGame->field_4 != 9 || gpGame->field_2) )
  {
    this->field_4 = -1;
    for ( i = 0; i < 2; ++i )
    {
      for ( j = 0; j < 11; ++j )
      {
        if ( *(&this->_11[12 * i + 25] + j) )
        {
          *((_WORD *)&gpGame->_1[24 * i + 24] + j) = *(_WORD *)&this->_11[49];
          if ( this->field_4 == -1 )
          {
            this->field_2 = i;
            this->field_4 = j;
          }
        }
      }
    }
    game::ShowCampaignInfo(gpGame, 0, 0);
    v2 = gpWindowManager->buttonPressedCode;
    if ( v2 == 30721 )
      return 0;
    if ( v2 == 30722 )
      return 1;
  }
  return 0;
}

//----- (004A7DF0) --------------------------------------------------------
heroWindowManager *__thiscall game::PlayPreScenarioSmacker(int this, int a2, int a3)
{
  heroWindowManager *result; // eax@48

  if ( a2 )
  {
    switch ( a3 )
    {
      case 0:
        PlaySmacker(19);
        break;
      case 1:
        PlaySmacker(20);
        break;
      case 2:
        PlaySmacker(21);
        break;
      case 3:
        PlaySmacker(22);
        break;
      case 4:
        if ( *(_BYTE *)(this + 12 * *(_BYTE *)(this + 3) + 8) )
          PlaySmacker(24);
        else
          PlaySmacker(23);
        PlaySmacker(25);
        break;
      case 5:
        if ( *(_BYTE *)(this + 3) == 1 )
          PlaySmacker(26);
        else
          PlaySmacker(27);
        break;
      case 6:
        PlaySmacker(28);
        break;
      case 7:
        if ( *(_BYTE *)(this + 12 * *(_BYTE *)(this + 2) + 11) )
          PlaySmacker(30);
        else
          PlaySmacker(29);
        break;
      case 8:
        PlaySmacker(31);
        break;
      case 9:
        PlaySmacker(32);
        break;
      case 10:
        PlaySmacker(33);
        break;
      case 11:
      case 12:
        if ( *(_BYTE *)(this + 12 * *(_BYTE *)(this + 3) + 8) )
          PlaySmacker(24);
        else
          PlaySmacker(23);
        PlaySmacker(25);
        break;
      default:
        break;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        PlaySmacker(5);
        break;
      case 1:
        PlaySmacker(6);
        break;
      case 2:
        PlaySmacker(7);
        break;
      case 3:
        if ( *(_BYTE *)(this + 12 * *(_BYTE *)(this + 3) + 7) )
          PlaySmacker(9);
        else
          PlaySmacker(8);
        break;
      case 4:
        PlaySmacker(10);
        break;
      case 5:
        if ( *(_BYTE *)(this + 3) )
          PlaySmacker(12);
        else
          PlaySmacker(11);
        break;
      case 6:
        PlaySmacker(13);
        break;
      case 7:
        PlaySmacker(14);
        break;
      case 8:
        PlaySmacker(15);
        break;
      case 9:
        PlaySmacker(16);
        break;
      case 11:
      case 12:
        PlaySmacker(10);
        break;
      default:
        break;
    }
  }
  result = gpWindowManager;
  gpWindowManager->cycleColors = 1;
  return result;
}

//----- (004A8140) --------------------------------------------------------
void __thiscall game::ShowCampaignInfo(void *this, int a2, int a3)
{
  void *v3; // [sp+Ch] [bp-48h]@1
  unsigned __int8 v4; // [sp+14h] [bp-40h]@34
  unsigned __int8 v5; // [sp+18h] [bp-3Ch]@31
  iconWidget *v6; // [sp+20h] [bp-34h]@29
  heroWindow *thisa; // [sp+24h] [bp-30h]@10
  signed __int16 v8; // [sp+28h] [bp-2Ch]@27
  int evt; // [sp+2Ch] [bp-28h]@42
  int v10; // [sp+30h] [bp-24h]@43
  int v11; // [sp+34h] [bp-20h]@43
  int v12; // [sp+44h] [bp-10h]@43
  int v13; // [sp+48h] [bp-Ch]@1
  int i; // [sp+4Ch] [bp-8h]@15
  widget *guiObj; // [sp+50h] [bp-4h]@15

  v3 = this;
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  mouseManager::ReallyShowPointer(gpMouseManager);
  v13 = gbUseEvilInterface;
  gbUseEvilInterface = *((_BYTE *)v3 + 2) == 1;
  bCampaignViewOnly = a2;
  iCurViewSide = *((_BYTE *)v3 + 2);
  iCurViewMap = *((_BYTE *)v3 + 4);
  if ( *((_BYTE *)v3 + 4) != 4 || a2 )
  {
    iCampaignTrackType = *((_BYTE *)v3 + 2) + 2 * *((_BYTE *)v3 + 3);
  }
  else if ( *((_BYTE *)v3 + 2) )
  {
    if ( *((_BYTE *)v3 + 19) )
      iCampaignTrackType = 5;
    else
      iCampaignTrackType = 6;
  }
  else
  {
    iCampaignTrackType = 4;
  }
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    campWin = heroWindow::heroWindow(thisa, 0, 0, "campaign.bin");
  else
    campWin = 0;
  if ( !campWin )
    MemError();
  guiObj = 0;
  for ( i = 0; i < 13; ++i )
  {
    if ( (iCampaignTrackType >= 4 || i < 11)
      && (iCampaignTrackType != 4 || i != 12)
      && (iCampaignTrackType != 5 || i != 12)
      && (iCampaignTrackType != 6 || i != 11)
      && *(&trackXY[26 * iCurViewSide] + 2 * i) != -1 )
    {
      v8 = i;
      if ( i > 11 )
        v8 = 11;
      v6 = (iconWidget *)operator new(45);
      if ( v6 )
      {
        if ( i < 4 )
          v5 = *((_BYTE *)v3 + 3);
        else
          v5 = *((_BYTE *)v3 + 2);
        if ( i < 4 )
          v4 = *((_BYTE *)v3 + 3);
        else
          v4 = *((_BYTE *)v3 + 2);
        guiObj = (widget *)iconWidget::iconWidget(
                             v6,
                             *(&trackXY[26 * v4] + 2 * i) - 2,
                             *(&word_51D0F2[26 * v5] + 2 * i) - 2,
                             41,
                             41,
                             "campxtrg.icn",
                             10,
                             0,
                             v8 + 850,
                             16,
                             1);
      }
      else
      {
        guiObj = 0;
      }
      if ( !guiObj )
        MemError();
      heroWindow::AddWidget(campWin, guiObj, -1);
    }
  }
  evt = 512;
  if ( !a2 )
  {
    v10 = 6;
    v11 = 901;
    v12 = 6;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  }
  if ( gbLowMemory )
  {
    v10 = 6;
    v11 = 902;
    v12 = 6;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  }
  soundManager::SwitchAmbientMusic((soundManager *)gpSoundManager, (unsigned int)*((_BYTE *)v3 + 2) < 1 ? 24 : 22);
  game::CampaignInfoUpdate(v3, 0);
  heroWindowManager::DoDialog(gpWindowManager, campWin, (int (__fastcall *)(tag_message *))CampaignHandler, 0);
  operator delete(campWin);
  gbUseEvilInterface = v13;
  if ( gpWindowManager->buttonPressedCode == 901 )
  {
    NormalDialog("Are you sure you want to restart this scenario?", 2, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      game::InitCampaignMap((game *)v3);
      gpAdvManager->field_A2 = 0;
      giBottomViewOverride = 0;
      heroWindowManager::FadeScreen(gpWindowManager, 1, 8, gPalette);
      advManager::SetInitialMapOrigin(gpAdvManager);
      advManager::RedrawAdvScreen(gpAdvManager, 1, 0);
      heroWindowManager::FadeScreen(gpWindowManager, 0, 8, gPalette);
    }
  }
}
// 4F19D4: using guessed type int gbUseEvilInterface;
// 4F74A8: using guessed type int gbLowMemory;
// 51D0F0: using guessed type __int16 trackXY[];
// 51D0F2: using guessed type __int16 word_51D0F2[];
// 52405C: using guessed type int giBottomViewOverride;
// 5240A8: using guessed type int gpSoundManager;
// 5304D0: using guessed type int iCampaignTrackType;
// 5304D4: using guessed type int bCampaignViewOnly;
// 5304D8: using guessed type int iCurViewSide;
// 5304DC: using guessed type int iCurViewMap;

//----- (004A85D0) --------------------------------------------------------
void __thiscall game::CampaignInfoUpdate(void *this, int a2)
{
  void *v2; // [sp+14h] [bp-60h]@1
  unsigned __int8 v3; // [sp+18h] [bp-5Ch]@7
  char *v4; // [sp+1Ch] [bp-58h]@56
  int evt; // [sp+20h] [bp-54h]@1
  int v6; // [sp+24h] [bp-50h]@32
  int v7; // [sp+28h] [bp-4Ch]@32
  int v8; // [sp+38h] [bp-3Ch]@4
  char a1; // [sp+3Ch] [bp-38h]@81
  int i; // [sp+70h] [bp-4h]@1

  v2 = this;
  evt = 512;
  for ( i = 0; i < 13; ++i )
  {
    if ( *((_BYTE *)v2 + 12 * iCurViewSide + i + 162) )
    {
      v8 = 11;
    }
    else if ( i < 11 && (i < 4 ? (v3 = *((_BYTE *)v2 + 3)) : (v3 = *((_BYTE *)v2 + 2)), *((_BYTE *)v2 + 12 * v3 + i + 5)) )
    {
      v8 = 10;
    }
    else
    {
      v8 = 12;
    }
    if ( iCurViewMap == i )
    {
      if ( i != 4 || iCampaignTrackType != 1 )
      {
        if ( i != 4 || iCampaignTrackType != 2 )
        {
          if ( i + 1 <= 11 )
          {
            if ( i + 1 >= 5 )
            {
              if ( *((_BYTE *)v2 + 2) )
                v8 += 6;
              else
                v8 += 3;
            }
            else if ( *((_BYTE *)v2 + 3) )
            {
              v8 += 6;
            }
            else
            {
              v8 += 3;
            }
          }
          else if ( *((_BYTE *)v2 + 3) )
          {
            v8 += 3;
          }
          else
          {
            v8 += 6;
          }
        }
        else
        {
          v8 += 9;
        }
      }
      else
      {
        v8 += 12;
      }
    }
    v6 = 4;
    v7 = i + 850;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  }
  v6 = 9;
  v7 = 809;
  v8 = (int)gText;
  sprintf(gText, "ctrack%02d.icn", iCampaignTrackType);
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  v6 = 3;
  v8 = (int)gText;
  v7 = 801;
  if ( iCurViewMap == 11 )
    sprintf(gText, L"5");
  else
    sprintf(gText, "%d", iCurViewMap + 1);
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  v7 = 802;
  if ( iCurViewMap == 11 )
  {
    sprintf(gText, "%s", (&cCampaignName[12 * (1 - iCurViewSide)])[4 * iCurViewMap]);
  }
  else if ( *((_BYTE *)v2 + 2) == *((_BYTE *)v2 + 3) || iCurViewMap != 4 )
  {
    sprintf(gText, "%s", (&cCampaignName[12 * iCurViewSide])[4 * iCurViewMap]);
  }
  else
  {
    sprintf(gText, "%s", off_4F7134[12 * iCurViewSide]);
  }
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  v7 = 803;
  if ( iCurViewMap == 11 )
  {
    sprintf(gText, "%s", (&cCampaignDescription[12 * (1 - iCurViewSide)])[4 * iCurViewMap]);
  }
  else if ( *((_BYTE *)v2 + 2) == *((_BYTE *)v2 + 3) || iCurViewMap != 4 )
  {
    sprintf(gText, "%s", (&cCampaignDescription[12 * iCurViewSide])[4 * iCurViewMap]);
  }
  else
  {
    sprintf(gText, "%s", off_4F7194[12 * iCurViewSide]);
  }
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  v7 = 804;
  sprintf(gText, "%d", *(_WORD *)((char *)v2 + 24 * iCurViewSide + 2 * iCurViewMap + 29));
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  strcpy(gText, byte_51D1EC);
  for ( i = 0; i < 12; ++i )
  {
    if ( *((_BYTE *)v2 + i + 126) )
    {
      strcat(gText, (&cCampaignAwards)[4 * i]);
      strcat(gText, L"\n");
    }
  }
  v7 = 805;
  heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  for ( i = 0; i < 3; ++i )
  {
    if ( iCurViewMap == 11 )
    {
      v4 = (char *)&campaignChoices + 180 * (1 - iCurViewSide) + 15 * iCurViewMap + 5 * i;
    }
    else if ( *((_BYTE *)v2 + 2) == *((_BYTE *)v2 + 3) || iCurViewMap != 4 )
    {
      v4 = (char *)&campaignChoices + 180 * iCurViewSide + 15 * iCurViewMap + 5 * i;
    }
    else
    {
      v4 = (char *)&campaignChoices + 180 * iCurViewSide + 5 * i + 165;
    }
    switch ( *v4 )
    {
      case 0:
        sprintf(gText, "%d %s", *(_WORD *)(v4 + 3), gResourceNames[*(_WORD *)(v4 + 1)]);
        break;
      case 1:
        switch ( *(_WORD *)(v4 + 1) )
        {
          case 26:
            strcpy(gText, "Minor Scroll");
            break;
          case 10:
            strcpy(gText, "Mage's Ring");
            break;
          case 19:
            strcpy(gText, "Defender Helm");
            break;
          case 24:
            strcpy(gText, "Power Axe");
            break;
          case 23:
            strcpy(gText, "Dragon Sword");
            break;
          case 25:
            strcpy(gText, "Breastplate");
            break;
          case 16:
            strcpy(gText, "Fizbin Medal");
            break;
          case 17:
            strcpy(gText, "Thunder Mace");
            break;
          case 18:
            strcpy(gText, "Gauntlets");
            break;
          default:
            sprintf(gText, "%s", gArtifactNames[*(_WORD *)(v4 + 1)]);
            break;
        }
        break;
      case 2:
        if ( *(_WORD *)(v4 + 1) == 43 )
          sprintf(gText, "Summon Earth");
        else
          sprintf(gText, "%s", gSpellNames[*(_WORD *)(v4 + 1)]);
        break;
      case 3:
        sprintf(gText, "%s %s", secondarySkillLevels[*(_WORD *)(v4 + 3)], gSecondarySkills[*(_WORD *)(v4 + 1)]);
        break;
      case 4:
        strcpy(&a1, gArmyNamesPlural[*(_WORD *)(v4 + 1)]);
        a1 -= 32;
        sprintf(gText, "%d %s", *(_WORD *)(v4 + 3), &a1);
        break;
      case 5:
        sprintf(gText, "%d %s", *(_WORD *)(v4 + 1), "Puzzle Pieces");
        break;
      case 6:
        sprintf(gText, "%d %s", *(_WORD *)(v4 + 1), "Experience");
        break;
      case 7:
        sprintf(gText, "n/a");
        break;
      case 8:
        sprintf(gText, gAlignmentNames[*(_WORD *)(v4 + 1)]);
        break;
      default:
        break;
    }
    v7 = i + 806;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  }
  for ( i = 0; i < 3; ++i )
  {
    v7 = i + 810;
    v6 = 4;
    if ( bCampaignViewOnly || !*(&gpGame->_11[12 * iCurViewSide + 25] + iCurViewMap) )
      v8 = 9;
    else
      v8 = 8;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
    if ( *((_BYTE *)v2 + 12 * iCurViewSide + iCurViewMap + 138) == i )
      v6 = 5;
    else
      v6 = 6;
    v8 = 4;
    heroWindow::BroadcastMessage(campWin, (tag_message *)&evt);
  }
  if ( a2 )
    heroWindow::DrawWindow(campWin);
}
// 4F6BD8: using guessed type char *gSecondarySkills[25];
// 4F7108: using guessed type char *cCampaignName[10];
// 4F7134: using guessed type char *off_4F7134[23];
// 4F7168: using guessed type char *cCampaignDescription[10];
// 4F7194: using guessed type char *off_4F7194[14];
// 5304D0: using guessed type int iCampaignTrackType;
// 5304D4: using guessed type int bCampaignViewOnly;
// 5304D8: using guessed type int iCurViewSide;
// 5304DC: using guessed type int iCurViewMap;

//----- (004A8FE0) --------------------------------------------------------
signed int __thiscall CampaignHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-1Ch]@28
  int v3; // [sp+14h] [bp-14h]@8
  void *v4; // [sp+18h] [bp-10h]@1
  char v5; // [sp+1Ch] [bp-Ch]@19
  char v6; // [sp+20h] [bp-8h]@14
  int v7; // [sp+24h] [bp-4h]@10
  signed int i; // [sp+24h] [bp-4h]@33

  v4 = this;
  if ( !soundManager::MusicPlaying((soundManager *)gpSoundManager) && gpAdvManager->ready == 1 )
    soundManager::SwitchAmbientMusic(
      (soundManager *)gpSoundManager,
      (unsigned __int8)giTerrainToMusicTrack[gpAdvManager->currentTerrain]);
  if ( giDialogTimeout && KBTickCount() > giDialogTimeout )
  {
    *(_DWORD *)v4 = 512;
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    giDialogTimeout = 0;
    return 2;
  }
  if ( *(_DWORD *)v4 != 512 )
    return 1;
  v3 = *((_DWORD *)v4 + 1);
  if ( v3 == 12 )
    goto LABEL_54;
  if ( v3 == 13 )
  {
    v2 = *((_DWORD *)v4 + 2);
    if ( v2 > 30721 )
    {
      if ( v2 != 30722 )
        return 1;
      if ( !bCampaignViewOnly )
      {
        if ( !*(&gpGame->_11[12 * iCurViewSide + 25] + iCurViewMap) )
        {
          NormalDialog(
            "The currently selected map is not a valid choice for your next scenario.",
            1,
            -1,
            -1,
            -1,
            0,
            -1,
            0,
            -1,
            0);
          return 1;
        }
        if ( iCurViewMap == 11 )
        {
          gpGame->field_4 = 4;
          gpGame->field_2 = 1 - gpGame->field_2;
          *(&gpGame->_11[12 * gpGame->field_4 + 25] + gpGame->field_2) = 1;
          *((_WORD *)&gpGame->_1[24 * gpGame->field_2 + 24] + gpGame->field_4) = *(_WORD *)&gpGame->_11[49];
          *(&gpGame->_11[12 * gpGame->field_2 + 1] + gpGame->field_4) = gpGame->_11[12 * (1 - gpGame->field_2) + 12];
          for ( i = 0; i < 12; ++i )
            *(&gpGame->hasDwarfAlliance + i) = 0;
        }
        else
        {
          gpGame->field_4 = iCurViewMap;
          gpGame->field_2 = iCurViewSide;
        }
      }
    }
    else if ( v2 != 30721 && v2 != 901 )
    {
      if ( v2 == 902 )
      {
        game::PlayPreScenarioSmacker((int)gpGame, iCurViewSide, iCurViewMap);
        heroWindow::DrawWindow(campWin);
      }
      return 1;
    }
    gpWindowManager->buttonPressedCode = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 2) = 10;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 2);
    giDialogTimeout = 0;
    return 2;
  }
  if ( v3 == 14 )
  {
LABEL_54:
    switch ( *((_DWORD *)v4 + 2) )
    {
      case 0x352:
      case 0x353:
      case 0x354:
      case 0x355:
      case 0x356:
      case 0x357:
      case 0x358:
      case 0x359:
      case 0x35A:
      case 0x35B:
      case 0x35C:
      case 0x35D:
        v7 = *((_DWORD *)v4 + 2) - 850;
        if ( giDebugLevel >= 1
          || *(&gpGame->_11[12 * iCurViewSide + 25] + v7)
          || v7 < 11
          && (v7 < 4 ? (v6 = gpGame->field_3) : (v6 = gpGame->field_2), *(&gpGame->_1[12 * (unsigned __int8)v6] + v7)) )
        {
          iCurViewMap = *((_DWORD *)v4 + 2) - 850;
          if ( v7 < 4 )
            v5 = gpGame->field_3;
          else
            v5 = gpGame->field_2;
          iCurViewSide = (unsigned __int8)v5;
          game::CampaignInfoUpdate(gpGame, 1);
        }
        break;
      case 0x32A:
      case 0x32B:
      case 0x32C:
        if ( !bCampaignViewOnly && *(&gpGame->_11[12 * iCurViewSide + 25] + iCurViewMap) )
        {
          *(&gpGame->_11[12 * iCurViewSide + 1] + iCurViewMap) = *((_BYTE *)v4 + 8) - 42;
          game::CampaignInfoUpdate(gpGame, 1);
        }
        break;
      default:
        return 1;
    }
  }
  return 1;
}
// 4F1CB4: using guessed type int giDialogTimeout;
// 4F21F0: using guessed type int giDebugLevel;
// 5240A8: using guessed type int gpSoundManager;
// 5304D4: using guessed type int bCampaignViewOnly;
// 5304D8: using guessed type int iCurViewSide;
// 5304DC: using guessed type int iCurViewMap;

//----- (004A9500) --------------------------------------------------------
void __thiscall game::InitEntireCampaign(game *this, char a2)
{
  memset(&this->field_2, 0, 0x147u);
  this->field_2 = a2;
  this->field_3 = a2;
  this->field_4 = -1;
}

//----- (004A9550) --------------------------------------------------------
game *__thiscall game::InitCampaignMap(game *this)
{
  char v1; // ST6C_1@38
  char *v2; // ST2C_4@62
  char *v3; // ST28_4@94
  game *result; // eax@107
  int v5; // [sp+Ch] [bp-5Ch]@87
  char *v7; // [sp+24h] [bp-44h]@98
  int v8; // [sp+28h] [bp-40h]@84
  char *v9; // [sp+2Ch] [bp-3Ch]@84
  char *v10; // [sp+30h] [bp-38h]@77
  signed int v11; // [sp+34h] [bp-34h]@48
  int v12; // [sp+38h] [bp-30h]@61
  signed int v13; // [sp+3Ch] [bp-2Ch]@12
  char *v14; // [sp+40h] [bp-28h]@3
  signed int v15; // [sp+44h] [bp-24h]@29
  signed int v16; // [sp+48h] [bp-20h]@23
  int v17; // [sp+4Ch] [bp-1Ch]@1
  signed int j; // [sp+54h] [bp-14h]@25
  signed int i; // [sp+58h] [bp-10h]@23
  signed int k; // [sp+58h] [bp-10h]@71
  signed int l; // [sp+58h] [bp-10h]@77
  signed int m; // [sp+58h] [bp-10h]@84
  signed int n; // [sp+58h] [bp-10h]@98
  signed int v24; // [sp+60h] [bp-8h]@25
  char *v25; // [sp+64h] [bp-4h]@23

  v17 = *(&this->_11[12 * iCurViewSide + 1] + iCurViewMap);
  if ( this->field_2 == this->field_3 || iCurViewMap != 4 )
    v14 = (char *)&campaignChoices + 180 * this->field_2 + 15 * this->field_4 + 5 * v17;
  else
    v14 = (char *)&campaignChoices + 180 * iCurViewSide + 5 * v17 + 165;
  gpGame->_11[71] = 0;
  memset(&this->field_44D, 0, 0x41u);
  if ( this->field_4 != 4 || this->field_3 == this->field_2 )
    sprintf(this->mapFilename, "CAMP%c%02d.H2C", (unsigned int)this->field_2 < 1 ? 71 : 69, this->field_4 + 1);
  else
    sprintf(this->mapFilename, "CAMP%c%02dB.H2C", (unsigned int)this->field_2 < 1 ? 69 : 71, this->field_4 + 1);
  this->mapFilename[20] = 0;
  if ( !this->field_4 )
    *(_WORD *)&this->_11[49] = 0;
  strcpy(gMapName, this->mapFilename);
  GetMapHeader(this->mapFilename, &this->mapHeader);
  game::LoadGame(this, "origdata.bin", 1, 0);
  game::InitNewGame(this, 0);
  if ( (unsigned __int8)*v14 == 8 )
  {
    v13 = 0;
    if ( this->field_2 == 1 )
    {
      if ( this->mapHeader.hasPlayer[0] )
        v13 = 1;
      if ( this->mapHeader.hasPlayer[1] )
        ++v13;
    }
    this->field_459[v13] = v14[1];
  }
  if ( this->field_4 + 1 > 2 )
  {
    if ( this->field_4 + 1 > 5 )
      gpGame->difficulty = 2;
    else
      gpGame->difficulty = 1;
  }
  else
  {
    gpGame->difficulty = 0;
  }
  this->numPlayers = this->mapHeader.numPlayers;
  game::NewMap(this, gMapName);
  v16 = 0;
  v25 = (char *)gpGame->players;
  for ( i = 0; v25[1] > i; ++i )
  {
    v24 = -1;
    for ( j = i; v25[1] > j; ++j )
    {
      if ( gpGame->heroes[v25[j + 4]].heroID != 54 && gpGame->heroes[v25[j + 4]].heroID != 57 )
      {
        if ( gpGame->heroes[v25[j + 4]].heroID != 55 && gpGame->heroes[v25[j + 4]].heroID != 58 )
          v15 = 0;
        else
          v15 = 90;
      }
      else
      {
        v15 = 100;
      }
      if ( v24 < v15 )
      {
        v24 = v15;
        v16 = j;
      }
    }
    if ( v24 != -1 )
    {
      v1 = v25[i + 4];
      v25[i + 4] = v25[v16 + 4];
      v25[v16 + 4] = v1;
    }
  }
  if ( v25[1] )
    v25[2] = v25[4];
  switch ( *v14 )
  {
    case 0:
      this->players[0].resources[*(_WORD *)(v14 + 1)] += *(_WORD *)(v14 + 3);
      break;
    case 1:
      if ( this->players[0].numHeroes > 0 )
        GiveArtifact(&gpGame->heroes[this->players[0].heroesOwned[0]], (ARTIFACT)*(_WORD *)(v14 + 1), 0, -1);
      break;
    case 2:
      if ( this->players[0].numHeroes > 0 )
      {
        v11 = 0;
        if ( !this->field_2 && this->field_4 == 5 && this->players[0].numHeroes > 1 )
          v11 = 1;
        gpGame->heroes[this->players[0].heroesOwned[v11]].spellsLearned[*(_WORD *)(v14 + 1)] = 1;
      }
      break;
    case 3:
      if ( this->players[0].numHeroes > 0 )
        hero::SetSS(&gpGame->heroes[this->players[0].heroesOwned[0]], *(_WORD *)(v14 + 1), *(_WORD *)(v14 + 3));
      break;
    case 4:
      if ( this->players[0].numHeroes > 0 )
        armyGroup::Add(
          &gpGame->heroes[this->players[0].heroesOwned[0]].army,
          *(_WORD *)(v14 + 1),
          *(_WORD *)(v14 + 3),
          -1);
      break;
    case 5:
      this->players[0]._3[0] = v14[1];
      break;
    case 6:
      v12 = gbInNewGameSetup;
      gbInNewGameSetup = 1;
      if ( this->players[0].numHeroes > 0 )
      {
        v2 = (char *)&gpGame->heroes[this->players[0].heroesOwned[0]];
        *(_DWORD *)(v2 + 57) += *(_WORD *)(v14 + 1);
        hero::CheckLevel(&gpGame->heroes[this->players[0].heroesOwned[0]]);
      }
      gbInNewGameSetup = v12;
      break;
    case 7:
      break;
  }
  if ( (this->field_88 || this->field_83 && this->field_4 == 9) && this->players[0].numHeroes > 0 )
    GiveArtifact(&gpGame->heroes[this->players[0].heroesOwned[0]], ARTIFACT_ULTIMATE_CROWN, 0, -1);
  gbRetreatWin = 1;
  if ( this->field_82 )
  {
    for ( k = 0; k < 54; ++k )
    {
      if ( gpGame->heroes[k].heroID == 55 )
        hero::Deallocate(&gpGame->heroes[k], 0);
    }
  }
  if ( this->field_80 )
  {
    v10 = (char *)&gpGame->heroes[this->players[3].heroesOwned[0]];
    for ( l = 0; l < 5; ++l )
    {
      if ( (signed int)*(_WORD *)&v10[2 * l + 106] >= 1 )
        *(_WORD *)&v10[2 * l + 106] *= 3;
    }
  }
  if ( this->field_4 == 6 && this->field_2 == 1 )
  {
    v8 = gbInNewGameSetup;
    gbInNewGameSetup = 1;
    v9 = (char *)&gpGame->heroes[this->players[0].heroesOwned[0]];
    for ( m = 0; m < 5; ++m )
    {
      v9[m + 101] = -1;
      *(_WORD *)&v9[2 * m + 106] = 0;
    }
    v5 = (unsigned __int8)v9[23];
    switch ( v5 )
    {
      case 1:
        armyGroup::Add((armyGroup *)(v9 + 101), 13, 12, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 15, 18, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 11, 40, -1);
        break;
      case 3:
        armyGroup::Add((armyGroup *)(v9 + 101), 29, 40, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 30, 24, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 31, 18, -1);
        break;
      case 5:
        armyGroup::Add((armyGroup *)(v9 + 101), 47, 50, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 51, 18, -1);
        armyGroup::Add((armyGroup *)(v9 + 101), 53, 8, -1);
        break;
    }
    v3 = (char *)&gpGame->heroes[this->players[0].heroesOwned[0]];
    *(_DWORD *)(v3 + 57) += 5000;
    hero::CheckLevel(&gpGame->heroes[this->players[0].heroesOwned[0]]);
    gbInNewGameSetup = v8;
  }
  if ( this->field_81 && this->field_4 == 9 || this->_11[0] )
  {
    v7 = (char *)&gpGame->heroes[this->players[0].heroesOwned[0]];
    for ( n = 0; n < 5; ++n )
    {
      v7[n + 101] = this->_11[2 * n + 51];
      *(_WORD *)&v7[2 * n + 106] = *(_WORD *)&this->_11[2 * n + 61] * ((unsigned int)this->field_80 < 1 ? 1 : 3);
    }
  }
  if ( this->field_2 == 1 && this->field_4 == 5 )
  {
    gpGame->mapHeader.winConditionType = 4;
    gpGame->mapHeader.winConditionArgument = 99;
    gpGame->mapHeader.allowDefeatAllVictory = 1;
  }
  if ( !this->field_2 && this->field_4 == 8 )
  {
    gpGame->mapHeader.field_22 = 0;
    *(_WORD *)&gpGame->mapHeader.field_23 = 0;
  }
  result = this;
  if ( !this->field_2 )
  {
    result = (game *)(this->field_4 + 1);
    if ( result == (game *)7 )
    {
      result = gpGame;
      *(_WORD *)&gpGame->mapHeader.field_23 = 90;
    }
  }
  return result;
}
// 523F1C: using guessed type int gbInNewGameSetup;
// 524210: using guessed type char gbRetreatWin;
// 5304D8: using guessed type int iCurViewSide;
// 5304DC: using guessed type int iCurViewMap;

//----- (004AA110) --------------------------------------------------------
bool __cdecl CDTest_Init()
{
  dword_51D4A8 = AIL_redbook_open(0);
  return dword_51D4A8 != 0;
}

//----- (004AA150) --------------------------------------------------------
void __cdecl CDTest_Cleanup()
{
  if ( dword_51D4A8 )
    AIL_redbook_close(dword_51D4A8);
  dword_51D4A8 = 0;
}

//----- (004AA190) --------------------------------------------------------
int __cdecl CDTest_VerifyCDQuick(unsigned int a1)
{
  int v1; // eax@1

  v1 = Random(1, 43);
  return CDTest_VerifyTrack(v1);
}

//----- (004AA1C0) --------------------------------------------------------
signed int __cdecl CDTest_VerifyCDThorough()
{
  signed int i; // [sp+Ch] [bp-4h]@1

  for ( i = 1; i <= 43; ++i )
  {
    if ( !CDTest_VerifyTrack(i) )
      return 0;
  }
  return 1;
}

//----- (004AA210) --------------------------------------------------------
bool __fastcall CDTest_VerifyTrack(signed int a1)
{
  bool result; // eax@2
  signed int tracknum; // [sp+Ch] [bp-Ch]@1
  unsigned __int32 startmsec; // [sp+10h] [bp-8h]@6
  unsigned __int32 endmsec; // [sp+14h] [bp-4h]@6

  tracknum = a1;
  if ( dword_51D4A8 )
  {
    if ( a1 >= 1 && a1 <= 43 )
    {
      AIL_redbook_track_info(dword_51D4A8, a1, &startmsec, &endmsec);
      result = *(_DWORD *)&Str1[8 * tracknum + 8] == startmsec && *(_DWORD *)&Str1[8 * tracknum + 12] == endmsec;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004AA2A0) --------------------------------------------------------
int __thiscall CDTest_GenerateTable(void *this, const char *a2)
{
  int result; // eax@2
  int v3; // eax@7
  int v4; // eax@7
  int v5; // eax@7
  int v6; // eax@7
  int v7; // eax@7
  int v8; // eax@7
  int v9; // eax@7
  int v10; // eax@9
  int v11; // eax@10
  int v12; // eax@11
  int v13; // eax@12
  void *v14; // [sp+Ch] [bp-7Ch]@1
  int v15; // [sp+10h] [bp-78h]@5
  unsigned __int32 startmsec; // [sp+14h] [bp-74h]@9
  char a1; // [sp+18h] [bp-70h]@7
  unsigned __int32 tracknum; // [sp+7Ch] [bp-Ch]@7
  unsigned __int32 v19; // [sp+80h] [bp-8h]@3
  unsigned __int32 endmsec; // [sp+84h] [bp-4h]@9

  v14 = this;
  if ( dword_51D4A8 )
  {
    v19 = AIL_redbook_tracks(dword_51D4A8);
    if ( v19 )
    {
      v15 = open((const char *)v14, 17153);
      if ( v15 )
      {
        sprintf(&a1, "// FILE : %s\n", v14);
        v3 = strlen(&a1);
        _write(v15, &a1, v3);
        sprintf(&a1, "// DO NOT EDIT.\n");
        v4 = strlen(&a1);
        _write(v15, &a1, v4);
        sprintf(&a1, "// THIS FILE WAS AUTOMATICALLY GENERATED BY CDTest_GenerateTable.\n");
        v5 = strlen(&a1);
        _write(v15, &a1, v5);
        sprintf(&a1, "\n\n\n");
        v6 = strlen(&a1);
        _write(v15, &a1, v6);
        sprintf(&a1, "#define CDTEST_NUMTRACKS %d\n\n\n", v19);
        v7 = strlen(&a1);
        _write(v15, &a1, v7);
        sprintf(&a1, "sCDTest_Track_Data cdTestTrackData[CDTEST_NUMTRACKS] =\n");
        v8 = strlen(&a1);
        _write(v15, &a1, v8);
        sprintf(&a1, "{\n");
        v9 = strlen(&a1);
        _write(v15, &a1, v9);
        for ( tracknum = 1; (signed int)tracknum <= (signed int)v19; ++tracknum )
        {
          AIL_redbook_track_info(dword_51D4A8, tracknum, &startmsec, &endmsec);
          sprintf(&a1, "  {%d, %d}", startmsec, endmsec);
          v10 = strlen(&a1);
          _write(v15, &a1, v10);
          if ( tracknum != v19 )
          {
            sprintf(&a1, L",");
            v11 = strlen(&a1);
            _write(v15, &a1, v11);
          }
          sprintf(&a1, L"\n");
          v12 = strlen(&a1);
          _write(v15, &a1, v12);
        }
        sprintf(&a1, "};\n");
        v13 = strlen(&a1);
        _write(v15, &a1, v13);
        _close(v15);
        result = _unlink(a2);
      }
      else
      {
        result = _unlink(a2);
      }
    }
    else
    {
      result = _unlink(a2);
    }
  }
  else
  {
    result = _unlink(a2);
  }
  return result;
}

//----- (004AA569) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (004AA5F0) --------------------------------------------------------
void __fastcall ResetHeroRVs(int a1, int a2, int a3)
{
  int v3; // ebx@9
  int v4; // ebx@18
  int v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  int j; // [sp+14h] [bp-8h]@6
  int i; // [sp+18h] [bp-4h]@4
  signed int k; // [sp+18h] [bp-4h]@15

  v5 = a2;
  v6 = a1;
  if ( a2 != -1 && a3 != -1 )
  {
    for ( i = 0; i < MAP_WIDTH; ++i )
    {
      for ( j = 0; j < MAP_HEIGHT; ++j )
      {
        if ( v6 )
        {
          v3 = abs(a3 - j);
          if ( abs(v5 - i) + v3 < 10 )
            *((_WORD *)gaiHeroStrategicRVOfPos + i + MAP_WIDTH * j) = -32001;
        }
        else
        {
          *((_WORD *)gaiHeroStrategicRVOfPos + i + MAP_WIDTH * j) = -32001;
          *((_WORD *)gaiHeroEventStratRVOfPos + i + MAP_WIDTH * j) = -32001;
        }
      }
    }
    *((_WORD *)gaiHeroEventStratRVOfPos + v5 + a3 * MAP_WIDTH) = -32001;
    for ( k = 0; k < 54; ++k )
    {
      if ( v6 )
      {
        v4 = abs(a3 - gpGame->heroes[k].x);
        if ( abs(v5 - gpGame->heroes[k].x) + v4 >= 10 )
          continue;
      }
      gaiHeroLiveChance[k] = -32001;
    }
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 532C60: using guessed type __int16 gaiHeroLiveChance[];

//----- (004AA7B0) --------------------------------------------------------
int __fastcall CheckDoMain(int a1, int a2)
{
  int result; // eax@2
  int v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+14h] [bp-Ch]@5
  int v5; // [sp+18h] [bp-8h]@5
  int v6; // [sp+1Ch] [bp-4h]@5

  v3 = a2;
  if ( KBTickCount() > iLastFrameRateTimer + 15 || (result = KBTickCount(), result > glTimers) )
  {
    Process1WindowsMessage();
    PollSound();
    if ( KBTickCount() > glTimers )
    {
      if ( !v3 )
      {
        v4 = bShowIt;
        v6 = gpAdvManager->field_1DE;
        v5 = gpAdvManager->field_1E2;
        gbDrawSavedCursor = 1;
        bShowIt = !*(_DWORD *)&blackoutComputer && !gbRemoteOn;
        if ( !bShowIt )
          bSpecialHideCursor = 1;
        if ( advManager::ComboDraw(gpAdvManager, gpAdvManager->field_1DE, gpAdvManager->field_1E2, 0) )
          advManager::UpdateScreen(gpAdvManager, 0, 0);
        else
          advManager::UpdBottomView(gpAdvManager, 0, 1, 1);
        bShowIt = v4;
        gbDrawSavedCursor = 0;
        bSpecialHideCursor = 0;
        gpAdvManager->field_1DE = v6;
        gpAdvManager->field_1E2 = v5;
      }
      glTimers = KBTickCount() + 120;
    }
    result = KBTickCount();
    iLastFrameRateTimer = result;
  }
  return result;
}
// 4F2AE4: using guessed type int gbDrawSavedCursor;
// 4F7494: using guessed type int gbRemoteOn;
// 51D5C8: using guessed type int iLastFrameRateTimer;
// 523F0C: using guessed type int bSpecialHideCursor;
// 524C14: using guessed type int bShowIt;

//----- (004AA940) --------------------------------------------------------
void *__thiscall philAI::philAI(void *this)
{
  signed int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; i < 6; ++i )
  {
    giBuildShipyard[i] = -1;
    giBuildBoat[i] = -1;
    giBuildBoatStuffTurn[i] = 0;
  }
  return this;
}

//----- (004AA9A0) --------------------------------------------------------
int __thiscall philAI::DoAllHeroInteractions(int this)
{
  int result; // eax@2
  signed int v2; // ST20_4@4
  int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; ; ++i )
  {
    result = gpCurPlayer->numCastles;
    if ( result <= i )
      break;
    if ( gpGame->castles[gpCurPlayer->castlesOwned[i]].visitingHeroIdx != -1 )
    {
      v2 = (signed int)&gpGame->castles[gpCurPlayer->castlesOwned[i]];
      philAI::HeroInteractionAtTown((int)&gpGame->heroes[*(_BYTE *)(v2 + 23)], v2, 0, (int)&unk_5305C8);
    }
  }
  return result;
}

//----- (004AAA50) --------------------------------------------------------
int __cdecl philAI::CheckForCreatureUpgrades()
{
  int result; // eax@2
  signed int v1; // [sp+10h] [bp-30h]@26
  int v2; // [sp+14h] [bp-2Ch]@25
  int v3; // [sp+18h] [bp-28h]@26
  char *v4; // [sp+1Ch] [bp-24h]@3
  signed int l; // [sp+20h] [bp-20h]@35
  signed int k; // [sp+24h] [bp-1Ch]@14
  signed int j; // [sp+28h] [bp-18h]@10
  signed int i; // [sp+2Ch] [bp-14h]@3
  int v9; // [sp+30h] [bp-10h]@1
  signed int v10; // [sp+34h] [bp-Ch]@14
  int v11; // [sp+38h] [bp-8h]@7
  int v12; // [sp+3Ch] [bp-4h]@1

  v12 = -1;
  v9 = 0;
LABEL_2:
  result = gpCurPlayer->numCastles;
  if ( result > v9 )
  {
    v4 = (char *)&gpGame->castles[gpCurPlayer->castlesOwned[v9]];
    for ( i = 0; ; ++i )
    {
      if ( i >= 2 )
      {
        ++v9;
        goto LABEL_2;
      }
      if ( i )
      {
        if ( v4[23] == -1 )
          continue;
        v11 = (int)&gpGame->heroes[v4[23]].army;
      }
      else
      {
        v11 = (int)(v4 + 8);
      }
      for ( j = 0; j < 5; ++j )
      {
        if ( *(_BYTE *)(j + v11) != -1 )
        {
          v10 = 0;
          for ( k = 20; k <= 24; ++k )
          {
            if ( LOBYTE((&gTownObjNames[3 * v4[3] + 27])[k + 1]) == *(_BYTE *)(j + v11) )
            {
              if ( (1 << (k + 5)) & *((_DWORD *)v4 + 6) )
              {
                v10 = 1;
                v12 = *(_BYTE *)(j + v11) + 1;
              }
            }
          }
          if ( (*(_BYTE *)(j + v11) == 35 || *(_BYTE *)(j + v11) == 36) && v4[27] & 0x40 )
          {
            v10 = 1;
            v12 = 37;
          }
          if ( v10 )
          {
            v2 = 2
               * *(_WORD *)(v11 + 2 * j + 5)
               * (gMonsterDatabase[v12].cost - gMonsterDatabase[*(_BYTE *)(j + v11)].cost);
            if ( v12 == 37 )
            {
              v1 = 3;
              v3 = 2 * *(_WORD *)(v11 + 2 * j + 5);
            }
            else if ( v12 == 46 )
            {
              v1 = 5;
              v3 = 2 * *(_WORD *)(v11 + 2 * j + 5);
            }
            else
            {
              v1 = -1;
              v3 = 0;
            }
            if ( gpCurPlayer->resources[6] >= v2 && (v1 == -1 || gpCurPlayer->resources[v1] >= v3) )
            {
              gpCurPlayer->resources[6] -= v2;
              if ( v1 != -1 )
                gpCurPlayer->resources[v1] -= v3;
              *(_BYTE *)(j + v11) = v12;
              for ( l = 0; l < 5; ++l )
              {
                if ( l != j && *(_BYTE *)(l + v11) == *(_BYTE *)(j + v11) && (signed int)*(_WORD *)(v11 + 2 * l + 5) > 0 )
                {
                  *(_WORD *)(v11 + 2 * l + 5) += *(_WORD *)(v11 + 2 * j + 5);
                  *(_WORD *)(v11 + 2 * j + 5) = 0;
                  *(_BYTE *)(j + v11) = -1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 4F3D10: using guessed type char *gTownObjNames[32];

//----- (004AADD0) --------------------------------------------------------
void __thiscall philAI::CheckBuyStuff(void *this)
{
  void *thisa; // [sp+10h] [bp-20h]@1
  int v2; // [sp+14h] [bp-1Ch]@33
  int v3; // [sp+18h] [bp-18h]@33
  int v4; // [sp+1Ch] [bp-14h]@36
  int v5; // [sp+20h] [bp-10h]@38
  town *v6; // [sp+24h] [bp-Ch]@5
  int v7; // [sp+28h] [bp-8h]@1
  int v8; // [sp+2Ch] [bp-4h]@1

  thisa = this;
  v7 = 0;
  v8 = 0;
  game::CheckHeroConsistency(gpGame);
  if ( gpCurPlayer->resources[6] >= 200 && (gpCurPlayer->resources[6] >= 2500 || gpCurPlayer->numHeroes) )
  {
    LogInt((int)"CheckBuy Start", gpCurPlayer->resources[6], -999, -999, -999, -999, -999, -999);
    v6 = 0;
    if ( giBuildShipyard[giCurPlayer] < 0 )
    {
      if ( giBuildBoat[giCurPlayer] >= 0 )
        v6 = &gpGame->castles[giBuildBoat[giCurPlayer]];
    }
    else
    {
      v6 = &gpGame->castles[giBuildShipyard[giCurPlayer]];
    }
    if ( giBuildShipyard[giCurPlayer] < 0 )
    {
      if ( giBuildBoat[giCurPlayer] >= 0 )
        v6 = &gpGame->castles[giBuildBoat[giCurPlayer]];
    }
    else
    {
      v6 = &gpGame->castles[giBuildShipyard[giCurPlayer]];
    }
    if ( v6 && v6->ownerIdx != giCurPlayer )
    {
      giBuildShipyard[giCurPlayer] = -1;
      giBuildBoat[giCurPlayer] = giBuildShipyard[giCurPlayer];
      v6 = 0;
    }
    if ( giBuildShipyard[giCurPlayer] >= 0 )
    {
      if ( CanBuy((int)v6, 3) && CanBuild((unsigned int *)v6, 3) )
      {
        philAI::BuildBuilding((signed int)v6, 3);
        giBuildShipyard[giCurPlayer] = -1;
      }
      else
      {
        gpCurPlayer->resources[6] -= 2000;
        gpCurPlayer->resources[0] -= 20;
      }
    }
    if ( giBuildBoat[giCurPlayer] >= 0 )
    {
      if ( v6->buildingsBuiltFlags & 8 && gpCurPlayer->resources[6] >= 1000 && gpCurPlayer->resources[0] >= 10 )
      {
        if ( game::GetBoatsBuilt(gpGame) < 48
          && !advManager::GetCell(gpAdvManager, v6->buildDockRelated, v6->field_7)->objType
          && game::CreateBoat(gpGame, v6->buildDockRelated, v6->field_7, 0) != -1 )
        {
          gpCurPlayer->resources[6] -= 1000;
          gpCurPlayer->resources[0] -= 10;
        }
        giBuildBoat[giCurPlayer] = -1;
      }
      else
      {
        gpCurPlayer->resources[6] -= 1000;
        gpCurPlayer->resources[0] -= 10;
      }
    }
    philAI::CheckForCreatureUpgrades();
    philAI::DoAllHeroInteractions((int)thisa);
    while ( !v7 )
    {
      philAI::GetBestBHC(thisa, giCurPlayer, (int)&v2);
      if ( v3 >= 0 && philAI::CanBuyBHC((int)&v2) )
      {
        if ( v3 )
        {
          if ( v3 == 1 )
          {
            philAI::BuildHero(v2, v4);
          }
          else if ( v3 == 2 )
          {
            philAI::BuildCreature(v2, v4, v5);
          }
        }
        else
        {
          philAI::BuildBuilding(v2, v4);
        }
        v8 = 1;
      }
      else
      {
        v7 = 1;
      }
    }
    if ( giBuildShipyard[giCurPlayer] >= 0 )
    {
      gpCurPlayer->resources[6] += 2000;
      gpCurPlayer->resources[0] += 20;
    }
    if ( giBuildBoat[giCurPlayer] >= 0 )
    {
      gpCurPlayer->resources[6] += 1000;
      gpCurPlayer->resources[0] += 10;
    }
    philAI::DoAllHeroInteractions((int)thisa);
    LogInt((int)"CheckBuy End  ", gpCurPlayer->resources[6], -999, -999, -999, -999, -999, -999);
  }
}

//----- (004AB290) --------------------------------------------------------
signed int __thiscall philAI::GoodAdjacent(void *this, int a1)
{
  signed int result; // eax@2
  void *v3; // [sp+Ch] [bp-30h]@1
  signed int v4; // [sp+18h] [bp-24h]@1
  int v5; // [sp+1Ch] [bp-20h]@16
  int v6; // [sp+20h] [bp-1Ch]@1
  int v7; // [sp+24h] [bp-18h]@1
  int row; // [sp+28h] [bp-14h]@6
  int col; // [sp+2Ch] [bp-10h]@6
  int v10; // [sp+30h] [bp-Ch]@16
  int v11; // [sp+34h] [bp-8h]@1
  int i; // [sp+38h] [bp-4h]@3

  v3 = this;
  v11 = -1;
  v7 = fReduceFactor;
  v6 = fBerserkFactor;
  fReduceFactor = 1065353216;
  fBerserkFactor = 1065353216;
  v4 = 100;
  if ( (advManager::GetCell(gpAdvManager, gpCurAIHero->x, gpCurAIHero->y)->objType & 0x7F) == 36 )
  {
    result = 0;
  }
  else
  {
    for ( i = 0; i < 8; ++i )
    {
      if ( advManager::ValidMoveWithEvent((int)gpAdvManager, (int)gpCurAIHero, i) )
      {
        col = gpCurAIHero->x + normalDirTable[4 * i];
        row = gpCurAIHero->y + byte_4F1DC1[4 * i];
        if ( advManager::GetCell(
               gpAdvManager,
               gpCurAIHero->x + normalDirTable[4 * i],
               gpCurAIHero->y + byte_4F1DC1[4 * i])->objType & 0x80 )
        {
          if ( !(*(&mapRevealed[col] + row * MAP_WIDTH) & 0x80)
            && (advManager::GetCell(gpAdvManager, col, row)->objType & 0x7F) != 36
            && (advManager::GetCell(gpAdvManager, col, row)->objType & 0x7F) != 39
            && (advManager::GetCell(gpAdvManager, col, row)->objType != 163
             || gpGame->castles[(unsigned __int8)((unsigned __int8)(advManager::GetCell(gpAdvManager, col, row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx != giCurPlayer
             || *(_WORD *)&gpCurAIHero->field_7 != giCurTurn) )
          {
            if ( advManager::GetCell(gpAdvManager, col, row)->objType != 170
              || gpGame->heroes[(unsigned __int8)((unsigned __int8)(advManager::GetCell(gpAdvManager, col, row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx != giCurPlayer
              || *(_WORD *)&gpCurAIHero->field_4 != giCurTurn )
            {
              v5 = philAI::ValueOfEventAtPosition(v3, __PAIR__(row, col), 2, (int)&v10);
              if ( v10 > 80 )
              {
                if ( v4 < v5 )
                {
                  v4 = v5;
                  v11 = i;
                }
              }
            }
          }
        }
      }
    }
    fReduceFactor = v7;
    fBerserkFactor = v6;
    if ( v11 == -1 )
    {
      result = 0;
    }
    else
    {
      *(_DWORD *)a1 = v11;
      result = 1;
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 5305C0: using guessed type int fReduceFactor;
// 5306D8: using guessed type int fBerserkFactor;
// 532C54: using guessed type int giCurTurn;

//----- (004AB580) --------------------------------------------------------
void __cdecl philAI::CheckReload()
{
  int v0; // [sp+3Ch] [bp-24h]@8
  mapCell *v1; // [sp+44h] [bp-1Ch]@8
  float v2; // [sp+48h] [bp-18h]@1
  int v3; // [sp+4Ch] [bp-14h]@9
  signed int v4; // [sp+4Ch] [bp-14h]@17
  int row; // [sp+50h] [bp-10h]@5
  int col; // [sp+54h] [bp-Ch]@3
  signed int v7; // [sp+58h] [bp-8h]@1
  float v8; // [sp+5Ch] [bp-4h]@1

  gbTroopReload = 0;
  fReduceFactor = 1065353216;
  v2 = 0.0;
  v8 = 0.0;
  v7 = philAI::FightValueOfStack(&gpCurAIHero->army, gpCurAIHero, 0, 0, 0, 0);
  if ( v7 < 100 )
    v7 = 100;
  searchArray::SeedPosition(
    gpSearchArray,
    gpCurAIHero->x,
    gpCurAIHero->y,
    HIBYTE(gpCurAIHero->field_2B),
    4 * gpCurAIHero->mobility,
    gpCurAIHero->flags & 0x80,
    0,
    gpCurAIHero->remainingMobility,
    gpCurAIHero->secondarySkillLevel[0],
    -1i64,
    0,
    0);
  for ( col = 0; col < MAP_WIDTH; ++col )
  {
    for ( row = 0; row < MAP_HEIGHT; ++row )
    {
      if ( *(&gpSearchArray->field_2414[col].field_4 + 9 * MAP_WIDTH * row) & 1 )
      {
        v1 = advManager::GetCell(gpAdvManager, col, row);
        v0 = v1->objType;
        if ( v0 == 163 )
        {
          v3 = philAI::FightValueOfStack(
                 &gpGame->castles[(unsigned __int8)((unsigned __int8)(v1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].garrison,
                 0,
                 0,
                 0,
                 0,
                 0);
          if ( gpGame->field_2773[(unsigned __int8)((unsigned __int8)(v1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == gpCurAIHero->ownerIdx )
          {
            if ( 2 * v7 < v3 )
              v2 = ((double)v3 / (double)(2 * v7) - 1.0)
                 * (double)(gpCurAIHero->mobility + 10)
                 / (double)(*(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * MAP_WIDTH * row) + 10)
                 + v2;
          }
          else if ( v7 >> 1 < v3 )
          {
            v8 = ((double)v3 / (double)(v7 >> 1) - 1.0)
               * (double)(gpCurAIHero->mobility + 30)
               / (double)(*(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * MAP_WIDTH * row) + 30)
               + v8;
          }
        }
        else if ( v0 == 170
  && gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(v1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != gpCurAIHero->ownerIdx )
        {
          v4 = philAI::FightValueOfStack(
                 &gpGame->heroes[(unsigned __int8)((unsigned __int8)(v1->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].army,
                 0,
                 0,
                 0,
                 0,
                 0);
          if ( v7 >> 1 < v4 )
            v8 = ((double)v4 / (double)(v7 >> 1) - 1.0)
               * (double)(gpCurAIHero->mobility + 30)
               / (double)(*(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * MAP_WIDTH * row) + 30)
               + v8;
        }
      }
    }
  }
  if ( v2 > 1.0 && v8 > 1.0 )
  {
    *(float *)&fReduceFactor = 3.0 / (v2 + v8 + 2.0);
    gbTroopReload = 1;
  }
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5305C0: using guessed type int fReduceFactor;
// 532C50: using guessed type int gbTroopReload;

//----- (004AB9B0) --------------------------------------------------------
int __cdecl philAI::CheckBerserk()
{
  signed __int64 v0; // qax@1
  int v2; // [sp+18h] [bp-24h]@10
  mapCell *v3; // [sp+24h] [bp-18h]@10
  int v4; // [sp+28h] [bp-14h]@13
  int v5; // [sp+28h] [bp-14h]@18
  signed int v6; // [sp+2Ch] [bp-10h]@1
  int row; // [sp+30h] [bp-Ch]@8
  int col; // [sp+34h] [bp-8h]@6
  signed int v9; // [sp+38h] [bp-4h]@1

  v6 = -1;
  gbBerserk = 0;
  fBerserkFactor = 1065353216;
  v9 = philAI::FightValueOfStack(&gpCurAIHero->army, gpCurAIHero, 1, 0, 0, 0);
  LODWORD(v0) = gpCurPlayer;
  if ( !gpCurPlayer->personality )
  {
    v0 = (signed __int64)((double)v9 * 1.15);
    v9 = (signed __int64)((double)v9 * 1.15);
  }
  if ( v9 < 100 )
    v9 = 100;
  if ( v9 >= 30000 )
  {
    for ( col = 0; ; ++col )
    {
      LODWORD(v0) = MAP_WIDTH;
      if ( col >= MAP_WIDTH )
        break;
      for ( row = 0; row < MAP_HEIGHT; ++row )
      {
        v3 = advManager::GetCell(gpAdvManager, col, row);
        v2 = v3->objType;
        if ( v2 == 163 )
        {
          if ( gpGame->field_2773[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != gpCurAIHero->ownerIdx
            && gpGame->field_2773[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != -1 )
          {
            v4 = philAI::FightValueOfStack(
                   &gpGame->castles[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].garrison,
                   0,
                   1,
                   1,
                   (unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5),
                   0);
            LODWORD(v0) = v9;
            if ( v4 > v9 )
              return v0;
            if ( v6 < v4 )
              v6 = v4;
          }
        }
        else if ( v2 == 170
  && gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != gpCurAIHero->ownerIdx )
        {
          LODWORD(v0) = philAI::FightValueOfStack(
                          &gpGame->heroes[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].army,
                          0,
                          1,
                          gpGame->heroes[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjType == 163,
                          gpGame->heroes[(unsigned __int8)((unsigned __int8)(v3->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].occupiedObjVal,
                          0);
          v5 = v0;
          LODWORD(v0) = 2 * v0;
          if ( (signed int)v0 > v9 )
            return v0;
          if ( 2 * v5 > v6 )
            v6 = 2 * v5;
        }
      }
    }
    if ( v6 > 0 )
    {
      LODWORD(v0) = v9;
      *(float *)&fBerserkFactor = (double)v6 * 0.75 / (double)v9;
      gbBerserk = 1;
    }
  }
  return v0;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5306D8: using guessed type int fBerserkFactor;
// 532CCC: using guessed type int gbBerserk;

//----- (004ABCA0) --------------------------------------------------------
void __stdcall philAI::DimensionDoorTo(__int64 a1)
{
  advManager::TeleportTo(gpAdvManager, gpCurAIHero, a1, SHIDWORD(a1), 0, 0);
  if ( gpCurAIHero->remainingMobility >= 225 )
    gpCurAIHero->remainingMobility -= 225;
  else
    gpCurAIHero->remainingMobility = 0;
  hero::UseSpell(gpCurAIHero, 56);
}

//----- (004ABD20) --------------------------------------------------------
signed int __thiscall philAI::DoAnywhereDDoorTownGate(void *this, signed int a1)
{
  signed int result; // eax@2
  int v3; // ST44_4@24
  int v4; // [sp+Ch] [bp-38h]@1
  mapCell *v5; // [sp+10h] [bp-34h]@19
  int v6; // [sp+14h] [bp-30h]@4
  mapCell *v7; // [sp+18h] [bp-2Ch]@42
  int v8; // [sp+1Ch] [bp-28h]@24
  int row; // [sp+20h] [bp-24h]@10
  signed int i; // [sp+24h] [bp-20h]@25
  int col; // [sp+28h] [bp-1Ch]@8
  int v12; // [sp+2Ch] [bp-18h]@29
  int v13; // [sp+30h] [bp-14h]@0
  signed int v14; // [sp+34h] [bp-10h]@3
  int a2; // [sp+38h] [bp-Ch]@29
  int a4; // [sp+3Ch] [bp-8h]@41
  int a3; // [sp+40h] [bp-4h]@41

  v4 = (int)this;
  if ( gpCurAIHero->flags & 0x80 )
  {
    result = 0;
  }
  else
  {
    v14 = -1;
    if ( a1 <= 25 )
      v6 = Random(0, 125) - 50;
    else
      v6 = a1 + 1000;
    if ( !hero::HasSpell(gpCurAIHero, 56) || gpCurAIHero->spellpoints < 30 )
      goto LABEL_55;
    for ( col = 0; col < MAP_WIDTH; ++col )
    {
      for ( row = 0; row < MAP_HEIGHT; ++row )
      {
        if ( !(*(&gpSearchArray->field_2414[col].field_4 + 9 * row * MAP_WIDTH) & 1)
          && abs(col - gpCurAIHero->x) <= 7
          && abs(row - gpCurAIHero->y) <= 7
          && (gpCurAIHero->x != col || gpCurAIHero->y != row) )
        {
          v5 = advManager::GetCell(gpAdvManager, col, row);
          if ( giGroundToTerrain[v5->groundIndex] && (v5->objType & 0x80 || a1 < 25 && Random(0, 10) < 2) )
          {
            v3 = philAI::RVOfPosition(v4, col, row, 0, -1, -1, 0, -1, -1, 2);
            v8 = Random(0, 30) + v3;
            if ( v6 < v8 )
            {
              for ( i = 0; i < 3; ++i )
              {
                if ( i )
                {
                  if ( i == 1 )
                  {
                    a2 = col;
                    v12 = row + 1;
                  }
                  else
                  {
                    a2 = col + 1;
                    v12 = row;
                  }
                }
                else
                {
                  a2 = col - 1;
                  v12 = row;
                }
                if ( !(*(&gpSearchArray->field_2414[a2].field_4 + 9 * v12 * MAP_WIDTH) & 1)
                  && (gpCurAIHero->x != a2 || gpCurAIHero->y != v12) )
                {
                  if ( a2 >= 0 )
                  {
                    if ( MAP_WIDTH - 1 >= a2 )
                    {
                      if ( v12 >= 0 )
                      {
                        if ( MAP_HEIGHT - 1 >= v12 )
                        {
                          if ( !advManager::FindAdjacentMonster(gpAdvManager, a2, v12, (int)&a3, (int)&a4, -1, -1) )
                          {
                            v7 = advManager::GetCell(gpAdvManager, a2, v12);
                            if ( giGroundToTerrain[v7->groundIndex] )
                            {
                              if ( !(v7->displayFlags & 8)
                                && !(v7->objType & 0x80)
                                && (v7->objectIndex == 255 || v7->displayFlags & 0x80) )
                              {
                                v14 = a2;
                                v13 = v12;
                                v6 = v8;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( v14 != -1 )
    {
      philAI::DimensionDoorTo(__PAIR__(v13, v14));
      result = 1;
    }
    else
    {
LABEL_55:
      result = 0;
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (004AC120) --------------------------------------------------------
signed int __stdcall philAI::DoDimensionDoor(int a1)
{
  signed int result; // eax@2
  mapCell *v2; // [sp+10h] [bp-1Ch]@7
  int v3; // [sp+14h] [bp-18h]@0
  int i; // [sp+18h] [bp-14h]@3
  int row; // [sp+1Ch] [bp-10h]@3
  int col; // [sp+20h] [bp-Ch]@3
  int v7; // [sp+24h] [bp-8h]@0
  signed int v8; // [sp+28h] [bp-4h]@3

  if ( *(_DWORD *)(a1 + 53) >= 75 )
  {
    v8 = -1;
    col = *(_DWORD *)(a1 + 25);
    row = *(_DWORD *)(a1 + 29);
    for ( i = gpSearchArray->field_8 - 1; i >= 1; --i )
    {
      col += normalDirTable[4 * *((_BYTE *)&gpSearchArray->field_2418 + i)];
      row += byte_4F1DC1[4 * *((_BYTE *)&gpSearchArray->field_2418 + i)];
      if ( abs(col - *(_DWORD *)(a1 + 25)) <= 7 )
      {
        if ( abs(row - *(_DWORD *)(a1 + 29)) <= 7 )
        {
          v2 = advManager::GetCell(gpAdvManager, col, row);
          if ( !(v2->objType & 0x80) )
          {
            if ( !(v2->displayFlags & 8) )
            {
              v8 = col;
              v7 = row;
              v3 = gpSearchArray->field_8 - i;
            }
          }
        }
      }
    }
    if ( v8 != -1 && v3 > 5 )
    {
      philAI::DimensionDoorTo(__PAIR__(v7, v8));
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004AC280) --------------------------------------------------------
int __cdecl philAI::SetupRelativeHeroStrengths()
{
  int result; // eax@2
  int v1; // [sp+10h] [bp-10h]@3
  signed int v2; // [sp+14h] [bp-Ch]@1
  int i; // [sp+18h] [bp-8h]@1
  char *hro; // [sp+1Ch] [bp-4h]@3

  v2 = -1;
  iAlphaMale = -1;
  for ( i = 0; ; ++i )
  {
    result = gpCurPlayer->numHeroes;
    if ( result <= i )
      break;
    hro = (char *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]];
    v1 = philAI::FightValueOfStack(&gpGame->heroes[gpCurPlayer->heroesOwned[i]].army, (hero *)hro, 1, 0, -1, 0);
    if ( v1 > v2 )
    {
      v2 = v1;
      iAlphaMale = (unsigned __int8)hro[2];
    }
  }
  return result;
}
// 530734: using guessed type int iAlphaMale;

//----- (004AC340) --------------------------------------------------------
int __thiscall ValidateHero(hero *this)
{
  int result; // eax@3
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 5; ++i )
  {
    result = this->army.creatureTypes[i];
    if ( result != -1 )
    {
      result = this->army.creatureTypes[i];
      if ( result >= 0 )
        result = this->army.creatureTypes[i];
    }
  }
  return result;
}

//----- (004AC3C0) --------------------------------------------------------
mouseManager *__thiscall philAI::DoAI(void *this, int a2)
{
  mouseManager *result; // eax@124
  void *v3; // [sp+1Ch] [bp-84h]@1
  signed int a8; // [sp+40h] [bp-60h]@68
  int a6; // [sp+44h] [bp-5Ch]@68
  town *v6; // [sp+48h] [bp-58h]@36
  int v7; // [sp+4Ch] [bp-54h]@35
  int a2a; // [sp+50h] [bp-50h]@40
  int v9; // [sp+54h] [bp-4Ch]@35
  int v10; // [sp+58h] [bp-48h]@35
  int v11; // [sp+5Ch] [bp-44h]@80
  mapCell *cell; // [sp+68h] [bp-38h]@61
  int i; // [sp+6Ch] [bp-34h]@6
  int v14; // [sp+70h] [bp-30h]@40
  int v15; // [sp+74h] [bp-2Ch]@1
  int v16; // [sp+78h] [bp-28h]@1
  int v17; // [sp+7Ch] [bp-24h]@24
  hero *thisa; // [sp+80h] [bp-20h]@13
  int v19; // [sp+84h] [bp-1Ch]@23
  int v20; // [sp+88h] [bp-18h]@26
  int trigY; // [sp+8Ch] [bp-14h]@81
  int a4; // [sp+90h] [bp-10h]@81
  int v23; // [sp+94h] [bp-Ch]@1
  char v24; // [sp+98h] [bp-8h]@76
  signed int a3; // [sp+9Ch] [bp-4h]@68

  v3 = this;
  v16 = 0;
  v23 = 0;
  v15 = 0;
  LogInt((int)"DO AI 1", a2, -999, -999, -999, -999, -999, -999);
  PollSound();
  if ( !gbGameOver && (!giLimitPlayer || giLimitPlayer == a2) )
  {
    LogInt((int)"DO AI", a2, -999, -999, -999, -999, -999, -999);
    InitAIMapVars();
    philAI::GetTurnAIVars(a2);
    if ( gpGame->day == 1 || gpGame->day == 1 )
    {
      for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
        *(_WORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]].field_7 = -99;
    }
    ShowStatus();
    philAI::SetupRelativeHeroStrengths();
    for ( i = 0; i < 7; ++i )
    {
      sprintf(gText, "RES - %15s  %d  %d", gResourceNames[i], gpCurPlayer->resources[i], gpCurPlayer->field_E7[i]);
      LogStr(gText);
    }
    philAI::CheckBuyStuff(v3);
    philAI::IncrementHourGlass();
    while ( 1 )
    {
      thisa = (hero *)philAI::DetermineHeroToMove(a2);
      if ( !thisa )
        break;
      ValidateHero(thisa);
      gpCurAIHero = thisa;
      if ( LOBYTE(thisa->field_29) == 255 || LOBYTE(gpCurAIHero->field_2B) )
      {
        giCurAIHeroMorale = armyGroup::GetMorale(&gpCurAIHero->army, gpCurAIHero, 0, 0);
        giCurAIHeroLuck = game::GetLuck(gpCurAIHero, 0, 0);
        armyGroup::GetMorale(&gpCurAIHero->army, gpCurAIHero, 0, 0);
        dword_5305C4 = -1;
        dword_532CE0 = 0;
        if ( gbGameOver )
          break;
        LogStr("\n\n\n\n");
        LogStr("===================================");
        LogInt((int)"Player with HeroTOMOVE", a2, -999, -999, -999, -999, -999, -999);
        LogStr(gpCurAIHero->name);
        LogStr(L"\n");
        philAI::CheckReload();
        philAI::CheckBerserk();
        giShowComputerRoute = 0;
        if ( *(_DWORD *)&blackoutComputer
          || gbRemoteOn
          || !MapExtraPosAndAdjacentsSet(gpCurAIHero->x, gpCurAIHero->y, giCurWatchPlayerBit) )
        {
          bShowIt = 0;
          advManager::SetHeroContext(gpAdvManager, gpCurAIHero->idx, 0);
        }
        else
        {
          bShowIt = 1;
          advManager::SetHeroContext(gpAdvManager, gpCurAIHero->idx, 0);
        }
        v19 = 0;
        ResetHeroRVs(0, 0, 0);
        if ( gpCurAIHero->flags & 0x80 )
          v17 = 15;
        else
          v17 = 5;
        v20 = gpCurAIHero->mobility + 800;
        v17 = (signed __int64)((1.7 - (double)gpGame->difficulty * 0.1) * (double)v17);
        v20 = (signed __int64)(((double)((signed int)gpGame->difficulty - 1) * 0.06 + 0.8) * (double)v20);
LABEL_27:
        if ( v19 || gpCurAIHero->remainingMobility < 75 )
        {
          gpCurAIHero->remainingMobility = 0;
          advManager::DeactivateCurrHero(gpAdvManager);
        }
        else
        {
          if ( gbGameOver )
            break;
          if ( gpCurAIHero->remainingMobility == gpCurAIHero->mobility
            && gpCurPlayer->field_40 > 15
            && LOBYTE(gpCurPlayer->field_41) == gpCurAIHero->x
            && HIBYTE(gpCurPlayer->field_41) == gpCurAIHero->y )
            advManager::ProcessSearch(gpAdvManager, *(_QWORD *)&gpCurAIHero->x);
          do
          {
            do
            {
              v9 = philAI::DetermineTargetPosition(
                     v3,
                     (int *)&gpCurAIHero->field_21,
                     (int *)&gpCurAIHero->field_25,
                     v20,
                     (int)&v10);
              v7 = game::GetTownId(gpGame, gpCurAIHero->x, gpCurAIHero->y);
              if ( v7 != -1 )
              {
                v6 = &gpGame->castles[v7];
                if ( gpGame->castles[v7].alignment )
                {
                  if ( (advManager::GetCell(
                          gpAdvManager,
                          *(_DWORD *)&gpCurAIHero->field_21,
                          *(_DWORD *)&gpCurAIHero->field_25)->objType & 0x7F) != 42 )
                    gpCurAIHero->remainingMobility = 0;
                }
              }
              if ( v10 != -1 )
              {
                a2a = v10;
                v14 = 99;
                goto LABEL_79;
              }
            }
            while ( v9 < 1000 && v10 == -1 && philAI::DoAnywhereDDoorTownGate(v3, v9) );
            if ( v9 < 75 && gpGame->day == 7 && gpCurAIHero->occupiedObjType == 163 )
              gpCurAIHero->remainingMobility = 0;
            for ( i = 0; dword_532CE0 > i; ++i )
            {
              if ( dword_5305D8[2 * i] == *(_DWORD *)&gpCurAIHero->field_21
                && dword_5305DC[2 * i] == *(_DWORD *)&gpCurAIHero->field_25
                && advManager::GetCell(
                     gpAdvManager,
                     *(_DWORD *)&gpCurAIHero->field_21,
                     *(_DWORD *)&gpCurAIHero->field_25)->objType != 163 )
                gpCurAIHero->remainingMobility = 0;
            }
            if ( dword_532CE0 < 30 )
            {
              dword_5305D8[2 * dword_532CE0] = gpCurAIHero->x;
              dword_5305DC[2 * dword_532CE0++] = gpCurAIHero->y;
            }
            giShowComputerRoute = 1;
            if ( gpCurAIHero->remainingMobility == gpCurAIHero->mobility )
            {
              v23 = 0;
              philAI::IncrementHourGlass();
            }
            if ( *(_DWORD *)&gpCurAIHero->field_21 == -1 || *(_DWORD *)&gpCurAIHero->field_25 == -1 )
            {
              v19 = 1;
              goto LABEL_27;
            }
            cell = 0;
            advManager::SetHeroContext(gpAdvManager, gpCurAIHero->idx, 0);
            searchArray::BuildPath(
              gpSearchArray,
              gpCurAIHero->x,
              gpCurAIHero->y,
              *(_DWORD *)&gpCurAIHero->field_21,
              *(_DWORD *)&gpCurAIHero->field_25,
              gpCurAIHero->remainingMobility);
            if ( !gpSearchArray->field_8 )
            {
              v19 = 1;
              goto LABEL_113;
            }
            if ( gpSearchArray->field_8 <= 0 )
            {
              v19 = 1;
              goto LABEL_113;
            }
            advManager::UpdateScreen(gpAdvManager, 0, 0);
          }
          while ( v9 > 1000
               && hero::HasSpell(gpCurAIHero, 56)
               && gpCurAIHero->spellpoints >= 30
               && philAI::DoDimensionDoor((int)gpCurAIHero) );
          v14 = 0;
          i = gpSearchArray->field_8 - 1;
          a6 = 0;
          a8 = 0;
          a3 = 1;
          while ( i >= 0 && v14 < v17 )
          {
            a3 = v14 + 1 == v17 || !i;
            if ( i > 0 )
            {
              a6 = 0;
              a8 = 0;
              if ( philAI::GoodAdjacent(v3, (int)&v24) )
              {
                *((_BYTE *)&gpSearchArray->field_2418 + i) = v24;
                a3 = 1;
              }
            }
            a2a = *((_BYTE *)&gpSearchArray->field_2418 + i);
LABEL_79:
            if ( advManager::GetMoveShowIt((int)gpCurAIHero, a2a) )
            {
              v11 = bShowIt;
              bShowIt = 1;
              mouseManager::HideColorPointer(gpMouseManager);
              ++v16;
              bShowIt = v11;
            }
            cell = advManager::MoveHero(gpAdvManager, a2a, a3, &a4, &trigY, (int)&a6, 1, (signed int)&a8, 0);
            ++v14;
            if ( cell || a6 || a8 )
              break;
            --i;
          }
          if ( gpCurAIHero->ownerIdx != giCurPlayer )
          {
            if ( !v15 )
            {
              v15 = 1;
              philAI::CheckBuyStuff(v3);
            }
            goto LABEL_120;
          }
          if ( gpCurAIHero->mobility >> 1 >= gpCurAIHero->remainingMobility && !v23 )
          {
            v23 = 1;
            philAI::IncrementHourGlass();
          }
          if ( i < 0
            && gpCurPlayer->field_40 > 15
            && LOBYTE(gpCurPlayer->field_41) == gpCurAIHero->x
            && HIBYTE(gpCurPlayer->field_41) == gpCurAIHero->y )
          {
            if ( gpCurAIHero->remainingMobility == gpCurAIHero->mobility )
              advManager::ProcessSearch(gpAdvManager, -1i64);
            else
              gpCurAIHero->remainingMobility = 0;
          }
          if ( i < 0
            && ((gpCurAIHero->x != *(_DWORD *)&gpCurAIHero->field_21
              || *(_DWORD *)&gpCurAIHero->field_25 != gpCurAIHero->y)
             && !cell
             || gpCurAIHero->remainingMobility < 75
             || a6 && !cell) )
            v19 = 1;
          v11 = bShowIt;
          bShowIt = 1;
          while ( v16 )
          {
            mouseManager::ShowColorPointer(gpMouseManager);
            --v16;
          }
          bShowIt = v11;
          advManager::UpdateRadar(gpAdvManager, 1, 0);
LABEL_113:
          if ( !cell )
            goto LABEL_27;
          advManager::DoAIEvent((int)gpAdvManager, cell, gpCurAIHero, __PAIR__(trigY, a4));
          if ( gpCurPlayer->curHeroIdx != -1 )
          {
            ValidateHero(gpCurAIHero);
            ResetHeroRVs(1, *(_DWORD *)&gpCurAIHero->field_21, *(_DWORD *)&gpCurAIHero->field_25);
            goto LABEL_27;
          }
        }
LABEL_120:
        if ( gpCurAIHero->occupiedObjType == 163 )
          philAI::CheckBuyStuff(v3);
      }
      else
      {
        gpCurAIHero->remainingMobility = 0;
      }
    }
  }
  game::CheckHeroConsistency(gpGame);
  gpCurAIHero = 0;
  CloseAIMapVars();
  while ( 1 )
  {
    result = gpMouseManager;
    if ( !gpMouseManager->cursorDisabled )
      break;
    mouseManager::ShowColorPointer(gpMouseManager);
  }
  return result;
}
// 4EF268: using guessed type int gbGameOver;
// 4F7494: using guessed type int gbRemoteOn;
// 51D598: using guessed type int giShowComputerRoute;
// 524794: using guessed type int giLimitPlayer;
// 524C14: using guessed type int bShowIt;
// 5305C4: using guessed type int dword_5305C4;
// 5306D4: using guessed type int giCurAIHeroLuck;
// 5306DC: using guessed type int giCurAIHeroMorale;
// 5306F0: using guessed type char giCurWatchPlayerBit;
// 532CE0: using guessed type int dword_532CE0;

//----- (004AD070) --------------------------------------------------------
int __thiscall philAI::GetGameAIVars(int this)
{
  int result; // eax@2
  int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; ; ++i )
  {
    result = gpGame->numPlayers;
    if ( result <= i )
      break;
    philAI::GetGameAttentionValue(i);
  }
  return result;
}

//----- (004AD0C0) --------------------------------------------------------
playerData *__stdcall philAI::GetTurnAIVars(int a1)
{
  signed __int64 v1; // qax@1
  int v2; // ebx@13
  __int64 v3; // ST08_8@54
  int v4; // ebx@73
  int v5; // eax@73
  char *v6; // ST70_4@112
  char *v7; // ST74_4@112
  int v8; // ebx@112
  playerData *result; // eax@121
  signed int v10; // [sp+40h] [bp-78h]@51
  char *v11; // [sp+44h] [bp-74h]@52
  mapCell *v12; // [sp+48h] [bp-70h]@49
  char v13; // [sp+4Ch] [bp-6Ch]@54
  char v14; // [sp+50h] [bp-68h]@54
  int v15; // [sp+54h] [bp-64h]@65
  char v16; // [sp+58h] [bp-60h]@54
  float v17; // [sp+5Ch] [bp-5Ch]@89
  int v18; // [sp+60h] [bp-58h]@65
  char v19; // [sp+64h] [bp-54h]@54
  int i; // [sp+68h] [bp-50h]@4
  int l; // [sp+6Ch] [bp-4Ch]@35
  int v22; // [sp+70h] [bp-48h]@73
  int v23; // [sp+74h] [bp-44h]@23
  int v24; // [sp+78h] [bp-40h]@107
  int k; // [sp+7Ch] [bp-3Ch]@17
  int j; // [sp+80h] [bp-38h]@6
  int m; // [sp+84h] [bp-34h]@44
  hero *hro; // [sp+88h] [bp-30h]@9
  int x; // [sp+8Ch] [bp-2Ch]@42
  float v30; // [sp+90h] [bp-28h]@54
  int v31; // [sp+94h] [bp-24h]@3
  float v32; // [sp+98h] [bp-20h]@3
  int v33; // [sp+9Ch] [bp-1Ch]@107
  town *v34; // [sp+A0h] [bp-18h]@6
  int v35; // [sp+A4h] [bp-14h]@42
  int v36; // [sp+A8h] [bp-10h]@95
  int v37; // [sp+ACh] [bp-Ch]@17
  playerData *v38; // [sp+B0h] [bp-8h]@63
  char v39; // [sp+B4h] [bp-4h]@54

  giCurTurn = gpGame->day + 7 * (gpGame->week - 1) + 28 * (gpGame->month - 1);
  philAI::GetTurnAttentionValue(a1);
  philAI::TurnCostResource(a1);
  LODWORD(iCurHourGlassPhase) = 0;
  iSandAnim = 0;
  v1 = (signed __int64)philAI::TurnValueOfObelisk(a1);
  *(_DWORD *)&gpCurPlayer->_5[0] = v1;
  *(_DWORD *)&gpCurPlayer->_5[4] = *(_DWORD *)&gpCurPlayer->_5[0] * (signed int)gpGame->numObelisks / 48;
  *(_DWORD *)&gpCurPlayer->_5[8] = philAI::MeanRVOfUnexploredTerritory(a1);
  bHeroBuiltThisTurn = 0;
  if ( giCurTurn - giBuildBoatStuffTurn[a1] > 8 )
  {
    giBuildShipyard[a1] = -1;
    giBuildBoat[a1] = -1;
  }
  v31 = 0;
  v32 = 0.0;
  if ( giCurTurn <= 7 )
  {
    dword_51D58C = 0;
    for ( i = 0; gpCurPlayer->numCastles > i; ++i )
    {
      v34 = &gpGame->castles[gpCurPlayer->castlesOwned[i]];
      for ( j = 0; j < 54; ++j )
      {
        hro = &gpGame->heroes[j];
        if ( gpGame->heroes[j].ownerIdx >= 0 )
        {
          if ( hro->ownerIdx <= 5 )
          {
            if ( hro->ownerIdx != giCurPlayer )
            {
              v2 = abs(hro->x - v34->x);
              if ( abs(hro->y - v34->y) + v2 < 16 )
              {
                dword_51D58C = 1050253722;
                goto LABEL_17;
              }
            }
          }
        }
      }
    }
  }
LABEL_17:
  v37 = 0;
  for ( k = 0; gpCurPlayer->numHeroes > k; ++k )
  {
    hro = &gpGame->heroes[gpCurPlayer->heroesOwned[k]];
    v32 = (double)philAI::FightValueOfStack(&hro->army, hro, 0, 0, 0, 0);
    v37 = (signed __int64)((double)v37 + v32);
    *(float *)&hro->field_E8 = v32 * 0.00004 + 0.4;
  }
  for ( k = 0; gpCurPlayer->numCastles > k; ++k )
  {
    v34 = &gpGame->castles[gpCurPlayer->castlesOwned[k]];
    v32 = (double)philAI::FightValueOfStack(&v34->garrison, 0, 0, 0, 0, 0);
    v37 = (signed __int64)((double)v37 + v32);
  }
  gpCurPlayer->field_10F = (double)(gpCurPlayer->resources[6] + gpCurPlayer->field_E7[6]) / (double)(v37 + 1000)
                         + *(float *)&gpCurPlayer->_4_2[22];
  v23 = 0;
  for ( k = 4; k < 37; ++k )
    v23 += gArtifactBaseRV[k];
  for ( k = 0; gpGame->numPlayers > k; ++k )
    *(float *)&gpGame->players[k].field_117 = 1.0
                                            / (double)((signed int)gpGame->couldBeNumDefeatedPlayers
                                                     + (signed int)gpGame->numPlayers);
  *(float *)&gpCurPlayer->field_113 = (double)v23 / 33.0;
  for ( k = 0; k < 72; ++k )
    gpGame->castles[k].alignment = 0;
  for ( k = 0; gpCurPlayer->numCastles > k; ++k )
    gpGame->castles[gpCurPlayer->castlesOwned[k]].alignment = 0;
  memset(gaiEnemyHeroReachable, 0, MAP_HEIGHT * MAP_WIDTH);
  for ( l = 0; gpGame->numPlayers > l; ++l )
  {
    if ( l != giCurPlayer && !OnMySide(l) )
    {
      for ( j = 0; gpGame->players[l].numHeroes > j; ++j )
      {
        v35 = (int)&gpGame->heroes[gpGame->players[l].heroesOwned[j]];
        searchArray::SeedPosition(
          gpSearchArray,
          *(_DWORD *)(v35 + 25),
          *(_DWORD *)(v35 + 29),
          *(_BYTE *)(v35 + 44),
          *(_DWORD *)(v35 + 49) + 100,
          *(_DWORD *)(v35 + 227) & 0x80,
          1,
          *(_DWORD *)(v35 + 49) + 100,
          *(_BYTE *)(v35 + 116),
          -1i64,
          0,
          0);
        for ( x = 0; MAP_WIDTH > x; ++x )
        {
          for ( m = 0; m < MAP_WIDTH; ++m )
          {
            if ( *(&gpSearchArray->field_2414[x].field_4 + 9 * MAP_WIDTH * m) & 1 )
            {
              *((_BYTE *)gaiEnemyHeroReachable + x + MAP_WIDTH * m) = 1;
              if ( m )
              {
                v12 = advManager::GetCell(gpAdvManager, x, m - 1);
                if ( v12->objType == 163 || (v12->objType & 0x7F) == 42 )
                {
                  v10 = game::GetTownId(gpGame, x, m - 1);
                  if ( v10 != -1 )
                  {
                    v11 = (char *)&gpGame->castles[v10];
                    if ( gpGame->castles[v10].ownerIdx == giCurPlayer )
                    {
                      if ( gpGame->castles[v10].buildingsBuiltFlags & 0x40 )
                      {
                        HIDWORD(v3) = (char *)gpGame + 250 * gpGame->castles[v10].visitingHeroIdx + 10180;
                        LODWORD(v3) = (char *)gpGame + 250 * gpGame->castles[v10].visitingHeroIdx + 10281;
                        philAI::ProbableOutcomeOfBattle(
                          v35 + 101,
                          v35,
                          v3,
                          (int)&gpGame->castles[v10].garrison,
                          1,
                          gpGame->castles[v10].idx,
                          gpGame->castles[v10].ownerIdx,
                          (int)&v30,
                          (int)&v19,
                          (int *)&v16,
                          (int *)&v14,
                          (int *)&v13,
                          (int *)&v39);
                        if ( v30 > 0.7 )
                          v11[2] = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  memset(gaiTurnValueOfMine, 7u, MAP_HEIGHT * MAP_WIDTH);
  for ( l = 0; gpGame->numPlayers > l; ++l )
  {
    if ( l != giCurPlayer )
    {
      v38 = &gpGame->players[l];
      for ( j = 0; v38->numHeroes > j; ++j )
      {
        v18 = gpGame->heroes[v38->heroesOwned[j]].x;
        v15 = gpGame->heroes[v38->heroesOwned[j]].y;
        for ( x = v18 - 10; v18 + 10 >= x; ++x )
        {
          for ( m = v15 - 10; v15 + 10 >= m; ++m )
          {
            if ( x >= 0 )
            {
              if ( MAP_WIDTH > x )
              {
                if ( m >= 0 )
                {
                  if ( m < MAP_HEIGHT )
                  {
                    v4 = abs(m - v15);
                    v5 = abs(x - v18);
                    v22 = abs(v5 + v4 - 4) >> 2;
                    if ( *((_BYTE *)gaiTurnValueOfMine + x + MAP_WIDTH * m) > v22 )
                      *((_BYTE *)gaiTurnValueOfMine + x + MAP_WIDTH * m) = v22;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  for ( k = 0; k < 54; ++k )
    dword_5304E8[k] = 1065353216;
  if ( gpGame->difficulty )
  {
    if ( gpGame->difficulty == 1 )
    {
      gfAttackHumanBonus = 0x3F800000u;
      gfAttackComputerBonus = 0x3F800000u;
    }
    else
    {
      *(float *)&gfAttackHumanBonus = (double)gpGame->difficulty * 0.07000000000000001 + 1.0;
      *(float *)&gfAttackComputerBonus = 1.1 - (double)gpGame->difficulty * 0.12;
    }
  }
  else
  {
    gfAttackHumanBonus = 0x3F19999Au;
    gfAttackComputerBonus = 0x3FA66666u;
  }
  if ( *(_DWORD *)&gbIAmGreatest )
    gfAttackComputerBonus = 0x3DCCCCCDu;
  v17 = 0.1;
  for ( k = 0; gpCurPlayer->numCastles > k; ++k )
  {
    if ( gpGame->castles[gpCurPlayer->castlesOwned[k]].buildingsBuiltFlags & 0x40 )
      v17 = v17 + 1.0;
    else
      v17 = v17 + 0.5;
  }
  v36 = (signed __int64)v17;
  giMaxHeroesForThisPlayer = 3;
  if ( gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers == 2 )
    ++giMaxHeroesForThisPlayer;
  if ( gpGame->numPlayers - gpGame->couldBeNumDefeatedPlayers == 3 )
    ++giMaxHeroesForThisPlayer;
  if ( v36 >= 5 )
    ++giMaxHeroesForThisPlayer;
  if ( v36 >= 10 )
    ++giMaxHeroesForThisPlayer;
  if ( gpGame->mapHeader.width == 36 )
    --giMaxHeroesForThisPlayer;
  if ( gpGame->mapHeader.width >= 108 )
    ++giMaxHeroesForThisPlayer;
  v24 = 16;
  v33 = 22;
  if ( gpCurPlayer->personality == 2 )
  {
    v24 = 8;
    v33 = 15;
  }
  if ( giCurTurn < v24 )
  {
    if ( v36 == 1 )
    {
      if ( gpCurPlayer->numHeroes == 1 )
      {
        v6 = (char *)&gpGame->heroes[gpCurPlayer->heroesOwned[0]];
        v7 = (char *)&gpGame->castles[gpCurPlayer->castlesOwned[0]];
        v8 = abs(gpGame->castles[gpCurPlayer->castlesOwned[0]].x - gpGame->heroes[gpCurPlayer->heroesOwned[0]].x);
        if ( abs((unsigned __int8)v7[5] - *(_DWORD *)(v6 + 29)) + v8 < 18 )
          giMaxHeroesForThisPlayer = 1;
      }
    }
  }
  if ( giCurTurn < v33 && giMaxHeroesForThisPlayer > 2 )
    giMaxHeroesForThisPlayer = 2;
  if ( gpCurPlayer->personality == 2 )
    ++v36;
  if ( v36 + 1 < giMaxHeroesForThisPlayer )
    giMaxHeroesForThisPlayer = v36 + 1;
  result = gpCurPlayer;
  if ( gpCurPlayer->_2 > giMaxHeroesForThisPlayer )
  {
    result = gpCurPlayer;
    giMaxHeroesForThisPlayer = gpCurPlayer->_2;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 50EA90: using guessed type int iSandAnim;
// 50EAA8: using guessed type __int64 iCurHourGlassPhase;
// 51D58C: using guessed type int dword_51D58C;
// 51D5C0: using guessed type int gfAttackHumanBonus;
// 51D5C4: using guessed type int gfAttackComputerBonus;
// 532C54: using guessed type int giCurTurn;
// 532C58: using guessed type int bHeroBuiltThisTurn;
// 532CE4: using guessed type int giMaxHeroesForThisPlayer;

//----- (004ADEA0) --------------------------------------------------------
void __thiscall philAI::GetBestBHC(void *this, int a2, int a3)
{
  int v3; // eax@3
  double v4; // st7@17
  double v5; // st7@19
  void *v6; // [sp+20h] [bp-270h]@1
  float v7; // [sp+24h] [bp-26Ch]@1
  int v8[72]; // [sp+28h] [bp-268h]@3
  int i; // [sp+148h] [bp-148h]@1
  float v10; // [sp+14Ch] [bp-144h]@1
  int v11; // [sp+150h] [bp-140h]@9
  int v12; // [sp+154h] [bp-13Ch]@3
  int v13[72]; // [sp+158h] [bp-138h]@11
  char v14; // [sp+278h] [bp-18h]@17
  int v15; // [sp+27Ch] [bp-14h]@18
  int v16; // [sp+280h] [bp-10h]@18
  int v17; // [sp+284h] [bp-Ch]@18
  int v18; // [sp+288h] [bp-8h]@1
  int v19; // [sp+28Ch] [bp-4h]@1

  v6 = this;
  v10 = 1.0;
  v7 = -99.0;
  v18 = 0;
  v19 = 0;
  for ( i = 0; gpCurPlayer->numCastles > i; ++i )
  {
    v12 = (int)&gpGame->castles[gpCurPlayer->castlesOwned[i]];
    v3 = philAI::FightValueOfStack((armyGroup *)(v12 + 8), 0, 0, 0, 0, 0);
    v8[i] = v3 + 400;
    v18 += v8[i];
    if ( *(_BYTE *)(v12 + 24) & 0x40 )
      v19 += 10;
    else
      v19 += 7;
  }
  if ( v19 < 1 )
    v19 = 1;
  v11 = v18 / v19;
  for ( i = 0; gpCurPlayer->numCastles > i; ++i )
  {
    v12 = (int)&gpGame->castles[gpCurPlayer->castlesOwned[i]];
    v13[i] = v11 * ((*(_DWORD *)(v12 + 24) & 0x40u) < 1 ? 7 : 10) + 400;
  }
  for ( i = 0; gpCurPlayer->numCastles > i; ++i )
  {
    v12 = (int)&gpGame->castles[gpCurPlayer->castlesOwned[i]];
    LogInt((int)"Turns Owned", *(_WORD *)(v12 + 85), -999, -999, -999, -999, -999, -999);
    if ( giCurTurn <= 3 || (signed int)*(_WORD *)(v12 + 85) >= 3 )
    {
      CheckDoMain(0, 0);
      philAI::GetBestBuilding(v6, v12, (int)&v14, (int)&v10);
      v4 = (double)(100 - Random(0, 10)) / 100.0 * v10;
      v10 = v4;
      if ( v4 > v7 )
      {
        v7 = v10;
        *(_DWORD *)a3 = *(_DWORD *)&v14;
        *(_DWORD *)(a3 + 4) = v15;
        *(_DWORD *)(a3 + 8) = v16;
        *(_DWORD *)(a3 + 12) = v17;
      }
      CheckDoMain(0, 0);
      philAI::GetBestCreature(v6, v12, (int)&v14, (int)&v10);
      v10 = ((double)v13[i] / (double)v8[i] / 3.0 + 0.66) * v10;
      v5 = (double)(100 - Random(0, 10)) / 100.0 * v10;
      v10 = v5;
      if ( v5 > v7 )
      {
        v7 = v10;
        *(_DWORD *)a3 = *(_DWORD *)&v14;
        *(_DWORD *)(a3 + 4) = v15;
        *(_DWORD *)(a3 + 8) = v16;
        *(_DWORD *)(a3 + 12) = v17;
      }
      CheckDoMain(0, 0);
      if ( gpCurPlayer->numHeroes < giMaxHeroesForThisPlayer && *(_BYTE *)(v12 + 24) & 0x40 )
      {
        philAI::GetBestHero(v12, (int)&v14, (int)&v10);
        v10 = (double)(100 - Random(0, 10)) / 100.0 * v10;
        if ( bHeroBuiltThisTurn || giCurTurn <= 5 || v10 <= 0.0 )
        {
          if ( !gpCurPlayer->numHeroes )
            v10 = v10 + 500.0;
        }
        else if ( (gpCurPlayer->field_E7[6] < 1250 || gpCurPlayer->numHeroes >= giMaxHeroesForThisPlayer - 2)
  && gpCurPlayer->numHeroes > 1 )
        {
          if ( gpCurPlayer->field_E7[6] >= 1500 && gpCurPlayer->numHeroes < giMaxHeroesForThisPlayer - 1 )
            v10 = v10 * 1.3;
        }
        else
        {
          v10 = v10 + 500.0;
        }
        if ( v7 < (double)v10 )
        {
          v7 = v10;
          *(_DWORD *)a3 = *(_DWORD *)&v14;
          *(_DWORD *)(a3 + 4) = v15;
          *(_DWORD *)(a3 + 8) = v16;
          *(_DWORD *)(a3 + 12) = v17;
        }
      }
    }
  }
  LogInt((int)"BestBHC ", *(_DWORD *)(a3 + 4), (signed __int64)(v7 * 100.0), *(_DWORD *)(a3 + 8), 0, 0, -999, -999);
  if ( v7 < 0.02 )
    *(_DWORD *)(a3 + 4) = -1;
}
// 532C54: using guessed type int giCurTurn;
// 532C58: using guessed type int bHeroBuiltThisTurn;
// 532CE4: using guessed type int giMaxHeroesForThisPlayer;
// 4ADEA0: using guessed type int var_268[72];
// 4ADEA0: using guessed type int var_138[72];

//----- (004AE470) --------------------------------------------------------
char *__stdcall philAI::DetermineHeroToMove(int a1)
{
  char *result; // eax@8
  signed int i; // [sp+10h] [bp-10h]@2
  signed int v3; // [sp+18h] [bp-8h]@1
  int v4; // [sp+1Ch] [bp-4h]@1

  v4 = 0;
  v3 = -1;
  if ( playerData::HasMobileHero(gpCurPlayer) )
  {
    for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
    {
      if ( gpGame->heroes[*(&gpGame->players[0].heroesOwned[284 * a1] + i - a1)].remainingMobility > v4 )
      {
        v4 = gpGame->heroes[*(&gpGame->players[0].heroesOwned[284 * a1] + i - a1)].remainingMobility;
        v3 = i;
      }
    }
  }
  if ( v3 < 0 )
  {
    gpGame->players[a1].curHeroIdx = -1;
    result = 0;
  }
  else
  {
    result = (char *)&gpGame->heroes[*(&gpGame->players[0].heroesOwned[284 * a1] + v3 - a1)];
  }
  return result;
}

//----- (004AE590) --------------------------------------------------------
signed int __thiscall philAI::DetermineTargetPosition(void *this, int *a2, int *a3, signed int a4, int a5)
{
  signed int result; // eax@2
  PathfindingInfo *v6; // ST68_4@22
  int v7; // ebx@46
  int v8; // ebx@88
  int v9; // ST80_4@102
  int v10; // ebx@113
  int v11; // ebx@113
  int v12; // esi@113
  void *v13; // [sp+2Ch] [bp-70h]@1
  int v14; // [sp+40h] [bp-5Ch]@3
  mapCell *v15; // [sp+44h] [bp-58h]@63
  signed int v16; // [sp+48h] [bp-54h]@22
  int v17; // [sp+4Ch] [bp-50h]@3
  int v18; // [sp+50h] [bp-4Ch]@98
  int v19; // [sp+54h] [bp-48h]@1
  int v20; // [sp+58h] [bp-44h]@88
  int j; // [sp+5Ch] [bp-40h]@91
  int i; // [sp+60h] [bp-3Ch]@30
  int row; // [sp+64h] [bp-38h]@39
  int v24; // [sp+68h] [bp-34h]@3
  int v25; // [sp+6Ch] [bp-30h]@100
  int col; // [sp+70h] [bp-2Ch]@35
  int v27; // [sp+74h] [bp-28h]@3
  int v28; // [sp+78h] [bp-24h]@28
  int v29; // [sp+7Ch] [bp-20h]@20
  int v30; // [sp+80h] [bp-1Ch]@26
  int v31; // [sp+84h] [bp-18h]@24
  bool v32; // [sp+88h] [bp-14h]@65
  int v33; // [sp+8Ch] [bp-10h]@37
  signed int a5a; // [sp+90h] [bp-Ch]@22
  int v35; // [sp+94h] [bp-8h]@46
  int v36; // [sp+98h] [bp-4h]@22

  v13 = this;
  if ( philAI::GoodAdjacent(this, (int)&v19) )
  {
    *a2 = gpCurAIHero->x + normalDirTable[4 * v19];
    *a3 = gpCurAIHero->y + byte_4F1DC1[4 * v19];
    *(_DWORD *)a5 = v19;
    result = 1000;
  }
  else
  {
    *(_DWORD *)a5 = -1;
    v27 = -1;
    v24 = -1;
    v14 = -999999;
    dword_5305CC = -1;
    dword_5306E0 = 0;
    dword_532CE8 = 0;
    dword_532CEC = 0;
    v17 = (unsigned __int8)giGroundToTerrain[advManager::GetCell(gpAdvManager, gpCurAIHero->x, gpCurAIHero->y)->groundIndex];
    if ( gpCurAIHero->secondarySkillLevel[0] > 1 )
    {
      switch ( gpGame->mapHeader.width )
      {
        case 0x24:
          a4 = (signed __int64)((double)a4 * 0.9);
          break;
        case 0x6C:
          a4 = (signed __int64)((double)a4 * 1.05);
          break;
        case 0x90:
          a4 = (signed __int64)((double)a4 * 1.1);
          break;
      }
    }
    else
    {
      if ( v17 == 2 || v17 == 3 )
        a4 = (signed __int64)((double)a4 * 1.15);
      if ( v17 == 5 )
        a4 = (signed __int64)((double)a4 * 1.35);
      if ( v17 == 7 )
        a4 = (signed __int64)((double)a4 * 1.25);
    }
    if ( gpCurPlayer->personality == 2 )
      a4 = (signed __int64)((double)a4 * 1.15);
    v29 = a4 / 100 / 4;
    if ( v29 < 6 )
      v29 = 6;
    a5a = 2 * a4;
    searchArray::SeedPosition(
      gpSearchArray,
      gpCurAIHero->x,
      gpCurAIHero->y,
      HIBYTE(gpCurAIHero->field_2B),
      2 * a4,
      gpCurAIHero->flags & 0x80,
      1,
      gpCurAIHero->remainingMobility,
      gpCurAIHero->secondarySkillLevel[0],
      -1i64,
      0,
      0);
    v6 = &gpSearchArray->field_2414[gpCurAIHero->x] + MAP_WIDTH * gpCurAIHero->y;
    v6->field_4 &= 0xFEu;
    v16 = -1;
    v36 = gpCurAIHero->x - 25;
    if ( v36 < 0 )
      v36 = 0;
    v31 = gpCurAIHero->y - 25;
    if ( v31 < 0 )
      v31 = 0;
    v30 = gpCurAIHero->x + 25;
    if ( MAP_WIDTH - 1 < v30 )
      v30 = MAP_WIDTH;
    v28 = gpCurAIHero->y + 25;
    if ( MAP_HEIGHT - 1 < v28 )
      v28 = MAP_HEIGHT;
    for ( i = 0; ; ++i )
    {
      if ( i < 2 )
      {
        if ( gpCurAIHero->flags & 0x80 && !i )
          continue;
        for ( col = v36; col < v30; ++col )
        {
          v33 = -1;
          ++v16;
          if ( v29 <= v16 )
            v16 = 0;
          for ( row = v31; row < v28; ++row )
          {
            ++v33;
            if ( v29 <= v33 )
              v33 = 0;
            if ( *(&gpSearchArray->field_2414[col].field_4 + 9 * row * MAP_WIDTH) & 1 )
            {
              if ( gpCurAIHero->flags & 0x80
                || ((v7 = abs(col - gpCurAIHero->x), v35 = abs(row - gpCurAIHero->y) + v7, i)
                 || v35 <= 5
                 || *(_DWORD *)&gpCurAIHero->field_21 == col && *(_DWORD *)&gpCurAIHero->field_25 == row
                 || v35 < 16
                 && (advManager::GetCell(gpAdvManager, col, row)->objType == 170
                  || advManager::GetCell(gpAdvManager, col, row)->objType == 163
                  && gpGame->castles[(unsigned __int8)((unsigned __int8)(advManager::GetCell(gpAdvManager, col, row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx != giCurPlayer))
                && (i != 1
                 || v35 > 5
                 && (*(_DWORD *)&gpCurAIHero->field_21 != col || *(_DWORD *)&gpCurAIHero->field_25 != row)
                 && (v35 >= 16
                  || advManager::GetCell(gpAdvManager, col, row)->objType != 170
                  && (advManager::GetCell(gpAdvManager, col, row)->objType != 163
                   || gpGame->castles[(unsigned __int8)((unsigned __int8)(advManager::GetCell(gpAdvManager, col, row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx == giCurPlayer))) )
              {
                v15 = advManager::GetCell(gpAdvManager, col, row);
                if ( *(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * row * MAP_WIDTH) <= a4 )
                {
                  v32 = v15->objType & 0x80
                     || v15->objType == 28 && gpCurAIHero->flags & 0x80
                     || !(col % v29)
                     && !(row % v29)
                     && (gpCurAIHero->flags & 0x80 && !giGroundToTerrain[v15->groundIndex]
                      || !(gpCurAIHero->flags & 0x80) && giGroundToTerrain[v15->groundIndex])
                     || LOBYTE(gpCurPlayer->field_41) == col && HIBYTE(gpCurPlayer->field_41) == row;
                }
                else if ( *(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * row * MAP_WIDTH) <= a5a )
                {
                  v32 = v15->objType == 163
                     || v15->objType == 170
                     || v15->objType == 171 && !(gpCurAIHero->flags & 0x80);
                }
                else
                {
                  v32 = 0;
                }
                if ( v32 )
                {
                  if ( LOBYTE(gpCurAIHero->field_29) != 255 )
                  {
                    v8 = abs(row - HIBYTE(gpCurAIHero->field_29));
                    v20 = abs(col - LOBYTE(gpCurAIHero->field_29)) + v8;
                    if ( SLOBYTE(gpCurAIHero->field_2B) < v20 )
                      v32 = 0;
                  }
                }
                if ( v32 )
                {
                  for ( j = 0; gpCurPlayer->numHeroes > j; ++j )
                  {
                    if ( v15->objType != 163
                      && v15->objType != 170
                      && gpCurPlayer->heroesOwned[j] != gpCurAIHero->idx
                      && *(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[j]].field_21 == col
                      && *(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[j]].field_25 == row )
                    {
                      v18 = -2000;
                      goto LABEL_107;
                    }
                  }
                  CheckDoMain(0, 0);
                  v25 = gpCurAIHero->mobility
                      - *(__int16 *)((char *)&gpSearchArray->field_2414[col].field_2 + 9 * row * MAP_WIDTH);
                  if ( v25 < 0 )
                    v25 = 0;
                  v9 = philAI::RVOfPosition(
                         (int)v13,
                         col,
                         row,
                         ((unsigned __int8)*(&gpSearchArray->field_2414[col].field_4 + 9 * row * MAP_WIDTH) >> 2) & 1,
                         *((_BYTE *)&gpSearchArray->field_2414[col].field_5 + 9 * row * MAP_WIDTH),
                         *((_BYTE *)&gpSearchArray->field_2414[col].field_5 + 9 * row * MAP_WIDTH + 1),
                         ((unsigned __int8)*(&gpSearchArray->field_2414[col].field_4 + 9 * row * MAP_WIDTH) >> 3) & 1,
                         *((_BYTE *)&gpSearchArray->field_2414[col].field_5 + 9 * row * MAP_WIDTH + 2),
                         *((_BYTE *)&gpSearchArray->field_2414[col].field_5 + 9 * row * MAP_WIDTH + 3),
                         2);
                  v18 = v9 * (Random(1, 50) + 75) / 100;
                }
                else
                {
                  v18 = -100;
                }
                if ( *a2 == col && *a3 == row )
                  v18 = (unsigned __int64)(signed __int64)((double)v18 * 1.5) + 20;
LABEL_107:
                if ( v14 >= v18 )
                {
                  if ( v14 == v18 )
                  {
                    if ( !v18 )
                    {
                      if ( !(advManager::GetCell(gpAdvManager, col, row)->objType & 0x80) )
                      {
                        if ( advManager::GetCell(gpAdvManager, v27, v24)->objType & 0x80
                          || (v10 = abs(v27 - gpCurAIHero->x),
                              v11 = abs(v24 - gpCurAIHero->y) + v10,
                              v12 = abs(col - gpCurAIHero->x),
                              v11 < abs(row - gpCurAIHero->y) + v12) )
                        {
                          v27 = col;
                          v24 = row;
                        }
                      }
                    }
                  }
                }
                else
                {
                  v27 = col;
                  v24 = row;
                  v14 = v18;
                }
              }
            }
          }
        }
        if ( i || v14 <= 150 )
          continue;
      }
      break;
    }
    if ( v14 < 75 && (dword_5306E0 || dword_532CE8) && !dword_532CEC && giCurTurn > 3 )
    {
      if ( (dword_532CE8 || giBuildShipyard[giCurPlayer] < 0 || giBuildShipyard[giCurPlayer] == dword_5305CC)
        && gpCurPlayer->resources[0] + 6 * gpCurPlayer->field_E7[0] >= ((unsigned int)dword_532CE8 < 1 ? 30 : 10) )
      {
        if ( !dword_532CE8 )
          giBuildShipyard[giCurPlayer] = dword_5305CC;
        giBuildBoat[giCurPlayer] = dword_5305CC;
        giBuildBoatStuffTurn[giCurPlayer] = giCurTurn;
        v14 = 123;
        v27 = gpGame->castles[dword_5305CC].x;
        v24 = gpGame->castles[dword_5305CC].y;
        if ( gpCurAIHero->x == v27 && gpCurAIHero->y == v24 )
          gpCurAIHero->remainingMobility = 0;
      }
      philAI::CheckBuyStuff(v13);
    }
    *a2 = v27;
    *a3 = v24;
    if ( LOBYTE(gpCurAIHero->field_29) != 255 && v14 <= 0 )
    {
      *a2 = LOBYTE(gpCurAIHero->field_29);
      *a3 = HIBYTE(gpCurAIHero->field_29);
    }
    LogInt(
      (int)"Hero, Best RV target XY  current XY",
      gpCurAIHero->ownerIdx,
      v14,
      *a2,
      *a3,
      gpCurAIHero->x,
      gpCurAIHero->y,
      -999);
    LogStr("\n\n****");
    result = v14;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 5305CC: using guessed type int dword_5305CC;
// 5306E0: using guessed type int dword_5306E0;
// 532C54: using guessed type int giCurTurn;
// 532CE8: using guessed type int dword_532CE8;
// 532CEC: using guessed type int dword_532CEC;

//----- (004AF410) --------------------------------------------------------
void __stdcall philAI::ProbableOutcomeOfBattle(int a1, int a2, __int64 a3, int a4, int a5, int a6, int a7, int a8, int a9, int *a10, int *a11, int *a12, int *a13)
{
  float v13; // ST94_4@29
  float v14; // [sp+74h] [bp-40h]@55
  float v15; // [sp+78h] [bp-3Ch]@3
  float v16; // [sp+7Ch] [bp-38h]@3
  float v17; // [sp+80h] [bp-34h]@8
  float v18; // [sp+8Ch] [bp-28h]@30
  signed int i; // [sp+90h] [bp-24h]@34
  signed int j; // [sp+90h] [bp-24h]@45
  float v21; // [sp+9Ch] [bp-18h]@7
  int v22; // [sp+A0h] [bp-14h]@1
  float v23; // [sp+A8h] [bp-Ch]@1
  float v24; // [sp+ACh] [bp-8h]@1
  int v25; // [sp+B0h] [bp-4h]@1

  v22 = 0;
  v25 = 0;
  v23 = (double)philAI::FightValueOfStack((armyGroup *)a1, (hero *)a2, 1, 0, 0, a5);
  v24 = (double)philAI::FightValueOfStack((armyGroup *)a3, HIDWORD(a3), 1, a5, a6, 0);
  if ( a4 )
    v24 = (double)philAI::FightValueOfStack((armyGroup *)a4, 0, 1, 0, 0, 0) + v24;
  v15 = (double)philAI::FightValueOfStack((armyGroup *)a1, (hero *)a2, 0, 0, 0, 0);
  v16 = (double)philAI::FightValueOfStack((armyGroup *)a3, HIDWORD(a3), 0, 0, 0, 0);
  if ( a4 )
    v16 = (double)philAI::FightValueOfStack((armyGroup *)a4, 0, 0, 0, 0, 0) + v16;
  if ( a5 )
    v24 = v24 * 1.11;
  v21 = v24;
  if ( a7 == -1 )
  {
    v17 = ((double)gpGame->difficulty * 0.15 + 0.7) * v23;
    if ( !gpCurPlayer->personality )
      v17 = v17 * 1.08;
  }
  else
  {
    v17 = v23;
    if ( gbHumanPlayer[a7] )
    {
      v21 = v24 * 1.14;
    }
    else if ( !gpCurPlayer->personality )
    {
      v17 = v23 * 1.08;
    }
  }
  if ( v17 < 1.0 )
    v17 = 1.0;
  if ( v21 < 1.0 )
    v21 = 1.0;
  pow();
  pow();
  *(float *)a8 = v17 / (v21 + v17);
  if ( *(float *)a8 >= 0.08 )
  {
    if ( *(float *)a8 >= 0.12 )
    {
      if ( *(float *)a8 >= 0.2 )
      {
        if ( *(float *)a8 >= 0.3 )
        {
          if ( *(float *)a8 < 0.4 )
            *(float *)a8 = *(float *)a8 - 0.02;
        }
        else
        {
          *(float *)a8 = *(float *)a8 - 0.04;
        }
      }
      else
      {
        *(float *)a8 = *(float *)a8 - 0.05;
      }
    }
    else
    {
      *(float *)a8 = *(float *)a8 - 0.07000000000000001;
    }
  }
  else
  {
    *(_DWORD *)a8 = 0;
  }
  *(_DWORD *)a9 = (signed __int64)((1.0 - *(float *)a8) * v15);
  *a10 = (signed __int64)(v16 * *(float *)a8);
  *a11 = (signed __int64)((1.0 - *(float *)a8) * v15 + (double)*(signed int *)a9 * *(float *)a8);
  *a12 = (signed __int64)((1.0 - *(float *)a8) * (double)*a10 + v16 * *(float *)a8);
  v13 = 1.33 - *(float *)&gpCurPlayer->_4_2[22];
  *a13 = (signed __int64)((double)-*a11 * v13 * v13);
  if ( a7 >= 0 )
  {
    v18 = *(float *)&gpCurPlayer->_4_2[22] + 0.66;
    if ( gbHumanPlayer[a7] )
      *a13 = (signed __int64)((double)*a12 * v18 * v18 * *(float *)&gfAttackHumanBonus + (double)*a13);
    else
      *a13 = (signed __int64)((double)*a12 * *(float *)&gfAttackComputerBonus * v18 * v18 + (double)*a13);
  }
  *a13 = (signed __int64)((double)*a13 * gpCurPlayer->field_10F);
  if ( a2 )
  {
    for ( i = 0; i < 14; ++i )
    {
      if ( (signed int)*(_BYTE *)(i + a2 + 213) >= 0 )
      {
        if ( (signed int)*(_BYTE *)(i + a2 + 213) < 37 )
          v22 += gArtifactBaseRV[*(_BYTE *)(a2 + i + 213)];
      }
    }
    if ( gpGame->mapHeader.winConditionType == 2 && *(_BYTE *)(a2 + 2) == gpGame->mapHeader.winConditionArgument )
      v22 += 50000;
    *a13 = (signed __int64)((double)*a13 - (1.0 - *(float *)a8) * (double)(v22 + 1400));
    *a13 = (signed __int64)((double)game::ExperienceValueOfStack(a3, SHIDWORD(a3))
                          * *(float *)(a2 + 232)
                          * *(float *)a8
                          * 0.8
                          + (double)*a13);
  }
  if ( HIDWORD(a3) )
  {
    for ( j = 0; j < 14; ++j )
    {
      if ( (signed int)*(_BYTE *)(j + HIDWORD(a3) + 213) >= 0 && (signed int)*(_BYTE *)(j + HIDWORD(a3) + 213) < 37 )
        v25 += gArtifactBaseRV[*(_BYTE *)(HIDWORD(a3) + j + 213)];
    }
    if ( gpGame->mapHeader.field_22 == 2 && *(_BYTE *)(HIDWORD(a3) + 2) == *(_WORD *)&gpGame->mapHeader.field_23 )
      v25 += 50000;
    if ( gbHumanPlayer[*(_BYTE *)(HIDWORD(a3) + 3)] )
      v14 = *(float *)&gfAttackHumanBonus;
    else
      v14 = *(float *)&gfAttackComputerBonus;
    *a13 = (signed __int64)((double)(v25 + 1250) * v14 * *(float *)a8 + (double)*a13);
  }
  if ( giDebugLevel >= 9 )
  {
    LogInt(
      (int)"POBA",
      (signed __int64)v17,
      (signed __int64)v21,
      (signed __int64)(*(float *)&gpCurPlayer->_4_2[22] * 100.0),
      0,
      v22,
      v25,
      (signed __int64)gpCurPlayer->field_10F);
    LogInt(
      (int)"POB",
      (signed __int64)v23,
      (signed __int64)v24,
      (signed __int64)(*(float *)a8 * 100.0),
      *a10,
      *a11,
      *a12,
      *a13);
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51D5C0: using guessed type int gfAttackHumanBonus;
// 51D5C4: using guessed type int gfAttackComputerBonus;

//----- (004AFB90) --------------------------------------------------------
double __stdcall sub_4AFB90(int a1)
{
  return 1.0;
}

//----- (004AFBB0) --------------------------------------------------------
int __stdcall philAI::ValueOfBuyingBuilding(int a1, signed int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15)
{
  double v15; // st7@112
  double v16; // st7@112
  signed int v17; // eax@112
  double v18; // st7@112
  int result; // eax@112
  char v20; // [sp+3Ch] [bp-60h]@110
  int v21; // [sp+40h] [bp-5Ch]@12
  int v22; // [sp+44h] [bp-58h]@1
  char v23; // [sp+48h] [bp-54h]@105
  int v24; // [sp+4Ch] [bp-50h]@98
  char v25; // [sp+50h] [bp-4Ch]@105
  char v26; // [sp+54h] [bp-48h]@105
  int v27; // [sp+58h] [bp-44h]@86
  char v28; // [sp+5Ch] [bp-40h]@105
  int i; // [sp+60h] [bp-3Ch]@1
  char v30; // [sp+64h] [bp-38h]@105
  int v31; // [sp+68h] [bp-34h]@1
  char v32; // [sp+6Ch] [bp-30h]@112
  int v33; // [sp+88h] [bp-14h]@1
  float v34; // [sp+8Ch] [bp-10h]@105
  int v35; // [sp+90h] [bp-Ch]@96
  int v36; // [sp+94h] [bp-8h]@6
  float v37; // [sp+98h] [bp-4h]@14

  v31 = *(_BYTE *)(a1 + 3);
  v33 = 0;
  v22 = -1;
  for ( i = 19; i < 30; ++i )
  {
    if ( (1 << i) & *(_DWORD *)(a1 + 24) )
    {
      ++v33;
      v22 = i;
    }
  }
  v36 = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( (signed int)*(_WORD *)(a1 + 2 * i + 13) > 0 )
      ++v36;
  }
  if ( a2 )
    v21 = 1;
  else
    v21 = *(_BYTE *)(a1 + 28) + 1;
  v37 = (double)GetBuildingBaseResourceValue(v31, a2, v21);
  if ( a2 >= 25 && a2 <= 29 )
    v37 = v37 - (double)GetBuildingBaseResourceValue(v31, a2 - 5, 1);
  if ( a2 == 30 )
    v37 = v37 - (double)GetBuildingBaseResourceValue(v31, 29, 1);
  if ( !a2 && (signed int)*(_BYTE *)(a1 + 28) > 1 )
    v37 = v37 - (double)GetBuildingBaseResourceValue(v31, 0, *(_BYTE *)(a1 + 28));
  switch ( a2 )
  {
    case 6:
      if ( *(_BYTE *)(a1 + 55) )
        v37 = -99.0;
      goto LABEL_105;
    case 0:
      if ( *(_BYTE *)(a1 + 3) && *(_BYTE *)(a1 + 3) != 1 )
      {
        if ( *(_BYTE *)(a1 + 28) )
        {
          if ( (signed int)*(_BYTE *)(a1 + 28) >= 4 && giCurTurn < 35
            || (signed int)*(_BYTE *)(a1 + 28) >= 3 && giCurTurn < 25
            || (signed int)*(_BYTE *)(a1 + 28) >= 2 && giCurTurn < 15 )
            v37 = v37 * 0.55;
        }
        else
        {
          v37 = v37 * 1.2;
        }
      }
      else if ( ((signed int)*(_BYTE *)(a1 + 28) < 4 || giCurTurn >= 40)
  && ((signed int)*(_BYTE *)(a1 + 28) < 3 || giCurTurn >= 30)
  && ((signed int)*(_BYTE *)(a1 + 28) < 2 || giCurTurn >= 20) )
      {
        v37 = v37 * 0.65;
      }
      else
      {
        v37 = v37 * 0.4;
      }
      goto LABEL_105;
    case 1:
      if ( *(_BYTE *)(a1 + 3) == 5 && *(_BYTE *)(a1 + 26) & 0x20 )
      {
        v37 = 1500.0;
      }
      else if ( giCurTurn < 21 )
      {
        v37 = 0.0;
      }
      goto LABEL_105;
    case 7:
      if ( giCurTurn < 3 && !(*(_BYTE *)(a1 + 26) & 0x20) )
        v37 = 0.0;
      goto LABEL_105;
    case 10:
      if ( giCurTurn < 21 )
        v37 = 0.0;
      goto LABEL_105;
    case 11:
      if ( gpGame->day < 6 )
        v37 = 0.0;
      goto LABEL_105;
    case 8:
    case 9:
    case 12:
    case 15:
      goto LABEL_63;
    case 13:
      if ( !*(_BYTE *)(a1 + 3) || *(_BYTE *)(a1 + 3) == 2 || *(_BYTE *)(a1 + 3) == 1 || *(_BYTE *)(a1 + 3) == 5 )
        goto LABEL_63;
      goto LABEL_105;
    case 3:
      v37 = 0.0;
      goto LABEL_105;
    case 4:
      v37 = (*(float *)&gpCurPlayer->_4_2[18] + 0.66) * v37;
      v37 = (*(float *)&gpCurPlayer->_4_2[22] * 2.0 + 0.33) * v37;
      v37 = ((double)v33 * 0.33 + 0.66) * v37;
      if ( (*(_BYTE *)(a1 + 3) || !(*(_BYTE *)(a1 + 26) & 0x10)) && gpGame->day < 6 )
        v37 = 0.0;
      goto LABEL_105;
    case 2:
      if ( *(_BYTE *)(a1 + 3) != 5 )
      {
        if ( !*(_BYTE *)(a1 + 3) && *(_BYTE *)(a1 + 26) & 0x20 || *(_BYTE *)(a1 + 3) == 2 && *(_BYTE *)(a1 + 26) & 0x20 )
        {
          v37 = 1000.0;
        }
        else
        {
LABEL_63:
          if ( giCurTurn < 16 )
            v37 = 0.0;
        }
      }
      goto LABEL_105;
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      if ( v36 == 5 )
      {
        v27 = 0;
        for ( i = 0; i < 5; ++i )
        {
          if ( LOBYTE((&gTownObjNames[3 * *(_BYTE *)(a1 + 3) + 27])[a2 + 1]) == *(_BYTE *)(i + a1 + 8) )
            v27 = 1;
        }
        if ( !v27 )
          goto LABEL_105;
      }
      v37 = (*(float *)&gpCurPlayer->_4_2[18] + 0.66) * v37;
      v37 = (*(float *)&gpCurPlayer->_4_2[22] * 2.0 + 0.33) * v37;
      v37 = (1.0 - (double)playerData::BuildingsOwned((int)gpCurPlayer, v31, a2, 0) * 0.05) * v37;
      if ( a2 - 19 < v22 )
        v37 = (1.66 - (double)v33 * 0.33) * v37;
      if ( *(_BYTE *)(a1 + 24) & 0x10 )
        v37 = v37 * 1.1;
      v35 = 0;
      break;
    case 14:
      goto LABEL_105;
  }
  while ( v35 < 12 )
  {
    v24 = gDwellingType[*(_BYTE *)(a1 + 3)][v35];
    if ( (1 << (v35 + 19)) & *(_DWORD *)(a1 + 24)
      && (signed int)*(_WORD *)(a1 + 2 * v35 + 30) > 0
      && (double)gMonsterDatabase[LOBYTE((&gTownObjNames[3 * *(_BYTE *)(a1 + 3) + 27])[a2 + 1])].fight_value_aux < (double)gMonsterDatabase[v24].fight_value_aux * 1.2 )
    {
      v37 = 0.0;
      break;
    }
    ++v35;
  }
LABEL_105:
  philAI::LikelihoodOfEnemyAttacking(a1, 0, (int)&v30, (int)&v28, (int)&v26, (int)&v25, (int)&v23, (int)&v34);
  v37 = (1.0 - v34 * 3.0) * v37;
  if ( *(_BYTE *)(a1 + 57) != giCurPlayer )
    v37 = v37 * 0.85;
  if ( v37 < 0.0 )
    v37 = 0.0;
  if ( a2 )
    v20 = 0;
  else
    v20 = *(_BYTE *)(a1 + 28);
  GetBuildingCost(v31, a2, &v32, v20);
  v15 = philAI::FutureDeflator((int)&v32);
  v16 = v15 * v37;
  v37 = v16;
  *(_DWORD *)a3 = (signed __int64)v16;
  v17 = philAI::RVConversion((int)&v32);
  v18 = v37 / (double)v17;
  result = a4;
  *(float *)a4 = v18;
  return result;
}
// 4F3D10: using guessed type char *gTownObjNames[32];
// 532C54: using guessed type int giCurTurn;

//----- (004B03D0) --------------------------------------------------------
int __thiscall philAI::GetBestBuilding(void *this, int a2, int a3, int a4)
{
  double v4; // st7@9
  double v5; // ST18_8@12
  double v6; // ST10_8@12
  char *v7; // eax@12
  int result; // eax@14
  int v9; // [sp+10h] [bp-34h]@0
  int v10; // [sp+14h] [bp-30h]@0
  int v11; // [sp+18h] [bp-2Ch]@0
  int v12; // [sp+1Ch] [bp-28h]@0
  int v13; // [sp+20h] [bp-24h]@0
  int v14; // [sp+24h] [bp-20h]@1
  int v15; // [sp+28h] [bp-1Ch]@7
  int v16; // [sp+2Ch] [bp-18h]@7
  float v17; // [sp+30h] [bp-14h]@1
  signed int building; // [sp+34h] [bp-10h]@1
  int v19; // [sp+38h] [bp-Ch]@7
  int v20; // [sp+3Ch] [bp-8h]@1
  int v21; // [sp+40h] [bp-4h]@1

  v14 = (int)this;
  v21 = -1027211264;
  v17 = -99.0;
  v20 = -1;
  for ( building = 0; building < 32; ++building )
  {
    if ( (!((1 << building) & *(_DWORD *)(a2 + 24)) || !building && (signed int)*(_BYTE *)(a2 + 28) < 5)
      && CanBuild((unsigned int *)a2, building) )
    {
      philAI::ValueOfBuyingBuilding(
        a2,
        building,
        (int)&v15,
        (int)&v19,
        v9,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        SLODWORD(v17),
        building,
        v19);
      if ( gpCurPlayer->personality == 1 )
      {
        v13 = v15;
        v15 = (signed __int64)((double)v15 * 1.3);
      }
      v12 = Random(1, 5) + 95;
      v4 = (double)v12 * *(float *)&v19 / 100.0;
      *(float *)&v16 = v4;
      if ( v4 > v17 )
      {
        v20 = building;
        v21 = v19;
        v17 = *(float *)&v16;
      }
      if ( giDebugLevel >= 5 )
      {
        v5 = *(float *)&v16;
        v6 = *(float *)&v19;
        v7 = GetBuildingName(*(_BYTE *)(a2 + 3), building);
        sprintf(
          gText,
          "Town:%2d  Building: % 18s   Raw BC = %8.2f,  RandBC = %8.2f.",
          *(_BYTE *)a2,
          v7,
          *(_QWORD *)&v6,
          *(_QWORD *)&v5);
        LogStr(gText);
      }
    }
  }
  *(_DWORD *)a3 = a2;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = v20;
  result = a4;
  *(_DWORD *)a4 = v21;
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;

//----- (004B0560) --------------------------------------------------------
int __stdcall philAI::ValueOfBuyingCreature(int a1, int a2, int a3, int a4, int a5)
{
  double v5; // st7@21
  double v6; // st7@21
  signed __int64 v7; // qax@21
  int result; // eax@21
  signed int j; // [sp+40h] [bp-50h]@14
  signed int i; // [sp+44h] [bp-4Ch]@5
  char *v11; // [sp+48h] [bp-48h]@2
  signed int v12; // [sp+4Ch] [bp-44h]@1
  char v13; // [sp+50h] [bp-40h]@21
  char v14; // [sp+54h] [bp-3Ch]@21
  float v15; // [sp+58h] [bp-38h]@21
  char v16; // [sp+5Ch] [bp-34h]@21
  char v17; // [sp+60h] [bp-30h]@21
  int v18; // [sp+64h] [bp-2Ch]@1
  char v19; // [sp+68h] [bp-28h]@21
  int costs; // [sp+6Ch] [bp-24h]@1
  float v21; // [sp+88h] [bp-8h]@21
  int v22; // [sp+8Ch] [bp-4h]@1

  v12 = 0;
  GetMonsterCost(a2, &costs);
  v18 = a4 * (unsigned __int64)philAI::RVConversion((int)&costs);
  v22 = (signed __int64)((double)(a4 * gMonsterDatabase[a2].fight_value) * gpCurPlayer->field_10F);
  if ( *(_BYTE *)(a1 + 23) != -1 )
  {
    v11 = (char *)&gpGame->heroes[*(_BYTE *)(a1 + 23)];
    v22 = (signed __int64)((double)v22 * 1.1);
    if ( gMonsterDatabase[a2].faction == (unsigned __int8)v11[23] )
      v22 = (signed __int64)((double)v22 * 1.1);
    if ( gMonsterDatabase[a2].creature_flags & 4 )
    {
      for ( i = 0; i < 5; ++i )
      {
        if ( v11[i + 101] != -1 )
        {
          if ( gMonsterDatabase[v11[i + 101]].creature_flags & 4 )
            ++v12;
        }
      }
      v22 = (signed __int64)((1.18 - (double)v12 * 0.06) * (double)v22);
    }
    v22 = (signed __int64)((*(float *)&gpGame->players[*(_BYTE *)(a1 + 1)]._4_2[22] + 0.66) * (double)v22);
  }
  if ( gMonsterDatabase[a2].creature_flags & 4 )
  {
    for ( j = 0; j < 5; ++j )
    {
      if ( *(_BYTE *)(j + a1 + 8) != -1 && gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].creature_flags & 4 )
        ++v12;
    }
    v22 = (signed __int64)((1.18 - (double)v12 * 0.06) * (double)v22);
  }
  philAI::LikelihoodOfEnemyAttacking(a1, 0, (int)&v19, (int)&v17, (int)&v16, (int)&v14, (int)&v13, (int)&v21);
  v5 = v21 + 0.96;
  v15 = v5;
  v22 = (signed __int64)(v5 * v15 * v15 * (double)v22);
  v6 = philAI::FutureDeflator((int)&costs);
  v7 = (signed __int64)(v6 * (double)v22);
  v22 = v7;
  *(_DWORD *)a3 = v7;
  result = a5;
  *(float *)a5 = (double)*(signed int *)a3 / (double)v18;
  return result;
}

//----- (004B0860) --------------------------------------------------------
int __thiscall philAI::GetBestCreature(void *this, int a1, int a2, int a3)
{
  double v4; // st7@34
  double v5; // ST18_8@37
  double v6; // ST10_8@37
  char *v7; // eax@37
  int result; // eax@39
  int v9; // [sp+24h] [bp-38h]@1
  int v10; // [sp+28h] [bp-34h]@30
  int v11; // [sp+2Ch] [bp-30h]@3
  int v12; // [sp+30h] [bp-2Ch]@5
  float v13; // [sp+34h] [bp-28h]@34
  float v14; // [sp+38h] [bp-24h]@1
  int creature; // [sp+3Ch] [bp-20h]@3
  int v16; // [sp+40h] [bp-1Ch]@30
  int j; // [sp+44h] [bp-18h]@5
  int v18; // [sp+48h] [bp-14h]@29
  int i; // [sp+4Ch] [bp-10h]@1
  unsigned __int64 v20; // [sp+50h] [bp-Ch]@1
  int v21; // [sp+58h] [bp-4h]@1

  v9 = (int)this;
  v20 = 4294967295i64;
  v21 = -1027211264;
  v14 = -99.0;
  for ( i = 0; i < 12; ++i )
  {
    creature = gDwellingType[*(_BYTE *)(a1 + 3)][i];
    v11 = 999999;
    if ( (1 << (i + 19)) & *(_DWORD *)(a1 + 24) && (signed int)*(_WORD *)(a1 + 2 * i + 30) > 0 )
    {
      v12 = 0;
      for ( j = 0; j < 5; ++j )
      {
        if ( *(_BYTE *)(j + a1 + 8) == -1 || *(_BYTE *)(j + a1 + 8) == creature )
          v12 = 1;
      }
      for ( j = 0; j < 5; ++j )
      {
        if ( *(_BYTE *)(j + a1 + 8) != -1 && gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].fight_value < v11 )
          v11 = gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].fight_value;
      }
      if ( gMonsterDatabase[creature].fight_value > v11 && gMonsterDatabase[creature].fight_value > 1000 )
        v12 = 1;
      if ( !i
        && *(_BYTE *)(a1 + 23) != -1
        && (*(_BYTE *)(a1 + 27) & 0x10
         || *(_BYTE *)(a1 + 26) & 0x80
         || *(_BYTE *)(a1 + 27) & 0x20
         || *(_BYTE *)(a1 + 27) & 0x40
         || *(_BYTE *)(a1 + 27) & 1) )
        v12 = 0;
      if ( v12 )
      {
        v18 = philAI::CreaturesToBuy(v9, (town *)a1, i);
        if ( v18 > 0 )
        {
          philAI::ValueOfBuyingCreature(a1, creature, (int)&v10, v18, (int)&v16);
          if ( !gpCurPlayer->personality )
            v10 = (signed __int64)((double)v10 * 1.3);
          if ( *(_BYTE *)(a1 + 2) )
            v10 *= 2;
          v4 = (double)(Random(1, 10) + 90) * *(float *)&v16 / 100.0;
          v13 = v4;
          if ( v4 > v14 )
          {
            v20 = __PAIR__(v18, i);
            v21 = v16;
            v14 = v13;
          }
          if ( giDebugLevel >= 5 )
          {
            v5 = v13;
            v6 = *(float *)&v16;
            v7 = GetMonsterName(creature);
            sprintf(
              gText,
              "Town:%2d  Creature: % 18s   Raw BC = %8.2f,  RandBC = %8.2f.",
              *(_BYTE *)a1,
              v7,
              *(_QWORD *)&v6,
              *(_QWORD *)&v5);
            LogStr(gText);
          }
        }
      }
    }
  }
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 4) = 2;
  *(_QWORD *)(a2 + 8) = v20;
  result = a3;
  *(_DWORD *)a3 = v21;
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;

//----- (004B0BA0) --------------------------------------------------------
int __thiscall philAI::CreaturesToBuy(int this, town *a2, int a3)
{
  return philAI::CreaturesToBuy(gDwellingType[a2->factionID][a3], a2->numCreaturesInDwelling[a3]);
}

//----- (004B0BF0) --------------------------------------------------------
signed int __stdcall philAI::CreaturesToBuy(int a1, int a2)
{
  signed int result; // eax@6
  signed int v3; // [sp+10h] [bp-4h]@1

  v3 = philAI::MaxBuyableCreatures(a1);
  if ( v3 > 1 )
    v3 >>= 1;
  if ( a2 < v3 )
    v3 = a2;
  if ( v3 <= 1 )
    result = 0;
  else
    result = v3;
  return result;
}

//----- (004B0C50) --------------------------------------------------------
int __stdcall philAI::MaxBuyableCreatures(int a1)
{
  signed int i; // [sp+10h] [bp-24h]@1
  int arr[7]; // [sp+14h] [bp-20h]@1
  int v4; // [sp+30h] [bp-4h]@4

  GetMonsterCost(a1, arr);
  for ( i = 0; i < 7; ++i )
  {
    if ( arr[i] )
    {
      if ( gpCurPlayer->resources[i] <= 0 )
        v4 = 0;
      else
        v4 = gpCurPlayer->resources[i] / arr[i];
    }
    else
    {
      v4 = 9999;
    }
  }
  return v4;
}
// 4B0C50: using guessed type int arr[7];

//----- (004B0CF0) --------------------------------------------------------
signed __int64 __stdcall philAI::ValueOfBuyingHero(int a1, int a2, int a3, int a4)
{
  signed __int64 result; // qax@22
  int v5; // [sp+2Ch] [bp-30h]@1
  signed int v6; // [sp+2Ch] [bp-30h]@8
  signed int v7; // [sp+2Ch] [bp-30h]@15
  signed int i; // [sp+34h] [bp-28h]@1
  bool v9; // [sp+38h] [bp-24h]@12
  signed int v10; // [sp+3Ch] [bp-20h]@1
  int v11; // [sp+40h] [bp-1Ch]@1
  int v12; // [sp+44h] [bp-18h]@1
  int v13; // [sp+48h] [bp-14h]@1
  int v14; // [sp+4Ch] [bp-10h]@1
  int v15; // [sp+50h] [bp-Ch]@1
  int v16; // [sp+54h] [bp-8h]@1
  int v17; // [sp+58h] [bp-4h]@1

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 2500;
  v10 = philAI::RVConversion((int)&v11);
  v5 = *(_DWORD *)(a2 + 57) + 2000;
  for ( i = 0; i < 14; ++i )
  {
    if ( (signed int)*(_BYTE *)(i + a2 + 213) >= 0 && (signed int)*(_BYTE *)(i + a2 + 213) < 82 )
    {
      if ( *(_BYTE *)(i + a2 + 213) != 81 )
        v5 += gArtifactBaseRV[*(_BYTE *)(i + a2 + 213)];
    }
  }
  v6 = (signed __int64)((*(float *)&gpCurPlayer->_4_2[26] + 1.0 - *(float *)&gpCurPlayer->_4_2[22])
                      * (double)(*(_DWORD *)(a2 + 57) / 2 + v5));
  v9 = *(_BYTE *)(a2 + 23) == 2 || *(_BYTE *)(a2 + 23) == 3 || *(_BYTE *)(a2 + 23) == 4 || *(_BYTE *)(a2 + 23) == 5;
  if ( *(_BYTE *)(a1 + 3) == *(_BYTE *)(a2 + 23) )
  {
    v7 = (signed __int64)((0.16 + 1.0) * (double)v6);
  }
  else if ( ((signed int)*(_BYTE *)(a1 + 28) < 2 || !v9) && ((signed int)*(_BYTE *)(a1 + 28) >= 2 || v9) )
  {
    v7 = (signed __int64)((1.0 - 0.16 / 2.0) * (double)v6);
  }
  else
  {
    v7 = (signed __int64)((0.16 / 2.0 + 1.0) * (double)v6);
  }
  result = (signed __int64)(philAI::FutureDeflator((int)&v11) * (double)v7);
  *(float *)a4 = (double)(signed int)result / (double)v10;
  *(_DWORD *)a3 = result;
  return result;
}

//----- (004B0F70) --------------------------------------------------------
int __stdcall philAI::GetBestHero(int a1, int a2, int a3)
{
  double v3; // st7@3
  int result; // eax@8
  char v5; // [sp+24h] [bp-20h]@3
  int v6; // [sp+28h] [bp-1Ch]@3
  float v7; // [sp+2Ch] [bp-18h]@3
  float v8; // [sp+30h] [bp-14h]@1
  int v9; // [sp+34h] [bp-10h]@3
  int i; // [sp+38h] [bp-Ch]@1
  int v11; // [sp+3Ch] [bp-8h]@1
  int v12; // [sp+40h] [bp-4h]@1

  v11 = -1;
  v12 = -1027211264;
  v8 = -99.0;
  for ( i = 0; i < 2; ++i )
  {
    v6 = (int)&gpGame->heroes[gpCurPlayer->heroesForPurchase[i]];
    philAI::ValueOfBuyingHero(a1, v6, (int)&v5, (int)&v9);
    v3 = ((double)Random(1, 10) + 90.0) * *(float *)&v9 / 100.0;
    v7 = v3;
    if ( v3 > v8 )
    {
      v11 = i;
      v12 = v9;
      v8 = v7;
    }
    if ( giDebugLevel >= 5 )
    {
      sprintf(gText, "Town:%2d  Hero    : % 15i   Raw BC = %8.2f,  RandBC = %8.2f.", *(_BYTE *)a1, i, *(float *)&v9, v7);
      LogStr(gText);
    }
  }
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = v11;
  *(_DWORD *)a3 = v12;
  result = 12 * *(_BYTE *)(a1 + 4) + 12 * gpGame->map.width * *(_BYTE *)(a1 + 5);
  if ( *(&gpGame->map.tiles->objType + result) == 170 )
  {
    result = a3;
    *(float *)a3 = *(float *)a3 - 200.0;
  }
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;

//----- (004B1110) --------------------------------------------------------
int __stdcall philAI::LikelihoodOfEnemyAttacking(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  *(_DWORD *)a3 = 1041865114;
  *(_DWORD *)a4 = 1058642330;
  *(_DWORD *)a5 = 3000;
  *(_DWORD *)a6 = (signed __int64)((double)*(signed int *)a5 * *(float *)a3);
  *(_DWORD *)a7 = 6;
  result = a8;
  *(float *)a8 = *(float *)a4 * *(float *)a3;
  return result;
}

//----- (004B1180) --------------------------------------------------------
int __stdcall philAI::MeanRVOfUnexploredTerritory(int a1)
{
  return 0;
}

//----- (004B11A0) --------------------------------------------------------
char *__stdcall philAI::GetGameAttentionValue(int a1)
{
  char *v1; // ST20_4@1
  char *result; // eax@1

  v1 = &gpGame->players[a1]._4_2[6];
  *(float *)v1 = (double)Random(0, 100) / 500.0 + 0.23;
  *((float *)v1 + 2) = (double)Random(0, 100) / 500.0 + 0.23;
  *((float *)v1 + 2) = (1.0 + 3.0) / 4.0 * *((float *)v1 + 2);
  *((float *)v1 + 2) = (5.0 - 1.0) / 4.0 * *((float *)v1 + 2);
  *(float *)v1 = (1.0 + 3.0) / 4.0 * *(float *)v1;
  *((float *)v1 + 2) = ((3.0 - (double)gpGame->numPlayers) * 0.15 + 1.0) * *((float *)v1 + 2);
  *(float *)v1 = ((3.0 - (double)gpGame->numPlayers) * 0.07000000000000001 + 1.0) * *(float *)v1;
  result = v1;
  *((float *)v1 + 1) = 1.0 - *((float *)v1 + 2) - *(float *)v1;
  return result;
}

//----- (004B12F0) --------------------------------------------------------
char *__stdcall philAI::GetTurnAttentionValue(int a1)
{
  char *result; // eax@10
  char *v2; // [sp+10h] [bp-8h]@1
  float v3; // [sp+14h] [bp-4h]@2

  v2 = &gpGame->players[a1]._4_2[6];
  *(_DWORD *)&gpGame->players[a1]._4_2[6] = 1053609165;
  *((_DWORD *)v2 + 2) = 1050253722;
  *((_DWORD *)v2 + 1) = 1050253722;
  *((_DWORD *)v2 + 3) = *(_DWORD *)v2;
  *((_DWORD *)v2 + 5) = *((_DWORD *)v2 + 2);
  *((_DWORD *)v2 + 4) = *((_DWORD *)v2 + 1);
  if ( giCurTurn >= 5 )
  {
    if ( giCurTurn >= 10 )
    {
      if ( giCurTurn >= 20 )
      {
        if ( giCurTurn >= 30 )
          v3 = 0.80000001;
        else
          v3 = 1.0;
      }
      else
      {
        v3 = 1.2;
      }
    }
    else
    {
      v3 = 1.4;
    }
  }
  else
  {
    v3 = 1.6;
  }
  result = v2;
  *((float *)v2 + 5) = *((float *)v2 + 5) * v3;
  return result;
}
// 532C54: using guessed type int giCurTurn;

//----- (004B13F0) --------------------------------------------------------
signed __int64 __stdcall philAI::RVConversion(int a1)
{
  return (signed __int64)((double)*(signed int *)(a1 + 20) * flt_53072C
                        + (double)*(signed int *)(a1 + 4) * flt_53071C
                        + (double)*(signed int *)(a1 + 24) * flt_530730
                        + (double)*(signed int *)(a1 + 8) * flt_530720
                        + (double)*(signed int *)(a1 + 12) * flt_530724
                        + (double)*(signed int *)(a1 + 16) * flt_530728
                        + (double)*(signed int *)a1 * gafAITurnCostResource[0]);
}
// 53071C: using guessed type float flt_53071C;
// 530720: using guessed type float flt_530720;
// 530724: using guessed type float flt_530724;
// 530728: using guessed type float flt_530728;
// 53072C: using guessed type float flt_53072C;
// 530730: using guessed type float flt_530730;

//----- (004B14A0) --------------------------------------------------------
double __stdcall philAI::TurnsToBuy(int a1)
{
  double v1; // st7@7
  float v3; // [sp+14h] [bp-Ch]@1
  signed int i; // [sp+18h] [bp-8h]@1
  float v5; // [sp+1Ch] [bp-4h]@5

  v3 = 0.0;
  for ( i = 0; i < 7; ++i )
  {
    if ( gpCurPlayer->resources[i] < *(_DWORD *)(a1 + 4 * i) )
    {
      if ( gpCurPlayer->field_E7[i] <= 0 )
        v5 = 99.0;
      else
        v5 = (double)((*(_DWORD *)(a1 + 4 * i) - gpCurPlayer->resources[i]) / gpCurPlayer->field_E7[i] + 1);
      v1 = v5;
      if ( v3 >= (double)v5 )
        v1 = v3;
      v3 = v1;
    }
  }
  return v3;
}

//----- (004B1570) --------------------------------------------------------
int __thiscall philAI::RVOfPosition(int col, int a2, int col_4, int arg8, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // eax@4
  int v11; // eax@9
  int v12; // eax@14
  int result; // eax@28
  int v14; // [sp+20h] [bp-B4h]@1
  wchar_t v15[2]; // [sp+24h] [bp-B0h]@63
  char prefix; // [sp+28h] [bp-ACh]@65
  int v17; // [sp+8Ch] [bp-48h]@61
  int v18; // [sp+94h] [bp-40h]@1
  int v19; // [sp+98h] [bp-3Ch]@15
  int v20; // [sp+9Ch] [bp-38h]@3
  int v21; // [sp+A0h] [bp-34h]@1
  int v22; // [sp+A4h] [bp-30h]@4
  int v23; // [sp+A8h] [bp-2Ch]@3
  int v24; // [sp+ACh] [bp-28h]@1
  int v25; // [sp+B0h] [bp-24h]@1
  int v26; // [sp+B4h] [bp-20h]@1
  int v27; // [sp+B8h] [bp-1Ch]@8
  int v28; // [sp+BCh] [bp-18h]@1
  int v29; // [sp+C0h] [bp-14h]@1
  int v30; // [sp+C4h] [bp-10h]@1
  int a4; // [sp+C8h] [bp-Ch]@13
  float v32; // [sp+CCh] [bp-8h]@41
  int a3; // [sp+D0h] [bp-4h]@13
  int v34; // [sp+100h] [bp+2Ch]@0

  v14 = col;
  v24 = 0;
  v18 = 100;
  v29 = 100;
  v21 = advManager::GetCell(gpAdvManager, a2, col_4)->objType;
  v26 = v21 & 0x7F;
  v28 = 100;
  v25 = 100;
  v30 = 100;
  if ( abs(a2 - gpCurAIHero->x) > 1 || abs(col_4 - gpCurAIHero->y) > 1 )
  {
    v23 = philAI::StrategicValueOfPosition(v14, gpCurAIHero->x, gpCurAIHero->y, 0, 1, &v22, 0);
    v10 = philAI::StrategicValueOfPosition(v14, a2, col_4, 0, 1, &v18, v34);
    v20 = v10 - v23;
  }
  else
  {
    v23 = 0;
    v20 = 0;
  }
  if ( v26 == 43 && v20 < 0 )
    v20 = 0;
  v27 = 0;
  if ( arg8 )
  {
    v11 = philAI::ValueOfEventAtPosition((void *)v14, __PAIR__(a6, a5), 1, (int)&v25);
    v27 += v11;
  }
  if ( a7 )
  {
    v24 = philAI::StrategicValueOfPosition(v14, a8, a9, 1, 1, &v29, 0);
    if ( v24 < 0 )
      v27 += v24;
  }
  if ( advManager::FindAdjacentMonster(gpAdvManager, a2, col_4, (int)&a3, (int)&a4, -1, -1) )
  {
    v12 = (int)advManager::GetCell(gpAdvManager, a2, col_4);
    if ( StopOnTrigger(v12) )
    {
      v19 = philAI::ValueOfEventAtPosition((void *)v14, __PAIR__(a4, a3), 1, (int)&v30);
      if ( v19 < 0 )
        v27 += v19;
      if ( v25 == 100 )
        v25 = v30;
      else
        v25 = v30 * v25 / 100;
    }
  }
  if ( v21 & 0x80 || LOBYTE(gpCurPlayer->field_41) == a2 && HIBYTE(gpCurPlayer->field_41) == col_4 )
    v19 = philAI::ValueOfEventAtPosition((void *)v14, __PAIR__(col_4, a2), a10, (int)&v28);
  else
    v19 = 0;
  if ( v28 < 100 )
    v20 = v28 * v20 / 100;
  if ( v18 >= 30 )
  {
    if ( v18 < 100 )
    {
      v19 = v19 * v18 / 100;
      v20 = v18 * v20 / 100;
    }
    if ( v29 >= 30 )
    {
      if ( v29 < 100 )
      {
        v19 = v19 * v29 / 100;
        v20 = v29 * v20 / 100;
      }
      if ( v25 >= 100 )
      {
        v27 += v19;
      }
      else if ( v27 <= 0 )
      {
        v27 += v25 * (v19 + v20) / 100;
      }
      else
      {
        v27 = v25 * (v19 + v27 + v20) / 100;
      }
      v32 = (double)*(__int16 *)((char *)&gpSearchArray->field_2414[a2].field_2 + 9 * MAP_WIDTH * col_4)
          / (double)gpCurAIHero->mobility;
      if ( gpCurAIHero->flags & 0x80 )
      {
        v32 = v32 * 0.5 + 0.5;
      }
      else if ( v32 <= 5.0 )
      {
        if ( v32 <= 4.0 )
        {
          if ( v32 <= 3.0 )
          {
            if ( v32 <= 2.0 )
            {
              if ( v32 <= 1.5 )
              {
                if ( v32 > 1.0 )
                  v32 = v32 * 1.2;
              }
              else
              {
                v32 = v32 * 1.4;
              }
            }
            else
            {
              v32 = v32 * 1.7;
            }
          }
          else
          {
            v32 = v32 * 2.0;
          }
        }
        else
        {
          v32 = v32 * 2.5;
        }
      }
      else
      {
        v32 = v32 * 3.0;
      }
      v27 = (signed __int64)((double)v27 / (v32 + 0.2));
      v20 = (signed __int64)((double)(2 * v20) / (v32 + 1.0));
      if ( v25 == 100 )
        v27 += v20;
      if ( gpCurAIHero->flags & 0x80 && v21 == 28 )
        v27 += 40;
      if ( giDebugLevel > 4 )
      {
        v17 = v21 & 0x7F;
        if ( v17 <= 0 || v17 >= 119 )
          *(_DWORD *)v15 = L" ";
        else
          *(_DWORD *)v15 = (&adventureMapLocations)[4 * v17];
        sprintf(&prefix, "FUN U :% 15s", *(_DWORD *)v15);
        LogInt((int)&prefix, a2, col_4, v27, v19, v20, 100 * v18, -999);
      }
      result = v27;
    }
    else
    {
      result = -100;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 4B1570: inconsistent function type and number of purged bytes
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F21F0: using guessed type int giDebugLevel;
// 51D76C: using guessed type wchar_t asc_51D76C[2];

//----- (004B1B60) --------------------------------------------------------
int __thiscall philAI::StrategicValueOfPosition(int a1, int a2, int a2_4, int a4, int argC, int *arg10, int a7)
{
  int v8; // ST50_4@29
  int v9; // ebx@73
  int v10; // ecx@74
  int v11; // [sp+1Ch] [bp-64h]@1
  searchArray *v12; // [sp+2Ch] [bp-54h]@15
  int v13; // [sp+30h] [bp-50h]@66
  signed int v14; // [sp+34h] [bp-4Ch]@5
  mapCell *v15; // [sp+38h] [bp-48h]@5
  mapCell *v16; // [sp+38h] [bp-48h]@34
  int v17; // [sp+3Ch] [bp-44h]@70
  int v18; // [sp+40h] [bp-40h]@73
  searchArray *this; // [sp+44h] [bp-3Ch]@16
  int v20; // [sp+48h] [bp-38h]@49
  signed int i; // [sp+4Ch] [bp-34h]@70
  signed int v22; // [sp+54h] [bp-2Ch]@5
  signed int v23; // [sp+5Ch] [bp-24h]@5
  int v24; // [sp+5Ch] [bp-24h]@87
  int row; // [sp+60h] [bp-20h]@31
  int v26; // [sp+64h] [bp-1Ch]@52
  int col; // [sp+68h] [bp-18h]@29
  int a6; // [sp+6Ch] [bp-14h]@22
  signed int a5; // [sp+70h] [bp-10h]@27
  int v30; // [sp+78h] [bp-8h]@39

  v11 = a1;
  if ( !a7 && !a4 && *((_WORD *)gaiHeroStrategicRVOfPos + a2 + MAP_WIDTH * a2_4) != -32001 )
  {
    *arg10 = *((_WORD *)gaiLiveChanceOfPos + a2 + MAP_WIDTH * a2_4);
    return *((_WORD *)gaiHeroStrategicRVOfPos + a2 + MAP_WIDTH * a2_4);
  }
  v23 = 0;
  v22 = 0;
  v14 = 0;
  v15 = advManager::GetCell(gpAdvManager, a2, a2_4);
  if ( v15->objType == 163
    && gpGame->castles[(unsigned __int8)((unsigned __int8)(v15->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx == giCurPlayer
    && gpGame->castles[(unsigned __int8)((unsigned __int8)(v15->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].buildingsBuiltFlags & 0x40 )
    v14 = 1;
  *arg10 = 100;
  if ( argC && !*((_BYTE *)gaiEnemyHeroReachable + a2 + MAP_WIDTH * a2_4) )
  {
    if ( a4 )
      return 0;
    argC = 0;
  }
  if ( dword_51D768 )
  {
    v22 = 1;
    v12 = (searchArray *)operator new(9496);
    if ( v12 )
      this = searchArray::searchArray(v12);
    else
      this = 0;
    if ( !this )
      MemError();
    searchArray::Init(this);
  }
  else
  {
    dword_51D768 = 1;
    this = &SVSearchArray;
  }
  a6 = gpCurAIHero->flags & 0x80;
  if ( a6 && advManager::GetCell(gpAdvManager, a2, a2_4)->objType == 28 )
    a6 = 0;
  if ( a4 || argC )
    a5 = 1700;
  else
    a5 = 700;
  searchArray::SeedPosition(this, a2, a2_4, 2, a5, a6, 0, 59999, gpCurAIHero->secondarySkillLevel[0], -1i64, 0, 0);
  v8 = (int)(&this->field_2414[MAP_WIDTH * a2_4] + a2);
  *(_BYTE *)(v8 + 4) &= 0xFEu;
  for ( col = 0; MAP_WIDTH > col; ++col )
  {
    for ( row = 0; MAP_HEIGHT > row; ++row )
    {
      if ( *(&this->field_2414[col].field_4 + 9 * row * MAP_WIDTH) & 1 )
      {
        v16 = advManager::GetCell(gpAdvManager, col, row);
        if ( !a4
          && v16->objType & 0x80
          && *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH) <= 700
          || argC && v16->objType == 170 )
        {
          CheckDoMain(0, 0);
          v30 = (signed __int64)((double)(25
                                        * philAI::ValueOfEventAtPosition(
                                            (void *)v11,
                                            __PAIR__(row, col),
                                            0,
                                            (int)&unk_5305C8))
                               / ((double)*(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH)
                                + 50.0));
          if ( !v14 || v16->objType != 170 || v30 >= 0 )
            v23 += v30;
        }
        if ( v16->objType == 170 )
        {
          if ( gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == -32001 )
            philAI::ValueOfEventAtPosition((void *)v11, __PAIR__(row, col), 0, (int)&unk_5305C8);
          if ( gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] != -32001
            && gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] < 100
            && !v14 )
          {
            v20 = gpGame->heroes[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].mobility;
            if ( gbHumanPlayer[gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]] )
            {
              if ( a7 + *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH) > v20 )
              {
                v26 = (signed __int64)((double)(100
                                              - (signed int)gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)])
                                     * 0.2);
              }
              else if ( a7 + *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH) > 500 )
              {
                v26 = (100
                     - gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)])
                    * (v20 - (a7 + *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH)) + 250)
                    / v20;
              }
              else
              {
                v26 = 100
                    - gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)];
              }
            }
            else
            {
              v26 = (100
                   - gaiHeroLiveChance[(unsigned __int8)((unsigned __int8)(v16->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)])
                  * (v20 + 500 - (a7 + *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH)))
                  / (v20 + 500);
            }
            *arg10 = *arg10 * (100 - v26) / 100;
          }
        }
        if ( gpCurAIHero->idx != iAlphaMale && (a2 != col || a2_4 != row) )
        {
          if ( *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH) < 1024
            && advManager::GetCell(gpAdvManager, col, row)->objType == 170
            && (unsigned __int8)((unsigned __int8)(advManager::GetCell(gpAdvManager, col, row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5) != gpCurAIHero->idx
            && gpGame->relatedToHeroForHireStatus[(unsigned __int8)((unsigned __int8)(advManager::GetCell(
                                                                                        gpAdvManager,
                                                                                        col,
                                                                                        row)->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)] == gpCurAIHero->ownerIdx )
          {
            v13 = 600 * (1024 - *(__int16 *)((char *)&this->field_2414[col].field_2 + 9 * row * MAP_WIDTH)) >> 10;
            if ( v13 > 0 )
              v23 -= v13;
          }
        }
      }
    }
  }
  v17 = (unsigned __int8)giGroundToTerrain[advManager::GetCell(gpAdvManager, a2, a2_4)->groundIndex];
  for ( i = 0; gpCurPlayer->numHeroes > i; ++i )
  {
    if ( gpCurPlayer->heroesOwned[i] != gpCurAIHero->idx )
    {
      v9 = abs(*(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]].field_25 - a2_4);
      v18 = abs(*(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]].field_21 - a2) + v9;
      if ( v18 < 9 )
      {
        v10 = advManager::GetCell(
                gpAdvManager,
                *(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]].field_21,
                *(_DWORD *)&gpGame->heroes[gpCurPlayer->heroesOwned[i]].field_25)->groundIndex;
        if ( v17 || (signed int)(unsigned __int8)giGroundToTerrain[v10] <= 0 )
        {
          if ( v17 <= 0 || giGroundToTerrain[v10] )
            v23 -= 600 * (9 - v18) / 9;
        }
      }
    }
  }
  if ( v22 )
  {
    if ( this )
    {
      searchArray::_searchArray(this);
      operator delete(this);
    }
  }
  else
  {
    dword_51D768 = 0;
  }
  if ( *arg10 < 100 )
    v23 -= 2500 * (100 - *arg10) / 100;
  v24 = (signed __int64)((double)v23 * 1.25);
  if ( v24 > 32000 )
    v24 = 32000;
  if ( !a4 && !a7 )
  {
    *((_WORD *)gaiHeroStrategicRVOfPos + a2 + MAP_WIDTH * a2_4) = v24;
    *((_WORD *)gaiLiveChanceOfPos + a2 + MAP_WIDTH * a2_4) = *arg10;
  }
  return v24;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 51D768: using guessed type int dword_51D768;
// 530734: using guessed type int iAlphaMale;
// 532C60: using guessed type __int16 gaiHeroLiveChance[];

//----- (004B2650) --------------------------------------------------------
int __stdcall philAI::ValueOfTown(town *twn)
{
  signed int i; // [sp+14h] [bp-8h]@1
  signed int v3; // [sp+18h] [bp-4h]@1
  int v4; // [sp+18h] [bp-4h]@6

  v3 = 0;
  for ( i = 0; i <= 24; ++i )
  {
    if ( (1 << i) & twn->buildingsBuiltFlags )
      v3 += GetBuildingBaseResourceValue(twn->factionID, i, twn->mageGuildLevel);
  }
  v4 = (unsigned __int64)(signed __int64)(flt_530730 * 1250.0 * 1.5 + (double)v3) + 750;
  if ( gpGame->mapHeader.field_22 == 1
    && twn->x == *(_WORD *)&gpGame->mapHeader.field_23
    && LOWORD(gpGame->mapHeader.field_2E) == twn->y )
    v4 += 50000;
  if ( gpGame->mapHeader.winConditionType == 1
    && gpGame->mapHeader.winConditionArgument == twn->x
    && gpGame->mapHeader.field_2C == twn->y )
    v4 += 50000;
  return v4;
}
// 530730: using guessed type float flt_530730;

//----- (004B27A0) --------------------------------------------------------
int __stdcall philAI::TurnCostResource(int a1)
{
  int result; // eax@4
  char *v2; // [sp+28h] [bp-48h]@1
  float v3[7]; // [sp+2Ch] [bp-44h]@6
  float v4; // [sp+48h] [bp-28h]@4
  int i; // [sp+4Ch] [bp-24h]@1
  int v6; // [sp+50h] [bp-20h]@1
  int v7[7]; // [sp+54h] [bp-1Ch]@3

  v2 = &gpGame->players[a1]._4_2[6];
  v6 = 0;
  for ( i = 0; i < 7; ++i )
  {
    v7[i] = (signed __int64)(((double)(5 * *(_DWORD *)&v2[4 * i + 52]) * 0.7 + (double)gpGame->players[a1].resources[i])
                           * (double)dword_4F1DE0[i]);
    v6 += v7[i];
  }
  result = v6 / 7;
  v4 = (double)(v6 / 7);
  for ( i = 0; i < 7; ++i )
  {
    v3[i] = (double)v7[i] / v4;
    result = i;
    gafAITurnCostResource[i] = (double)dword_4F1DE0[i] / (v3[i] / 2.0 + 0.5);
  }
  return result;
}
// 4F1DE0: using guessed type int dword_4F1DE0[];
// 4B27A0: using guessed type int var_1C[7];
// 4B27A0: using guessed type float var_44[7];

//----- (004B28F0) --------------------------------------------------------
double __stdcall philAI::TurnValueOfObelisk(int a1)
{
  double result; // st7@4
  int v2; // eax@7
  signed int v3; // [sp+24h] [bp-Ch]@1
  char *v4; // [sp+2Ch] [bp-4h]@1

  v4 = &gpGame->players[a1]._4_2[6];
  v3 = gArtifactBaseRV[gpGame->field_6397];
  if ( gpGame->mapHeader.winConditionType == 3 )
    v3 *= 2;
  if ( gpGame->field_6397 == -1 )
  {
    result = 0.0;
  }
  else
  {
    *(_DWORD *)&gpGame->players[a1]._5[0] = 48 * (v3 / 110) / gpGame->numObelisks;
    if ( gpCurPlayer->personality == 2 )
      *((_DWORD *)v4 + 20) = (signed __int64)((double)*((signed int *)v4 + 20) * 1.4);
    v2 = game::SetupPuzzlePieces(gpGame, giCurPlayer, 1);
    *((_DWORD *)v4 + 20) = (signed __int64)((1.5 - (double)abs(48 - v2) / 48.0) * (double)*((signed int *)v4 + 20));
    *((_DWORD *)v4 + 20) = (signed __int64)((*((float *)v4 + 5) + 0.66) * (double)*((signed int *)v4 + 20));
    result = (double)*((signed int *)v4 + 20);
  }
  return result;
}

//----- (004B2A50) --------------------------------------------------------
double __stdcall philAI::FutureDeflator(int a1)
{
  __int16 v1; // fps@1
  char v2; // c0@1
  float v4; // [sp+14h] [bp-4h]@1

  UNDEF(v1);
  v4 = 1.0 - philAI::TurnsToBuy(a1) * 0.15000001;
  if ( v2 )
    v4 = 0.0;
  return v4;
}

//----- (004B2AB0) --------------------------------------------------------
int __stdcall philAI::FightValueOfStack(armyGroup *arm, hero *hro, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@87
  town *v7; // eax@91
  town *castle; // [sp+74h] [bp-120h]@96
  Spell v10; // [sp+78h] [bp-11Ch]@0
  float v11; // [sp+7Ch] [bp-118h]@102
  signed int v12; // [sp+80h] [bp-114h]@107
  int v13; // [sp+80h] [bp-114h]@113
  float v14; // [sp+84h] [bp-110h]@102
  signed int v15; // [sp+88h] [bp-10Ch]@120
  int v16[46]; // [sp+8Ch] [bp-108h]@115
  Spell v17; // [sp+144h] [bp-50h]@101
  int v18; // [sp+148h] [bp-4Ch]@111
  int v19; // [sp+14Ch] [bp-48h]@87
  int v20; // [sp+150h] [bp-44h]@91
  int v21; // [sp+154h] [bp-40h]@98
  int v22; // [sp+158h] [bp-3Ch]@80
  int attack; // [sp+15Ch] [bp-38h]@80
  int numArchers; // [sp+160h] [bp-34h]@80
  float v25; // [sp+164h] [bp-30h]@1
  int v26; // [sp+168h] [bp-2Ch]@1
  float v27; // [sp+16Ch] [bp-28h]@17
  Spell i; // [sp+170h] [bp-24h]@120
  Spell spell; // [sp+174h] [bp-20h]@12
  int v30; // [sp+178h] [bp-1Ch]@1
  float v31; // [sp+17Ch] [bp-18h]@1
  float v32; // [sp+180h] [bp-14h]@1
  int fightValue; // [sp+184h] [bp-10h]@15
  town *this; // [sp+188h] [bp-Ch]@1
  int v35; // [sp+18Ch] [bp-8h]@1
  int v36; // [sp+190h] [bp-4h]@1

  v35 = 0;
  v30 = 0;
  v26 = 0;
  v31 = 0.89999998;
  v25 = 1.1;
  v32 = 0.75;
  v36 = 1036831949;
  this = 0;
  if ( a6 )
  {
    if ( hero::HasArtifact(hro, 21) || hero::HasSpell(hro, 47) || hro->secondarySkillLevel[10] )
    {
      v25 = 1.05;
      v32 = 0.94999999;
    }
    if ( hro->secondarySkillLevel[1] || hero::HasArtifact(hro, 63) )
      v31 = 1.05;
  }
  if ( a4 )
  {
    this = &gpGame->castles[a5];
    if ( !(gpGame->castles[a5].buildingsBuiltFlags & 0x40) )
      a4 = 0;
  }
  for ( spell = 0; (signed int)spell < 5; ++spell )
  {
    if ( arm->creatureTypes[spell] != -1 )
    {
      fightValue = arm->quantities[spell] * gMonsterDatabase[arm->creatureTypes[spell]].fight_value;
      if ( a3 )
      {
        if ( arm->quantities[spell] <= 500 )
        {
          if ( arm->quantities[spell] <= 300 )
          {
            if ( arm->quantities[spell] <= 180 )
            {
              if ( arm->quantities[spell] <= 140 )
              {
                if ( arm->quantities[spell] <= 100 )
                {
                  if ( arm->quantities[spell] <= 75 )
                  {
                    if ( arm->quantities[spell] <= 50 )
                    {
                      if ( arm->quantities[spell] <= 35 )
                      {
                        if ( arm->quantities[spell] <= 23 )
                        {
                          if ( arm->quantities[spell] <= 16 )
                          {
                            if ( arm->quantities[spell] <= 11 )
                            {
                              if ( arm->quantities[spell] <= 8 )
                              {
                                if ( arm->quantities[spell] <= 5 )
                                {
                                  if ( arm->quantities[spell] <= 3 )
                                  {
                                    if ( arm->quantities[spell] <= 2 )
                                    {
                                      if ( arm->quantities[spell] <= 2 )
                                        v27 = -0.57999998;
                                      else
                                        v27 = -0.40000001;
                                    }
                                    else
                                    {
                                      v27 = -0.30000001;
                                    }
                                  }
                                  else
                                  {
                                    v27 = -0.1;
                                  }
                                }
                                else
                                {
                                  v27 = 0.0;
                                }
                              }
                              else
                              {
                                v27 = 0.20999999;
                              }
                            }
                            else
                            {
                              v27 = 0.31999999;
                            }
                          }
                          else
                          {
                            v27 = 0.5;
                          }
                        }
                        else
                        {
                          v27 = 0.75;
                        }
                      }
                      else
                      {
                        v27 = 1.0;
                      }
                    }
                    else
                    {
                      v27 = 1.4;
                    }
                  }
                  else
                  {
                    v27 = 1.63;
                  }
                }
                else
                {
                  v27 = 2.0999999;
                }
              }
              else
              {
                v27 = 2.4200001;
              }
            }
            else
            {
              v27 = 3.0799999;
            }
          }
          else
          {
            v27 = 3.9000001;
          }
        }
        else
        {
          v27 = 4.4000001;
        }
        if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & SHOOTER
          || arm->creatureTypes[spell] == CREATURE_VAMPIRE
          || arm->creatureTypes[spell] == CREATURE_VAMPIRE_LORD
          || arm->creatureTypes[spell] == CREATURE_SPRITE
          || arm->creatureTypes[spell] == CREATURE_ROGUE
          || arm->creatureTypes[spell] == CREATURE_HYDRA
          || arm->creatureTypes[spell] == CREATURE_TROLL )
        {
          v27 = v27 * 0.7;
        }
        else if ( arm->creatureTypes[spell] == 14 )
        {
          v27 = v27 * 0.85;
        }
        else if ( arm->creatureTypes[spell] == 31 || arm->creatureTypes[spell] == 59 )
        {
          v27 = v27 * 1.2;
        }
        fightValue = (signed __int64)((v27 + 1.0) * (double)fightValue);
        if ( a4 )
        {
          if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & 4 )
            fightValue = (signed __int64)((double)fightValue * 1.18);
          if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & 2 )
            fightValue = (signed __int64)((double)fightValue * 0.95);
        }
        if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & 4 && hro && hro->secondarySkillLevel[1] )
          fightValue = (signed __int64)((double)fightValue * gfSSAIArcheryMod[hro->secondarySkillLevel[1]]);
        if ( a6 )
        {
          if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & 4 )
            fightValue = (signed __int64)((double)fightValue * v31);
          if ( gMonsterDatabase[arm->creatureTypes[spell]].creature_flags & 2 )
            fightValue = (signed __int64)((double)fightValue * v25);
          else
            fightValue = (signed __int64)((double)fightValue * v32);
        }
      }
      v35 += fightValue;
    }
  }
  if ( a4 )
  {
    v22 = 0;
    town::CalcNumLevelArchers(this, &numArchers, &attack);
    if ( BYTE1(this->buildingsBuiltFlags) & 1 )
      v22 += numArchers >> 1;
    if ( BYTE1(this->buildingsBuiltFlags) & 2 )
      v22 += numArchers >> 1;
    numArchers += v22;
    v26 = (signed __int64)(((double)attack * 0.1 + 1.0) * (double)(400 * numArchers));
  }
  if ( a3 && hro )
  {
    v6 = hero::Stats(hro, 0);
    v19 = hero::Stats(hro, PRIMARY_SKILL_DEFENSE) + v6 + 20;
    if ( v19 < 0 )
      v19 = 0;
    if ( v19 > 40 )
      v19 = 40;
    v35 = (signed __int64)((double)v35 * gfStatPower[v19]);
    v26 = (signed __int64)((double)v26 * gfStatPower[v19]);
    v7 = hero::GetOccupiedTown(hro);
    v20 = armyGroup::GetMorale(&hro->army, hro, v7, 0);
    if ( v20 <= 0 )
    {
      if ( v20 < 0 )
        v35 = v35 * (v20 + 24) / 24;
    }
    else
    {
      v35 = v35 * (v20 + 48) / 48;
    }
    if ( a4 )
      castle = this;
    else
      castle = 0;
    v21 = game::GetLuck(hro, 0, castle);
    if ( v21 )
      v35 = v35 * (v21 + 16) / 16;
    if ( hro->spellpoints >= 3 )
    {
      v17 = 0;
      if ( hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER) > 10 )
      {
        v14 = *(float *)&dword_4F2AC0;
        v11 = *(float *)&dword_4F2A90;
      }
      else
      {
        v14 = *(float *)&gfPhilAIDurationMod[hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER)];
        v11 = *(float *)&gfPhilAISpellPowerMod[hero::Stats(hro, PRIMARY_SKILL_SPELLPOWER)];
      }
      for ( spell = 0; (signed int)spell < 46; ++spell )
      {
        if ( hero::HasSpell(hro, spell) )
        {
          v12 = gsSpellInfo[spell].appearingChance;
          if ( gsSpellInfo[spell].attributes & 8 )
          {
            v12 = (signed __int64)((double)v12 * v14);
          }
          else if ( gsSpellInfo[spell].attributes & 1 )
          {
            v12 = (signed __int64)((double)v12 * v11);
          }
          v18 = hro->spellpoints / GetManaCost(spell, hro);
          if ( v18 > 10 )
            v18 = 10;
          v13 = (signed __int64)((double)v12 * gfSpellCastNumMod[v18]);
          if ( v13 <= 0 )
            v13 = 1;
          v16[v17++] = v13;
        }
      }
      for ( spell = 0; (signed int)spell < 7 && spell < v17; ++spell )
      {
        v15 = 0;
        for ( i = 0; v17 > i; ++i )
        {
          if ( v16[i] > v15 )
          {
            v15 = v16[i];
            v10 = i;
          }
        }
        v30 = (signed __int64)((double)v15 * gfSpellTypeNumMod[spell] + (double)v30);
        v16[v10] = 0;
      }
    }
  }
  if ( 2 * v35 >= v30 )
  {
    if ( (double)v30 <= (double)v35 * 1.5 )
    {
      if ( v35 < v30 )
        v30 = (signed __int64)((double)v35 * 0.75);
    }
    else
    {
      v30 = v35;
    }
  }
  else
  {
    v30 = (signed __int64)((double)v35 * 1.25);
  }
  if ( 2 * v35 >= v26 )
  {
    if ( (double)v26 <= (double)v35 * 1.5 )
    {
      if ( v35 < v26 )
        v26 = (signed __int64)((double)v35 * 0.9);
    }
    else
    {
      v26 = (signed __int64)((double)v35 * 1.25);
    }
  }
  else
  {
    v26 = (signed __int64)((double)v35 * 1.5);
  }
  if ( giDebugLevel == 9 )
    LogInt((int)"FV3", v35, v30, v26, 0, 0, -999, -999);
  v35 += v30;
  v35 += v26;
  return v35;
}
// 4F21F0: using guessed type int giDebugLevel;
// 4F28B0: using guessed type float gfStatPower[];
// 4F2A38: using guessed type float gfSpellCastNumMod[];
// 4F2A68: using guessed type int gfPhilAISpellPowerMod[];
// 4F2A90: using guessed type int dword_4F2A90;
// 4F2A98: using guessed type int gfPhilAIDurationMod[];
// 4F2AC0: using guessed type int dword_4F2AC0;
// 4F2AC8: using guessed type float gfSpellTypeNumMod[];
// 4F3B00: using guessed type float gfSSAIArcheryMod[];
// 4B2AB0: using guessed type int var_108[46];

//----- (004B36D0) --------------------------------------------------------
int __stdcall philAI::EvaluateOneTimeCreaturePurchase(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  signed int i; // [sp+14h] [bp-10h]@8
  int v8; // [sp+18h] [bp-Ch]@7
  signed int v9; // [sp+1Ch] [bp-8h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)a5 = 0;
  *(_DWORD *)a6 = -1;
  v9 = 999999;
  if ( a3 )
    *(_DWORD *)a4 = a2;
  else
    *(_DWORD *)a4 = philAI::MaxBuyableCreatures(a1);
  if ( *(_DWORD *)a4 > a2 )
    *(_DWORD *)a4 = a2;
  result = a4;
  if ( *(_DWORD *)a4 )
  {
    v8 = *(_DWORD *)a4 * gMonsterDatabase[a1].fight_value;
    if ( !armyGroup::CanJoin(&gpCurAIHero->army, a1) )
    {
      for ( i = 0; i < 5; ++i )
      {
        if ( gpCurAIHero->army.creatureTypes[i] == a1 )
        {
          *(_DWORD *)a6 = -1;
          i = 5;
        }
        else if ( gMonsterDatabase[i].fight_value * gpCurAIHero->army.quantities[i] < v9 )
        {
          v9 = gMonsterDatabase[i].fight_value * gpCurAIHero->army.quantities[i];
          *(_DWORD *)a6 = i;
        }
      }
    }
    if ( *(_DWORD *)a6 != -1 )
      v8 -= v9;
    *(_DWORD *)a5 = (signed __int64)((double)v8 * gpGame->players[gpCurAIHero->ownerIdx].field_10F);
    if ( !a3 )
    {
      GetMonsterCost(a1, &costTemp);
      *(_DWORD *)a5 -= *(_DWORD *)a4 * (unsigned __int64)philAI::RVConversion((int)&costTemp);
    }
    result = a5;
    if ( *(_DWORD *)a5 < 0 )
    {
      *(_DWORD *)a5 = 0;
      result = a4;
      *(_DWORD *)a4 = 0;
    }
  }
  return result;
}

//----- (004B38C0) --------------------------------------------------------
int __stdcall philAI::QuickCombat(int a1, int a2, __int64 a3, int a4, int a5, float *a6, float *a7)
{
  double v7; // st7@6
  signed int v8; // ST50_4@56
  signed int v9; // ST48_4@62
  float v11; // [sp+34h] [bp-60h]@10
  int v12; // [sp+38h] [bp-5Ch]@4
  float v13; // [sp+3Ch] [bp-58h]@7
  char v14; // [sp+40h] [bp-54h]@6
  __int16 quantity[2]; // [sp+44h] [bp-50h]@56
  char v16; // [sp+48h] [bp-4Ch]@6
  float v17; // [sp+4Ch] [bp-48h]@6
  char v18; // [sp+50h] [bp-44h]@6
  float v19; // [sp+54h] [bp-40h]@17
  char v20; // [sp+58h] [bp-3Ch]@6
  int v21; // [sp+60h] [bp-34h]@3
  Spell spell; // [sp+64h] [bp-30h]@37
  int v23; // [sp+6Ch] [bp-28h]@37
  unsigned __int64 this; // [sp+70h] [bp-24h]@65
  float v25; // [sp+78h] [bp-1Ch]@12
  int v26; // [sp+7Ch] [bp-18h]@1
  int xp; // [sp+80h] [bp-14h]@3
  float v28; // [sp+84h] [bp-10h]@6
  int v29; // [sp+88h] [bp-Ch]@3
  int v30; // [sp+8Ch] [bp-8h]@37
  char v31; // [sp+90h] [bp-4h]@6

  v26 = game::ExperienceValueOfStack(a1, a2);
  if ( a4 )
    v26 += 500;
  xp = game::ExperienceValueOfStack(a3, SHIDWORD(a3));
  v26 = (signed __int64)(((double)gpGame->difficulty * 0.12 + 1.0) * (double)v26);
  xp = (signed __int64)(((double)gpGame->difficulty * 0.12 + 1.0) * (double)xp);
  v21 = 0;
  v29 = 0;
  if ( HIDWORD(a3) )
    v12 = *(_BYTE *)(HIDWORD(a3) + 3);
  else
    v12 = -1;
  philAI::ProbableOutcomeOfBattle(
    a1,
    a2,
    a3,
    0,
    a4,
    a5,
    v12,
    (int)&v17,
    (int)&v20,
    (int *)&v18,
    (int *)&v16,
    (int *)&v14,
    (int *)&v31);
  v7 = (double)Random(0, 100) / 100.0;
  v28 = v7;
  if ( v7 >= v17 )
  {
    v13 = 1.0 - v17;
    v29 = a3;
  }
  else
  {
    v21 = 1;
    v13 = v17;
    v29 = a1;
  }
  if ( v17 >= (double)v28 )
    v11 = v17 - v28;
  else
    v11 = v28 - v17;
  v25 = v11;
  if ( v21 && v17 > 0.6 )
    v25 = (v17 + 0.65) * v25;
  if ( v25 > 1.0 )
    v25 = 1.0;
  v19 = (1.0 - v25) * (1.0 - v25);
  if ( v13 > 0.8 && v19 > 0.2 )
    v19 = v19 * v19;
  if ( v13 > 0.96 && (1.0 - v13) / 2.0 < v19 )
    v19 = (1.0 - v13) / 2.0;
  if ( v19 > 0.6 && v19 < 0.99 )
    v19 = v19 - 0.1;
  if ( v21 )
  {
    if ( a2 )
    {
      advManager::GiveExperience((hero *)a2, xp, 1);
      hero::ApplyBattleWinTemps((hero *)a2);
    }
    hero::CheckLevel((hero *)a2);
    *(_DWORD *)a7 = 1065353216;
    *a6 = v19;
  }
  else
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 53) = 0;
      hero::ApplyBattleLossTemps((hero *)a2);
    }
    if ( HIDWORD(a3) )
      hero::ApplyBattleWinTemps((hero *)a2);
    *a7 = v19;
    *(_DWORD *)a6 = 1065353216;
    if ( *a6 >= 0.99 && HIDWORD(a3) )
    {
      advManager::GiveExperience(HIDWORD(a3), xp, 1);
      hero::CheckLevel(HIDWORD(a3));
    }
  }
  v30 = 0;
  v23 = 0;
  for ( spell = 0; (signed int)spell < 5; ++spell )
  {
    if ( *(_BYTE *)(spell + a2 + 101) != -1 )
      v30 += *(_WORD *)(a2 + 2 * spell + 106);
    if ( HIDWORD(a3) )
    {
      if ( *(_BYTE *)(spell + HIDWORD(a3) + 101) != -1 )
        v23 += *(_WORD *)(HIDWORD(a3) + 2 * spell + 106);
    }
  }
  gbRetreatWin = 0;
  if ( (!v21 || HIDWORD(a3)) && Random(0, 100) < 60 )
    gbRetreatWin = 1;
  if ( !gbRetreatWin )
  {
    if ( *a6 <= 0.99 )
    {
      if ( *a7 > 0.99 )
        advManager::TransferArtifacts(SHIDWORD(a3), a2);
    }
    else
    {
      advManager::TransferArtifacts(a2, SHIDWORD(a3));
    }
  }
  philAI::DamageGroup((void *)a1, a2, SHIDWORD(a3), *a6);
  philAI::DamageGroup((void *)a3, SHIDWORD(a3), a2, *a7);
  if ( v21 && hero::GetSSLevel((hero *)a2, SECONDARY_SKILL_NECROMANCY) )
  {
    v8 = hero::GetSSLevel((hero *)a2, SECONDARY_SKILL_NECROMANCY);
    *(_DWORD *)quantity = (signed __int64)((double)v8 * (double)v23 * 0.12);
    if ( *(_DWORD *)quantity <= 0 )
      *(_DWORD *)quantity = 1;
    armyGroup::Add((armyGroup *)(a2 + 101), 47, quantity[0], -1);
  }
  else if ( HIDWORD(a3) && *a7 <= 0.999 && hero::GetSSLevel(HIDWORD(a3), SECONDARY_SKILL_NECROMANCY) )
  {
    v9 = hero::GetSSLevel(HIDWORD(a3), SECONDARY_SKILL_NECROMANCY);
    *(_DWORD *)quantity = (signed __int64)((double)v9 * (double)v30 * 0.12);
    if ( *(_DWORD *)quantity <= 0 )
      *(_DWORD *)quantity = 1;
    armyGroup::Add((armyGroup *)(HIDWORD(a3) + 101), 47, quantity[0], -1);
  }
  this = 0i64;
  if ( v21 )
  {
    this = __PAIR__(a2, HIDWORD(a3));
  }
  else if ( *a7 <= 0.999 )
  {
    this = __PAIR__(HIDWORD(a3), a2);
  }
  if ( (_DWORD)this && *(_BYTE *)(this + 127) && HIDWORD(this) )
  {
    for ( spell = 0; (signed int)spell < 65; ++spell )
    {
      if ( hero::HasSpell((hero *)this, spell)
        && !hero::HasSpell(HIDWORD(this), spell)
        && gsSpellInfo[spell].level <= *(_BYTE *)(HIDWORD(this) + 127) + 1
        && gsSpellInfo[spell].attributes & 2 )
      {
        *(_BYTE *)(spell + HIDWORD(this) + 148) = 1;
        break;
      }
    }
  }
  hero::ApplyBattleWinTemps((hero *)a2);
  if ( HIDWORD(a3) )
    hero::ApplyBattleWinTemps(HIDWORD(a3));
  if ( v21 && a4 )
    game::ClaimTown(gpGame, a5, giCurPlayer, 0);
  gbRetreatWin = 0;
  return v21;
}
// 524210: using guessed type char gbRetreatWin;

//----- (004B3FE0) --------------------------------------------------------
void __stdcall philAI::HeroInteractionAtHero(int a1, int a2, int a3, int a4)
{
  double v4; // st7@32
  float v5; // [sp+30h] [bp-44h]@33
  int this; // [sp+3Ch] [bp-38h]@9
  signed int v7; // [sp+40h] [bp-34h]@36
  PRIMARY_SKILL skill; // [sp+44h] [bp-30h]@11
  signed int skilla; // [sp+44h] [bp-30h]@17
  signed int skillb; // [sp+44h] [bp-30h]@37
  int v11; // [sp+48h] [bp-2Ch]@26
  signed int i; // [sp+4Ch] [bp-28h]@6
  float v13; // [sp+50h] [bp-24h]@32
  int v14; // [sp+54h] [bp-20h]@11
  int v15; // [sp+58h] [bp-1Ch]@25
  int v16; // [sp+5Ch] [bp-18h]@39
  float v17; // [sp+60h] [bp-14h]@25
  int v18; // [sp+64h] [bp-10h]@26
  int v19; // [sp+68h] [bp-Ch]@32
  int v20; // [sp+6Ch] [bp-8h]@32
  float v21; // [sp+70h] [bp-4h]@35

  *(_DWORD *)a4 = 0;
  if ( !a3 || *(_BYTE *)(a1 + 2) == iAlphaMale || *(_BYTE *)(a2 + 2) == iAlphaMale )
  {
    if ( !a3 )
    {
      *(_WORD *)(a1 + 4) = giCurTurn;
      *(_BYTE *)(a1 + 6) = *(_BYTE *)(a2 + 2);
      *(_WORD *)(a2 + 4) = giCurTurn;
      *(_BYTE *)(a2 + 6) = *(_BYTE *)(a1 + 2);
    }
    for ( i = 0; i < 2; ++i )
    {
      if ( i )
        this = a2;
      else
        this = a1;
      *(&v14 + i) = 0;
      for ( skill = 0; (signed int)skill < 4; ++skill )
      {
        if ( (signed int)skill < 2 || hero::HasArtifact((hero *)this, 81) )
          *(&v14 + i) += 800 * hero::Stats((hero *)this, skill);
      }
      for ( skilla = 0; skilla < 14; ++skilla )
      {
        if ( skilla != 13 && *(_BYTE *)(skilla + this + 116) )
          *(&v14 + i) += *(&dword_4F1F3C[3 * skilla] + *(_BYTE *)(this + skilla + 116));
      }
    }
    v17 = (double)v14 / (double)(v14 + v15);
    if ( v15 >= v14 )
    {
      v18 = a2;
      v11 = a1;
      v17 = 1.0 - v17;
    }
    else
    {
      v18 = a1;
      v11 = a2;
    }
    if ( a3 && *(_BYTE *)(v11 + 2) == iAlphaMale && v17 < 0.6 )
      v11 = v18;
    v19 = philAI::FightValueOfStack((armyGroup *)(v18 + 101), 0, 0, 0, 0, 0);
    v20 = philAI::FightValueOfStack((armyGroup *)(v11 + 101), 0, 0, 0, 0, 0);
    v4 = (double)v19 / (double)(v20 + v19);
    v13 = v4;
    if ( v4 > 0.69999999 )
      v5 = v13 - 0.69999999;
    else
      v5 = 0.69999999 - v13;
    v21 = v5;
    if ( v5 >= 0.15 )
    {
      v7 = (signed __int64)((double)(v20 + v19) * v21 * gpCurPlayer->field_10F);
      if ( a3 )
      {
        for ( skillb = 0; skillb < 14; ++skillb )
        {
          v16 = *(_BYTE *)(skillb + v11 + 213);
          if ( v16 != -1 && v16 != 81 )
            v7 += gArtifactBaseRV[v16];
        }
      }
      else
      {
        advManager::TransferArtifacts(v11, v18);
        if ( v13 <= 0.69999999 )
          philAI::RedistributeTroops(
            v11 + 101,
            (void *)(v18 + 101),
            1,
            1,
            v20,
            v19,
            (signed __int64)((double)(v20 + v19) * v21));
        else
          philAI::RedistributeTroops(
            v18 + 101,
            (void *)(v11 + 101),
            1,
            1,
            v19,
            v20,
            (signed __int64)((double)(v20 + v19) * v21));
        philAI::SetupRelativeHeroStrengths();
      }
      *(_DWORD *)a4 = (signed __int64)((double)v7 * 0.1);
    }
  }
}
// 4F1F3C: using guessed type int dword_4F1F3C[];
// 530734: using guessed type int iAlphaMale;
// 532C54: using guessed type int giCurTurn;

//----- (004B43E0) --------------------------------------------------------
void __stdcall philAI::HeroInteractionAtTown(int a1, signed int a2, int a3, int a4)
{
  int v4; // ebx@4
  int v5; // ebx@14
  int v6; // ebx@44
  double v7; // st7@73
  float v8; // ST54_4@73
  float v9; // [sp+28h] [bp-5Ch]@62
  signed int v10; // [sp+2Ch] [bp-58h]@39
  signed int v11; // [sp+30h] [bp-54h]@75
  float v12; // [sp+34h] [bp-50h]@71
  int v13; // [sp+3Ch] [bp-48h]@73
  int v14; // [sp+40h] [bp-44h]@111
  float v15; // [sp+44h] [bp-40h]@44
  signed int j; // [sp+48h] [bp-3Ch]@35
  int v17; // [sp+4Ch] [bp-38h]@108
  signed int n; // [sp+50h] [bp-34h]@90
  float v19; // [sp+54h] [bp-30h]@47
  int v20; // [sp+58h] [bp-2Ch]@4
  int v21; // [sp+58h] [bp-2Ch]@14
  signed int k; // [sp+58h] [bp-2Ch]@76
  signed int l; // [sp+58h] [bp-2Ch]@82
  signed int m; // [sp+58h] [bp-2Ch]@88
  int i; // [sp+5Ch] [bp-28h]@33
  int v26; // [sp+60h] [bp-24h]@44
  float v27; // [sp+64h] [bp-20h]@64
  int v28; // [sp+68h] [bp-1Ch]@44
  int v29; // [sp+70h] [bp-14h]@67
  int v30; // [sp+74h] [bp-10h]@111
  int v31; // [sp+7Ch] [bp-8h]@105
  signed int v32; // [sp+80h] [bp-4h]@44

  *(_DWORD *)a4 = 0;
  if ( a3 )
  {
    if ( *(_BYTE *)(a2 + 24) & 8 && *(_BYTE *)a2 != dword_5305CC )
    {
      v4 = abs(*(_BYTE *)(a2 + 4) - *(_DWORD *)(a1 + 25));
      v20 = abs(*(_BYTE *)(a2 + 5) - *(_DWORD *)(a1 + 29)) + v4;
      if ( dword_532CE8 )
      {
        if ( v20 < dword_5304E0 )
        {
          dword_5304E0 = v20;
          dword_5305CC = *(_BYTE *)a2;
        }
      }
      else
      {
        dword_5304E0 = v20;
        dword_5305CC = *(_BYTE *)a2;
      }
      dword_5306E0 = 1;
      dword_532CE8 = 1;
    }
    else if ( *(_BYTE *)(a2 + 24) & 0x40
  && !giGroundToTerrain[advManager::GetCell(gpAdvManager, *(_BYTE *)(a2 + 4) - 1, *(_BYTE *)(a2 + 5) + 1)->groundIndex]
  && !dword_532CE8
  && *(_BYTE *)a2 != dword_5305CC )
    {
      v5 = abs(*(_BYTE *)(a2 + 4) - *(_DWORD *)(a1 + 25));
      v21 = abs(*(_BYTE *)(a2 + 5) - *(_DWORD *)(a1 + 29)) + v5;
      if ( dword_5306E0 )
      {
        if ( v21 < dword_5304E0 )
        {
          dword_5304E0 = v21;
          dword_5305CC = *(_BYTE *)a2;
        }
      }
      else
      {
        dword_5304E0 = v21;
        dword_5305CC = *(_BYTE *)a2;
      }
      dword_5306E0 = 1;
    }
  }
  else
  {
    *(_WORD *)(a1 + 7) = giCurTurn;
    *(_BYTE *)(a1 + 9) = *(_BYTE *)a2;
    if ( !hero::HasArtifact((hero *)a1, 81) && *(_BYTE *)(a2 + 24) & 1 )
    {
      if ( gpCurPlayer->resources[6] < 500 )
      {
        *(_DWORD *)(a1 + 53) = 0;
      }
      else
      {
        GiveArtifact((hero *)a1, ARTIFACT_MAGIC_BOOK, 1, -1);
        gpCurPlayer->resources[6] -= 500;
      }
    }
    if ( *(_BYTE *)(a2 + 24) & 1
      && hero::HasArtifact((hero *)a1, 81)
      && 10 * hero::Stats((hero *)a1, PRIMARY_SKILL_KNOWLEDGE) > *(_WORD *)a1 )
      *(_DWORD *)(a1 + 53) = 0;
  }
  if ( *(_BYTE *)(a2 + 24) & 1 && (a3 || hero::HasArtifact((hero *)a1, 81)) )
  {
    *(_DWORD *)a4 += philAI::ManaRefreshValue(a1, 1);
    for ( i = 1; *(_BYTE *)(a1 + 123) + 2 >= i; ++i )
    {
      for ( j = 0; *(_BYTE *)(i + a2 + 79) > j; ++j )
      {
        if ( !hero::HasSpell((hero *)a1, *(_BYTE *)(j + 4 * i - 4 + a2 + 60)) )
        {
          if ( gsSpellInfo[*(_BYTE *)(j + 4 * i - 4 + a2 + 60)].attributes & 1 )
            v10 = hero::Stats((hero *)a1, PRIMARY_SKILL_KNOWLEDGE);
          else
            v10 = 1;
          *(_DWORD *)a4 += v10 * gsSpellInfo[*(_BYTE *)(j + 4 * i - 4 + a2 + 60)].appearingChance;
        }
      }
    }
  }
  v28 = philAI::FightValueOfStack((armyGroup *)(a1 + 101), 0, 0, 0, 0, 0);
  v32 = philAI::FightValueOfStack((armyGroup *)(a2 + 8), 0, 0, 0, 0, 0);
  v15 = (double)v32 / (double)(v32 + v28);
  v6 = hero::Stats((hero *)a1, 0);
  v26 = hero::Stats((hero *)a1, PRIMARY_SKILL_DEFENSE) + v6;
  if ( v26 > 10 )
    v26 = 10;
  if ( *(_BYTE *)(a2 + 24) & 0x40 )
    v19 = 0.54 - (double)v26 * 0.02;
  else
    v19 = 0.33 - (double)v26 * 0.01;
  if ( giCurTurn > 7 )
  {
    if ( giCurTurn > 14 )
    {
      if ( giCurTurn <= 21 )
        v19 = v19 * 0.8;
    }
    else
    {
      v19 = v19 * 0.5;
    }
  }
  else
  {
    v19 = *(float *)&dword_51D58C;
  }
  if ( *(_BYTE *)(a1 + 2) == iAlphaMale )
    v19 = v19 * 0.5;
  if ( gpGame->mapHeader.winConditionType == 1
    && gpGame->mapHeader.winConditionArgument == *(_BYTE *)(a2 + 4)
    && gpGame->mapHeader.field_2C == *(_BYTE *)(a2 + 5) )
    v19 = 0.80000001;
  if ( v19 < (double)v15 )
    v9 = v15 - v19;
  else
    v9 = v19 - v15;
  v27 = v9;
  if ( v19 * 0.15 <= v9 && v9 >= 0.08 )
  {
    v29 = 0;
    if ( v19 < (double)v15 )
      v29 = 1;
    if ( a3 )
    {
      if ( v28 >= v32 )
        v12 = 0.13;
      else
        v12 = 0.25;
      v7 = v9 + 1.0 - 0.22;
      v8 = v7;
      v13 = (signed __int64)((v7 * v8 - 1.0) * gpCurPlayer->field_10F * (double)(v32 + v28) * v12);
      if ( v13 < 0 )
        v13 = 0;
      v11 = 0;
      if ( v29 )
      {
        for ( k = 0; k < 5; ++k )
        {
          if ( (signed int)*(_WORD *)(a1 + 2 * k + 106) <= 0 )
            v11 = 1;
        }
      }
      else
      {
        for ( l = 0; l < 5; ++l )
        {
          if ( (signed int)*(_WORD *)(a2 + 2 * l + 13) <= 0 )
            v11 = 1;
        }
      }
      if ( !v11 )
      {
        for ( m = 0; m < 5; ++m )
        {
          for ( n = 0; n < 5; ++n )
          {
            if ( *(_BYTE *)(n + a1 + 101) == *(_BYTE *)(m + a2 + 8) )
            {
              v11 = 1;
              break;
            }
          }
        }
      }
      if ( !v11 )
        v13 = 0;
      *(_DWORD *)a4 += v13;
      if ( *(_BYTE *)(a2 + 2) && *(_BYTE *)(a2 + 23) == -1 )
        *(_DWORD *)a4 += 500;
    }
    else
    {
      town::GiveSpells((town *)a2, 0);
      if ( v29 )
        v27 = v9 + 0.04;
      if ( v29 )
        v31 = a2 + 8;
      else
        v31 = a1 + 101;
      if ( v29 )
        v17 = a1 + 101;
      else
        v17 = a2 + 8;
      if ( v29 )
      {
        v30 = v32;
        v14 = v28;
      }
      else
      {
        v30 = v28;
        v14 = v32;
      }
      philAI::RedistributeTroops(
        v31,
        (void *)v17,
        (unsigned int)v29 < 1,
        v29,
        v30,
        v14,
        (signed __int64)((double)(v32 + v28) * v27));
      if ( *(_BYTE *)a2 == dword_5305C4 && *(_DWORD *)(a1 + 53) <= 20 )
        *(_DWORD *)(a1 + 53) = 0;
    }
  }
}
// 51D58C: using guessed type int dword_51D58C;
// 5304E0: using guessed type int dword_5304E0;
// 5305C4: using guessed type int dword_5305C4;
// 5305CC: using guessed type int dword_5305CC;
// 5306E0: using guessed type int dword_5306E0;
// 530734: using guessed type int iAlphaMale;
// 532C54: using guessed type int giCurTurn;
// 532CE8: using guessed type int dword_532CE8;

//----- (004B4C50) --------------------------------------------------------
void __stdcall philAI::RedistributeTroops(int a1, void *a2, int a3, int a4, int a5, int a6, signed int a7)
{
  int quantity; // [sp+30h] [bp-24h]@39
  signed int v8; // [sp+34h] [bp-20h]@21
  signed int v9; // [sp+3Ch] [bp-18h]@22
  signed int v10; // [sp+40h] [bp-14h]@10
  signed int k; // [sp+44h] [bp-10h]@13
  signed int i; // [sp+48h] [bp-Ch]@4
  signed int j; // [sp+48h] [bp-Ch]@10
  signed int l; // [sp+48h] [bp-Ch]@24
  signed int v15; // [sp+4Ch] [bp-8h]@1
  signed int v16; // [sp+50h] [bp-4h]@0

  v15 = 1;
  gbTroopReload = 0;
  while ( v15 )
  {
    if ( a3 )
    {
      v16 = 0;
      for ( i = 0; i < 5; ++i )
      {
        if ( *(_BYTE *)(i + a1) != -1 )
          v16 += *(_WORD *)(a1 + 2 * i + 5);
      }
      if ( v16 <= 1 )
        break;
    }
    v10 = -1;
    for ( j = 0; j < 5; ++j )
    {
      if ( v10 == -1 )
      {
        for ( k = 0; k < 5; ++k )
        {
          if ( *(_BYTE *)(j + a1) != -1 && *((_BYTE *)a2 + k) == *(_BYTE *)(j + a1) )
          {
            v10 = j;
            break;
          }
        }
      }
    }
    if ( v10 == -1 )
    {
      v8 = -9999;
      if ( a4 )
        v9 = 1;
      else
        v9 = 9;
      for ( l = 0; l < 5; ++l )
      {
        if ( *(_BYTE *)(l + a1) != -1 )
        {
          if ( (!a4 || gMonsterDatabase[*(_BYTE *)(l + a1)].speed <= v9)
            && (a4 || gMonsterDatabase[*(_BYTE *)(l + a1)].speed >= v9) )
          {
            if ( gMonsterDatabase[*(_BYTE *)(l + a1)].speed == v9
              && *(_WORD *)(a1 + 2 * l + 5) * gMonsterDatabase[*(_BYTE *)(l + a1)].fight_value > v8 )
            {
              v8 = *(_WORD *)(a1 + 2 * l + 5) * gMonsterDatabase[*(_BYTE *)(l + a1)].fight_value;
              v10 = l;
            }
          }
          else
          {
            v9 = gMonsterDatabase[*(_BYTE *)(l + a1)].speed;
            v8 = *(_WORD *)(a1 + 2 * l + 5) * gMonsterDatabase[*(_BYTE *)(l + a1)].fight_value;
            v10 = l;
          }
        }
      }
    }
    if ( v10 == -1 )
    {
      v15 = 0;
    }
    else if ( armyGroup::CanJoin((armyGroup *)a2, *(_BYTE *)(v10 + a1)) )
    {
      quantity = (signed __int64)((double)a7 / (double)gMonsterDatabase[*(_BYTE *)(v10 + a1)].fight_value + 0.5);
      if ( quantity <= 0 )
      {
        v15 = 0;
      }
      else
      {
        if ( *(_WORD *)(a1 + 2 * v10 + 5) >= quantity )
        {
          v15 = 0;
          if ( ((double)quantity >= (double)*(_WORD *)(a1 + 2 * v10 + 5) * 0.65
             || *(_WORD *)(a1 + 2 * v10 + 5) - 1 <= quantity)
            && (double)(((signed int)*(_WORD *)(a1 + 2 * v10 + 5) - quantity)
                      * gMonsterDatabase[*(_BYTE *)(v10 + a1)].fight_value) < (double)(a5 - a7) * 0.2 )
            quantity = *(_WORD *)(a1 + 2 * v10 + 5);
        }
        else
        {
          quantity = *(_WORD *)(a1 + 2 * v10 + 5);
        }
        if ( a3 && v16 <= quantity )
        {
          quantity = v16 - 1;
          v15 = 0;
        }
        if ( (double)a7 >= (double)(quantity * gMonsterDatabase[*(_BYTE *)(v10 + a1)].fight_value) * 1.2 )
          a7 -= quantity * gMonsterDatabase[*(_BYTE *)(a1 + v10)].fight_value;
        else
          v15 = 0;
        armyGroup::Add((armyGroup *)a2, *(_BYTE *)(v10 + a1), quantity, -1);
        *(_WORD *)(a1 + 2 * v10 + 5) -= quantity;
        if ( !*(_WORD *)(a1 + 2 * v10 + 5) )
          *(_BYTE *)(v10 + a1) = -1;
      }
    }
    else
    {
      v15 = 0;
    }
  }
}
// 532C50: using guessed type int gbTroopReload;

//----- (004B5100) --------------------------------------------------------
bool __stdcall philAI::ChooseGoldOrExperience(int a1, int a2)
{
  return gpCurPlayer->resources[6] > 4000;
}

//----- (004B5140) --------------------------------------------------------
int __stdcall philAI::ChooseEvaluateBattle(int a1, int a2, __int64 a3, int a4, int a5, signed int a6, int a7, int a8)
{
  int result; // eax@5
  int v9; // [sp+18h] [bp-20h]@2
  char v10; // [sp+1Ch] [bp-1Ch]@4
  char v11; // [sp+20h] [bp-18h]@4
  char v12; // [sp+24h] [bp-14h]@4
  int v13; // [sp+28h] [bp-10h]@4
  char v14; // [sp+2Ch] [bp-Ch]@4
  float v15; // [sp+30h] [bp-8h]@4

  if ( HIDWORD(a3) )
    v9 = *(_BYTE *)(HIDWORD(a3) + 3);
  else
    v9 = -1;
  philAI::ProbableOutcomeOfBattle(
    a1,
    a2,
    a3,
    0,
    a4,
    a5,
    v9,
    (int)&v15,
    (int)&v14,
    (int *)&v12,
    (int *)&v11,
    (int *)&v10,
    &v13);
  v13 = (signed __int64)((double)a6 * v15 + (double)v13);
  if ( v13 > 0 )
  {
    *(_DWORD *)a8 = v13;
    result = a7;
    *(_DWORD *)a7 = 1;
  }
  else
  {
    *(_DWORD *)a8 = 0;
    result = a7;
    *(_DWORD *)a7 = 0;
  }
  return result;
}

//----- (004B5210) --------------------------------------------------------
bool __stdcall philAI::ChooseToFightForArtifact(int a1, char a2, int a3)
{
  char v4; // [sp+18h] [bp-24h]@7
  char v5; // [sp+1Ch] [bp-20h]@7
  char v6; // [sp+20h] [bp-1Ch]@7
  char v7; // [sp+24h] [bp-18h]@7
  int v8; // [sp+28h] [bp-14h]@1
  int i; // [sp+2Ch] [bp-10h]@1
  float v10; // [sp+30h] [bp-Ch]@7
  int v11; // [sp+34h] [bp-8h]@7
  int v12; // [sp+38h] [bp-4h]@7

  v8 = gArtifactBaseRV[a1];
  for ( i = 0; i < 5; ++i )
  {
    gpMonGroup->creatureTypes[i] = a2;
    if ( i )
      gpMonGroup->quantities[i] = 0;
    else
      gpMonGroup->quantities[0] = 1;
  }
  philAI::ProbableOutcomeOfBattle(
    (int)&gpCurAIHero->army,
    (int)gpCurAIHero,
    (unsigned int)gpMonGroup,
    0,
    0,
    0,
    -1,
    (int)&v10,
    (int)&v7,
    (int *)&v6,
    (int *)&v5,
    (int *)&v4,
    &v12);
  v11 = (signed __int64)((double)v8 * v10 + (double)v12);
  return v11 > 0;
}

//----- (004B5310) --------------------------------------------------------
signed __int64 __stdcall philAI::NetValueOfArtifact(int a1, signed int a2, int a3, signed int a4)
{
  return (signed __int64)((double)gArtifactBaseRV[a1]
                        - ((double)a4 * gafAITurnCostResource[a3]
                         + (double)a2 * flt_530730));
}
// 530730: using guessed type float flt_530730;

//----- (004B5370) --------------------------------------------------------
int __cdecl philAI::ChooseToPayRansomOnHero(unsigned int a1)
{
  return 1;
}
// 4B5370: inconsistent function type and number of purged bytes

//----- (004B5390) --------------------------------------------------------
void __stdcall philAI::BuildBuilding(signed int a1, signed int a2)
{
  int v2; // ST10_4@1
  char *v3; // eax@1
  signed int i; // [sp+10h] [bp-20h]@3
  int v5[7]; // [sp+14h] [bp-1Ch]@3

  v2 = *(_BYTE *)a1;
  v3 = GetBuildingName(*(_BYTE *)(a1 + 3), a2);
  sprintf(gText, "Player %d built %s in town %d.\n", giCurPlayer, v3, v2);
  LogStr(gText);
  if ( giDebugLevel >= 3 )
  {
    AiPrint(gText);
    DelayMilli(1500);
  }
  GetBuildingCost(*(_BYTE *)(a1 + 3), a2, v5, *(_BYTE *)(a1 + 28));
  for ( i = 0; i < 7; ++i )
    gpCurPlayer->resources[i] -= v5[i];
  town::BuildBuilding((town *)a1, a2);
  ShowStatus();
}
// 4F21F0: using guessed type int giDebugLevel;
// 4B5390: using guessed type int var_1C[7];

//----- (004B5470) --------------------------------------------------------
void __stdcall philAI::BuildHero(signed int a1, int a2)
{
  int v2; // ST30_4@3
  int v3; // ST2C_4@3
  int v4; // ST34_4@3
  mapCell *v5; // ST24_4@3
  char v6; // al@3

  sprintf(gText, "Player %d built hero in town %d.\n", giCurPlayer, *(_BYTE *)a1);
  LogStr(gText);
  if ( giDebugLevel >= 3 )
  {
    AiPrint(gText);
    DelayMilli(1500);
  }
  gpCurPlayer->resources[6] -= gHeroGoldCost;
  gpCurPlayer->heroesOwned[gpCurPlayer->numHeroes++] = gpCurPlayer->heroesForPurchase[a2];
  v2 = *(_BYTE *)(a1 + 4);
  v3 = *(_BYTE *)(a1 + 5);
  v4 = (int)&gpGame->heroes[gpCurPlayer->heroesForPurchase[a2]];
  game::SetRandomHeroArmies(gpGame, gpGame->heroes[gpCurPlayer->heroesForPurchase[a2]].idx, 1u);
  *(_WORD *)(v4 + 4) = -99;
  *(_WORD *)(v4 + 7) = -99;
  *(_BYTE *)(v4 + 3) = giCurPlayer;
  *(_DWORD *)(v4 + 25) = v2;
  *(_DWORD *)(v4 + 29) = v3;
  *(_DWORD *)(v4 + 227) = 0;
  *(_BYTE *)(v4 + 44) = 2;
  *(_DWORD *)(v4 + 53) = hero::CalcMobility((hero *)v4);
  *(_DWORD *)(v4 + 49) = *(_DWORD *)(v4 + 53);
  *(_WORD *)(v4 + 45) = *(&gpGame->map.tiles[v2].objType + 12 * v3 * gpGame->map.width);
  *(_WORD *)(v4 + 47) = (unsigned __int8)((unsigned __int8)(*(&gpGame->map.tiles[v2].field_4_1_1_isShadow_1_13_extraInfo
                                                            + 6 * v3 * gpGame->map.width) >> 8) >> -5);
  *(&gpGame->map.tiles[v2].objType + 12 * v3 * gpGame->map.width) = -86;
  v5 = &gpGame->map.tiles[v3 * gpGame->map.width] + v2;
  v5->field_4_1_1_isShadow_1_13_extraInfo = v5->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8
                                                                                        * gpCurPlayer->heroesForPurchase[a2];
  gpGame->relatedToHeroForHireStatus[*(_BYTE *)(v4 + 2)] = *(_BYTE *)(a1 + 1);
  CheckValidAvailableHeroes();
  SendMapChange(3, *(_BYTE *)(v4 + 2), *(_DWORD *)(v4 + 25), *(_DWORD *)(v4 + 29), -999, 0, 0);
  *(_BYTE *)(a1 + 23) = *(_BYTE *)(v4 + 2);
  town::GiveSpells((town *)a1, 0);
  v6 = game::GetNewHeroId(gpGame, giCurPlayer, -1, 1);
  gpCurPlayer->heroesForPurchase[a2] = v6;
  gpGame->relatedToHeroForHireStatus[gpCurPlayer->heroesForPurchase[a2]] = 64;
  bHeroBuiltThisTurn = 1;
  philAI::HeroInteractionAtTown(v4, a1, 0, (int)&unk_5305C8);
  ShowStatus();
}
// 4F1DA8: using guessed type int gHeroGoldCost;
// 4F21F0: using guessed type int giDebugLevel;
// 532C58: using guessed type int bHeroBuiltThisTurn;

//----- (004B57A0) --------------------------------------------------------
void __stdcall philAI::BuildCreature(int a1, int a2, int a3)
{
  int v3; // ST14_4@1
  char *v4; // eax@1
  double v5; // st7@14
  float v6; // ST3C_4@15
  signed int v7; // [sp+18h] [bp-34h]@3
  signed int v8; // [sp+1Ch] [bp-30h]@9
  signed int i; // [sp+20h] [bp-2Ch]@3
  signed int j; // [sp+20h] [bp-2Ch]@10
  signed int k; // [sp+20h] [bp-2Ch]@20
  float v12; // [sp+24h] [bp-28h]@12
  int creatureType; // [sp+28h] [bp-24h]@3
  int arr[7]; // [sp+2Ch] [bp-20h]@20
  float v15; // [sp+48h] [bp-4h]@9

  v3 = *(_BYTE *)a1;
  v4 = GetMonsterName(gDwellingType[*(_BYTE *)(a1 + 3)][a2]);
  sprintf(gText, "Player %d built %d %s in town %d.\n", giCurPlayer, a3, v4, v3);
  LogStr(gText);
  if ( giDebugLevel >= 3 )
  {
    AiPrint(gText);
    DelayMilli(1500);
  }
  creatureType = gDwellingType[*(_BYTE *)(a1 + 3)][a2];
  v7 = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( *(_BYTE *)(i + a1 + 8) == -1 || *(_BYTE *)(i + a1 + 8) == creatureType )
      v7 = 1;
  }
  v15 = 1000000000.0;
  v8 = -1;
  if ( !v7 )
  {
    for ( j = 0; j < 5; ++j )
    {
      v12 = (double)((signed int)*(_WORD *)(a1 + 2 * j + 13) * gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].fight_value);
      if ( gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].faction != *(_BYTE *)(a1 + 3) )
        v12 = v12 * 0.35;
      v5 = ((double)gMonsterDatabase[*(_BYTE *)(j + a1 + 8)].fight_value + 500.0) / 500.0 * v12;
      if ( v5 < v15 )
      {
        v6 = v5;
        v15 = v6;
        v8 = j;
      }
    }
    if ( v8 == -1 )
      v8 = 0;
    gpCurPlayer->resources[6] += *(_WORD *)(a1 + 2 * v8 + 13) * gMonsterDatabase[*(_BYTE *)(v8 + a1 + 8)].cost;
    *(_BYTE *)(v8 + a1 + 8) = -1;
    *(_WORD *)(a1 + 2 * v8 + 13) = 0;
  }
  GetMonsterCost(creatureType, arr);
  for ( k = 0; k < 7; ++k )
    gpCurPlayer->resources[k] -= a3 * arr[k];
  *(_WORD *)(a1 + 2 * a2 + 30) -= a3;
  armyGroup::Add((armyGroup *)(a1 + 8), creatureType, a3, -1);
  ShowStatus();
}
// 4F21F0: using guessed type int giDebugLevel;
// 4B57A0: using guessed type int arr[7];

//----- (004B5A60) --------------------------------------------------------
signed int __stdcall philAI::CanBuyBHC(int a1)
{
  signed int result; // eax@3
  int v2; // [sp+Ch] [bp-2Ch]@1
  signed int i; // [sp+14h] [bp-24h]@12
  int arr[7]; // [sp+1Ch] [bp-1Ch]@12

  v2 = *(_DWORD *)(a1 + 4);
  if ( !v2 )
  {
    if ( CanBuy(*(_DWORD *)a1, *(_DWORD *)(a1 + 8)) )
      return 1;
    return 0;
  }
  if ( v2 == 1 )
  {
    if ( gpCurPlayer->resources[6] >= gHeroGoldCost && *(_BYTE *)(*(_DWORD *)a1 + 23) == -1 && !bHeroBuiltThisTurn )
      return 1;
    return 0;
  }
  if ( v2 != 2 )
    return 0;
  if ( (signed int)*(_WORD *)(*(_DWORD *)a1 + 2 * *(_DWORD *)(a1 + 8) + 30) >= *(_DWORD *)(a1 + 12) )
  {
    GetMonsterCost(gDwellingType[*(_BYTE *)(*(_DWORD *)a1 + 3)][*(_DWORD *)(a1 + 8)], arr);
    for ( i = 0; i < 7; ++i )
    {
      if ( *(_DWORD *)(a1 + 12) * arr[i] > gpCurPlayer->resources[i] )
        return 0;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F1DA8: using guessed type int gHeroGoldCost;
// 532C58: using guessed type int bHeroBuiltThisTurn;
// 4B5A60: using guessed type int arr[7];

//----- (004B5BC0) --------------------------------------------------------
bool __stdcall philAI::CombatMonsterEvent(int a1, char a2, int a3, int a4)
{
  int v5; // [sp+10h] [bp-14h]@8
  signed int i; // [sp+14h] [bp-10h]@2
  int j; // [sp+14h] [bp-10h]@5
  signed int k; // [sp+14h] [bp-10h]@8
  char v9; // [sp+18h] [bp-Ch]@8
  char v10; // [sp+1Ch] [bp-8h]@8
  int v11; // [sp+20h] [bp-4h]@8

  memset(gpMonGroup, 0xFFu, 5u);
  memset(gpMonGroup->quantities, 0, 0xAu);
  if ( *(_DWORD *)a3 / 5 > 0 )
  {
    for ( i = 0; i < 5; ++i )
    {
      gpMonGroup->creatureTypes[i] = a2;
      gpMonGroup->quantities[i] = *(_DWORD *)a3 / 5;
    }
  }
  for ( j = *(_DWORD *)a3 % 5 - 1; j >= 0; --j )
  {
    gpMonGroup->creatureTypes[j] = a2;
    ++gpMonGroup->quantities[j];
  }
  v11 = philAI::QuickCombat(a1 + 101, a1, (unsigned int)gpMonGroup, 0, 0, (float *)&v10, (float *)&v9);
  v5 = 0;
  for ( k = 0; k < 5; ++k )
    v5 += gpMonGroup->quantities[k];
  *(_DWORD *)a3 = v5;
  return v11 != 0;
}

//----- (004B5D30) --------------------------------------------------------
int __stdcall philAI::FightEvent(int a1, int a2, int a3)
{
  int result; // eax@2
  __int16 v4; // ax@66
  int v5; // [sp+34h] [bp-5Ch]@4
  int v6; // [sp+38h] [bp-58h]@37
  int v7; // [sp+3Ch] [bp-54h]@3
  int v8; // [sp+40h] [bp-50h]@3
  int v9; // [sp+44h] [bp-4Ch]@3
  int v10; // [sp+48h] [bp-48h]@3
  int v11; // [sp+4Ch] [bp-44h]@1
  int v12; // [sp+50h] [bp-40h]@3
  int v13; // [sp+54h] [bp-3Ch]@3
  int v14; // [sp+58h] [bp-38h]@3
  int v15; // [sp+5Ch] [bp-34h]@3
  int v16; // [sp+60h] [bp-30h]@37
  int i; // [sp+64h] [bp-2Ch]@9
  char v18; // [sp+68h] [bp-28h]@40
  int v19; // [sp+6Ch] [bp-24h]@4
  int v20; // [sp+70h] [bp-20h]@4
  int v21[2]; // [sp+74h] [bp-1Ch]@8
  int v22; // [sp+7Ch] [bp-14h]@3
  int v23; // [sp+80h] [bp-10h]@3
  int v24; // [sp+84h] [bp-Ch]@3
  int v25; // [sp+88h] [bp-8h]@3
  int v26; // [sp+8Ch] [bp-4h]@40

  v11 = *(_BYTE *)(a2 + 9) & 0x7F;
  if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) == 1 )
  {
    result = 0;
  }
  else
  {
    v7 = 1;
    v8 = 3;
    v9 = 6;
    v10 = 12;
    v22 = 5;
    v23 = 10;
    v24 = 20;
    v25 = 40;
    v12 = 2;
    v13 = 3;
    v14 = 5;
    v15 = 10;
    if ( v11 == 12 )
    {
      v19 = 48;
      v20 = *(&v10 + (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5));
    }
    else if ( v11 == 32 )
    {
      v19 = 59;
      v20 = *(&v5 + (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5));
    }
    else
    {
      v19 = 47;
      v20 = v21[(unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5)];
    }
    for ( i = 0; i < 5; ++i )
    {
      gpMonGroup->creatureTypes[i] = v19;
      gpMonGroup->quantities[i] = v20;
    }
    v5 = 0;
    switch ( v11 )
    {
      case 12:
        switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
        {
          case 2u:
            v5 = (signed __int64)(flt_530730 * 500.0);
            break;
          case 3u:
            v5 = (signed __int64)(flt_530730 * 1000.0);
            break;
          case 4u:
            v5 = (signed __int64)(flt_530730 * 3000.0);
            break;
          case 5u:
            v5 = (signed __int64)(flt_530730 * 1000.0 + *(float *)&gpCurPlayer->field_113);
            break;
          default:
            goto LABEL_37;
        }
        break;
      case 32:
        switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
        {
          case 2u:
            v5 = (signed __int64)(flt_530730 * 1000.0);
            break;
          case 3u:
            v5 = (signed __int64)(flt_530730 * 2000.0);
            break;
          case 4u:
            v5 = (signed __int64)(flt_530730 * 5000.0);
            break;
          case 5u:
            v5 = (signed __int64)(flt_530730 * 2000.0 + *(float *)&gpCurPlayer->field_113);
            break;
          default:
            goto LABEL_37;
        }
        break;
      case 91:
        switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
        {
          case 2u:
            v5 = (signed __int64)(flt_530730 * 500.0);
            break;
          case 3u:
            v5 = (signed __int64)(flt_530730 * 1000.0);
            break;
          case 4u:
            v5 = (signed __int64)(flt_530730 * 2000.0);
            break;
          case 5u:
            v5 = (signed __int64)(flt_530730 * 5000.0);
            break;
          default:
            goto LABEL_37;
        }
        break;
    }
LABEL_37:
    philAI::ChooseEvaluateBattle(a1 + 101, a1, (unsigned int)gpMonGroup, 0, 0, v5, (int)&v16, (int)&v6);
    if ( a3 )
    {
      result = v6;
    }
    else
    {
      if ( v16 )
      {
        v26 = philAI::QuickCombat(a1 + 101, a1, (unsigned int)gpMonGroup, 0, 0, (float *)v21, (float *)&v18);
        if ( v26 )
        {
          switch ( v11 )
          {
            case 12:
              switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
              {
                case 2u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 500);
                  break;
                case 3u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 1000);
                  break;
                case 4u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 3000);
                  break;
                case 5u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 1000);
                  advManager::GiveRandomArtifact(gpAdvManager, (hero *)a1);
                  break;
                default:
                  goto LABEL_66;
              }
              break;
            case 32:
              switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
              {
                case 2u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 1000);
                  break;
                case 3u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 2000);
                  break;
                case 4u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 5000);
                  break;
                case 5u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 2000);
                  advManager::GiveRandomArtifact(gpAdvManager, (hero *)a1);
                  break;
                default:
                  goto LABEL_66;
              }
              break;
            case 91:
              switch ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(a2 + 4) >> 8) >> -5) )
              {
                case 2u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 500);
                  break;
                case 3u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 1000);
                  break;
                case 4u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 2000);
                  break;
                case 5u:
                  advManager::GiveResource(gpAdvManager, (hero *)a1, 6, 5000);
                  break;
                default:
                  goto LABEL_66;
              }
              break;
          }
LABEL_66:
          v4 = *(_WORD *)(a2 + 4) & 7;
          LOBYTE(v4) = v4 | 8;
          *(_WORD *)(a2 + 4) = v4;
        }
      }
      result = 0;
    }
  }
  return result;
}
// 530730: using guessed type float flt_530730;
// 4B5D30: using guessed type int var_1C[2];

//----- (004B6410) --------------------------------------------------------
signed int __stdcall philAI::DamageGroup(void *a1, int a2, int a3, float a4)
{
  signed int result; // eax@2

  if ( a4 >= 0.99 )
  {
    if ( a2 )
      advManager::HeroLoses((int)gpAdvManager, a2);
    else
      armyGroup::DamageGroup((armyGroup *)a1, a4);
    result = 1;
  }
  else
  {
    armyGroup::DamageGroup((armyGroup *)a1, a4);
    result = 0;
  }
  return result;
}

//----- (004B6490) --------------------------------------------------------
playerData *__cdecl philAI::IncrementHourGlass()
{
  playerData *result; // eax@1
  signed int v1; // [sp+10h] [bp-4h]@1

  result = (playerData *)gpCurPlayer->numHeroes;
  v1 = gpCurPlayer->numHeroes;
  if ( v1 < 4 )
  {
    result = gpCurPlayer;
    if ( gpCurPlayer->resources[6] >= 2500 )
    {
      if ( !bHeroBuiltThisTurn )
        ++v1;
    }
  }
  LODWORD(iCurHourGlassPhase) = iCurHourGlassPhase + 1;
  if ( v1 == 1 )
  {
    LODWORD(iCurHourGlassPhase) = iCurHourGlassPhase + 1;
    LODWORD(iCurHourGlassPhase) = iCurHourGlassPhase + 1;
  }
  if ( v1 == 2 && (_DWORD)iCurHourGlassPhase != 1 )
    LODWORD(iCurHourGlassPhase) = iCurHourGlassPhase + 1;
  if ( v1 == 3 && ((_DWORD)iCurHourGlassPhase == 3 || (_DWORD)iCurHourGlassPhase == 6) )
    LODWORD(iCurHourGlassPhase) = iCurHourGlassPhase + 1;
  if ( (signed int)iCurHourGlassPhase > 9 )
    LODWORD(iCurHourGlassPhase) = 9;
  return result;
}
// 50EAA8: using guessed type __int64 iCurHourGlassPhase;
// 532C58: using guessed type int bHeroBuiltThisTurn;

//----- (004B6560) --------------------------------------------------------
void __stdcall philAI::TownEvent(int a1, int a2, __int64 a3)
{
  int v3; // [sp+10h] [bp-1Ch]@7
  char v4; // [sp+1Ch] [bp-10h]@5
  char v5; // [sp+20h] [bp-Ch]@5
  void *this; // [sp+24h] [bp-8h]@1
  int v7; // [sp+28h] [bp-4h]@5

  this = &gpGame->castles[(unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5)];
  advManager::DemobilizeCurrHero(gpAdvManager);
  if ( *((_BYTE *)this + 1) != giCurPlayer )
  {
    if ( town::HasGarrison((town *)this) )
    {
      if ( (signed int)*((_BYTE *)this + 1) >= 0 && gbHumanPlayer[*((_BYTE *)this + 1)] )
      {
        if ( *((_BYTE *)this + 23) == -1 )
          v3 = 0;
        else
          v3 = (int)&gpGame->heroes[*((_BYTE *)this + 23)];
        if ( !advManager::DoCombat(
                gpAdvManager,
                a3,
                a2,
                (const void *)(a2 + 101),
                (int)this,
                v3,
                (char *)this + 8,
                a3,
                SBYTE4(a3),
                -1,
                1) )
        {
          game::ClaimTown(gpGame, *(_BYTE *)this, giCurPlayer, 0);
          dword_5305C4 = *(_BYTE *)this;
        }
      }
      else
      {
        v7 = philAI::QuickCombat(
               a2 + 101,
               a2,
               (unsigned int)((char *)this + 8),
               1,
               *(_BYTE *)this,
               (float *)&v5,
               (float *)&v4);
      }
    }
    else
    {
      game::ClaimTown(gpGame, *(_BYTE *)this, giCurPlayer, 0);
    }
  }
  if ( *((_BYTE *)this + 1) == giCurPlayer && *(_QWORD *)(a2 + 25) == a3 )
  {
    *((_BYTE *)this + 23) = gpCurPlayer->curHeroIdx;
    *(_WORD *)(a2 + 45) = 163;
    *(_WORD *)(a2 + 47) = *(_BYTE *)this;
    philAI::HeroInteractionAtTown(a2, (signed int)this, 0, (int)&unk_5305C8);
  }
  advManager::MobilizeCurrHero(gpAdvManager, 0);
  town::GiveSpells((town *)this, 0);
}
// 5305C4: using guessed type int dword_5305C4;

//----- (004B6790) --------------------------------------------------------
signed int __stdcall philAI::ComputeUpgradeValue(int a1, int a2)
{
  signed int result; // eax@2
  signed int v3; // [sp+18h] [bp-8h]@3
  int v4; // [sp+1Ch] [bp-4h]@1

  v4 = hero::CreatureTypeCount(gpCurAIHero, a1);
  if ( v4 )
  {
    v3 = (signed __int64)((double)(v4 * (gMonsterDatabase[a2].fight_value - gMonsterDatabase[a1].fight_value))
                        * gpCurPlayer->field_10F);
    if ( hero::CreatureTypeCount(gpCurAIHero, a2) )
      v3 = (signed __int64)((double)v3 * 1.2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004B6840) --------------------------------------------------------
signed int __stdcall philAI::ComputeValueOfSS(int a1, int a2, int a3)
{
  int v4; // [sp+30h] [bp-1Ch]@10
  signed int v5; // [sp+38h] [bp-14h]@7
  signed int v6; // [sp+3Ch] [bp-10h]@7
  signed int i; // [sp+40h] [bp-Ch]@7
  signed int v8; // [sp+44h] [bp-8h]@1
  signed int v9; // [sp+48h] [bp-4h]@1

  v8 = *(&dword_4F1F3C[3 * a2] + a3);
  v9 = philAI::FightValueOfStack((armyGroup *)(a1 + 101), (hero *)a1, 1, 0, 0, 0);
  if ( a2 != 13 )
    v8 = (signed __int64)(((double)v9 / gpCurPlayer->field_10F / 2500.0 + 0.5) * (double)v8);
  switch ( a2 )
  {
    case 5:
      if ( *(_BYTE *)(a1 + 227) & 0x80 )
        v8 = (signed __int64)((double)v8 * 1.3);
      break;
    case 1:
      v6 = 0;
      v5 = 0;
      for ( i = 0; i < 5; ++i )
      {
        if ( *(_BYTE *)(i + a1 + 101) != -1 )
        {
          v4 = *(_WORD *)(a1 + 2 * i + 106) * gMonsterDatabase[*(_BYTE *)(i + a1 + 101)].fight_value;
          v5 += v4;
          if ( gMonsterDatabase[*(_BYTE *)(i + a1 + 101)].creature_flags & 4 )
            v6 += v4;
        }
      }
      v8 = (signed __int64)(((double)v6 / (double)v5 / 0.2 + 0.25) * (double)v8);
      break;
    case 7:
    case 8:
      if ( !hero::HasArtifact((hero *)a1, 81) || hero::Stats((hero *)a1, PRIMARY_SKILL_KNOWLEDGE) < 2 )
        v8 = (signed __int64)((double)v8 * 0.5);
      break;
    default:
      return v8;
  }
  return v8;
}
// 4F1F3C: using guessed type int dword_4F1F3C[];

//----- (004B6A60) --------------------------------------------------------
signed int __stdcall philAI::ComputeValueOfFreeSS(int a1, int a2)
{
  signed int result; // eax@3

  if ( *(_BYTE *)(a2 + a1 + 116) || *(_DWORD *)(a1 + 144) >= 8 )
    result = 0;
  else
    result = philAI::ComputeValueOfSS(a1, a2, 1);
  return result;
}

//----- (004B6AC0) --------------------------------------------------------
int __stdcall philAI::ManaRefreshValue(int a1, int a2)
{
  int result; // eax@2
  float v3; // ST24_4@4
  int v4; // [sp+1Ch] [bp-10h]@1
  int v5; // [sp+24h] [bp-8h]@1
  int v6; // [sp+28h] [bp-4h]@1

  v5 = 0;
  v6 = 10 * a2 * hero::Stats((hero *)a1, PRIMARY_SKILL_KNOWLEDGE);
  v4 = v6 - *(_WORD *)a1;
  if ( v4 > 0 )
  {
    if ( v4 > 0 )
    {
      v3 = (double)v4 / (double)v6;
      v5 = (signed __int64)((double)(5 * v4) * v3);
    }
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004B6B60) --------------------------------------------------------
int __thiscall philAI::ValueOfEventAtPosition(void *this, __int64 a1, int a2, int a3)
{
  int result; // eax@3
  __int16 v5; // ax@95
  __int16 v6; // ax@105
  __int16 v7; // ax@106
  __int16 v8; // ax@106
  int v9; // ebx@174
  signed int v10; // ebx@215
  int v11; // ebx@215
  signed int v12; // ebx@216
  int v13; // ebx@216
  signed int v14; // [sp+44h] [bp-E4h]@69
  int v15; // [sp+50h] [bp-D8h]@1
  float v16; // [sp+54h] [bp-D4h]@144
  float v17; // [sp+58h] [bp-D0h]@146
  float v18; // [sp+5Ch] [bp-CCh]@58
  int v19[7]; // [sp+60h] [bp-C8h]@85
  int v20; // [sp+7Ch] [bp-ACh]@179
  int v21; // [sp+80h] [bp-A8h]@175
  int v22; // [sp+84h] [bp-A4h]@168
  int v23; // [sp+88h] [bp-A0h]@176
  int v24; // [sp+8Ch] [bp-9Ch]@176
  mapCell *v25; // [sp+90h] [bp-98h]@172
  int v26; // [sp+94h] [bp-94h]@175
  int row; // [sp+98h] [bp-90h]@168
  int j; // [sp+9Ch] [bp-8Ch]@170
  int i; // [sp+C4h] [bp-64h]@142
  int v30; // [sp+CCh] [bp-5Ch]@151
  char v31; // [sp+D4h] [bp-54h]@131
  int v32; // [sp+DCh] [bp-4Ch]@108
  int v33; // [sp+E4h] [bp-44h]@4
  unsigned int v34; // [sp+E8h] [bp-40h]@4
  char v35; // [sp+F0h] [bp-38h]@131
  int v36; // [sp+100h] [bp-28h]@108
  int v37; // [sp+110h] [bp-18h]@11
  int v38; // [sp+114h] [bp-14h]@148
  unsigned int v39; // [sp+124h] [bp-4h]@106

  v15 = (int)this;
  if ( a2 || *((_WORD *)gaiHeroEventStratRVOfPos + a1 + HIDWORD(a1) * MAP_WIDTH) == -32001 )
  {
    gbReduceByReload = 1;
    gbReduceByBerserk = 1;
    *(_DWORD *)a3 = 100;
    v33 = 0;
    v34 = (unsigned int)advManager::GetCell(gpAdvManager, a1, SHIDWORD(a1));
    if ( gpCurPlayer->field_40 <= 15
      || LOBYTE(gpCurPlayer->field_41) != (_DWORD)a1
      || HIBYTE(gpCurPlayer->field_41) != HIDWORD(a1) )
    {
      if ( *(_BYTE *)(v34 + 9) & 0x80 )
      {
        switch ( *(_BYTE *)(v34 + 9) & 0x7F )
        {
          case LOCATION_ARMY_CAMP:
            v33 = philAI::EvaluateMonsterEvent(
                    *(_BYTE *)(v34 + 3),
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5),
                    a3);
            break;
          case LOCATION_RESOURCE:
            v37 = (signed int)*(_BYTE *)(v34 + 3) >> 1;
            if ( v37 == 6 )
              v33 = (signed __int64)((double)(100 * (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5))
                                   * gafAITurnCostResource[6]);
            else
              v33 = (signed __int64)((double)(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)
                                   * gafAITurnCostResource[v37]);
            break;
          case LOCATION_TREASURE_CHEST:
            v33 = (signed __int64)(flt_530730 * 1600.0);
            break;
          case LOCATION_HERO:
            v33 = philAI::EvaluateHeroEvent(
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5),
                    a1,
                    SHIDWORD(a1),
                    a2,
                    a3);
            break;
          case LOCATION_TOWN:
            v33 = philAI::EvaluateTownEvent(
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5),
                    a1,
                    SHIDWORD(a1),
                    a2,
                    a3);
            break;
          case LOCATION_CAMPFIRE:
            v33 = (signed __int64)((flt_53071C
                                  + flt_530720
                                  + flt_530724
                                  + flt_530728
                                  + gafAITurnCostResource[0]
                                  + flt_53072C)
                                 / 6.0
                                 * 5.0
                                 + flt_530730 * 500.0);
            break;
          case LOCATION_ARTIFACT:
            v33 = philAI::EvaluateArtifactEvent(
                    (signed int)*(_BYTE *)(v34 + 3) >> 1,
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5));
            break;
          case LOCATION_ALCHEMIST_LAB:
          case LOCATION_MINE:
          case LOCATION_SAWMILL:
            v33 = philAI::EvaluateMineEvent(
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5),
                    a1,
                    SHIDWORD(a1),
                    a3);
            break;
          case LOCATION_OBELISK:
            if ( gpGame->boatBuilt[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) + 47] & (unsigned __int8)giCurPlayerBit )
              v33 = 0;
            else
              v33 = *(_DWORD *)&gpCurPlayer->_5[0];
            break;
          case LOCATION_OASIS:
            if ( !(gpCurAIHero->flags & 8) )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 350.0);
            break;
          case LOCATION_BUOY:
            if ( !(gpCurAIHero->flags & 2) && giCurAIHeroMorale < 3 )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 200.0);
            break;
          case LOCATION_TEMPLE:
            if ( !(BYTE1(gpCurAIHero->flags) & 1) && giCurAIHeroMorale < 3 )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 400.0);
            break;
          case LOCATION_FAERIE_RING:
            if ( !(gpCurAIHero->flags & 0x10) && giCurAIHeroLuck < 3 )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 200.0);
            break;
          case LOCATION_IDOL:
            if ( !(BYTE1(gpCurAIHero->flags) & 0x20) && giCurAIHeroLuck < 3 )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 200.0);
            break;
          case LOCATION_FOUNTAIN:
            if ( !(gpCurAIHero->flags & 4) && giCurAIHeroLuck < 3 )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 200.0);
            break;
          case LOCATION_WATERING_HOLE:
            if ( !(BYTE1(gpCurAIHero->flags) & 2) )
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 300.0);
            break;
          case LOCATION_SHRINE_FIRST:
          case LOCATION_SHRINE_SECOND_ORDER:
          case LOCATION_SHRINE_THIRD_ORDER:
            if ( hero::Stats(gpCurAIHero, PRIMARY_SKILL_KNOWLEDGE) <= 0
              || !hero::HasArtifact(gpCurAIHero, 81)
              || hero::HasSpell(gpCurAIHero, (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) - 1) )
            {
              v33 = 0;
            }
            else if ( gsSpellInfo[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) - 1].level <= gpCurAIHero->secondarySkillLevel[7] + 2 )
            {
              v33 = gsSpellInfo[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) - 1].appearingChance;
              if ( gsSpellInfo[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) - 1].attributes & 1 )
              {
                if ( hero::Stats(gpCurAIHero, PRIMARY_SKILL_KNOWLEDGE) <= 40 )
                  v18 = gfStatPower[hero::Stats(gpCurAIHero, PRIMARY_SKILL_KNOWLEDGE)];
                else
                  v18 = *(float *)&dword_4F2950;
                v33 = (signed __int64)((double)v33 * v18);
              }
            }
            break;
          case LOCATION_GAZEBO:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->gazeboesVisited )
              v33 = 0;
            else
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
            break;
          case LOCATION_TREE_OF_KNOWLEDGE:
            v33 = 0;
            if ( !((1 << ((*(_WORD *)(v34 + 4) >> 3) & 0x1F)) & gpCurAIHero->treesOfKnowledgeVisited) )
            {
              v14 = (signed int)(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) >> 6;
              if ( v14 == 1 )
              {
                v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1500.0);
              }
              else if ( v14 == 2 )
              {
                if ( gpCurPlayer->resources[6] >= 2000 )
                  v33 = (signed __int64)((double)(signed int)(signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1500.0)
                                       - flt_530730 * 2000.0);
              }
              else if ( v14 == 3 && gpCurPlayer->resources[5] >= 10 )
              {
                v33 = (signed __int64)((double)(signed int)(signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1500.0)
                                     - flt_53072C * 10.0);
              }
              if ( v33 < 0 )
                v33 = 0;
            }
            break;
          case LOCATION_WINDMILL:
            if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 99 )
            {
              v33 = 0;
            }
            else
            {
              memset(v19, 0, 0x1Cu);
              v19[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)] = 2;
              v33 = philAI::RVConversion((int)v19);
            }
            break;
          case LOCATION_MAGIC_GARDEN:
            if ( (unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5 )
            {
              if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 7 )
                v33 = (signed __int64)(flt_530730 * 500.0);
              else
                v33 = (signed __int64)(flt_530714[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)]
                                     * 5.0);
            }
            else
            {
              v33 = 0;
            }
            break;
          case LOCATION_FLOTSAM:
            v33 = (signed __int64)(gafAITurnCostResource[0] * 5.0);
            break;
          case LOCATION_SEA_CHEST:
            if ( ((unsigned __int16)(*(_WORD *)(v34 + 4) >> 3) >> 8) & 1 )
            {
              v5 = *(_WORD *)(v34 + 4) >> 3;
              v33 = (signed __int64)(flt_530730 * 1000.0 + (double)gArtifactBaseRV[(unsigned __int8)v5]);
            }
            else if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 1 )
            {
              v33 = (signed __int64)(flt_530730 * 1500.0);
            }
            else
            {
              v33 = (signed __int64)(flt_530730 * 200.0);
            }
            if ( v33 <= 0 )
              v33 = 150;
            break;
          case LOCATION_WAGON:
          case LOCATION_LEAN_TO:
            if ( (unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5 )
            {
              if ( (*(_WORD *)(v34 + 4) >> 3) & 0x80 )
              {
                v6 = *(_WORD *)(v34 + 4) >> 3;
                v33 = gArtifactBaseRV[v6 & 0x7F];
              }
              else
              {
                v7 = *(_WORD *)(v34 + 4) >> 3;
                v37 = (v7 & 0xF) - 1;
                v8 = *(_WORD *)(v34 + 4) >> 3;
                v39 = (v8 & 0xF0u) >> 4;
                v33 = (signed __int64)((double)(signed int)v39 * gafAITurnCostResource[v37]);
              }
            }
            else
            {
              v33 = 0;
            }
            break;
          case LOCATION_ANCIENT_LAMP:
            v32 = 60;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_TREE_CITY:
            v32 = 20;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_WATCH_TOWER:
            v32 = 12;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_TREE_HOUSE:
            v32 = 20;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_EXCAVATION:
            v32 = 47;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_HALFLING_HOLE:
            v32 = 38;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_RUINS:
            v32 = 61;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_TROLL_BRIDGE:
            if ( ((unsigned __int16)(*(_WORD *)(v34 + 4) >> 3) >> 8) & 1 )
            {
              v33 = 0;
              break;
            }
            v32 = 17;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_DRAGON_CITY:
            if ( ((unsigned __int16)(*(_WORD *)(v34 + 4) >> 3) >> 8) & 1 )
            {
              v33 = 0;
              break;
            }
            v32 = 36;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_CITY_OF_DEAD:
            if ( ((unsigned __int16)(*(_WORD *)(v34 + 4) >> 3) >> 8) & 1 )
            {
              v33 = 0;
            }
            else
            {
              v32 = 55;
              v36 = 0;
LABEL_131:
              philAI::EvaluateOneTimeCreaturePurchase(
                v32,
                (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5),
                v36,
                (int)&v31,
                (int)&v33,
                (int)&v35);
              gbReduceByReload = 0;
            }
            break;
          case LOCATION_CAVE:
            v32 = 29;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_ARCHERS_HOUSE:
            v32 = 1;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_GOBLIN_HUT:
            v32 = 11;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_PEASANT_HUT:
            v32 = 0;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_DWARF_COTTAGE:
          case LOCATION_DWARF_CABIN:
            v32 = 21;
            v36 = 1;
            goto LABEL_131;
          case LOCATION_DESRT_TENT:
            v32 = 58;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_WAGON_CAMP:
            v32 = 57;
            v36 = 0;
            goto LABEL_131;
          case LOCATION_SHIPWRECK_SURVIVOR:
            v33 = gArtifactBaseRV[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)];
            if ( v33 < 125 )
              v33 = 125;
            break;
          case LOCATION_SKELETON:
            if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 1 )
              v33 = 0;
            else
              v33 = *(_DWORD *)&gArtifactLevel[4 * (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)
                                             + 96];
            break;
          case LOCATION_GRAVEYARD:
          case LOCATION_SHIPWRECK:
          case LOCATION_DERELICT_SHIP:
            v33 = philAI::FightEvent((int)gpCurAIHero, v34, 1);
            break;
          case LOCATION_PYRAMID:
            if ( (unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5 )
            {
              i = (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) - 1;
              if ( gsSpellInfo[i].attributes & 1 )
              {
                if ( hero::Stats(gpCurAIHero, PRIMARY_SKILL_SPELLPOWER) <= 40 )
                  v16 = gfBattleStat[hero::Stats(gpCurAIHero, PRIMARY_SKILL_SPELLPOWER)];
                else
                  v16 = gfBattleStat[40];
                v17 = v16;
              }
              else
              {
                v17 = 1.0;
              }
              v38 = (signed __int64)((double)gsSpellInfo[i].appearingChance * gpCurPlayer->field_10F * v17);
              for ( i = 0; i < 5; ++i )
              {
                gpMonGroup->creatureTypes[i] = 51;
                gpMonGroup->quantities[i] = 10;
              }
              philAI::ChooseEvaluateBattle(
                (int)&gpCurAIHero->army,
                (int)gpCurAIHero,
                (unsigned int)gpMonGroup,
                0,
                0,
                v38,
                (int)&v30,
                (int)&v33);
              if ( !v30 )
                v33 = -50;
            }
            else
            {
              v33 = 0;
            }
            break;
          case LOCATION_DAEMON_CAVE:
            if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 1 )
            {
              v33 = 0;
            }
            else
            {
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 100.0
                                   + *(float *)&gpCurPlayer->field_113
                                   + *(float *)&gpCurAIHero->field_E8 * 300.0
                                   + flt_530730 * 2500.0
                                   + *(float *)&gpCurAIHero->field_E8 * 300.0
                                   + flt_530730 * -750.0);
              if ( (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5) == 5
                && gpCurPlayer->resources[6] < 2500 )
                v33 = -100;
            }
            break;
          case LOCATION_ABANDONED_MINE:
            v38 = (signed __int64)((double)*((_BYTE *)gaiTurnValueOfMine + a1 + HIDWORD(a1) * MAP_WIDTH)
                                 * (double)dword_4F1F38
                                 * flt_530730);
            for ( i = 0; i < 5; ++i )
            {
              gpMonGroup->creatureTypes[i] = gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)].guardianType;
              gpMonGroup->quantities[i] = gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)].guadianQty
                                        / 5;
            }
            philAI::ChooseEvaluateBattle(
              (int)&gpCurAIHero->army,
              (int)gpCurAIHero,
              (unsigned int)gpMonGroup,
              0,
              0,
              v38,
              (int)&v30,
              (int)&v33);
            if ( !v30 )
              v33 = -50;
            break;
          case LOCATION_STONE_LITHS:
          case LOCATION_WHIRLPOOL:
            if ( dword_51D7EC )
            {
              dword_51D7EC = 0;
              v22 = -9999;
              for ( row = 0; MAP_HEIGHT > row; ++row )
              {
                for ( j = 0; j < MAP_WIDTH; ++j )
                {
                  v25 = advManager::GetCell(gpAdvManager, j, row);
                  if ( *(_BYTE *)(v34 + 9) == v25->objType )
                  {
                    if ( *(_BYTE *)(v34 + 3) == v25->objectIndex )
                    {
                      v9 = abs(a1 - j);
                      if ( abs(HIDWORD(a1) - row) + v9 > 3 )
                      {
                        v26 = (signed __int64)((double)philAI::StrategicValueOfPosition(v15, j, row, 0, 0, &v21, 700)
                                             * 0.85);
                        if ( v26 > v22 )
                        {
                          v22 = v26;
                          v23 = j;
                          v24 = row;
                        }
                      }
                    }
                  }
                }
              }
              v20 = philAI::StrategicValueOfPosition(v15, gpCurAIHero->x, gpCurAIHero->y, 0, 0, &v21, 500);
              if ( v20 + 200 >= v22 )
              {
                if ( a2 )
                  v33 = -200;
                else
                  v33 = 0;
              }
              else
              {
                v33 = v22 - v20 - 200;
              }
              dword_51D7EC = 1;
              gbReduceByReload = 0;
            }
            else
            {
              v33 = 0;
            }
            break;
          case LOCATION_FORT:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->fortsVisited )
              v33 = 0;
            else
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
            break;
          case LOCATION_WITCH_DOCTORS_HUT:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->witchDoctorHutsVisited )
              v33 = 0;
            else
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
            break;
          case LOCATION_STANDING_STONES:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->standingStonesVisited )
              v33 = 0;
            else
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
            break;
          case LOCATION_MERCENARY_CAMP:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->mercenaryCampsVisited )
              v33 = 0;
            else
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
            break;
          case LOCATION_XANADU:
            if ( (1 << (*(_WORD *)(v34 + 4) >> 3)) & gpCurAIHero->xanadusVisited )
            {
              v33 = 0;
            }
            else if ( gpCurAIHero->oldLevel + 2 * gpCurAIHero->secondarySkillLevel[4] < 10 )
            {
              v33 = 0;
            }
            else
            {
              v33 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 8000.0);
            }
            break;
          case LOCATION_LIGHTHOUSE:
            if ( gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)].owner == gpCurAIHero->ownerIdx
              || OnMySide(gpGame->mines[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5)].owner) )
              v33 = 0;
            else
              v33 = 1000;
            break;
          case LOCATION_WATERWHEEL:
            v33 = (signed __int64)((double)(500 * (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5))
                                 * flt_530730);
            break;
          case LOCATION_BOAT:
            dword_532CEC = 1;
            v33 = 90;
            break;
          case LOCATION_BOTTLE:
            v33 = 105;
            break;
          case LOCATION_HILL_FORT:
            v10 = philAI::ComputeUpgradeValue(21, 22);
            v11 = philAI::ComputeUpgradeValue(15, 16) + v10;
            v33 = philAI::ComputeUpgradeValue(12, 13) + v11;
            break;
          case LOCATION_FREEMANS_FOUNDRY:
            v12 = philAI::ComputeUpgradeValue(3, 4);
            v13 = philAI::ComputeUpgradeValue(5, 6) + v12;
            v33 = philAI::ComputeUpgradeValue(40, 41) + v13;
            break;
          case LOCATION_MAGIC_WELL:
            v33 = philAI::ManaRefreshValue((int)gpCurAIHero, 1);
            break;
          case LOCATION_ARTESIAN_SPRING:
            if ( (unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5 )
              v33 = philAI::ManaRefreshValue((int)gpCurAIHero, 2);
            else
              v33 = 0;
            break;
          case LOCATION_WITCH_HUT:
            v33 = philAI::ComputeValueOfFreeSS(
                    (int)gpCurAIHero,
                    (unsigned __int8)((unsigned __int8)(*(_WORD *)(v34 + 4) >> 8) >> -5));
            break;
          case LOCATION_SIGN:
          case LOCATION_ORACLE:
          case LOCATION_TRADING_POST:
          case LOCATION_SPHINX:
          case LOCATION_TAR_PIT:
          case LOCATION_MAGELLANS_MAPS:
          case LOCATION_OBSERVATION_TOWER:
            v33 = 0;
            break;
          case LOCATION_ALCHEMIST_TOWER:
            v33 = philAI::EvaluateGenericSite(v34);
            break;
          case LOCATION_BARRIER:
            v33 = philAI::EvaluateBarrier(v34);
            break;
          case LOCATION_TRAVELLER_TENT:
            v33 = philAI::EvaluatePassword(v34);
            break;
          case LOCATION_EXPANSION_DWELLING:
            v33 = philAI::EvaluateRecruitSite(v34);
            break;
          case LOCATION_JAIL:
            v33 = philAI::EvaluateJail(v34);
            break;
          default:
            sprintf(
              gText,
              "AI encountered object type %d and doesn't know how to deal with it.   Tell Phil",
              *(_BYTE *)(v34 + 9) & 0x7F);
            NormalDialog(gText, 1, -1, -1, -1, 0, -1, 0, -1, 0);
            v33 = 0;
            break;
        }
      }
      else if ( !(unsigned __int8)(*(&mapRevealed[(_DWORD)a1] + HIDWORD(a1) * MAP_WIDTH) & giCurPlayerBit) )
      {
        v33 = 5;
      }
    }
    else
    {
      v33 = gUltArtifactAvgValue * (gpCurPlayer->field_40 - 15) / 100;
    }
    if ( gbTroopReload && gbReduceByReload )
      v33 = (signed __int64)((double)v33 * *(float *)&fReduceFactor);
    if ( gbBerserk && gbReduceByBerserk )
      v33 = (signed __int64)((double)v33 * *(float *)&fBerserkFactor);
    if ( !a2 )
    {
      if ( v33 > 0 && *(&mapRevealed[(_DWORD)a1] + HIDWORD(a1) * MAP_WIDTH) & 0x80 && (*(_BYTE *)(v34 + 9) & 0x7F) != 24 )
        v33 = 0;
      if ( v33 >= 0 || (*(_BYTE *)(v34 + 9) & 0x7F) == 42 )
      {
        if ( v33 <= 32000 )
        {
          if ( v33 < -32000 )
            v33 = -32000;
        }
        else
        {
          v33 = 32000;
        }
      }
      else
      {
        v33 = 0;
      }
      *((_WORD *)gaiHeroEventStratRVOfPos + a1 + HIDWORD(a1) * MAP_WIDTH) = v33;
    }
    result = v33;
  }
  else
  {
    result = *((_WORD *)gaiHeroEventStratRVOfPos + a1 + HIDWORD(a1) * MAP_WIDTH);
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 4F1F38: using guessed type int dword_4F1F38;
// 4F21EC: using guessed type int gUltArtifactAvgValue;
// 4F28B0: using guessed type float gfStatPower[];
// 4F2950: using guessed type int dword_4F2950;
// 51D7EC: using guessed type int dword_51D7EC;
// 5305C0: using guessed type int fReduceFactor;
// 5306D4: using guessed type int giCurAIHeroLuck;
// 5306D8: using guessed type int fBerserkFactor;
// 5306DC: using guessed type int giCurAIHeroMorale;
// 53071C: using guessed type float flt_53071C;
// 530720: using guessed type float flt_530720;
// 530724: using guessed type float flt_530724;
// 530728: using guessed type float flt_530728;
// 53072C: using guessed type float flt_53072C;
// 530730: using guessed type float flt_530730;
// 532C50: using guessed type int gbTroopReload;
// 532C5C: using guessed type char giCurPlayerBit;
// 532CCC: using guessed type int gbBerserk;
// 532CD0: using guessed type int gbReduceByBerserk;
// 532CD4: using guessed type int gbReduceByReload;
// 532CEC: using guessed type int dword_532CEC;
// 4B6B60: using guessed type int var_C8[7];

//----- (004B8610) --------------------------------------------------------
signed int __stdcall philAI::EvaluateGenericSite(int a1)
{
  signed int v1; // ST20_4@21
  signed int v3; // [sp+28h] [bp-24h]@18
  int v4; // [sp+2Ch] [bp-20h]@20
  signed int i; // [sp+38h] [bp-14h]@2
  signed int j; // [sp+38h] [bp-14h]@18
  signed int v7; // [sp+40h] [bp-Ch]@1
  int v8; // [sp+44h] [bp-8h]@1

  v8 = 0;
  v7 = 0;
  switch ( ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 0x3F )
  {
    case 0:
      for ( i = 0; i < 14; ++i )
      {
        if ( IsCursedItem(gpCurAIHero->artifacts[i]) )
          ++v8;
      }
      if ( gpCurPlayer->resources[6] > 1500 )
        v7 = 500 * v8;
      break;
    case 1:
      if ( !(BYTE2(gpCurAIHero->flags) & 0x40) )
        v7 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 1000.0);
      break;
    case 5:
      if ( !(BYTE2(gpCurAIHero->flags) & 0x10) && giCurAIHeroLuck < 3 )
        v7 = (signed __int64)(*(float *)&gpCurAIHero->field_E8 * 200.0);
      break;
    case 6:
      if ( !(BYTE2(gpCurAIHero->flags) & 0x20) )
      {
        v3 = 0;
        for ( j = 0; j < 5; ++j )
        {
          v4 = gpCurAIHero->army.creatureTypes[j];
          if ( v4 != -1 )
          {
            v1 = gpCurAIHero->army.quantities[j];
            v3 += (v1 - (unsigned __int64)(signed __int64)((double)v1 * 0.7)) * gMonsterDatabase[v4].hp;
          }
        }
        v7 = (signed __int64)((double)v3 * *(float *)&gpCurAIHero->field_E8);
      }
      break;
    case 4:
      v7 = philAI::ComputeUpgradeValue(7, 8);
      if ( !(BYTE2(gpCurAIHero->flags) & 0x80) )
        v7 = (signed __int64)((double)(200 * (8 - gpGame->day)) * *(float *)&gpCurAIHero->field_E8 + (double)v7);
      break;
    case 2:
    case 3:
      return v7;
  }
  return v7;
}
// 5306D4: using guessed type int giCurAIHeroLuck;

//----- (004B88B0) --------------------------------------------------------
signed int __stdcall philAI::EvaluateBarrier(int a1)
{
  signed int result; // eax@2

  if ( gpCurPlayer->barrierTentsVisited & (1 << (((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7)) )
    result = 5000;
  else
    result = 0;
  return result;
}

//----- (004B8910) --------------------------------------------------------
signed int __stdcall philAI::EvaluatePassword(int a1)
{
  signed int result; // eax@2

  if ( gpCurPlayer->barrierTentsVisited & (1 << (((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7)) )
    result = 0;
  else
    result = 2500;
  return result;
}

//----- (004B8970) --------------------------------------------------------
int __stdcall philAI::EvaluateRecruitSite(int a1)
{
  __int16 v2; // [sp+18h] [bp-18h]@1
  char v3; // [sp+1Ch] [bp-14h]@8
  int v4; // [sp+20h] [bp-10h]@1
  int v5; // [sp+24h] [bp-Ch]@1
  int v6; // [sp+28h] [bp-8h]@1
  char v7; // [sp+2Ch] [bp-4h]@8

  v4 = ((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) & 7;
  v2 = (signed __int16)(unsigned __int8)((unsigned __int8)(*(_WORD *)(a1 + 4) >> 8) >> -5) >> 3;
  v5 = 0;
  v6 = 0;
  switch ( v4 )
  {
    case 0:
      v5 = 59;
      break;
    case 1:
      v5 = 62;
      break;
    case 2:
      v5 = 63;
      break;
    case 3:
      v5 = 64;
      break;
    case 4:
      v5 = 65;
      break;
    default:
      break;
  }
  philAI::EvaluateOneTimeCreaturePurchase(v5, v2, 0, (int)&v3, (int)&v6, (int)&v7);
  gbReduceByReload = 0;
  return v6;
}
// 532CD4: using guessed type int gbReduceByReload;

//----- (004B8A70) --------------------------------------------------------
int __cdecl philAI::EvaluateJail(unsigned int a1)
{
  return 10000;
}
// 4B8A70: inconsistent function type and number of purged bytes

//----- (004B8A90) --------------------------------------------------------
void *__cdecl InitAIMapVars()
{
  void *result; // eax@1

  CloseAIMapVars();
  searchArray::Init(&SVSearchArray);
  gaiLiveChanceOfPos = BaseAlloc(2 * MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D840 + 8);
  gaiHeroStrategicRVOfPos = BaseAlloc(2 * MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D840 + 9);
  gaiHeroEventStratRVOfPos = BaseAlloc(2 * MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D840 + 10);
  gaiTurnValueOfMine = BaseAlloc(MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D840 + 11);
  result = BaseAlloc(MAP_HEIGHT * MAP_WIDTH, "F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D840 + 12);
  gaiEnemyHeroReachable = result;
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;
// 51D840: using guessed type __int16 word_51D840;

//----- (004B8B90) --------------------------------------------------------
void __cdecl CloseAIMapVars()
{
  if ( gaiLiveChanceOfPos )
    BaseFree(gaiLiveChanceOfPos, (int)"F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D8D0 + 1);
  if ( gaiHeroStrategicRVOfPos )
    BaseFree(gaiHeroStrategicRVOfPos, (int)"F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D8D0 + 2);
  if ( gaiHeroEventStratRVOfPos )
    BaseFree(gaiHeroEventStratRVOfPos, (int)"F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D8D0 + 3);
  if ( gaiTurnValueOfMine )
    BaseFree(gaiTurnValueOfMine, (int)"F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D8D0 + 4);
  if ( gaiEnemyHeroReachable )
    BaseFree(gaiEnemyHeroReachable, (int)"F:\\h2xsrc\\Source\\PHILAI.CPP", word_51D8D0 + 5);
  gaiLiveChanceOfPos = 0;
  gaiHeroStrategicRVOfPos = 0;
  gaiHeroEventStratRVOfPos = 0;
  gaiTurnValueOfMine = 0;
  gaiEnemyHeroReachable = 0;
  searchArray::Close(&SVSearchArray);
}
// 51D8D0: using guessed type __int16 word_51D8D0;

//----- (004B8CB0) --------------------------------------------------------
bool __fastcall OnMySide(int a1)
{
  return a1 != -1
      && (giCurPlayer == a1
       || gbInCampaign && !gpGame->field_2 && gpGame->field_4 == 9 && a1
       || gbInCampaign && gpGame->field_2 == 1 && gpGame->field_4 == 10 && a1
       || gpGame->mapHeader.winConditionType == WIN_CONDITION_DEFEAT_COLOR
       && (gpGame->mapHeader.winConditionArgument == 99 && a1
        || gpGame->mapHeader.winConditionArgument != 99
        && (gpGame->players[giCurPlayer].color < (signed int)HIWORD(gpGame->mapHeader.field_2E)
         && gpGame->players[a1].color < (signed int)HIWORD(gpGame->mapHeader.field_2E)
         || gpGame->players[giCurPlayer].color >= (signed int)HIWORD(gpGame->mapHeader.field_2E)
         && gpGame->players[a1].color >= (signed int)HIWORD(gpGame->mapHeader.field_2E)))
       || gbInCampaign
       && !gpGame->field_2
       && gpGame->field_4 == 8
       && gpGame->players[a1].color
       && gpGame->players[a1].color != 3);
}

//----- (004B8F20) --------------------------------------------------------
int __stdcall philAI::EvaluateArtifactEvent(int a1, int a2)
{
  int result; // eax@2
  char v3; // [sp+1Ch] [bp-38h]@16
  char v4; // [sp+20h] [bp-34h]@16
  char v5; // [sp+24h] [bp-30h]@16
  char v6; // [sp+28h] [bp-2Ch]@16
  int v7; // [sp+2Ch] [bp-28h]@3
  int i; // [sp+30h] [bp-24h]@8
  float v9; // [sp+34h] [bp-20h]@16
  int v10; // [sp+38h] [bp-1Ch]@3
  int v11; // [sp+40h] [bp-14h]@16
  int v12; // [sp+44h] [bp-10h]@7
  int v13; // [sp+4Ch] [bp-8h]@16

  if ( hero::NumArtifacts(gpCurAIHero) == 14 )
  {
    result = 0;
  }
  else
  {
    v10 = 0;
    v7 = gArtifactBaseRV[a1];
    if ( a1 == 86 )
    {
      if ( hero::HasSpell(gpCurAIHero, a2) )
        result = v7;
      else
        result = v7 + gsSpellInfo[a2].appearingChance;
    }
    else
    {
      v12 = v7;
      if ( BYTE1(a2) & 1 )
      {
        for ( i = 0; i < 5; ++i )
        {
          gpMonGroup->creatureTypes[i] = a2;
          if ( gpMonGroup->creatureTypes[i] == 57 )
          {
            gpMonGroup->quantities[i] = 10;
          }
          else if ( i )
          {
            gpMonGroup->quantities[i] = 0;
          }
          else
          {
            gpMonGroup->quantities[0] = 1;
          }
        }
        philAI::ProbableOutcomeOfBattle(
          (int)&gpCurAIHero->army,
          (int)gpCurAIHero,
          (unsigned int)gpMonGroup,
          0,
          0,
          0,
          -1,
          (int)&v9,
          (int)&v6,
          (int *)&v5,
          (int *)&v4,
          (int *)&v3,
          &v13);
        v11 = (signed __int64)((double)gArtifactBaseRV[a1] * v9 + (double)v13);
        if ( v11 < 0 )
          v11 = 0;
        v10 = v11;
      }
      else
      {
        switch ( a2 & 0xF )
        {
          case 1:
            v10 = v12;
            break;
          case 4:
            if ( gpCurAIHero->secondarySkillLevel[7] )
              v10 = v12;
            else
              v10 = 0;
            break;
          case 5:
            if ( gpCurAIHero->secondarySkillLevel[6] )
              v10 = v12;
            else
              v10 = 0;
            break;
          case 3:
            v10 = philAI::NetValueOfArtifact(a1, 2000, 0, 0);
            break;
          case 6:
            v10 = philAI::NetValueOfArtifact(a1, 2500, (a2 & 0xF0u) >> 4, 3);
            break;
          case 7:
            v10 = philAI::NetValueOfArtifact(a1, 3000, (a2 & 0xF0u) >> 4, 5);
            break;
          case 2:
            break;
        }
      }
      result = v10;
    }
  }
  return result;
}

//----- (004B91E0) --------------------------------------------------------
int __stdcall philAI::EvaluateMineEvent(int a1, int a2, int a3, int a4)
{
  int result; // eax@3
  float v5; // [sp+1Ch] [bp-2Ch]@19
  signed int v6; // [sp+20h] [bp-28h]@17
  char v7; // [sp+24h] [bp-24h]@12
  char v8; // [sp+28h] [bp-20h]@12
  char v9; // [sp+2Ch] [bp-1Ch]@12
  char v10; // [sp+30h] [bp-18h]@12
  int i; // [sp+34h] [bp-14h]@6
  float v12; // [sp+38h] [bp-10h]@12
  int v13; // [sp+3Ch] [bp-Ch]@1
  int v14; // [sp+40h] [bp-8h]@5
  int v15; // [sp+44h] [bp-4h]@12

  v13 = 0;
  if ( gpGame->field_60A6[a1] == gpCurAIHero->ownerIdx || OnMySide(gpGame->field_60A6[a1]) )
  {
    result = v13;
  }
  else
  {
    if ( gpGame->mines[a1].guardianType != -1 )
    {
      v14 = gpGame->mines[a1].guadianQty;
      memset(gpMonGroup, 0xFFu, 5u);
      memset(gpMonGroup->quantities, 0, 0xAu);
      if ( v14 / 5 > 0 )
      {
        for ( i = 0; i < 5; ++i )
        {
          gpMonGroup->creatureTypes[i] = gpGame->mines[a1].guardianType;
          gpMonGroup->quantities[i] = v14 / 5;
        }
      }
      for ( i = v14 % 5 - 1; i >= 0; --i )
      {
        gpMonGroup->creatureTypes[i] = gpGame->mines[a1].guardianType;
        ++gpMonGroup->quantities[i];
      }
      philAI::ProbableOutcomeOfBattle(
        (int)&gpCurAIHero->army,
        (int)gpCurAIHero,
        (unsigned int)gpMonGroup,
        0,
        0,
        0,
        -1,
        (int)&v12,
        (int)&v10,
        (int *)&v9,
        (int *)&v8,
        (int *)&v7,
        &v15);
      *(_DWORD *)a4 = (signed __int64)v12;
      v13 = v15;
    }
    if ( !*(_DWORD *)&gbIAmGreatest || gpGame->field_60A6[a1] < 0 || gbHumanPlayer[gpGame->field_60A6[a1]] )
    {
      v6 = (signed __int64)((double)gMineCharacteristics[gpGame->mines[a1].type]
                          * gafAITurnCostResource[gpGame->mines[a1].type]
                          * (double)*((_BYTE *)gaiTurnValueOfMine + a2 + a3 * MAP_WIDTH));
      if ( gpGame->field_60A6[a1] >= 0 )
      {
        if ( gbHumanPlayer[gpGame->field_60A6[a1]] )
          v5 = *(float *)&gfAttackHumanBonus;
        else
          v5 = *(float *)&gfAttackComputerBonus;
        v6 = (signed __int64)((double)v6 * v5);
      }
      v13 += v6;
      result = v13;
    }
    else
    {
      result = v13;
    }
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F1F20: using guessed type int gMineCharacteristics[];
// 51D5C0: using guessed type int gfAttackHumanBonus;
// 51D5C4: using guessed type int gfAttackComputerBonus;

//----- (004B94F0) --------------------------------------------------------
int __stdcall philAI::EvaluateMonsterEvent(int creat, __int16 a2, int a3)
{
  signed int v3; // ST50_4@8
  char v5; // [sp+20h] [bp-34h]@8
  char v6; // [sp+24h] [bp-30h]@8
  char v7; // [sp+28h] [bp-2Ch]@8
  char v8; // [sp+2Ch] [bp-28h]@8
  int v9; // [sp+30h] [bp-24h]@8
  int i; // [sp+34h] [bp-20h]@2
  char v11; // [sp+38h] [bp-1Ch]@8
  float v12; // [sp+3Ch] [bp-18h]@8
  int v13; // [sp+40h] [bp-14h]@1
  float v14; // [sp+44h] [bp-10h]@8
  int v15; // [sp+48h] [bp-Ch]@1
  int v16; // [sp+4Ch] [bp-8h]@1
  int v17; // [sp+50h] [bp-4h]@8

  v16 = a2 & 0xFFF;
  v13 = a2 & 0x1000;
  v15 = 0;
  memset(gpMonGroup, 0xFFu, 5u);
  memset(gpMonGroup->quantities, 0, 0xAu);
  if ( v16 / 5 > 0 )
  {
    for ( i = 0; i < 5; ++i )
    {
      gpMonGroup->creatureTypes[i] = creat;
      gpMonGroup->quantities[i] = v16 / 5;
    }
  }
  for ( i = v16 % 5 - 1; i >= 0; --i )
  {
    gpMonGroup->creatureTypes[i] = creat;
    ++gpMonGroup->quantities[i];
  }
  philAI::ProbableOutcomeOfBattle(
    (int)&gpCurAIHero->army,
    (int)gpCurAIHero,
    (unsigned int)gpMonGroup,
    0,
    0,
    0,
    -1,
    (int)&v12,
    (int)&v9,
    (int *)&v8,
    (int *)&v6,
    (int *)&v5,
    &v17);
  philAI::EvaluateOneTimeCreaturePurchase(creat, v16, 1, (int)&v11, (int)&v9, (int)&v7);
  v3 = philAI::FightValueOfStack(&gpCurAIHero->army, gpCurAIHero, 0, 0, 0, 0);
  v14 = (double)v3 / (double)(v16 * gMonsterDatabase[creat].fight_value);
  if ( v13
    && v14 > 2.0
    && !hero::HasArtifact(gpCurAIHero, 70)
    && armyGroup::CanJoin(&gpCurAIHero->army, creat)
    && creat != CREATURE_GHOST
    && creat != CREATURE_EARTH_ELEMENTAL
    && creat != CREATURE_AIR_ELEMENTAL
    && creat != CREATURE_FIRE_ELEMENTAL
    && creat != CREATURE_WATER_ELEMENTAL )
  {
    *(_DWORD *)a3 = 100;
    *(_DWORD *)a3 = (signed __int64)(v12 * 60.0 + 40.0);
    if ( armyGroup::CanJoin(&gpCurAIHero->army, creat) )
      v15 = v9;
    else
      v15 = 0;
    v15 = (signed __int64)((double)v15 * 0.6 + (double)v17 * 0.4);
  }
  else if ( v14 <= 5.0 )
  {
    *(_DWORD *)a3 = (signed __int64)(v12 * 100.0);
    v15 = v17;
  }
  else
  {
    if ( hero::GetSSLevel(gpCurAIHero, SECONDARY_SKILL_NECROMANCY) )
      v15 = 120;
    else
      v15 = 0;
    v15 += v16 * gMonsterDatabase[creat].hp;
  }
  if ( v15 < 0 )
    gbReduceByReload = 0;
  return v15;
}
// 532CD4: using guessed type int gbReduceByReload;

//----- (004B9820) --------------------------------------------------------
int __stdcall philAI::EvaluateHeroEvent(int a1, int a2, int a3, int a4, int a5)
{
  __int64 v5; // ST08_8@29
  float v7; // [sp+2Ch] [bp-34h]@24
  int v8; // [sp+30h] [bp-30h]@22
  int v9; // [sp+34h] [bp-2Ch]@21
  char *v10; // [sp+38h] [bp-28h]@21
  char *twn; // [sp+3Ch] [bp-24h]@22
  signed int v12; // [sp+40h] [bp-20h]@21
  char v13; // [sp+44h] [bp-1Ch]@29
  char v14; // [sp+48h] [bp-18h]@29
  char v15; // [sp+4Ch] [bp-14h]@29
  char v16; // [sp+50h] [bp-10h]@29
  float v17; // [sp+54h] [bp-Ch]@29
  int v18; // [sp+58h] [bp-8h]@3

  if ( gpGame->relatedToHeroForHireStatus[a1] == gpCurAIHero->ownerIdx )
  {
    if ( a4 )
    {
      if ( a4 == 1 )
        v18 = -20000;
      else
        v18 = -500;
    }
    else
    {
      v18 = 0;
    }
    if ( giCurTurn - *(_WORD *)&gpCurAIHero->field_4 >= 4 || gpGame->heroes[a1].idx != gpCurAIHero->field_6 )
      philAI::HeroInteractionAtHero((int)gpCurAIHero, (int)&gpGame->heroes[a1], 1, (int)&v18);
    gaiHeroLiveChance[a1] = 100;
  }
  else if ( OnMySide(gpGame->relatedToHeroForHireStatus[a1]) )
  {
    if ( a4 )
    {
      if ( a4 == 1 )
        v18 = -20000;
      else
        v18 = -1500;
    }
    else
    {
      v18 = 0;
    }
  }
  else if ( !*(_DWORD *)&gbIAmGreatest || gbHumanPlayer[gpGame->relatedToHeroForHireStatus[a1]] )
  {
    v18 = 0;
    v12 = 0;
    v9 = 0;
    v10 = (char *)&gpGame->heroes[a1];
    if ( gpGame->heroes[a1].occupiedObjType == 163 )
    {
      twn = (char *)&gpGame->castles[gpGame->heroes[a1].occupiedObjVal];
      v9 = (int)&gpGame->castles[gpGame->heroes[a1].occupiedObjVal].garrison;
      v12 = philAI::ValueOfTown(&gpGame->castles[gpGame->heroes[a1].occupiedObjVal]);
      v8 = *twn;
      if ( twn[1] >= 0 )
      {
        if ( gbHumanPlayer[twn[1]] )
          v7 = *(float *)&gfAttackHumanBonus;
        else
          v7 = *(float *)&gfAttackComputerBonus;
        v12 = (signed __int64)(((double)(5 - (signed int)gpGame->numPlayers) * 0.25 * v7 + 1.0) * (double)v12);
      }
    }
    else
    {
      v8 = -1;
    }
    HIDWORD(v5) = v10;
    LODWORD(v5) = v10 + 101;
    philAI::ProbableOutcomeOfBattle(
      (int)&gpCurAIHero->army,
      (int)gpCurAIHero,
      v5,
      v9,
      (unsigned int)v9 >= 1,
      v8,
      v10[3],
      (int)&v17,
      (int)&v16,
      (int *)&v15,
      (int *)&v14,
      (int *)&v13,
      &v18);
    *(_DWORD *)a5 = (signed __int64)(v17 * 100.0);
    if ( v12 > 0 )
      v18 = (signed __int64)((double)v12 * v17 + (double)v18);
    if ( gbHumanPlayer[v10[3]] && v18 > 200 )
    {
      if ( gpCurPlayer->personality )
        v18 = (signed __int64)((double)v18 * 1.5);
      else
        v18 *= 2;
    }
    if ( v17 <= 0.75 )
    {
      if ( v17 <= 0.5 )
      {
        if ( v17 <= 0.4 )
        {
          if ( v17 <= 0.3 )
          {
            if ( v17 <= 0.2 )
              gaiHeroLiveChance[a1] = (signed __int64)(v17 * 100.0);
            else
              gaiHeroLiveChance[a1] = (signed __int64)(v17 * 113.0);
          }
          else
          {
            gaiHeroLiveChance[a1] = (signed __int64)(v17 * 125.0);
          }
        }
        else
        {
          gaiHeroLiveChance[a1] = (signed __int64)(v17 * 130.0);
        }
      }
      else
      {
        gaiHeroLiveChance[a1] = (signed __int64)(v17 * 136.0);
      }
    }
    else
    {
      gaiHeroLiveChance[a1] = 100;
    }
    if ( gaiHeroLiveChance[a1] > 100 )
      gaiHeroLiveChance[a1] = 100;
    if ( !a4 && v17 < 0.4 )
      v18 = (signed __int64)((3.0 - v17 * 2.0) * (double)v18);
    if ( !a4 && v17 < 0.2 )
      v18 = (signed __int64)((2.0 - v17 * 2.0) * (double)v18);
    if ( v18 < 0 )
      gbReduceByReload = 0;
    gbReduceByBerserk = 0;
    if ( v18 > 0
      && 70 - 5 * gpGame->difficulty > giCurTurn
      && !(unsigned __int8)(*(&mapRevealed[a2] + a3 * MAP_WIDTH) & giCurPlayerBit) )
      v18 = 0;
  }
  else
  {
    v18 = 0;
    *(_DWORD *)a5 = 100;
  }
  return v18;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 51D5C0: using guessed type int gfAttackHumanBonus;
// 51D5C4: using guessed type int gfAttackComputerBonus;
// 532C54: using guessed type int giCurTurn;
// 532C5C: using guessed type char giCurPlayerBit;
// 532C60: using guessed type __int16 gaiHeroLiveChance[];
// 532CD0: using guessed type int gbReduceByBerserk;
// 532CD4: using guessed type int gbReduceByReload;

//----- (004B9DD0) --------------------------------------------------------
int __stdcall philAI::EvaluateTownEvent(int a1, int a2, int a3, int a4, int a5)
{
  __int64 v5; // ST08_8@25
  float v7; // [sp+2Ch] [bp-28h]@31
  signed int v8; // [sp+30h] [bp-24h]@24
  char v9; // [sp+34h] [bp-20h]@25
  char v10; // [sp+38h] [bp-1Ch]@25
  char v11; // [sp+3Ch] [bp-18h]@25
  char v12; // [sp+40h] [bp-14h]@25
  float v13; // [sp+44h] [bp-10h]@25
  int v14; // [sp+48h] [bp-Ch]@1
  town *this; // [sp+4Ch] [bp-8h]@1
  int v16; // [sp+50h] [bp-4h]@25

  v14 = 0;
  this = &gpGame->castles[a1];
  if ( gpGame->field_2773[a1] == gpCurAIHero->ownerIdx )
  {
    if ( this->visitingHeroIdx == -1 )
    {
      v14 = 0;
      if ( giCurTurn - *(_WORD *)&gpCurAIHero->field_7 >= 4 || gpCurAIHero->field_9 != this->idx )
      {
        philAI::HeroInteractionAtTown((int)gpCurAIHero, (signed int)this, 1, (int)&v14);
        v14 = (signed __int64)((double)v14 * *(float *)&dword_5304E8[gpCurAIHero->idx]);
      }
    }
    else if ( a4 )
    {
      v14 = -500;
    }
    else
    {
      v14 = 0;
    }
    gbReduceByReload = 0;
  }
  else if ( OnMySide(gpGame->field_2773[a1]) )
  {
    if ( a4 )
      v14 = -1500;
    else
      v14 = 0;
  }
  else if ( !*(_DWORD *)&gbIAmGreatest || gpGame->field_2773[a1] < 0 || gbHumanPlayer[gpGame->field_2773[a1]] )
  {
    if ( gpGame->difficulty >= 3
      || 40 - 8 * gpGame->difficulty <= giCurTurn
      || (unsigned __int8)(*(&mapRevealed[a2] + a3 * MAP_WIDTH) & giCurPlayerBit) )
    {
      v8 = philAI::ValueOfTown(this);
      if ( gpGame->castles[a1].visitingHeroIdx == -1 )
      {
        if ( town::HasGarrison(this) )
        {
          philAI::ProbableOutcomeOfBattle(
            (int)&gpCurAIHero->army,
            (int)gpCurAIHero,
            (unsigned int)&this->garrison,
            0,
            1,
            a1,
            this->ownerIdx,
            (int)&v13,
            (int)&v12,
            (int *)&v11,
            (int *)&v10,
            (int *)&v9,
            &v16);
        }
        else
        {
          v13 = 1.0;
          v16 = 0;
        }
      }
      else
      {
        HIDWORD(v5) = (char *)gpGame + 250 * this->visitingHeroIdx + 10180;
        LODWORD(v5) = (char *)gpGame + 250 * this->visitingHeroIdx + 10281;
        philAI::ProbableOutcomeOfBattle(
          (int)&gpCurAIHero->army,
          (int)gpCurAIHero,
          v5,
          (int)&this->garrison,
          1,
          a1,
          this->ownerIdx,
          (int)&v13,
          (int)&v12,
          (int *)&v11,
          (int *)&v10,
          (int *)&v9,
          &v16);
      }
      *(_DWORD *)a5 = (signed __int64)(v13 * 100.0);
      if ( this->ownerIdx >= 0 )
      {
        if ( gbHumanPlayer[this->ownerIdx] )
          v7 = *(float *)&gfAttackHumanBonus;
        else
          v7 = *(float *)&gfAttackComputerBonus;
        v8 = (signed __int64)(((double)(5 - (signed int)gpGame->numPlayers) * 0.25 + 0.9) * v7 * (double)v8);
      }
      v14 = (signed __int64)((double)v8 * v13 + (double)v16);
      if ( gpGame->field_2773[a1] != -1 )
        gbReduceByBerserk = 0;
    }
    else
    {
      v14 = 0;
    }
  }
  else
  {
    v14 = 0;
  }
  if ( this->ownerIdx != -1 && gbHumanPlayer[this->ownerIdx] && v14 > 200 )
  {
    if ( gpCurPlayer->personality )
      v14 = (signed __int64)((double)v14 * 1.3);
    else
      v14 = (signed __int64)((double)v14 * 1.6);
  }
  return v14;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 51D5C0: using guessed type int gfAttackHumanBonus;
// 51D5C4: using guessed type int gfAttackComputerBonus;
// 532C54: using guessed type int giCurTurn;
// 532C5C: using guessed type char giCurPlayerBit;
// 532CD0: using guessed type int gbReduceByBerserk;
// 532CD4: using guessed type int gbReduceByReload;

//----- (004BA260) --------------------------------------------------------
signed int __cdecl game::SetupCampaignGame()
{
  PlaySmacker(4);
  PlaySmacker(35);
  return 1;
}

//----- (004BA290) --------------------------------------------------------
signed int __cdecl game::SetupBaud()
{
  int v1; // [sp+Ch] [bp-18h]@6
  heroWindow *this; // [sp+1Ch] [bp-8h]@1
  heroWindow *window; // [sp+20h] [bp-4h]@2

  this = (heroWindow *)operator new(68);
  if ( this )
    window = heroWindow::heroWindow(this, 405, 8, "stpbaud.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  heroWindowManager::DoDialog(gpWindowManager, window, (int (__fastcall *)(tag_message *))SetupBaudHandler, 0);
  operator delete(window);
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        *((_DWORD *)&modemBaudRate + gbDirectConnect) = 2400;
        break;
      case 2:
        *((_DWORD *)&modemBaudRate + gbDirectConnect) = 9600;
        break;
      case 3:
        *((_DWORD *)&modemBaudRate + gbDirectConnect) = 19200;
        break;
      case 4:
        *((_DWORD *)&modemBaudRate + gbDirectConnect) = 38400;
        break;
      default:
        return 1;
    }
  }
  return 1;
}
// 4F7478: using guessed type int gbDirectConnect;

//----- (004BA3E0) --------------------------------------------------------
signed int __cdecl game::SetupComPort()
{
  signed int result; // eax@11
  int v1; // [sp+Ch] [bp-40h]@6
  heroWindow *this; // [sp+1Ch] [bp-30h]@1
  heroWindow *window; // [sp+20h] [bp-2Ch]@2
  char a2; // [sp+24h] [bp-28h]@18

  LogStr("SCP 1");
  this = (heroWindow *)operator new(68);
  if ( this )
    window = heroWindow::heroWindow(this, 405, 8, "stpcom.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  LogStr("SCP 2");
  heroWindowManager::DoDialog(gpWindowManager, window, (int (__fastcall *)(tag_message *))SetupComPortHandler, 0);
  operator delete(window);
  LogStr("SCP 3");
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        *((_DWORD *)&modemComPort + gbDirectConnect) = 1;
        break;
      case 2:
        *((_DWORD *)&modemComPort + gbDirectConnect) = 2;
        break;
      case 3:
        *((_DWORD *)&modemComPort + gbDirectConnect) = 3;
        break;
      case 4:
        *((_DWORD *)&modemComPort + gbDirectConnect) = 4;
        break;
      default:
        break;
    }
  }
  LogStr("SCP 4");
  if ( game::SetupBaud() )
  {
    LogStr("SCP 5");
    if ( !gbDirectConnect )
    {
      strcpy((char *)&gConfig + 174, "ATZ");
      sprintf(gText, "%s", &gConfig + 174);
      GetDataEntry(
        "Please enter any special initialization string required by your modem, or hit 'ENTER' to accept the default.",
        (int)&a2,
        40,
        gText,
        0,
        1);
      strcpy((char *)&gConfig + 174, &a2);
    }
    WritePrefs();
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F7478: using guessed type int gbDirectConnect;

//----- (004BA5E0) --------------------------------------------------------
signed int __cdecl game::SetupHotSeatGame()
{
  int v1; // [sp+Ch] [bp-34h]@6
  heroWindow *this; // [sp+1Ch] [bp-24h]@1
  char a1; // [sp+20h] [bp-20h]@23
  int window; // [sp+38h] [bp-8h]@2
  int i; // [sp+3Ch] [bp-4h]@16

  this = (heroWindow *)operator new(68);
  if ( this )
    window = (int)heroWindow::heroWindow(this, 405, 8, "stphotst.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))SetupHotSeatGameHandler,
    0);
  operator delete((void *)window);
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        iLastMsgNumHumanPlayers = 2;
        break;
      case 2:
        iLastMsgNumHumanPlayers = 3;
        break;
      case 3:
        iLastMsgNumHumanPlayers = 4;
        break;
      case 4:
        iLastMsgNumHumanPlayers = 5;
        break;
      case 5:
        iLastMsgNumHumanPlayers = 6;
        break;
      default:
        break;
    }
  }
  for ( i = 0; i < 6; ++i )
    strcpy(cPlayerNames[i], byte_51DA2C);
  if ( !giSetupGameType )
  {
    sprintf(gText, "Do you wish to enter each player's name?");
    NormalDialog(gText, 2, -1, -1, -1, 0, -1, 0, -1, 0);
    if ( gpWindowManager->buttonPressedCode == 30725 )
    {
      for ( i = 0; i < iLastMsgNumHumanPlayers; ++i )
      {
        strcpy(&a1, byte_51DA5C);
        sprintf(gText, "Enter player %d's name.", i + 1);
        GetDataEntry(gText, (int)cPlayerNames[i], 20, &a1, 0, 1);
      }
    }
  }
  return 1;
}
// 523004: using guessed type char giSetupGameType;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;

//----- (004BA820) --------------------------------------------------------
signed int __cdecl game::SetupNetworkGame()
{
  int v1; // [sp+Ch] [bp-34h]@8
  heroWindow *this; // [sp+1Ch] [bp-24h]@1
  int evt; // [sp+20h] [bp-20h]@7
  int v4; // [sp+24h] [bp-1Ch]@7
  int v5; // [sp+28h] [bp-18h]@7
  int v6; // [sp+38h] [bp-8h]@7
  int window; // [sp+3Ch] [bp-4h]@2

  this = (heroWindow *)operator new(68);
  if ( this )
    window = (int)heroWindow::heroWindow(this, 405, 8, "stpnet.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  if ( gbNoCDRom )
  {
    evt = 512;
    v4 = 5;
    v5 = 1;
    v6 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))SetupNetworkGameHandler,
    0);
  operator delete((void *)window);
  v1 = gpWindowManager->buttonPressedCode;
  switch ( v1 )
  {
    case 1:
      iMPExtendedType = 1;
      break;
    case 2:
      iMPExtendedType = 2;
      break;
    case 30721:
      return 0;
  }
  return 1;
}
// 4F1CBC: using guessed type int gbNoCDRom;
// 523ED8: using guessed type int iMPExtendedType;

//----- (004BA950) --------------------------------------------------------
bool __cdecl game::SetupNetworkGame2()
{
  int v1; // [sp+Ch] [bp-ECh]@11
  heroWindow *this; // [sp+1Ch] [bp-DCh]@1
  int v3; // [sp+20h] [bp-D8h]@10
  int v4; // [sp+24h] [bp-D4h]@10
  int v5; // [sp+28h] [bp-D0h]@10
  int v6; // [sp+38h] [bp-C0h]@10
  int evt; // [sp+3Ch] [bp-BCh]@8
  int v8; // [sp+40h] [bp-B8h]@8
  int v9; // [sp+44h] [bp-B4h]@8
  int v10; // [sp+54h] [bp-A4h]@8
  int window; // [sp+58h] [bp-A0h]@2
  int v12; // [sp+5Ch] [bp-9Ch]@6
  HMODULE v13; // [sp+60h] [bp-98h]@9
  struct _OSVERSIONINFOA VersionInformation; // [sp+64h] [bp-94h]@6

  this = (heroWindow *)operator new(68);
  if ( this )
    window = (int)heroWindow::heroWindow(this, 405, 8, "stpnet2.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  memset(&VersionInformation, 0, 0x94u);
  VersionInformation.dwOSVersionInfoSize = 148;
  v12 = GetVersionExA(&VersionInformation);
  LogInt((int)"Version", v12, VersionInformation.dwPlatformId, -999, -999, -999, -999, -999);
  if ( v12 && VersionInformation.dwPlatformId == 2 )
  {
    evt = 512;
    v8 = 5;
    v10 = 4096;
    v9 = 3;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  v13 = 0;
  v13 = LoadLibraryA("DPLAYX.DLL");
  if ( !v13 )
  {
    v3 = 512;
    v4 = 5;
    v6 = 4096;
    v5 = 1;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&v3);
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))SetupNetworkGame2Handler,
    0);
  operator delete((void *)window);
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        iMPNetProtocol = 1;
        break;
      case 2:
        iMPNetProtocol = 2;
        break;
      case 3:
        iMPNetProtocol = 3;
        break;
      case 4:
        iMPNetProtocol = 4;
        break;
      default:
        return game::SetupNetworkGame() != 0;
    }
  }
  return game::SetupNetworkGame() != 0;
}
// 4F31B4: using guessed type int iMPNetProtocol;

//----- (004BABF0) --------------------------------------------------------
signed int __cdecl game::SetupModemGame()
{
  int v1; // [sp+Ch] [bp-40h]@23
  heroWindow *v2; // [sp+1Ch] [bp-30h]@16
  heroWindow *v3; // [sp+20h] [bp-2Ch]@12
  heroWindow *v4; // [sp+24h] [bp-28h]@7
  heroWindow *this; // [sp+28h] [bp-24h]@3
  int evt; // [sp+2Ch] [bp-20h]@22
  int v7; // [sp+30h] [bp-1Ch]@22
  int v8; // [sp+34h] [bp-18h]@22
  int v9; // [sp+44h] [bp-8h]@22
  int window; // [sp+48h] [bp-4h]@4

  LogStr("SMC 1");
  if ( gbDirectConnect )
  {
    if ( *((_DWORD *)&modemComPort + gbDirectConnect) )
    {
      v4 = (heroWindow *)operator new(68);
      if ( v4 )
        window = (int)heroWindow::heroWindow(v4, 405, 8, "stpdccfg.bin");
      else
        window = 0;
    }
    else
    {
      this = (heroWindow *)operator new(68);
      if ( this )
        window = (int)heroWindow::heroWindow(this, 405, 8, "stpdc.bin");
      else
        window = 0;
    }
  }
  else if ( *((_DWORD *)&modemComPort + gbDirectConnect) )
  {
    v2 = (heroWindow *)operator new(68);
    if ( v2 )
      window = (int)heroWindow::heroWindow(v2, 405, 8, "stpmcfg.bin");
    else
      window = 0;
  }
  else
  {
    v3 = (heroWindow *)operator new(68);
    if ( v3 )
      window = (int)heroWindow::heroWindow(v3, 405, 8, "stpmodem.bin");
    else
      window = 0;
  }
  if ( !window )
    MemError();
  LogStr("SMC 2");
  if ( gbNoCDRom )
  {
    evt = 512;
    v7 = 5;
    v8 = 1;
    v9 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  LogStr("SMC 3");
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))SetupModemGameHandler,
    0);
  LogStr("SMC 4");
  operator delete((void *)window);
  LogStr("SMC 5");
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        LogStr("SMC 6");
        iMPExtendedType = 3;
        if ( !*((_DWORD *)&modemComPort + gbDirectConnect) )
        {
          LogStr("SMC 7");
          if ( !game::SetupComPort() )
            return 0;
          LogStr("SMC 8");
        }
        LogStr("SMC 9");
        if ( !gbDirectConnect )
          GetDataEntry("Please enter the telephone number.", (int)&numbuf, 35, 0, 0, 1);
        LogStr("SMC a");
        break;
      case 2:
        iMPExtendedType = 4;
        if ( !*((_DWORD *)&modemComPort + gbDirectConnect) && !game::SetupComPort() )
          return 0;
        break;
      case 3:
        gbDoModemConfig = 1;
        break;
    }
  }
  return 1;
}
// 4F1CBC: using guessed type int gbNoCDRom;
// 4F7478: using guessed type int gbDirectConnect;
// 51D960: using guessed type int gbDoModemConfig;
// 523ED8: using guessed type int iMPExtendedType;

//----- (004BAF10) --------------------------------------------------------
signed int __cdecl game::SetupMultiPlayerGame()
{
  int v1; // [sp+Ch] [bp-38h]@8
  heroWindow *this; // [sp+1Ch] [bp-28h]@1
  signed int v3; // [sp+20h] [bp-24h]@17
  int evt; // [sp+24h] [bp-20h]@7
  int v5; // [sp+28h] [bp-1Ch]@7
  int v6; // [sp+2Ch] [bp-18h]@7
  int v7; // [sp+3Ch] [bp-8h]@7
  int window; // [sp+40h] [bp-4h]@2

  this = (heroWindow *)operator new(68);
  if ( this )
    window = (int)heroWindow::heroWindow(this, 405, 8, "stpmp.bin");
  else
    window = 0;
  if ( !window )
    MemError();
  if ( gbNoCDRom )
  {
    evt = 512;
    v5 = 5;
    v6 = 1;
    v7 = 4096;
    heroWindow::BroadcastMessage((heroWindow *)window, (tag_message *)&evt);
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)window,
    (int (__fastcall *)(tag_message *))SetupMultiPlayerGameHandler,
    0);
  operator delete((void *)window);
  gbDirectConnect = 0;
  v1 = gpWindowManager->buttonPressedCode;
  if ( v1 <= 30721 )
  {
    if ( v1 == 30721 )
      return 0;
    switch ( v1 )
    {
      case 1:
        iMPBaseType = 2;
        if ( game::SetupHotSeatGame() )
          return 1;
        return 0;
      case 2:
        iMPBaseType = 1;
        if ( game::SetupNetworkGame2() )
          return 1;
        return 0;
      case 4:
        gbDirectConnect = 1;
        break;
      case 3:
        gbDirectConnect = 0;
        break;
      default:
        return 1;
    }
    iMPBaseType = 0;
    v3 = 1;
    LogStr("Common Modem 1");
    while ( v3 )
    {
      LogStr("Common Modem 2");
      if ( !game::SetupModemGame() )
        return 0;
      LogStr("Common Modem 3");
      if ( gbDoModemConfig )
      {
        LogStr("Common Modem 4");
        gbDoModemConfig = 0;
        if ( !game::SetupComPort() )
          return 0;
        LogStr("Common Modem 5");
      }
      else
      {
        v3 = 0;
      }
      LogStr("Common Modem 6");
    }
    LogStr("Common Modem 7");
  }
  return 1;
}
// 4F1CBC: using guessed type int gbNoCDRom;
// 4F7478: using guessed type int gbDirectConnect;
// 51D960: using guessed type int gbDoModemConfig;
// 524778: using guessed type int iMPBaseType;

//----- (004BB170) --------------------------------------------------------
int __thiscall game::SetupGame(game *this)
{
  int v1; // eax@49
  int v3; // [sp+Ch] [bp-5Ch]@45
  int v4; // [sp+10h] [bp-58h]@32
  signed int v5; // [sp+14h] [bp-54h]@25
  heroWindow *v6; // [sp+30h] [bp-38h]@40
  heroWindow *v7; // [sp+38h] [bp-30h]@27
  heroWindow *thisa; // [sp+40h] [bp-28h]@18
  tag_message evt; // [sp+44h] [bp-24h]@24
  int window; // [sp+60h] [bp-8h]@19
  int v11; // [sp+64h] [bp-4h]@1

  LogStr("Setup 0");
  v11 = 1;
  xIsPlayingExpansionCampaign = 0;
  LOBYTE(xIsExpansionMap) = 0;
  gbInCampaign = 0;
  *(_DWORD *)gbCampaignSideChoice = 0;
  iMPExtendedType = 10;
  iMPBaseType = 10;
  iLastMsgNumHumanPlayers = 1;
  gbWaitForRemoteReceive = 0;
  gbDirectConnect = 0;
  gbInSetupDialog = 1;
  if ( giMenuCommand == -1 )
  {
    thisa = (heroWindow *)operator new(68);
    if ( thisa )
      window = (int)heroWindow::heroWindow(thisa, 405, 8, "stpnewgm.bin");
    else
      window = 0;
    if ( !window )
      MemError();
    if ( gbNoCDRom )
    {
      evt.eventCode = INPUT_GUI_MESSAGE_CODE;
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4096;
      evt.yCoordOrFieldID = 1;
      heroWindow::BroadcastMessage((heroWindow *)window, &evt);
      evt.yCoordOrFieldID = 2;
      heroWindow::BroadcastMessage((heroWindow *)window, &evt);
    }
    heroWindowManager::DoDialog(
      gpWindowManager,
      (heroWindow *)window,
      (int (__fastcall *)(tag_message *))SetupGameHandler,
      0);
    operator delete((void *)window);
    v5 = LOWORD(gpWindowManager->buttonPressedCode);
    if ( v5 <= 30721 )
    {
      if ( v5 == 30721 )
      {
        v11 = 0;
        goto LABEL_69;
      }
      if ( v5 != 1 )
      {
        if ( v5 == 2 )
        {
          if ( (unsigned __int8)giSetupGameType == 1 )
          {
            v7 = (heroWindow *)operator new(68);
            if ( v7 )
              window = (int)heroWindow::heroWindow(v7, 405, 8, "x_loadcm.bin");
            else
              window = 0;
            if ( !window )
              MemError();
            heroWindowManager::DoDialog(
              gpWindowManager,
              (heroWindow *)window,
              (int (__fastcall *)(tag_message *))ExpLoadCampaignHandler,
              0);
            operator delete((void *)window);
            v4 = LOWORD(gpWindowManager->buttonPressedCode);
            switch ( v4 )
            {
              case 1:
                gbInCampaign = 1;
                break;
              case 2:
                xIsPlayingExpansionCampaign = 1;
                LOBYTE(xIsExpansionMap) = 1;
                break;
              case 30721:
                v11 = 0;
                goto LABEL_69;
            }
          }
          else
          {
            v6 = (heroWindow *)operator new(68);
            if ( v6 )
              window = (int)heroWindow::heroWindow(v6, 405, 8, "x_loadcm.bin");
            else
              window = 0;
            if ( !window )
              MemError();
            heroWindowManager::DoDialog(
              gpWindowManager,
              (heroWindow *)window,
              (int (__fastcall *)(tag_message *))ExpLoadCampaignHandler,
              0);
            operator delete((void *)window);
            v3 = LOWORD(gpWindowManager->buttonPressedCode);
            switch ( v3 )
            {
              case 1:
                gbInCampaign = 1;
                if ( !game::SetupCampaignGame() )
                {
                  v11 = 0;
                  goto LABEL_69;
                }
                break;
              case 2:
                xIsPlayingExpansionCampaign = 1;
                LOBYTE(xIsExpansionMap) = 1;
                v1 = ExpCampaign::Choose();
                ExpCampaign::InitNewCampaign((int)&xCampaign, v1);
                break;
              case 30721:
                v11 = 0;
                goto LABEL_69;
            }
          }
        }
        else if ( v5 == 3 && !game::SetupMultiPlayerGame() )
        {
          v11 = 0;
          goto LABEL_69;
        }
      }
    }
    LogStr(" Setup 1");
    if ( iMPBaseType == 1 || !iMPBaseType )
    {
      LogStr(" Setup 2");
      RemoteMain((void *)iMPExtendedType);
      LogStr(" Setup 3");
      if ( iMPExtendedType == 2 || iMPExtendedType == 4 )
        gbWaitForRemoteReceive = 1;
    }
  }
  else
  {
    switch ( giMenuCommand )
    {
      case 40110:
      case 40127:
        iLastMsgNumHumanPlayers = 2;
        iMPBaseType = 2;
        break;
      case 40111:
      case 40128:
        iLastMsgNumHumanPlayers = 3;
        iMPBaseType = 2;
        break;
      case 40112:
      case 40129:
        iLastMsgNumHumanPlayers = 4;
        iMPBaseType = 2;
        break;
      case 40114:
      case 40131:
        iMPBaseType = 1;
        iMPExtendedType = 1;
        goto LABEL_12;
      case 40115:
      case 40132:
        iMPBaseType = 1;
        iMPExtendedType = 2;
        goto LABEL_12;
      case 40117:
      case 40134:
        iMPBaseType = 0;
        iMPExtendedType = 3;
        goto LABEL_12;
      case 40118:
      case 40135:
        iMPBaseType = 0;
        iMPExtendedType = 4;
        goto LABEL_12;
      case 40120:
      case 40137:
        iMPBaseType = 0;
        iMPExtendedType = 3;
        gbDirectConnect = 1;
        goto LABEL_12;
      case 40121:
      case 40138:
        iMPBaseType = 0;
        iMPExtendedType = 4;
        gbDirectConnect = 1;
LABEL_12:
        LogStr("Setup 0a");
        RemoteMain((void *)iMPExtendedType);
        if ( iMPExtendedType == 2 || iMPExtendedType == 4 )
          gbWaitForRemoteReceive = 1;
        break;
      case 40102:
      case 40123:
        break;
    }
    giMenuCommand = -1;
    v11 = 1;
  }
LABEL_69:
  gbInSetupDialog = 0;
  return v11;
}
// 4F19A8: using guessed type int giMenuCommand;
// 4F1CBC: using guessed type int gbNoCDRom;
// 4F307C: using guessed type int gbInSetupDialog;
// 4F7478: using guessed type int gbDirectConnect;
// 523004: using guessed type char giSetupGameType;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523ED8: using guessed type int iMPExtendedType;
// 523F08: using guessed type int gbWaitForRemoteReceive;
// 524778: using guessed type int iMPBaseType;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (004BB840) --------------------------------------------------------
signed int __cdecl game::PickLoadGame()
{
  signed int result; // eax@2
  int v1; // [sp+Ch] [bp-40h]@15
  fileRequester *v2; // [sp+28h] [bp-24h]@25
  heroWindow *this; // [sp+30h] [bp-1Ch]@10
  heroWindow *window; // [sp+34h] [bp-18h]@11
  char a7; // [sp+3Ch] [bp-10h]@4
  baseManager *a2; // [sp+48h] [bp-4h]@26

  if ( gbWaitForRemoteReceive )
    return 1;
  if ( gbInCampaign )
  {
    sprintf(&a7, "*.GMC");
  }
  else if ( xIsPlayingExpansionCampaign )
  {
    sprintf(&a7, "*.GXC");
  }
  else if ( gbRemoteOn && xNetHasOldPlayers )
  {
    NormalDialog(
      "At least one player does not have the Heroes II Expansion set.  You will only be able to choose from original Heroes II games.",
      1,
      -1,
      -1,
      -1,
      0,
      -1,
      0,
      -1,
      0);
    sprintf(&a7, "*.GM%d", iLastMsgNumHumanPlayers);
  }
  else
  {
    this = (heroWindow *)operator new(68);
    if ( this )
      window = heroWindow::heroWindow(this, 405, 8, "x_mapmnu.bin");
    else
      window = 0;
    if ( !window )
      MemError();
    heroWindowManager::DoDialog(gpWindowManager, window, (int (__fastcall *)(tag_message *))ExpStdGameHandler, 0);
    operator delete(window);
    v1 = LOWORD(gpWindowManager->buttonPressedCode);
    switch ( v1 )
    {
      case 1:
        LOBYTE(xIsExpansionMap) = 0;
        break;
      case 2:
        LOBYTE(xIsExpansionMap) = 1;
        break;
      case 30721:
        return 0;
    }
    if ( xIsExpansionMap )
      sprintf(&a7, "*.GX%d", iLastMsgNumHumanPlayers);
    else
      sprintf(&a7, "*.GM%d", iLastMsgNumHumanPlayers);
  }
  v2 = (fileRequester *)operator new(1071);
  if ( v2 )
    a2 = (baseManager *)fileRequester::fileRequester(v2, 200, 58, 2, &a7, ".\\GAMES\\", &a7);
  else
    a2 = 0;
  if ( !a2 )
    MemError();
  if ( executive::DoDialog(gpExec, a2) == BUTTON_OK )
  {
    game::LoadGame(gpGame, gLastFilename, 0, 0);
    operator delete(a2);
    result = 1;
  }
  else
  {
    operator delete(a2);
    result = 0;
  }
  return result;
}
// 4F7494: using guessed type int gbRemoteOn;
// 51AC64: using guessed type char xNetHasOldPlayers;
// 5235D4: using guessed type int iLastMsgNumHumanPlayers;
// 523F08: using guessed type int gbWaitForRemoteReceive;
// 5304A0: using guessed type char xIsPlayingExpansionCampaign;

//----- (004BBAF0) --------------------------------------------------------
signed int __thiscall SetupCampaignGameHandler(void *this)
{
  return BaseSetupHandler(this);
}

//----- (004BBB10) --------------------------------------------------------
signed int __thiscall SetupComPortHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      if ( v2 == 30721 )
      {
        v4 = 4;
      }
      else
      {
        switch ( v2 )
        {
          case 1:
            v4 = 0;
            break;
          case 2:
            v4 = 1;
            break;
          case 3:
            v4 = 2;
            break;
          case 4:
            v4 = 3;
            break;
          default:
            break;
        }
      }
    }
    if ( v4 >= 0 )
    {
      if ( gbDirectConnect )
        NormalDialog((&gSetupDCComPortHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      else
        NormalDialog((&gSetupComPortHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
  return BaseSetupHandler(v3);
}
// 4F7478: using guessed type int gbDirectConnect;

//----- (004BBC50) --------------------------------------------------------
signed int __thiscall SetupBaudHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      if ( v2 == 30721 )
      {
        v4 = 4;
      }
      else
      {
        switch ( v2 )
        {
          case 1:
            v4 = 0;
            break;
          case 2:
            v4 = 1;
            break;
          case 3:
            v4 = 2;
            break;
          case 4:
            v4 = 3;
            break;
          default:
            break;
        }
      }
    }
    if ( v4 >= 0 )
    {
      if ( gbDirectConnect )
        NormalDialog((&gSetupDCBaudHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      else
        NormalDialog((&gSetupBaudHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
  return BaseSetupHandler(v3);
}
// 4F7478: using guessed type int gbDirectConnect;

//----- (004BBD90) --------------------------------------------------------
signed int __thiscall SetupHotSeatGameHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      if ( v2 == 30721 )
      {
        v4 = 5;
      }
      else
      {
        switch ( v2 )
        {
          case 1:
            v4 = 0;
            break;
          case 2:
            v4 = 1;
            break;
          case 3:
            v4 = 2;
            break;
          case 4:
            v4 = 3;
            break;
          case 5:
            v4 = 4;
            break;
          default:
            break;
        }
      }
    }
    if ( v4 >= 0 )
      NormalDialog((&gSetupHotSeatGameHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BBEB0) --------------------------------------------------------
signed int __thiscall SetupModemGameHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      switch ( v2 )
      {
        case 30721:
          v4 = 3;
          break;
        case 1:
          v4 = 0;
          break;
        case 2:
          v4 = 1;
          break;
        case 3:
          v4 = 2;
          break;
      }
    }
    if ( v4 >= 0 )
    {
      if ( gbDirectConnect )
        NormalDialog((&gSetupDCGameHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
      else
        NormalDialog((&gSetupModemGameHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
    }
  }
  return BaseSetupHandler(v3);
}
// 4F7478: using guessed type int gbDirectConnect;

//----- (004BBFE0) --------------------------------------------------------
signed int __thiscall SetupMultiPlayerGameHandler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      if ( v2 == 30721 )
      {
        v4 = 4;
      }
      else
      {
        switch ( v2 )
        {
          case 1:
            v4 = 0;
            break;
          case 2:
            v4 = 1;
            break;
          case 3:
            v4 = 2;
            break;
          case 4:
            v4 = 3;
            break;
          default:
            break;
        }
      }
    }
    if ( v4 >= 0 )
      NormalDialog((&gSetupMultiPlayerGameHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC0F0) --------------------------------------------------------
signed int __thiscall SetupNetworkGameHandler(void *this)
{
  int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    switch ( v2 )
    {
      case 1:
        v4 = 0;
        break;
      case 2:
        v4 = 1;
        break;
      case 30721:
        v4 = 2;
        break;
    }
    if ( v4 >= 0 )
      NormalDialog((&xSetupCampaignGameHelp)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC1D0) --------------------------------------------------------
signed int __thiscall SetupNetworkGame2Handler(void *this)
{
  signed int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= 30721 )
    {
      switch ( v2 )
      {
        case 30721:
          v4 = 3;
          break;
        case 1:
          v4 = 0;
          break;
        case 2:
          v4 = 1;
          break;
        case 3:
          v4 = 2;
          break;
      }
    }
    if ( v4 >= 0 )
      NormalDialog((&gSetupNetworkGame2Help)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC2D0) --------------------------------------------------------
signed int __thiscall SetupGameHandler(void *this)
{
  CREATURE_FLAGS v2; // [sp+14h] [bp-Ch]@4
  void *v3; // [sp+18h] [bp-8h]@1
  signed int v4; // [sp+1Ch] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    if ( v2 <= (CREATURE_PETRIFIED|CREATURE_BROWN|TWO_HEXER|0x1800) )
    {
      switch ( v2 )
      {
        case CREATURE_PETRIFIED|CREATURE_BROWN|TWO_HEXER|0x1800:
          v4 = 3;
          break;
        case TWO_HEXER:
          v4 = 0;
          break;
        case FLYER:
          v4 = 1;
          break;
        case FLYER|TWO_HEXER:
          v4 = 2;
          break;
      }
    }
    if ( v4 >= 0 )
      NormalDialog((&xSetupStandardGameHelp)[4 * v4], TRANSIENT_FOR_RIGHT_CLICKS, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC420) --------------------------------------------------------
signed int __thiscall ExpNewCampaignHandler(int this)
{
  int v2; // [sp+Ch] [bp-Ch]@4
  int v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *(_BYTE *)(this + 13) & 2 && (*(_DWORD *)(this + 4) == 12 || *(_DWORD *)(this + 4) == 14) )
  {
    v4 = -1;
    v2 = *(_DWORD *)(this + 8);
    switch ( v2 )
    {
      case 1:
        v4 = 0;
        break;
      case 2:
        v4 = 1;
        break;
      case 30721:
        v4 = 2;
        break;
    }
    if ( v4 >= 0 )
      NormalDialog((&off_51A720)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler((void *)v3);
}

//----- (004BC500) --------------------------------------------------------
signed int __thiscall ExpLoadCampaignHandler(void *this)
{
  int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    switch ( v2 )
    {
      case 1:
        v4 = 0;
        break;
      case 2:
        v4 = 1;
        break;
      case 30721:
        v4 = 2;
        break;
    }
    if ( v4 >= 0 )
      NormalDialog((&off_51A720)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC5E0) --------------------------------------------------------
signed int __thiscall ExpStdGameHandler(void *this)
{
  int v2; // [sp+Ch] [bp-Ch]@4
  void *v3; // [sp+10h] [bp-8h]@1
  signed int v4; // [sp+14h] [bp-4h]@4

  v3 = this;
  if ( *((_BYTE *)this + 13) & 2 && (*((_DWORD *)this + 1) == 12 || *((_DWORD *)this + 1) == 14) )
  {
    v4 = -1;
    v2 = *((_DWORD *)this + 2);
    switch ( v2 )
    {
      case 1:
        v4 = 0;
        break;
      case 2:
        v4 = 1;
        break;
      case 30721:
        v4 = 2;
        break;
    }
    if ( v4 >= 0 )
      NormalDialog((&off_51A730)[4 * v4], 4, -1, -1, -1, 0, -1, 0, -1, 0);
  }
  return BaseSetupHandler(v3);
}

//----- (004BC6C0) --------------------------------------------------------
signed int __thiscall BaseSetupHandler(void *this)
{
  signed int result; // eax@13
  void *v2; // [sp+10h] [bp-8h]@1
  signed int v3; // [sp+14h] [bp-4h]@1

  v2 = this;
  v3 = 0;
  PollSound();
  if ( *(_DWORD *)v2 == 512
    && *((_DWORD *)v2 + 1) == 13
    && (*((_DWORD *)v2 + 2) > 0 && *((_DWORD *)v2 + 2) <= 1000 || *((_DWORD *)v2 + 2) == 30721) )
    v3 = 1;
  if ( v3 || giMenuCommand != -1 )
  {
    gpWindowManager->buttonPressedCode = *((_DWORD *)v2 + 2);
    *((_DWORD *)v2 + 2) = 10;
    *((_DWORD *)v2 + 1) = *((_DWORD *)v2 + 2);
    if ( giMenuCommand != -1 )
      gpWindowManager->buttonPressedCode = 30721;
    result = 2;
  }
  else
  {
    CheckShingleUpdate();
    result = 1;
  }
  return result;
}
// 4F19A8: using guessed type int giMenuCommand;

//----- (004BC7B0) --------------------------------------------------------
int __fastcall add_node(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 4) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = a2;
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 4);
    result = a2;
    *(_DWORD *)(a1 + 4) = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 4) = a2;
    result = *(_DWORD *)(a1 + 4);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (004BC830) --------------------------------------------------------
int __thiscall pop_node(int this)
{
  int v2; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
    *(_DWORD *)this = *(_DWORD *)(v2 + 4);
  if ( !*(_DWORD *)this )
    *(_DWORD *)(this + 4) = 0;
  return v2;
}

//----- (004BC880) --------------------------------------------------------
int __thiscall init_anchor(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)this = 0;
  result = this;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (004BC8B0) --------------------------------------------------------
void __thiscall ShutdownComError(void *this)
{
  void *v1; // [sp+10h] [bp-260h]@1
  char thisa; // [sp+14h] [bp-25Ch]@22
  DWORD v3; // [sp+208h] [bp-68h]@1
  char a1; // [sp+20Ch] [bp-64h]@2

  v1 = this;
  v3 = GetLastError();
  switch ( v3 )
  {
    case 1u:
      strcpy(&a1, "ERROR_INVALID_FUNCTION    ");
      break;
    case 2u:
      strcpy(&a1, "ERROR_FILE_NOT_FOUND      ");
      break;
    case 3u:
      strcpy(&a1, "ERROR_PATH_NOT_FOUND      ");
      break;
    case 4u:
      strcpy(&a1, "ERROR_TOO_MANY_OPEN_FILES ");
      break;
    case 5u:
      strcpy(&a1, "ERROR_ACCESS_DENIED       ");
      break;
    case 6u:
      strcpy(&a1, "ERROR_INVALID_HANDLE      ");
      break;
    case 7u:
      strcpy(&a1, "ERROR_ARENA_TRASHED       ");
      break;
    case 8u:
      strcpy(&a1, "ERROR_NOT_ENOUGH_MEMORY   ");
      break;
    case 9u:
      strcpy(&a1, "ERROR_INVALID_BLOCK       ");
      break;
    case 0xAu:
      strcpy(&a1, "ERROR_BAD_ENVIRONMENT     ");
      break;
    case 0xBu:
      strcpy(&a1, "ERROR_BAD_FORMAT          ");
      break;
    case 0xCu:
      strcpy(&a1, "ERROR_INVALID_ACCESS      ");
      break;
    case 0xDu:
      strcpy(&a1, "ERROR_INVALID_DATA        ");
      break;
    case 0xFu:
      strcpy(&a1, "ERROR_INVALID_DRIVE       ");
      break;
    case 0x10u:
      strcpy(&a1, "ERROR_CURRENT_DIRECTORY   ");
      break;
    case 0x11u:
      strcpy(&a1, "ERROR_NOT_SAME_DEVICE     ");
      break;
    case 0x12u:
      strcpy(&a1, "ERROR_NO_MORE_FILES       ");
      break;
    case 0xB7u:
      strcpy(&a1, "ERROR_ALREADY_EXISTS      ");
      break;
    default:
      strcpy(&a1, "UNKNOWN_ERROR             ");
      break;
  }
  sprintf(&thisa, cWinComError, v1, v3, &a1);
  strcat(&thisa, off_4F6FAC);
  strcat(&thisa, off_4F6FB0);
  strcat(&thisa, off_4F6FB4);
  strcat(&thisa, off_4F6FB8);
  strcat(&thisa, off_4F6FBC);
  ShutDown(&thisa);
}

//----- (004BCC50) --------------------------------------------------------
signed __int16 __fastcall com_init(unsigned __int8 a1, DWORD a2, int a3)
{
  signed __int16 result; // ax@9
  DWORD v4; // [sp+10h] [bp-50h]@1
  unsigned __int8 v5; // [sp+14h] [bp-4Ch]@1
  struct _COMMTIMEOUTS CommTimeouts; // [sp+18h] [bp-48h]@27
  CHAR FileName; // [sp+2Ch] [bp-34h]@10
  struct _DCB aDCB; // [sp+38h] [bp-28h]@12
  int v9; // [sp+54h] [bp-Ch]@23
  int i; // [sp+58h] [bp-8h]@1

  v4 = a2;
  v5 = a1;
  for ( i = 0; i < 2; ++i )
    dword_532CF0[24 * i] = -1;
  for ( i = 0; i < 2 && dword_532CF0[24 * i] != -1; ++i )
    ;
  if ( i < 2 )
  {
    _wsprintfA(&FileName, "COM%d", a1);
    dword_532CF0[24 * i] = (int)CreateFileA(&FileName, 0xC0000000u, 0, 0, 3u, 0, 0);
    if ( dword_532CF0[24 * i] == -1 )
    {
      sprintf(gText, "Opening COM%d", v5);
      ShutdownComError(gText);
      result = -1;
    }
    else
    {
      aDCB.DCBlength = 28;
      GetCommState((HANDLE)dword_532CF0[24 * i], &aDCB);
      memcpy(&dword_532CF8[24 * i], &aDCB, 0x1Cu);
      GetCommTimeouts((HANDLE)dword_532CF0[24 * i], (LPCOMMTIMEOUTS)&dword_532CF0[24 * i + 9]);
      switch ( v4 )
      {
        case 1u:
          aDCB.BaudRate = 2400;
          break;
        case 2u:
          aDCB.BaudRate = 4800;
          break;
        case 3u:
          aDCB.BaudRate = 9600;
          break;
        case 4u:
          aDCB.BaudRate = 19200;
          break;
        case 5u:
          aDCB.BaudRate = 38400;
          break;
        default:
          aDCB.BaudRate = v4;
          break;
      }
      aDCB.fDummy2 &= 0xFFFFFFFDu;
      aDCB.fDummy2 |= 4u;
      if ( a3 )
        aDCB.fDummy2 |= 8u;
      else
        aDCB.fDummy2 &= 0xFFFFFFF7u;
      aDCB.fDummy2 = aDCB.fDummy2 & 0xFFFFFFDF | 0x10;
      aDCB.fDummy2 &= 0xFFFFFDFFu;
      aDCB.fDummy2 &= 0xFFFFFEFFu;
      aDCB.fDummy2 &= 0xFFFFF7FFu;
      aDCB.fDummy2 = aDCB.fDummy2 & 0xFFFFEFFF | 0x2000;
      aDCB.fDummy2 |= 0x4000u;
      aDCB.ByteSize = 8;
      aDCB.Parity = 0;
      aDCB.StopBits = 0;
      v9 = SetupComm((HANDLE)dword_532CF0[24 * i], 0x2000u, 0x1000u);
      if ( !v9 )
        ShutdownComError("Initialize communications paramaters");
      v9 = SetCommState((HANDLE)dword_532CF0[24 * i], &aDCB);
      if ( !v9 )
        ShutdownComError("Configure communications device");
      CommTimeouts.ReadIntervalTimeout = -1;
      CommTimeouts.ReadTotalTimeoutConstant = 0;
      CommTimeouts.ReadTotalTimeoutMultiplier = 0;
      CommTimeouts.WriteTotalTimeoutConstant = 0;
      CommTimeouts.WriteTotalTimeoutMultiplier = 0;
      v9 = SetCommTimeouts((HANDLE)dword_532CF0[24 * i], &CommTimeouts);
      if ( !v9 )
        ShutdownComError("Set communications timeouts");
      init_anchor((int)&dword_532D40[24 * i], 0);
      init_anchor((int)&dword_532D48[24 * i], 0);
      result = i;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}
// 532CF0: using guessed type int dword_532CF0[];
// 532CF8: using guessed type int dword_532CF8[];
// 532D40: using guessed type int dword_532D40[];
// 532D48: using guessed type int dword_532D48[];

//----- (004BCFA0) --------------------------------------------------------
int __fastcall com_term(__int16 a1)
{
  int result; // eax@1
  __int16 v2; // [sp+Ch] [bp-8h]@1
  int a1a; // [sp+10h] [bp-4h]@3

  v2 = a1;
  result = 32 * a1;
  if ( dword_532CF0[24 * a1] != -1 )
  {
    SetCommState((HANDLE)dword_532CF0[24 * a1], (LPDCB)&dword_532CF0[24 * a1 + 2]);
    SetCommTimeouts((HANDLE)dword_532CF0[24 * v2], (LPCOMMTIMEOUTS)&dword_532CF0[24 * v2 + 9]);
    CloseHandle((HANDLE)dword_532CF0[24 * v2]);
    dword_532CF0[24 * v2] = -1;
    while ( 1 )
    {
      a1a = pop_node((int)&dword_532D40[24 * v2]);
      if ( !a1a )
        break;
      BaseFree((void *)a1a, (int)"F:\\h2xsrc\\Source\\comwin.cpp", word_51DF7C + 13);
    }
    while ( 1 )
    {
      result = pop_node((int)&dword_532D48[24 * v2]);
      if ( !result )
        break;
      BaseFree((void *)result, (int)"F:\\h2xsrc\\Source\\comwin.cpp", word_51DF7C + 17);
    }
  }
  return result;
}
// 51DF7C: using guessed type __int16 word_51DF7C;
// 532CF0: using guessed type int dword_532CF0[];
// 532D40: using guessed type int dword_532D40[];
// 532D48: using guessed type int dword_532D48[];

//----- (004BD0C0) --------------------------------------------------------
__int16 __fastcall com_rcv(__int16 a1, unsigned __int16 a2, LPVOID lpBuffer)
{
  __int16 result; // ax@10
  unsigned __int16 v4; // [sp+Ch] [bp-24h]@1
  __int16 v5; // [sp+10h] [bp-20h]@1
  DWORD nNumberOfBytesToRead; // [sp+14h] [bp-1Ch]@5
  struct _COMSTAT Stat; // [sp+1Ch] [bp-14h]@2
  DWORD NumberOfBytesRead; // [sp+28h] [bp-8h]@8
  DWORD Errors; // [sp+2Ch] [bp-4h]@2

  v4 = a2;
  v5 = a1;
  if ( dword_532CF0[24 * a1] == -1 )
    goto LABEL_14;
  if ( !ClearCommError((HANDLE)dword_532CF0[24 * a1], &Errors, &Stat) )
    ShutdownComError("Clear communications error queue");
  nNumberOfBytesToRead = Stat.cbInQue > v4 ? v4 : Stat.cbInQue;
  if ( nNumberOfBytesToRead )
  {
    if ( !ReadFile((HANDLE)dword_532CF0[24 * v5], lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
      ShutdownComError("Read communications data");
    result = NumberOfBytesRead;
  }
  else
  {
LABEL_14:
    result = 0;
  }
  return result;
}
// 532CF0: using guessed type int dword_532CF0[];

//----- (004BD1A0) --------------------------------------------------------
signed __int16 __thiscall com_snd(__int16 this, unsigned __int16 a2, const void *a3, int a4)
{
  __int16 v5; // [sp+10h] [bp-Ch]@1
  int v6; // [sp+18h] [bp-4h]@8

  v5 = this;
  if ( dword_532CF0[24 * this] == -1 )
    return 1;
  if ( a2 )
  {
    v6 = (int)BaseAlloc(a2 + 10, "F:\\h2xsrc\\Source\\comwin.cpp", word_51DFF8 + 16);
    if ( v6 )
    {
      *(_WORD *)(v6 + 8) = a2;
      memcpy((void *)(v6 + 10), a3, a2);
      if ( a4 )
        add_node((int)&dword_532D48[24 * v5], v6);
      else
        add_node((int)&dword_532D40[24 * v5], v6);
      return 0;
    }
    return 1;
  }
  if ( !SetCommBreak((HANDLE)dword_532CF0[24 * this]) )
    ShutdownComError("Set communications break");
  Sleep(0x1F4u);
  if ( !ClearCommBreak((HANDLE)dword_532CF0[24 * v5]) )
    ShutdownComError("Clear communications break");
  return 0;
}
// 51DFF8: using guessed type __int16 word_51DFF8;
// 532CF0: using guessed type int dword_532CF0[];
// 532D40: using guessed type int dword_532D40[];
// 532D48: using guessed type int dword_532D48[];

//----- (004BD2F0) --------------------------------------------------------
__int16 __cdecl sub_4BD2F0()
{
  return 0;
}

//----- (004BD310) --------------------------------------------------------
char __fastcall com_stat(__int16 a1)
{
  DWORD ModemStat; // [sp+14h] [bp-4h]@2

  return dword_532CF0[24 * a1] != -1
      && GetCommModemStatus((HANDLE)dword_532CF0[24 * a1], &ModemStat)
      && ModemStat & 0x10
      && ModemStat & 0x80;
}
// 532CF0: using guessed type int dword_532CF0[];

//----- (004BD380) --------------------------------------------------------
int __cdecl comm_wrt_task()
{
  int result; // eax@2
  int a1; // [sp+10h] [bp-10h]@3
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-Ch]@9
  HANDLE *v3; // [sp+18h] [bp-8h]@1
  unsigned int i; // [sp+1Ch] [bp-4h]@6

  v3 = (HANDLE *)dword_532CF0;
  while ( 1 )
  {
    result = (int)v3;
    if ( *v3 == (HANDLE)-1 )
      break;
    result = pop_node((int)(v3 + 22));
    a1 = result;
    if ( !result )
    {
      result = pop_node((int)(v3 + 20));
      a1 = result;
    }
    if ( !a1 )
      break;
    for ( i = 0; *v3 != (HANDLE)-1 && *(_WORD *)(a1 + 8) > i; i += NumberOfBytesWritten )
    {
      if ( !WriteFile(*v3, (LPCVOID)(a1 + i + 10), *(_WORD *)(a1 + 8) - i, &NumberOfBytesWritten, 0) )
        ShutdownComError("Write communications data");
    }
    BaseFree((void *)a1, (int)"F:\\h2xsrc\\Source\\comwin.cpp", word_51E050 + 28);
  }
  return result;
}
// 51E050: using guessed type __int16 word_51E050;
// 532CF0: using guessed type int dword_532CF0[];

//----- (004BD470) --------------------------------------------------------
hexcell *__thiscall hexcell::hexcell(hexcell *this)
{
  this->combatObjIdx = -1;
  this->isBlocked = 0;
  this->unitOwner = -1;
  this->stackIdx = 0;
  this->occupiersOtherHexIsToLeft = -1;
  this->numCorpses = 0;
  return this;
}

//----- (004BD4E0) --------------------------------------------------------
void __thiscall hexcell::DrawLowerDeadOccupants(hexcell *this)
{
  hexcell *thisa; // [sp+Ch] [bp-10h]@1
  int i; // [sp+14h] [bp-8h]@2

  thisa = this;
  if ( this->numCorpses > 0 )
  {
    for ( i = 0; thisa->numCorpses - 1 > i; ++i )
    {
      if ( thisa->corpseOtherHexIsToLeft[i] != gpCombatManager->creatures[thisa->corpseOwners[i]][thisa->corpseStackIndices[i]].facingRight )
        army::DrawToBuffer(
          &gpCombatManager->creatures[thisa->corpseOwners[i]][thisa->corpseStackIndices[i]],
          thisa->centerX,
          thisa->occupyingCreatureBottomY,
          0);
    }
  }
}

//----- (004BD5B0) --------------------------------------------------------
void __thiscall hexcell::DrawUpperDeadOccupant(hexcell *this)
{
  hexcell *thisa; // [sp+Ch] [bp-10h]@1
  int i; // [sp+14h] [bp-8h]@2

  thisa = this;
  if ( this->numCorpses > 0 )
  {
    for ( i = this->numCorpses - 1; thisa->numCorpses > i; ++i )
    {
      if ( thisa->corpseOtherHexIsToLeft[i] != gpCombatManager->creatures[thisa->corpseOwners[i]][thisa->corpseStackIndices[i]].facingRight )
        army::DrawToBuffer(
          &gpCombatManager->creatures[thisa->corpseOwners[i]][thisa->corpseStackIndices[i]],
          thisa->centerX,
          thisa->occupyingCreatureBottomY,
          0);
    }
  }
}

//----- (004BD680) --------------------------------------------------------
void __thiscall hexcell::DrawOccupant(hexcell *this, int a2, int a3)
{
  if ( this->unitOwner != -1 && (a2 == 100 || gpCombatManager->creatures[this->unitOwner][this->stackIdx].field_6 == a2) )
  {
    if ( gbLimitToExtent
      && this->unitOwner == gpCombatManager->activeStackOwner
      && this->stackIdx == gpCombatManager->activeStack )
      gbCurrArmyDrawn = 1;
    if ( gpCombatManager->creatures[this->unitOwner][this->stackIdx].facingRight != this->occupiersOtherHexIsToLeft )
      army::DrawToBuffer(
        &gpCombatManager->creatures[this->unitOwner][this->stackIdx],
        this->centerX,
        this->occupyingCreatureBottomY,
        a3);
  }
}
// 4F7488: using guessed type int gbLimitToExtent;
// 4F748C: using guessed type int gbCurrArmyDrawn;

//----- (004BD7F0) --------------------------------------------------------
int __thiscall hexcell::DrawTower(hexcell *this, int a2)
{
  int result; // eax@1
  hexcell *thisa; // [sp+Ch] [bp-18h]@1
  int v6; // [sp+10h] [bp-14h]@8
  int v7; // [sp+14h] [bp-10h]@4
  int row; // [sp+1Ch] [bp-8h]@1

  thisa = this;
  icon::CombatClipDrawToBuffer(
    gpCombatManager->combatScreenIcons[5],
    this->centerX + 28,
    thisa->occupyingCreatureBottomY,
    a2,
    &thisa->drawingBounds,
    1,
    0,
    0,
    0);
  result = (thisa->occupyingCreatureBottomY - 139) / 42;
  row = (thisa->occupyingCreatureBottomY - 139) / 42;
  if ( row != 4 )
  {
    if ( row & 1 )
    {
      v7 = thisa->centerX + 28;
      result = icon::CombatClipDrawToBuffer(
                 gpCombatManager->combatScreenIcons[5],
                 v7,
                 thisa->occupyingCreatureBottomY,
                 9,
                 &thisa->drawingBounds,
                 1,
                 0,
                 0,
                 0);
    }
    else
    {
      v6 = thisa->centerX;
      result = icon::CombatClipDrawToBuffer(
                 gpCombatManager->combatScreenIcons[5],
                 v6,
                 thisa->occupyingCreatureBottomY,
                 9,
                 &thisa->drawingBounds,
                 0,
                 0,
                 0,
                 0);
    }
  }
  return result;
}

//----- (004BD960) --------------------------------------------------------
void __thiscall hexcell::DrawObstacle(hexcell *this)
{
  icon::CombatClipDrawToBuffer(
    gpCombatManager->combatObjIcons[this->combatObjIdx],
    this->centerX,
    this->occupyingCreatureBottomY,
    0,
    &this->drawingBounds,
    0,
    0,
    0,
    0);
}

//----- (004BD9B0) --------------------------------------------------------
int __thiscall swapManager::swapManager(int this)
{
  int v1; // ST0C_4@1

  v1 = this;
  baseManager::baseManager((baseManager *)this);
  *(_DWORD *)v1 = &swapManager::_vftable_;
  *(_DWORD *)(v1 + 54) = 0;
  *(_DWORD *)(v1 + 58) = 0;
  *(_DWORD *)(v1 + 70) = -1;
  *(_DWORD *)(v1 + 74) = -1;
  *(_DWORD *)(v1 + 86) = -1;
  *(_DWORD *)(v1 + 78) = -1;
  *(_DWORD *)(v1 + 82) = -1;
  *(_DWORD *)(v1 + 62) = 0;
  *(_DWORD *)(v1 + 66) = 0;
  return v1;
}
// 4EAEF0: using guessed type int (__stdcall *swapManager___vftable_)(int);

//----- (004BDA40) --------------------------------------------------------
int __thiscall swapManager::swapManager(tag_message *this)
{
  int v1; // ST0C_4@1
  int v3; // [sp+18h] [bp+8h]@0
  int v4; // [sp+1Ch] [bp+Ch]@0

  v1 = (int)this;
  baseManager::baseManager((baseManager *)this);
  *(_DWORD *)v1 = &swapManager::_vftable_;
  *(_DWORD *)(v1 + 62) = v3;
  *(_DWORD *)(v1 + 66) = v4;
  return v1;
}
// 4BDA40: inconsistent function type and number of purged bytes
// 4EAEF0: using guessed type int (__stdcall *swapManager___vftable_)(int);

//----- (004BDA80) --------------------------------------------------------
int __thiscall swapManager::Reset(int this)
{
  int v1; // ST0C_4@1
  int result; // eax@1

  v1 = this;
  *(_DWORD *)(this + 82) = -1;
  *(_DWORD *)(v1 + 78) = *(_DWORD *)(v1 + 82);
  *(_DWORD *)(v1 + 86) = *(_DWORD *)(v1 + 78);
  *(_DWORD *)(v1 + 74) = *(_DWORD *)(v1 + 86);
  result = *(_DWORD *)(this + 74);
  *(_DWORD *)(this + 70) = result;
  return result;
}

//----- (004BDAD0) --------------------------------------------------------
int __thiscall swapManager::DrawSwapWin(int this)
{
  heroWindow::DrawWindow(*(heroWindow **)(this + 54), 0);
  heroWindowManager::UpdateScreen(gpWindowManager);
  return 0;
}

//----- (004BDB00) --------------------------------------------------------
int __thiscall swapManager::Open(void *this, int a2)
{
  signed int v2; // eax@11
  char v3; // al@11
  void *v5; // [sp+Ch] [bp-2Ch]@1
  heroWindow *thisa; // [sp+10h] [bp-28h]@1
  int evt; // [sp+14h] [bp-24h]@6
  int v8; // [sp+18h] [bp-20h]@6
  int v9; // [sp+1Ch] [bp-1Ch]@6
  char *v10; // [sp+2Ch] [bp-Ch]@6
  int a2a; // [sp+30h] [bp-8h]@8
  int i; // [sp+34h] [bp-4h]@6

  v5 = this;
  swapManager::Reset((int)this);
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    *(_DWORD *)((char *)v5 + 54) = heroWindow::heroWindow(thisa, 0, 0, "swapwin.bin");
  else
    *(_DWORD *)((char *)v5 + 54) = 0;
  if ( !*(_DWORD *)((char *)v5 + 54) )
    MemError();
  SetWinText(*(heroWindow **)((char *)v5 + 54), 21);
  evt = 512;
  v8 = 9;
  sprintf(gText, "port%04d.icn", *(_BYTE *)(*(_DWORD *)((char *)v5 + 62) + 24));
  v9 = 65;
  v10 = gText;
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
  sprintf(gText, "port%04d.icn", *(_BYTE *)(*(_DWORD *)((char *)v5 + 66) + 24));
  v9 = 66;
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
  v8 = 3;
  sprintf(gText, "%s meets %s", *(_DWORD *)((char *)v5 + 62) + 10, *(_DWORD *)((char *)v5 + 66) + 10);
  v10 = gText;
  v9 = 77;
  heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
  for ( i = 0; i < 2; ++i )
  {
    for ( a2a = 0; a2a < 8; ++a2a )
    {
      if ( *(_DWORD *)(*(_DWORD *)((char *)v5 + 4 * i + 62) + 144) <= a2a )
      {
        v8 = 6;
        v9 = a2a + 8 * i + 200;
        v10 = (char *)4;
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
      }
      else
      {
        v8 = 4;
        v9 = a2a + 8 * i + 200;
        v10 = (char *)hero::GetNthSS(*(hero **)((char *)v5 + 4 * i + 62), a2a);
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
        v8 = 3;
        v9 = a2a + 8 * i + 216;
        v10 = gText;
        v2 = hero::GetNthSS(*(hero **)((char *)v5 + 4 * i + 62), a2a);
        v3 = hero::GetSSLevel(*(hero **)((char *)v5 + 4 * i + 62), (SECONDARY_SKILL)v2);
        sprintf(gText, "%d", v3);
        heroWindow::BroadcastMessage(*(heroWindow **)((char *)v5 + 54), (tag_message *)&evt);
      }
    }
  }
  evt = 512;
  v8 = 6;
  v10 = (char *)2;
  v9 = 1;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v9 = 2;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v9 = 3;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v9 = 4;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v9 = 5;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v9 = 6;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  swapManager::Update(v5);
  heroWindowManager::AddWindow(gpWindowManager, *(heroWindow **)((char *)v5 + 54), -1, 1);
  KBChangeMenu(hmnuAdv);
  giMonoIconSkip = 2;
  *(_DWORD *)((char *)v5 + 58) = resourceManager::GetIcon(gpResourceManager, "swapbtn.icn");
  giMonoIconSkip = -1;
  mouseManager::SetPointer(gpMouseManager, 0);
  *((_DWORD *)v5 + 3) = 256;
  *((_DWORD *)v5 + 4) = a2;
  *(_DWORD *)((char *)v5 + 50) = 1;
  strcpy((char *)v5 + 20, "swapManager");
  return 0;
}
// 4F2E74: using guessed type int giMonoIconSkip;

//----- (004BDEC0) --------------------------------------------------------
int __thiscall swapManager::Close(int this)
{
  int v1; // ST10_4@1
  int evt; // [sp+1Ch] [bp-1Ch]@1
  int v4; // [sp+20h] [bp-18h]@1
  int v5; // [sp+24h] [bp-14h]@1
  int v6; // [sp+34h] [bp-4h]@1

  v1 = this;
  resourceManager::Dispose(gpResourceManager, *(resource **)(this + 58));
  heroWindowManager::RemoveWindow(gpWindowManager, *(heroWindow **)(v1 + 54));
  operator delete(*(void **)(v1 + 54));
  *(_DWORD *)(v1 + 50) = 0;
  gpAdvManager->ready = 1;
  evt = 512;
  v4 = 5;
  v6 = 2;
  v5 = 1;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v5 = 2;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v5 = 3;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v5 = 4;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v5 = 5;
  heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
  v5 = 6;
  return heroWindow::BroadcastMessage(gpAdvManager->adventureScreen, (tag_message *)&evt);
}

//----- (004BDFF0) --------------------------------------------------------
void __thiscall swapManager::DrawSelector(int this)
{
  int v1; // [sp+Ch] [bp-3Ch]@10
  int v2; // [sp+10h] [bp-38h]@4
  int v3; // [sp+14h] [bp-34h]@3
  int offsetY; // [sp+28h] [bp-20h]@1
  int offsetX; // [sp+30h] [bp-18h]@1

  offsetX = 0;
  offsetY = 0;
  if ( *(_DWORD *)(this + 70) != -1 && *(_DWORD *)(this + 78) != -1 )
  {
    v3 = *(_DWORD *)(this + 70);
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v1 = *(_DWORD *)(this + 86);
        if ( v1 )
        {
          if ( v1 == 1 )
          {
            offsetX = 36 * (*(_DWORD *)(this + 78) % 7) + 367;
            offsetY = *(_DWORD *)(this + 78) <= 6 ? 347 : 127;
          }
        }
        else
        {
          offsetX = 45 * *(_DWORD *)(this + 78) + 381;
          offsetY = 267;
        }
      }
    }
    else
    {
      v2 = *(_DWORD *)(this + 86);
      if ( v2 )
      {
        if ( v2 == 1 )
        {
          offsetX = 36 * (*(_DWORD *)(this + 78) % 7) + 23;
          offsetY = *(_DWORD *)(this + 78) <= 6 ? 347 : 127;
        }
      }
      else
      {
        offsetX = 45 * *(_DWORD *)(this + 78) + 36;
        offsetY = 267;
      }
    }
    icon::FillToBuffer(*(icon **)(this + 58), offsetX, offsetY, (*(_DWORD *)(this + 86) < 1u) + 2, 10, 0, 0);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, offsetX, offsetY, 0x2Eu, 46);
  }
}

//----- (004BE1F0) --------------------------------------------------------
signed int __thiscall swapManager::Main(int this, int a2)
{
  int v2; // ST4C_4@15
  signed int result; // eax@99
  int v4; // [sp+10h] [bp-24h]@4
  int v5; // [sp+14h] [bp-20h]@1
  int v6; // [sp+18h] [bp-1Ch]@1
  signed int v7; // [sp+20h] [bp-14h]@10
  int a2a; // [sp+24h] [bp-10h]@10
  int v9; // [sp+28h] [bp-Ch]@20
  int v10; // [sp+28h] [bp-Ch]@36
  signed int v11; // [sp+2Ch] [bp-8h]@1
  bool a3; // [sp+30h] [bp-4h]@1

  v6 = this;
  v11 = 0;
  a3 = (*(_BYTE *)(a2 + 13) & 2) != 0;
  v5 = *(_DWORD *)a2;
  if ( v5 == 32 )
  {
    if ( !(*(_BYTE *)(a2 + 13) & 2) )
    {
      swapManager::Reset(this);
      swapManager::Update((void *)v6);
      swapManager::DrawSwapWin(v6);
    }
  }
  else
  {
    if ( v5 != 512 )
      goto LABEL_98;
    v4 = *(_DWORD *)(a2 + 4);
    if ( v4 == 12 )
    {
LABEL_88:
      switch ( *(_DWORD *)(a2 + 8) )
      {
        case 0xC8:
        case 0xC9:
        case 0xCA:
        case 0xCB:
        case 0xCC:
        case 0xCD:
        case 0xCE:
        case 0xCF:
          v7 = 0;
          a2a = *(_DWORD *)(a2 + 8) - 200;
          goto LABEL_14;
        case 0xD8:
        case 0xD9:
        case 0xDA:
        case 0xDB:
        case 0xDC:
        case 0xDD:
        case 0xDE:
        case 0xDF:
          v7 = 0;
          a2a = *(_DWORD *)(a2 + 8) - 216;
          goto LABEL_14;
        case 0xD0:
        case 0xD1:
        case 0xD2:
        case 0xD3:
        case 0xD4:
        case 0xD5:
        case 0xD6:
        case 0xD7:
          v7 = 1;
          a2a = *(_DWORD *)(a2 + 8) - 208;
          goto LABEL_14;
        case 0xE0:
        case 0xE1:
        case 0xE2:
        case 0xE3:
        case 0xE4:
        case 0xE5:
        case 0xE6:
        case 0xE7:
          v7 = 1;
          a2a = *(_DWORD *)(a2 + 8) - 224;
LABEL_14:
          if ( *(_DWORD *)(*(_DWORD *)(this + 4 * v7 + 62) + 144) > a2a )
          {
            v2 = hero::GetNthSS(*(hero **)(this + 4 * v7 + 62), a2a);
            hero::DoSSLevelDialog(*(hero **)(v6 + 4 * v7 + 62), v2, a3);
          }
          break;
        case 0x41:
          if ( !(*(_BYTE *)(a2 + 13) & 2) )
          {
            HeroView(*(_BYTE *)(*(_DWORD *)(this + 62) + 2), 1, 0);
            advManager::RedrawAdvScreen(gpAdvManager, 1, 0);
            swapManager::Update((void *)v6);
            swapManager::DrawSwapWin(v6);
            swapManager::Reset(v6);
            heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
          }
          break;
        case 0x42:
          if ( !(*(_BYTE *)(a2 + 13) & 2) )
          {
            HeroView(*(_BYTE *)(*(_DWORD *)(this + 66) + 2), 1, 0);
            advManager::RedrawAdvScreen(gpAdvManager, 1, 0);
            swapManager::Update((void *)v6);
            swapManager::DrawSwapWin(v6);
            swapManager::Reset(v6);
            heroWindowManager::FadeScreen(gpWindowManager, 0, 8, 0);
          }
          break;
        case 0x58:
        case 0x59:
        case 0x5A:
        case 0x5B:
        case 0x5C:
        case 0x5D:
        case 0x5E:
        case 0x5F:
        case 0x60:
        case 0x61:
        case 0x62:
        case 0x63:
        case 0x64:
        case 0x65:
          v9 = *(_DWORD *)(a2 + 8) - 88;
          if ( *(_BYTE *)(a2 + 13) & 2 || *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 213) != 81 )
          {
            if ( *(_BYTE *)(a2 + 13) & 2 )
            {
              if ( *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 213) != -1 )
                hero::ViewArtifact(
                  *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 213),
                  1u,
                  *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 236));
            }
            else if ( *(_DWORD *)(this + 86) == 1 )
            {
              *(_DWORD *)(this + 74) = 0;
              *(_DWORD *)(this + 82) = v9;
              if ( *(_DWORD *)(this + 70) || *(_DWORD *)(this + 78) != *(_DWORD *)(this + 82) )
              {
                swapManager::SwapArtifacts(this);
                swapManager::Reset(v6);
              }
              else
              {
                hero::ViewArtifact(
                  *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 213),
                  0,
                  *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 236));
                swapManager::Reset(v6);
              }
            }
            else if ( *(_BYTE *)(*(_DWORD *)(this + 62) + v9 + 213) == -1 )
            {
              swapManager::Reset(this);
            }
            else
            {
              *(_DWORD *)(this + 70) = 0;
              *(_DWORD *)(this + 74) = -1;
              *(_DWORD *)(this + 86) = 1;
              *(_DWORD *)(this + 78) = v9;
              *(_DWORD *)(this + 82) = -1;
            }
          }
          else
          {
            NormalDialog("This item can't be traded.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
          break;
        case 0x66:
        case 0x67:
        case 0x68:
        case 0x69:
        case 0x6A:
        case 0x6B:
        case 0x6C:
        case 0x6D:
        case 0x6E:
        case 0x6F:
        case 0x70:
        case 0x71:
        case 0x72:
        case 0x73:
          v10 = *(_DWORD *)(a2 + 8) - 102;
          if ( *(_BYTE *)(a2 + 13) & 2 || *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 213) != 81 )
          {
            if ( *(_BYTE *)(a2 + 13) & 2 )
            {
              if ( *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 213) != -1 )
                hero::ViewArtifact(
                  *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 213),
                  1u,
                  *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 236));
            }
            else if ( *(_DWORD *)(this + 86) == 1 )
            {
              *(_DWORD *)(this + 74) = 1;
              *(_DWORD *)(this + 82) = v10;
              if ( *(_DWORD *)(this + 70) != 1 || *(_DWORD *)(this + 78) != *(_DWORD *)(this + 82) )
              {
                swapManager::SwapArtifacts(this);
                swapManager::Reset(v6);
              }
              else
              {
                hero::ViewArtifact(
                  *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 213),
                  0,
                  *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 236));
                swapManager::Reset(v6);
              }
            }
            else if ( *(_BYTE *)(*(_DWORD *)(this + 66) + v10 + 213) == -1 )
            {
              swapManager::Reset(this);
            }
            else
            {
              *(_DWORD *)(this + 70) = 1;
              *(_DWORD *)(this + 74) = -1;
              *(_DWORD *)(this + 86) = 1;
              *(_DWORD *)(this + 78) = v10;
              *(_DWORD *)(this + 82) = -1;
            }
          }
          else
          {
            NormalDialog("This item can't be traded.", 1, -1, -1, -1, 0, -1, 0, -1, 0);
          }
          break;
        case 0x4E:
        case 0x4F:
        case 0x50:
        case 0x51:
        case 0x52:
          if ( *(_BYTE *)(a2 + 13) & 2 )
          {
            if ( *(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 62) + 23) != -1 )
              game::ViewArmy(
                gpGame,
                119,
                20,
                (CREATURES)*(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 62) + 23),
                *(_WORD *)(*(_DWORD *)(this + 62) + 2 * *(_DWORD *)(a2 + 8) - 50),
                0,
                0,
                1u,
                1,
                *(hero **)(this + 62),
                0,
                (armyGroup *)(*(_DWORD *)(this + 62) + 101),
                *(_DWORD *)(a2 + 8) - 78);
          }
          else if ( *(_DWORD *)(this + 86) )
          {
            if ( *(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 62) + 23) == -1 )
            {
              swapManager::Reset(this);
            }
            else
            {
              *(_DWORD *)(this + 70) = 0;
              *(_DWORD *)(this + 74) = -1;
              *(_DWORD *)(this + 86) = 0;
              *(_DWORD *)(this + 78) = *(_DWORD *)(a2 + 8) - 78;
              *(_DWORD *)(this + 82) = -1;
            }
          }
          else
          {
            *(_DWORD *)(this + 74) = 0;
            *(_DWORD *)(this + 82) = *(_DWORD *)(a2 + 8) - 78;
            if ( *(_DWORD *)(this + 70) || *(_DWORD *)(this + 78) != *(_DWORD *)(this + 82) )
            {
              if ( *(_BYTE *)(a2 + 12) & 3
                && (*(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + *(_DWORD *)(this + 82) + 101) == -1
                 || *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + *(_DWORD *)(this + 78) + 101) == *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + *(_DWORD *)(this + 82) + 101)) )
              {
                swapManager::SplitMons(this);
                swapManager::Reset(v6);
              }
              else
              {
                swapManager::SwapMons(this);
                swapManager::Reset(v6);
              }
            }
            else
            {
              swapManager::ViewMon(this);
              swapManager::Reset(v6);
            }
          }
          break;
        case 0x53:
        case 0x54:
        case 0x55:
        case 0x56:
        case 0x57:
          if ( *(_BYTE *)(a2 + 13) & 2 )
          {
            if ( *(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 66) + 18) != -1 )
              game::ViewArmy(
                gpGame,
                119,
                20,
                (CREATURES)*(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 66) + 18),
                *(_WORD *)(*(_DWORD *)(this + 66) + 2 * *(_DWORD *)(a2 + 8) - 60),
                0,
                0,
                1u,
                1,
                *(hero **)(this + 66),
                0,
                (armyGroup *)(*(_DWORD *)(this + 66) + 101),
                *(_DWORD *)(a2 + 8) - 83);
          }
          else if ( *(_DWORD *)(this + 86) )
          {
            if ( *(_BYTE *)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(this + 66) + 18) == -1 )
            {
              swapManager::Reset(this);
            }
            else
            {
              *(_DWORD *)(this + 70) = 1;
              *(_DWORD *)(this + 74) = -1;
              *(_DWORD *)(this + 86) = 0;
              *(_DWORD *)(this + 78) = *(_DWORD *)(a2 + 8) - 83;
              *(_DWORD *)(this + 82) = -1;
            }
          }
          else
          {
            *(_DWORD *)(this + 74) = 1;
            *(_DWORD *)(this + 82) = *(_DWORD *)(a2 + 8) - 83;
            if ( *(_DWORD *)(this + 70) != 1 || *(_DWORD *)(this + 78) != *(_DWORD *)(this + 82) )
            {
              if ( *(_BYTE *)(a2 + 12) & 3
                && (*(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + *(_DWORD *)(this + 82) + 101) == -1
                 || *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + *(_DWORD *)(this + 78) + 101) == *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + *(_DWORD *)(this + 82) + 101)) )
              {
                swapManager::SplitMons(this);
                swapManager::Reset(v6);
              }
              else
              {
                swapManager::SwapMons(this);
                swapManager::Reset(v6);
              }
            }
            else
            {
              swapManager::ViewMon(this);
              swapManager::Reset(v6);
            }
          }
          break;
        case 0x43:
        case 0x44:
        case 0x45:
        case 0x46:
        case 0x47:
        case 0x48:
        case 0x49:
        case 0x4A:
        case 0x4B:
        case 0x4C:
        case 0x4D:
        case 0x74:
        case 0x75:
        case 0x76:
        case 0x77:
        case 0x78:
        case 0x79:
        case 0x7A:
        case 0x7B:
        case 0x7C:
        case 0x7D:
        case 0x7E:
        case 0x7F:
        case 0x80:
        case 0x81:
        case 0x82:
        case 0x83:
        case 0x84:
        case 0x85:
        case 0x86:
        case 0x87:
        case 0x88:
        case 0x89:
        case 0x8A:
        case 0x8B:
        case 0x8C:
        case 0x8D:
        case 0x8E:
        case 0x8F:
        case 0x90:
        case 0x91:
        case 0x92:
        case 0x93:
        case 0x94:
        case 0x95:
        case 0x96:
        case 0x97:
        case 0x98:
        case 0x99:
        case 0x9A:
        case 0x9B:
        case 0x9C:
        case 0x9D:
        case 0x9E:
        case 0x9F:
        case 0xA0:
        case 0xA1:
        case 0xA2:
        case 0xA3:
        case 0xA4:
        case 0xA5:
        case 0xA6:
        case 0xA7:
        case 0xA8:
        case 0xA9:
        case 0xAA:
        case 0xAB:
        case 0xAC:
        case 0xAD:
        case 0xAE:
        case 0xAF:
        case 0xB0:
        case 0xB1:
        case 0xB2:
        case 0xB3:
        case 0xB4:
        case 0xB5:
        case 0xB6:
        case 0xB7:
        case 0xB8:
        case 0xB9:
        case 0xBA:
        case 0xBB:
        case 0xBC:
        case 0xBD:
        case 0xBE:
        case 0xBF:
        case 0xC0:
        case 0xC1:
        case 0xC2:
        case 0xC3:
        case 0xC4:
        case 0xC5:
        case 0xC6:
        case 0xC7:
          break;
      }
      if ( !a3 )
      {
        swapManager::Update((void *)v6);
        swapManager::DrawSwapWin(v6);
        swapManager::DrawSelector(v6);
      }
      goto LABEL_98;
    }
    if ( v4 != 13 )
    {
      if ( v4 != 14 )
        goto LABEL_98;
      goto LABEL_88;
    }
    if ( !(*(_BYTE *)(a2 + 13) & 2) && *(_DWORD *)(a2 + 8) == 30720 )
      v11 = 1;
  }
LABEL_98:
  if ( v11 == 1 )
  {
    *(_DWORD *)a2 = 16384;
    *(_DWORD *)(a2 + 4) = 4;
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (004BECE0) --------------------------------------------------------
BOOL __thiscall swapManager::ViewMon(int this)
{
  int v1; // ST3C_4@1
  int v2; // ST2C_4@1
  armyGroup *v3; // ST28_4@1
  hero *v4; // ST20_4@1
  int v5; // eax@1

  v1 = this;
  v2 = *(_DWORD *)(this + 82);
  v3 = (armyGroup *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + 101);
  v4 = *(hero **)(this + 4 * *(_DWORD *)(this + 70) + 62);
  v5 = armyGroup::GetNumArmies((armyGroup *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + 101));
  return game::ViewArmy(
           gpGame,
           119,
           20,
           (CREATURES)*(_BYTE *)(*(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 70) + 62) + *(_DWORD *)(v1 + 82) + 101),
           *(_WORD *)(*(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 70) + 62) + 2 * *(_DWORD *)(v1 + 82) + 106),
           0,
           v5 == 1,
           1u,
           0,
           v4,
           0,
           v3,
           v2);
}

//----- (004BED90) --------------------------------------------------------
void __thiscall swapManager::SwapArtifacts(int this)
{
  signed int v1; // eax@8
  char v2; // al@8
  int v3; // [sp+Ch] [bp-34h]@1
  int evt; // [sp+10h] [bp-30h]@3
  int v5; // [sp+14h] [bp-2Ch]@8
  int v6; // [sp+18h] [bp-28h]@8
  char *v7; // [sp+28h] [bp-18h]@8
  int i; // [sp+2Ch] [bp-14h]@3
  int j; // [sp+30h] [bp-10h]@5
  ARTIFACT a2; // [sp+34h] [bp-Ch]@1
  char v11; // [sp+38h] [bp-8h]@1
  ARTIFACT v12; // [sp+3Ch] [bp-4h]@1

  v3 = this;
  a2 = *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + *(_DWORD *)(this + 78) + 213);
  v12 = *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + *(_DWORD *)(this + 82) + 213);
  GiveTakeArtifactStat(*(hero **)(this + 4 * *(_DWORD *)(this + 70) + 62), a2, 1);
  GiveTakeArtifactStat(*(hero **)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62), v12, 1);
  *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 70) + 62) + *(_DWORD *)(v3 + 78) + 213) = v12;
  *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62) + *(_DWORD *)(v3 + 82) + 213) = a2;
  v11 = *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 70) + 62) + *(_DWORD *)(v3 + 78) + 236);
  *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 70) + 62) + *(_DWORD *)(v3 + 78) + 236) = *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62) + *(_DWORD *)(v3 + 82) + 236);
  *(_BYTE *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62) + *(_DWORD *)(v3 + 82) + 236) = v11;
  GiveTakeArtifactStat(*(hero **)(v3 + 4 * *(_DWORD *)(v3 + 70) + 62), v12, 0);
  GiveTakeArtifactStat(*(hero **)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62), a2, 0);
  hero::CheckAnduranPieces(*(hero **)(v3 + 4 * *(_DWORD *)(v3 + 70) + 62), 1);
  hero::CheckAnduranPieces(*(hero **)(v3 + 4 * *(_DWORD *)(v3 + 74) + 62), 1);
  if ( a2 == 102 || v12 == 102 )
  {
    evt = 512;
    for ( i = 0; i < 2; ++i )
    {
      for ( j = 0; j < 8; ++j )
      {
        if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * i + 62) + 144) > j )
        {
          v5 = 3;
          v6 = j + 8 * i + 216;
          v7 = gText;
          v1 = hero::GetNthSS(*(hero **)(v3 + 4 * i + 62), j);
          v2 = hero::GetSSLevel(*(hero **)(v3 + 4 * i + 62), (SECONDARY_SKILL)v1);
          sprintf(gText, "%d", v2);
          heroWindow::BroadcastMessage(*(heroWindow **)(v3 + 54), (tag_message *)&evt);
        }
      }
    }
  }
}

//----- (004BEFF0) --------------------------------------------------------
void __thiscall swapManager::SwapMons(int this)
{
  int v1; // [sp+Ch] [bp-14h]@1
  armyGroup *thisa; // [sp+10h] [bp-10h]@7
  signed int i; // [sp+14h] [bp-Ch]@1
  int v4; // [sp+18h] [bp-8h]@1
  armyGroup *oth; // [sp+1Ch] [bp-4h]@7

  v1 = this;
  v4 = 0;
  for ( i = 0; i < 5; ++i )
  {
    if ( *(_BYTE *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + i + 101) != -1 )
    {
      if ( (signed int)*(_WORD *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + 2 * i + 106) > 0 )
        ++v4;
    }
  }
  thisa = (armyGroup *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + 101);
  oth = (armyGroup *)(*(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + 101);
  if ( thisa->creatureTypes[*(_DWORD *)(this + 78)] == oth->creatureTypes[*(_DWORD *)(this + 82)] )
  {
    if ( armyGroup::GetNumArmies(thisa) != 1 )
    {
      oth->quantities[*(_DWORD *)(v1 + 82)] += thisa->quantities[*(_DWORD *)(v1 + 78)];
      thisa->creatureTypes[*(_DWORD *)(v1 + 78)] = -1;
      thisa->quantities[*(_DWORD *)(v1 + 78)] = 0;
    }
  }
  else if ( thisa == oth || armyGroup::GetNumArmies(thisa) != 1 || oth->creatureTypes[*(_DWORD *)(v1 + 82)] != -1 )
  {
    armyGroup::Swap(thisa, *(_DWORD *)(v1 + 78), oth, *(_DWORD *)(v1 + 82));
  }
}

//----- (004BF170) --------------------------------------------------------
void __thiscall swapManager::Update(void *this)
{
  char v1; // al@3
  char v2; // al@3
  void *v3; // [sp+Ch] [bp-24h]@1
  tag_message evt; // [sp+10h] [bp-20h]@1
  int skill; // [sp+2Ch] [bp-4h]@1

  v3 = this;
  evt.eventCode = 512;
  evt.xCoordOrKeycode = 3;
  evt.payload = gText;
  for ( skill = 0; skill < 4; ++skill )
  {
    evt.yCoordOrFieldID = skill + 67;
    v1 = hero::Stats(*(hero **)((char *)v3 + 62), (PRIMARY_SKILL)skill);
    sprintf(gText, "%d", v1);
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
    evt.yCoordOrFieldID = skill + 72;
    v2 = hero::Stats(*(hero **)((char *)v3 + 66), (PRIMARY_SKILL)skill);
    sprintf(gText, "%d", v2);
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 5; ++skill )
  {
    evt.yCoordOrFieldID = skill + 78;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 62) + skill + 101) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 4;
      evt.payload = (void *)*(_BYTE *)(*(_DWORD *)((char *)v3 + 62) + skill + 101);
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 5; ++skill )
  {
    evt.yCoordOrFieldID = skill + 116;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 62) + skill + 101) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 3;
      sprintf(gText, "%d", *(_WORD *)(*(_DWORD *)((char *)v3 + 62) + 2 * skill + 106));
      evt.payload = gText;
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 5; ++skill )
  {
    evt.yCoordOrFieldID = skill + 83;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 66) + skill + 101) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 4;
      evt.payload = (void *)*(_BYTE *)(*(_DWORD *)((char *)v3 + 66) + skill + 101);
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 5; ++skill )
  {
    evt.yCoordOrFieldID = skill + 121;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 66) + skill + 101) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 3;
      sprintf(gText, "%d", *(_WORD *)(*(_DWORD *)((char *)v3 + 66) + 2 * skill + 106));
      evt.payload = gText;
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 14; ++skill )
  {
    evt.yCoordOrFieldID = skill + 88;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 62) + skill + 213) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 4;
      evt.payload = (void *)*(_BYTE *)(*(_DWORD *)((char *)v3 + 62) + skill + 213);
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
  for ( skill = 0; skill < 14; ++skill )
  {
    evt.yCoordOrFieldID = skill + 102;
    if ( *(_BYTE *)(*(_DWORD *)((char *)v3 + 66) + skill + 213) == -1 )
    {
      evt.xCoordOrKeycode = 6;
      evt.payload = (void *)4;
    }
    else
    {
      evt.xCoordOrKeycode = 5;
      evt.payload = (void *)4;
      heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
      evt.xCoordOrKeycode = 4;
      evt.payload = (void *)*(_BYTE *)(*(_DWORD *)((char *)v3 + 66) + skill + 213);
    }
    heroWindow::BroadcastMessage(*(heroWindow **)((char *)v3 + 54), &evt);
  }
}

//----- (004BF5F0) --------------------------------------------------------
heroWindowManager *__thiscall swapManager::SplitMons(int this)
{
  heroWindowManager *result; // eax@9
  int v2; // [sp+Ch] [bp-44h]@1
  heroWindow *thisa; // [sp+18h] [bp-38h]@1
  int evt; // [sp+20h] [bp-30h]@6
  int v5; // [sp+24h] [bp-2Ch]@9
  int v6; // [sp+28h] [bp-28h]@9
  char *v7; // [sp+38h] [bp-18h]@9
  __int16 v8; // [sp+3Ch] [bp-14h]@1
  int v9; // [sp+40h] [bp-10h]@1
  int i; // [sp+44h] [bp-Ch]@15
  __int16 v11; // [sp+48h] [bp-8h]@1
  int v12; // [sp+4Ch] [bp-4h]@1

  v2 = this;
  v8 = 68;
  v9 = *(_DWORD *)(this + 4 * *(_DWORD *)(this + 70) + 62) + 101;
  v12 = *(_DWORD *)(this + 4 * *(_DWORD *)(this + 74) + 62) + 101;
  v11 = 1;
  thisa = (heroWindow *)operator new(68);
  if ( thisa )
    gpTownManager->dialog = heroWindow::heroWindow(thisa, 177, 20, "splitwin.bin");
  else
    gpTownManager->dialog = 0;
  if ( !gpTownManager->dialog )
    MemError();
  gpTownManager->field_16A = 0;
  gpTownManager->field_16E = *(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5);
  evt = 512;
  if ( *(_DWORD *)(v2 + 70) == *(_DWORD *)(v2 + 74) )
    sprintf(gText, "Move how many troops?");
  else
    sprintf(
      gText,
      "Move how many %s troops from %s to %s?",
      gArmyNames[*(_BYTE *)(*(_DWORD *)(v2 + 78) + v9)],
      *(_DWORD *)(v2 + 4 * *(_DWORD *)(v2 + 70) + 62) + 10,
      *(_DWORD *)(v2 + 4 * *(_DWORD *)(v2 + 74) + 62) + 10);
  v5 = 3;
  v6 = 1;
  v7 = gText;
  heroWindow::BroadcastMessage(gpTownManager->dialog, (tag_message *)&evt);
  sprintf(gText, "%d", gpTownManager->field_16A);
  v6 = 68;
  v7 = gText;
  heroWindow::BroadcastMessage(gpTownManager->dialog, (tag_message *)&evt);
  heroWindowManager::DoDialog(
    gpWindowManager,
    gpTownManager->dialog,
    (int (__fastcall *)(tag_message *))SplitArmyHandler,
    0);
  operator delete(gpTownManager->dialog);
  result = gpWindowManager;
  if ( gpWindowManager->buttonPressedCode == 30722 )
  {
    if ( *(_BYTE *)(*(_DWORD *)(v2 + 78) + v9) == *(_BYTE *)(*(_DWORD *)(v2 + 82) + v12) )
    {
      *(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5) -= LOWORD(gpTownManager->field_16A);
      *(_WORD *)(v12 + 2 * *(_DWORD *)(v2 + 82) + 5) += LOWORD(gpTownManager->field_16A);
      result = (heroWindowManager *)*(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5);
      if ( !*(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5) )
      {
        result = *(heroWindowManager **)(v2 + 78);
        *((_BYTE *)&result->vtable + v9) = -1;
      }
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(v2 + 82) + v12) != -1 )
      {
        for ( i = 0; i < 5 && *(_BYTE *)(i + v12) != -1; ++i )
          ;
        if ( i < 5 )
          *(_DWORD *)(v2 + 82) = i;
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 82) + v12) = *(_BYTE *)(*(_DWORD *)(v2 + 78) + v9);
      *(_WORD *)(v12 + 2 * *(_DWORD *)(v2 + 82) + 5) = gpTownManager->field_16A;
      *(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5) -= LOWORD(gpTownManager->field_16A);
      result = (heroWindowManager *)*(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5);
      if ( !*(_WORD *)(v9 + 2 * *(_DWORD *)(v2 + 78) + 5) )
      {
        result = *(heroWindowManager **)(v2 + 78);
        *((_BYTE *)&result->vtable + v9) = -1;
      }
    }
  }
  return result;
}

//----- (004BF980) --------------------------------------------------------
int __thiscall advManager::StartCursor(int this, signed int a2)
{
  int v2; // ST24_4@4
  int v3; // ST20_4@4
  int result; // eax@4
  int v5; // [sp+Ch] [bp-18h]@1

  v5 = this;
  *(_DWORD *)(this + 638) = a2;
  *(_DWORD *)(this + 642) = advManager::GetCursorBaseFrame(a2) + 1;
  if ( *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) <= 0 )
    *(_DWORD *)(v5 + 650) = 2;
  else
    *(_DWORD *)(v5 + 650) = 1;
  v2 = normalDirTable[4 * a2];
  v3 = byte_4F1DC1[4 * a2];
  *(_DWORD *)(v5 + 662) = *(_DWORD *)(v5 + 658);
  *(_DWORD *)(v5 + 670) = *(_DWORD *)(v5 + 666);
  *(_DWORD *)(v5 + 658) += v2;
  *(_DWORD *)(v5 + 666) += v3;
  result = **(_DWORD **)(v5 + 174)
         + 12 * (*(_DWORD *)(v5 + 474) + *(_DWORD *)(v5 + 666)) * *(_DWORD *)(*(_DWORD *)(v5 + 174) + 8)
         + 12 * (*(_DWORD *)(v5 + 470) + *(_DWORD *)(v5 + 658));
  *(_BYTE *)(result + 8) |= 0x40u;
  return result;
}

//----- (004BFAC0) --------------------------------------------------------
void __thiscall advManager::StopCursor(advManager *this, int a2)
{
  mapCell *v2; // ST14_4@4

  if ( a2 )
  {
    bMoveSoundMade = 1;
    this->field_282 = advManager::GetCursorBaseFrame(this->field_27E);
    this->field_286 = 0;
    EveryOther = 0;
    hOldWalkSample = 0;
    hNewWalkSample = 0;
  }
  this->field_28A = 0;
  if ( this->field_296 != -1 )
  {
    v2 = &this->map->tiles[this->viewX + this->field_296] + this->map->width * (this->viewY + this->field_29E);
    v2->displayFlags &= 0xBFu;
    this->field_29E = -1;
    this->field_296 = this->field_29E;
  }
  this->field_28E = 0;
}
// 51E180: using guessed type int bMoveSoundMade;
// 51E1B4: using guessed type int hOldWalkSample;
// 51E1B8: using guessed type int hNewWalkSample;
// 51E1BC: using guessed type int EveryOther;

//----- (004BFBE0) --------------------------------------------------------
void __thiscall advManager::DrawCursor(advManager *this)
{
  int v1; // ecx@44
  int spriteIdx; // [sp+18h] [bp-Ch]@9
  int spriteIdxa; // [sp+18h] [bp-Ch]@18
  int a4; // [sp+1Ch] [bp-8h]@6
  int a3; // [sp+20h] [bp-4h]@6
  int a3a; // [sp+20h] [bp-4h]@9

  if ( bShowIt && !bSpecialHideCursor )
  {
    if ( gbDrawSavedCursor )
    {
      this->field_27E = S1cursorDirection;
      this->field_282 = S1cursorBaseFrame;
      this->field_286 = S1cursorFrameCount;
      this->field_28A = S1cursorCycle;
      this->field_28E = S1cursorTurning;
    }
    a3 = this->field_1F6 + 224;
    a4 = this->field_1FA + 255;
    if ( this->field_27A == 6 )
      a4 = this->field_1FA + 245;
    if ( this->field_282 & 0x80 )
    {
      a3a = this->field_1F6 + 256;
      spriteIdx = this->field_286 + (this->field_282 & 0x7F);
      if ( this->field_27A == 6 && !(advManager::GetCell(this, this->viewX + 7, this->viewY + 7)->displayFlags & 4) )
        FlipIconToBitmap(this->frothIcon, gpWindowManager->screenBuffer, a3a, a4, spriteIdx, 1, 0, 0, 480, 480, 0);
      FlipIconToBitmap(
        (icon *)this->heroIcons[this->field_27A],
        gpWindowManager->screenBuffer,
        a3a,
        a4,
        spriteIdx,
        1,
        0,
        0,
        480,
        480,
        0);
      if ( this->field_27A == 6 )
      {
        FlipIconToBitmap(
          (icon *)this->flagIcons2[gpCurPlayer->color],
          gpWindowManager->screenBuffer,
          a3a,
          a4,
          spriteIdx,
          0,
          0,
          0,
          0,
          0,
          0);
      }
      else
      {
        if ( !this->field_28A )
          spriteIdx = (((unsigned __int64)this->field_202 >> 32) ^ abs(this->field_202) & 7)
                    + (this->field_282 & 0x7F)
                    - ((unsigned __int64)this->field_202 >> 32)
                    + 56;
        FlipIconToBitmap(
          (icon *)this->flagIcons1[gpCurPlayer->color],
          gpWindowManager->screenBuffer,
          a3a,
          a4,
          spriteIdx,
          1,
          0,
          0,
          480,
          480,
          0);
        ++this->field_206;
      }
    }
    else
    {
      spriteIdxa = this->field_286 + this->field_282;
      if ( this->field_27A == 6 && !(advManager::GetCell(this, this->viewX + 7, this->viewY + 7)->displayFlags & 4) )
        IconToBitmap(this->frothIcon, gpWindowManager->screenBuffer, a3, a4, spriteIdxa, 1, 0, 0, 0x1E0u, 480, 0);
      IconToBitmap(
        (icon *)this->heroIcons[this->field_27A],
        gpWindowManager->screenBuffer,
        a3,
        a4,
        spriteIdxa,
        1,
        0,
        0,
        0x1E0u,
        480,
        0);
      if ( this->field_27A == 6 )
      {
        IconToBitmap(
          (icon *)this->flagIcons2[gpCurPlayer->color],
          gpWindowManager->screenBuffer,
          a3,
          a4,
          spriteIdxa,
          0,
          0,
          0,
          0,
          0,
          0);
      }
      else
      {
        if ( !this->field_28A )
          spriteIdxa = (((unsigned __int64)this->field_202 >> 32) ^ abs(this->field_202) & 7)
                     + (this->field_282 & 0x7F)
                     - ((unsigned __int64)this->field_202 >> 32)
                     + 56;
        IconToBitmap(
          (icon *)this->flagIcons1[gpCurPlayer->color],
          gpWindowManager->screenBuffer,
          a3,
          a4,
          spriteIdxa,
          1,
          0,
          0,
          0x1E0u,
          480,
          0);
        ++this->field_206;
      }
    }
    if ( this->field_28A && *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) != 4 )
    {
      ++this->field_286;
      if ( *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) == 3
        && (this->field_286 == 4 || this->field_286 == 1) )
        ++this->field_286;
      if ( !*((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) )
      {
        EveryOther = 1 - EveryOther;
        if ( EveryOther )
          --this->field_286;
      }
    }
    if ( this->field_286 >= 8 )
      this->field_286 = 0;
    if ( !this->field_28E )
    {
      if ( !this->field_286 )
        hOldWalkSample = hNewWalkSample;
      if ( this->field_286 == 3 || *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) == 4 && !bMoveSoundMade )
      {
        bMoveSoundMade = 1;
        if ( !EveryOther )
        {
          v1 = advManager::GetCell(this, this->viewX + 7, this->viewY + 7)->groundIndex;
          hNewWalkSample = (int)soundManager::MemorySample(
                                  (soundManager *)gpSoundManager,
                                  this->walkSamples[(unsigned __int8)giGroundToTerrain[v1]]);
        }
      }
    }
    if ( !gbDrawSavedCursor )
    {
      S1cursorDirection = this->field_27E;
      S1cursorBaseFrame = this->field_282;
      S1cursorFrameCount = this->field_286;
      S1cursorCycle = this->field_28A;
      S1cursorTurning = this->field_28E;
    }
  }
}
// 4F2AE4: using guessed type int gbDrawSavedCursor;
// 51E180: using guessed type int bMoveSoundMade;
// 51E1B4: using guessed type int hOldWalkSample;
// 51E1B8: using guessed type int hNewWalkSample;
// 51E1BC: using guessed type int EveryOther;
// 523F0C: using guessed type int bSpecialHideCursor;
// 5240A8: using guessed type int gpSoundManager;
// 524C14: using guessed type int bShowIt;
// 532DB0: using guessed type int S1cursorFrameCount;
// 532DB4: using guessed type int S1cursorBaseFrame;
// 532DE4: using guessed type int S1cursorDirection;
// 532DE8: using guessed type int S1cursorCycle;
// 532DEC: using guessed type int S1cursorTurning;

//----- (004C01E0) --------------------------------------------------------
int __thiscall advManager::DrawCursorShadow(advManager *this)
{
  int result; // eax@15
  signed int v3; // [sp+10h] [bp-1Ch]@30
  signed int v4; // [sp+14h] [bp-18h]@13
  int v5; // [sp+18h] [bp-14h]@18
  int spriteIdx; // [sp+20h] [bp-Ch]@9
  int spriteIdxa; // [sp+20h] [bp-Ch]@34
  int a4; // [sp+24h] [bp-8h]@6
  int a3; // [sp+28h] [bp-4h]@6

  if ( bShowIt && !bSpecialHideCursor )
  {
    if ( gbDrawSavedCursor )
    {
      this->field_27E = S1cursorDirection;
      this->field_282 = S1cursorBaseFrame;
      this->field_286 = S1cursorFrameCount;
      this->field_28A = S1cursorCycle;
      this->field_28E = S1cursorTurning;
    }
    a3 = this->field_1F6 + 224;
    a4 = this->field_1FA + 255;
    if ( this->field_27A == 6 )
      a4 = this->field_1FA + 245;
    if ( this->field_282 & 0x80 )
    {
      spriteIdx = this->field_286 + (this->field_282 & 0x7F);
      if ( this->field_276 && this->field_27A == 6 )
      {
        if ( spriteIdx < 9 || spriteIdx >= 36 )
          v4 = 0;
        else
          v4 = 36;
        result = IconToBitmap(
                   this->boatShadowIcon,
                   gpWindowManager->screenBuffer,
                   this->field_1F6 + 224,
                   a4,
                   v4 + spriteIdx,
                   1,
                   0,
                   0,
                   0x1E0u,
                   480,
                   0);
      }
      else
      {
        result = (int)this;
        if ( this->field_276 )
        {
          result = (int)this;
          if ( this->field_27A != 6 )
          {
            v5 = this->field_286 + (this->field_282 & 0x7F);
            if ( spriteIdx == 51 )
              v5 = 56;
            if ( v5 == 50 )
              v5 = 57;
            if ( v5 == 49 )
              v5 = 58;
            if ( v5 == 47 )
              v5 = 55;
            if ( v5 == 46 )
              v5 = 55;
            if ( v5 < 9 || v5 >= 36 )
              v3 = 0;
            else
              v3 = 50;
            result = IconToBitmap(
                       this->shadowIcon,
                       gpWindowManager->screenBuffer,
                       this->field_1F6 + 224,
                       a4,
                       v3 + v5,
                       1,
                       0,
                       0,
                       0x1E0u,
                       480,
                       0);
          }
        }
      }
    }
    else
    {
      spriteIdxa = this->field_286 + this->field_282;
      if ( this->field_276 && this->field_27A == 6 )
      {
        result = IconToBitmap(
                   this->boatShadowIcon,
                   gpWindowManager->screenBuffer,
                   a3,
                   a4,
                   spriteIdxa,
                   1,
                   0,
                   0,
                   0x1E0u,
                   480,
                   0);
      }
      else
      {
        result = (int)this;
        if ( this->field_276 )
        {
          result = (int)this;
          if ( this->field_27A != 6 )
            result = IconToBitmap(
                       this->shadowIcon,
                       gpWindowManager->screenBuffer,
                       a3,
                       a4,
                       spriteIdxa,
                       1,
                       0,
                       0,
                       0x1E0u,
                       480,
                       0);
        }
      }
    }
    if ( !gbDrawSavedCursor )
    {
      S1cursorDirection = this->field_27E;
      S1cursorBaseFrame = this->field_282;
      S1cursorFrameCount = this->field_286;
      S1cursorCycle = this->field_28A;
      result = this->field_28E;
      S1cursorTurning = this->field_28E;
    }
  }
  return result;
}
// 4F2AE4: using guessed type int gbDrawSavedCursor;
// 523F0C: using guessed type int bSpecialHideCursor;
// 524C14: using guessed type int bShowIt;
// 532DB0: using guessed type int S1cursorFrameCount;
// 532DB4: using guessed type int S1cursorBaseFrame;
// 532DE4: using guessed type int S1cursorDirection;
// 532DE8: using guessed type int S1cursorCycle;
// 532DEC: using guessed type int S1cursorTurning;

//----- (004C0550) --------------------------------------------------------
int __stdcall advManager::GetCursorBaseFrame(signed int a1)
{
  int result; // eax@3

  if ( a1 <= 4 )
  {
    result = 9 * a1;
  }
  else
  {
    switch ( a1 )
    {
      case 5:
        result = 155;
        break;
      case 6:
        result = 146;
        break;
      case 7:
        result = 137;
        break;
      default:
        result = 0;
        break;
    }
  }
  return result;
}

//----- (004C05E0) --------------------------------------------------------
void __thiscall advManager::TurnTo(int this, int a2)
{
  int thisa; // [sp+10h] [bp-14h]@1
  signed int v3; // [sp+14h] [bp-10h]@7
  int v4; // [sp+18h] [bp-Ch]@1
  signed int v5; // [sp+1Ch] [bp-8h]@1
  int v6; // [sp+20h] [bp-4h]@7
  int v7; // [sp+20h] [bp-4h]@19

  thisa = this;
  v5 = 1;
  v4 = a2 - *(_DWORD *)(this + 638);
  if ( a2 != *(_DWORD *)(this + 638) )
  {
    if ( v4 < 0 && v4 >= -4 || v4 > 0 && v4 > 4 )
      v5 = -1;
    *(_DWORD *)(this + 654) = 1;
    v6 = 2 * *(_DWORD *)(this + 638);
    v3 = giStepDelay[*((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer])];
    if ( !*((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) )
      v3 *= 3;
    if ( *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) == 1 )
      v3 = (signed __int64)((double)v3 * 1.5);
    do
    {
      *(_DWORD *)(thisa + 650) = 1;
      if ( *(_DWORD *)(thisa + 634) < 6 )
        *(_DWORD *)(thisa + 642) = horseFrameFlip[v6];
      else
        *(_DWORD *)(thisa + 642) = boatFrameFlip[v6];
      *(_DWORD *)(thisa + 646) = 0;
      animTimer = KBTickCount() + v3;
      if ( *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) != 4 )
      {
        if ( advManager::ComboDraw((advManager *)thisa, *(_DWORD *)(thisa + 470), *(_DWORD *)(thisa + 474), 0) )
          advManager::UpdateScreen((advManager *)thisa, 0, 0);
        if ( bShowIt )
          DelayTil(&animTimer);
      }
      v7 = v5 + v6;
      if ( v7 < 0 )
        v7 = 15;
      v6 = (((unsigned __int64)v7 >> 32) ^ abs(v7) & 0xF) - ((unsigned __int64)v7 >> 32);
    }
    while ( 2 * a2 != v6 );
    *(_DWORD *)(thisa + 638) = a2;
    advManager::StopCursor((advManager *)thisa, 1);
    if ( bShowIt )
      DelayTil(&animTimer);
    if ( advManager::ComboDraw((advManager *)thisa, *(_DWORD *)(thisa + 470), *(_DWORD *)(thisa + 474), 0) )
      advManager::UpdateScreen((advManager *)thisa, 0, 0);
  }
}
// 4F1D58: using guessed type __int16 horseFrameFlip[];
// 4F1D78: using guessed type __int16 boatFrameFlip[];
// 51E1A0: using guessed type int giStepDelay[];
// 524C14: using guessed type int bShowIt;

//----- (004C0840) --------------------------------------------------------
bool __stdcall advManager::GetMoveShowIt(int a1, int a2)
{
  int v3; // [sp+10h] [bp-8h]@1
  int v4; // [sp+14h] [bp-4h]@1

  v4 = normalDirTable[4 * a2];
  v3 = byte_4F1DC1[4 * a2];
  return (gbThisNetHumanPlayer[giCurPlayer] || !*(_DWORD *)&blackoutComputer)
      && (MapExtraPosAndAdjacentsSet(*(_DWORD *)(a1 + 25), *(_DWORD *)(a1 + 29), giCurWatchPlayerBit)
       || MapExtraPosAndAdjacentsSet(v4 + *(_DWORD *)(a1 + 25), v3 + *(_DWORD *)(a1 + 29), giCurWatchPlayerBit));
}
// 5306F0: using guessed type char giCurWatchPlayerBit;

//----- (004C08F0) --------------------------------------------------------
mapCell *__thiscall advManager::MoveHero(advManager *this, int a7, signed int a6, int *trigX, int *trigY, int arg10, int arg14, signed int a8, int a9)
{
  int v9; // eax@3
  mapCell *fromCell; // ST90_4@5
  signed int terrain; // ST74_4@5
  boat *boat; // ST5C_4@16
  mapCell *v13; // eax@16
  __int64 v14; // ST98_8@21
  int v15; // ebx@46
  int v16; // eax@46
  int v17; // edx@64
  int v18; // ecx@86
  int v20; // [sp+10h] [bp-80h]@19
  int v22; // [sp+20h] [bp-70h]@122
  int img2Arg; // [sp+24h] [bp-6Ch]@120
  int img2Type; // [sp+28h] [bp-68h]@120
  int img1Type; // [sp+2Ch] [bp-64h]@120
  int img1Arg; // [sp+30h] [bp-60h]@120
  int v27; // [sp+34h] [bp-5Ch]@68
  signed int v28; // [sp+44h] [bp-4Ch]@46
  int deltaY; // [sp+48h] [bp-48h]@3
  int v30; // [sp+4Ch] [bp-44h]@3
  int deltaX; // [sp+50h] [bp-40h]@3
  int v32; // [sp+58h] [bp-38h]@3
  int cost; // [sp+5Ch] [bp-34h]@5
  int v34; // [sp+60h] [bp-30h]@46
  mapCell *v35; // [sp+64h] [bp-2Ch]@3
  int v36; // [sp+68h] [bp-28h]@5
  mapCell *v37; // [sp+6Ch] [bp-24h]@89
  signed int i; // [sp+74h] [bp-1Ch]@12
  int j; // [sp+74h] [bp-1Ch]@64
  signed int k; // [sp+74h] [bp-1Ch]@109
  signed int l; // [sp+74h] [bp-1Ch]@120
  hero *hro; // [sp+80h] [bp-10h]@3
  void *mapEvent; // [sp+84h] [bp-Ch]@1
  mapCell *toCell; // [sp+88h] [bp-8h]@5
  int v45; // [sp+8Ch] [bp-4h]@64

  mapEvent = 0;
  if ( gbThisNetHumanPlayer[giCurPlayer] )
    SetNoDialogMenus(0);
  gbHitEvent = 0;
  *(_DWORD *)a8 = 0;
  *(_DWORD *)arg10 = 0;
  gbHeroMoving = 1;
  v35 = 0;
  v9 = (int)(&gpGame->gameDifficulty + 125 * gpCurPlayer->curHeroIdx);
  hro = (hero *)(v9 + 10180);
  v32 = *(_DWORD *)(v9 + 10205);
  v30 = *(_DWORD *)(v9 + 10209);
  deltaX = normalDirTable[4 * a7];
  deltaY = byte_4F1DC1[4 * a7];
  bShowIt = advManager::GetMoveShowIt(v9 + 10180, a7);
  if ( bShowIt )
    gbMoveShown = 1;
  fromCell = advManager::GetCell(this, hro->x, hro->y);
  terrain = (unsigned __int8)giGroundToTerrain[fromCell->groundIndex];
  toCell = advManager::GetCell(this, deltaX + hro->x, deltaY + hro->y);
  cost = CalcTerrainCost(
           terrain,
           a7 & 1,
           hro->remainingMobility,
           hro->secondarySkillLevel[0],
           ((unsigned __int8)fromCell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1,
           ((unsigned __int8)toCell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1);
  v36 = CalcTerrainCost(
          (unsigned __int8)giGroundToTerrain[toCell->groundIndex],
          0,
          hro->remainingMobility - cost,
          hro->secondarySkillLevel[0],
          ((unsigned __int8)toCell->bitfield_1_hasObject_1_isRoad_6_objTileset >> 1) & 1,
          1);
  if ( !a9 && hro->remainingMobility < cost )
  {
    *(_DWORD *)arg10 = 1;
    hro->remainingMobility = 0;
    advManager::StopCursor(this, 1);
    goto LABEL_95;
  }
  SendMapChange(1, hro->idx, hro->x, hro->y, giCurPlayer, a6, a7);
  advManager::MobilizeCurrHero(this, 0);
  *trigX = deltaX + hro->x;
  *trigY = deltaY + hro->y;
  if ( this->field_27E != a7 )
    advManager::TurnTo((int)this, a7);
  HIBYTE(hro->field_2B) = a7;
  if ( hro->flags & 0x80 && toCell->objType == 28 )
  {
    for ( i = 0; i < 48 && gpGame->boats[i].field_6 != hro->idx; ++i )
      ;
    boat = &gpGame->boats[i];
    v13 = advManager::GetCell(this, hro->x, hro->y);
    boat->underlyingObjType = v13->objType;
    boat->underlyingObjExtra = v13->field_4_1_1_isShadow_1_13_extraInfo >> 3;
    boat->field_3 = LOBYTE(this->field_27E);
    boat->field_6 |= 0x80u;
    v13->objType = -85;
    v13->field_4_1_1_isShadow_1_13_extraInfo = v13->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * i;
    boat->x = LOBYTE(hro->x);
    boat->y = LOBYTE(hro->y);
    advManager::StopCursor(this, 1);
    advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
    advManager::UpdateScreen(this, 0, 0);
    this->field_272 = 0;
  }
  if ( !(toCell->objType & 0x80) || !advManager::ValidMoveWithEvent((int)gpAdvManager, (int)hro, a7) )
    goto LABEL_41;
  v20 = toCell->objType & 0x7F;
  if ( v20 != 35 )
  {
    if ( v20 == 42 )
    {
      if ( hro->flags & 0x80
        && !(gpGame->heroes[(unsigned __int8)((unsigned __int8)(toCell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].flags & 0x80) )
        goto LABEL_95;
      goto LABEL_33;
    }
    if ( v20 == 43 )
    {
      if ( hro->flags & 0x80 )
        goto LABEL_95;
      advManager::StopCursor(this, 1);
      this->field_272 = 0;
      v14 = LoadPlaySample("killfade.82m");
      heroWindowManager::SaveFizzleSource(gpWindowManager, 192, 192, 96, 96);
      advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
      heroWindowManager::FizzleForward(
        gpWindowManager,
        192,
        192,
        96,
        96,
        (unsigned int)gbThisNetHumanPlayer[giCurPlayer] < 1 ? 50 : -1,
        0,
        0);
      WaitEndSample((void *)0xFFFFFFFF, (resource *)v14, HIDWORD(v14));
    }
    else if ( StopOnTrigger((int)toCell) )
    {
LABEL_33:
      advManager::StopCursor(this, 1);
      advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
      advManager::UpdateScreen(this, 0, 0);
      hro->remainingMobility -= cost;
      if ( hro->remainingMobility < v36 )
        hro->remainingMobility = 0;
      v35 = toCell;
      goto LABEL_95;
    }
    goto LABEL_41;
  }
  if ( gpGame->castles[(unsigned __int8)((unsigned __int8)(toCell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)].ownerIdx == giCurPlayer
    || !town::HasGarrison(&gpGame->castles[(unsigned __int8)((unsigned __int8)(toCell->field_4_1_1_isShadow_1_13_extraInfo >> 8) >> -5)]) )
  {
LABEL_41:
    if ( advManager::ValidMove(this, a7, 0) )
    {
      if ( hro->occupiedObjType == 163 )
        gpGame->castles[hro->occupiedObjVal].visitingHeroIdx = -1;
      if ( this->field_A2 )
        *(_WORD *)(2 * (deltaX + hro->x) + 2 * MAP_WIDTH * (deltaY + hro->y) + this->sizeOfSomethingMapRelated) = 0;
      this->field_1FA = 0;
      this->field_1F6 = this->field_1FA;
      v15 = giVisRange[hro->secondarySkillLevel[3]];
      v16 = hero::HasArtifact(hro, 64);
      game::SetVisibility(
        gpGame,
        deltaX + this->viewX + 7,
        deltaY + this->viewY + 7,
        giCurPlayer,
        ((unsigned int)v16 >= 1) + v15);
      this->field_2AE = 1;
      v28 = dword_51E188[*((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer])];
      v34 = giStepDelay[*((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer])];
      advManager::StartCursor((int)this, a7);
      if ( *((_DWORD *)&gConfig + gbThisNetHumanPlayer[giCurPlayer]) == 4 )
      {
        if ( EveryOther )
          --this->field_282;
        bMoveSoundMade = 0;
        advManager::MoveOrigin((int)this, deltaX, deltaY);
        hro->x += deltaX;
        hro->y += deltaY;
        if ( advManager::ComboDraw(this, 0) )
          advManager::UpdateScreen(this, 0, 0);
        EveryOther = 1 - EveryOther;
      }
      else
      {
        if ( deltaX != 1 || deltaY != -1 )
        {
          if ( deltaX != -1 || deltaY != 1 )
          {
            if ( deltaX != 1 || deltaY != 1 )
            {
              if ( deltaX == -1 && deltaY == -1 )
              {
                giDeferObjDrawX = hro->x - 1;
                giDeferObjDrawY = hro->y;
              }
            }
            else
            {
              giDeferObjDrawX = hro->x;
              giDeferObjDrawY = hro->y + 1;
            }
          }
          else
          {
            giDeferObjDrawX = hro->x;
            giDeferObjDrawY = hro->y + 1;
          }
        }
        else
        {
          giDeferObjDrawX = hro->x + 1;
          giDeferObjDrawY = hro->y;
        }
        gbEnlargeScreenBlit = 0;
        dword_4F2E80 = 1;
        v17 = 16 % v28;
        v45 = 16 / v28;
        for ( j = 0; 2 * v45 > j; ++j )
        {
          if ( v45 == j )
          {
            advManager::MoveOrigin((int)this, deltaX, deltaY);
            hro->x += deltaX;
            hro->y += deltaY;
            this->field_1F6 = dword_51E1C4[deltaX];
            this->field_1FA = dword_51E1C4[deltaY];
          }
          v27 = KBTickCount();
          if ( j + 1 == 2 * v45 )
          {
            this->field_1F6 = 0;
            this->field_1FA = 0;
          }
          else
          {
            this->field_1F6 += deltaX * v28;
            this->field_1FA += deltaY * v28;
          }
          if ( advManager::ComboDraw(this, 0) )
          {
            giLimitUpdMinX = -1;
            advManager::UpdateScreen(this, 0, 0);
          }
          if ( bShowIt )
            DelayTilMilli(v34 + v27);
        }
        giDeferObjDrawY = -1;
        giDeferObjDrawX = -1;
        dword_4F2E80 = 0;
        advManager::DrawAdventureBorder((int)this, v17);
        gbEnlargeScreenBlit = 1;
      }
      hro->remainingMobility -= cost;
      if ( hro->remainingMobility < v36 )
      {
        hro->remainingMobility = 0;
        a6 = 1;
      }
      mapEvent = GetMapEvent(*trigX, *trigY);
      if ( mapEvent && !arg14 )
        a6 = 1;
      advManager::StopCursor(this, a6);
      if ( arg14 && a6 && advManager::ComboDraw(this, 0) )
        advManager::UpdateScreen(this, 0, 0);
      advManager::SetEnvironmentOrigin(this, this->viewX + 7, this->viewY + 7, 0);
      v18 = advManager::GetCell(this, this->viewX + 7, this->viewY + 7)->groundIndex;
      if ( (unsigned __int8)giGroundToTerrain[v18] != this->currentTerrain )
      {
        this->currentTerrain = (unsigned __int8)giGroundToTerrain[v18];
        if ( !*(_DWORD *)&useCDMusic )
          soundManager::SwitchAmbientMusic(
            (soundManager *)gpSoundManager,
            (unsigned __int8)giTerrainToMusicTrack[this->currentTerrain]);
      }
      this->field_1FA = 0;
      this->field_1F6 = this->field_1FA;
      v37 = advManager::GetCell(this, this->viewX + this->field_292, this->viewY + this->field_29A);
      *trigX = this->viewX + this->field_292;
      *trigY = this->viewY + this->field_29A;
      if ( v37->objType & 0x80 || hro->flags & 0x80 && v37->objType == 28 )
      {
        v35 = v37;
        switch ( v37->objType & 0x7F )
        {
          case LOCATION_NOTHING_SPECIAL:
          case LOCATION_NOTHING_SPECIAL|LOCATION_ALCHEMIST_LAB:
          case LOCATION_STREAM:
          case LOCATION_TREES:
          case LOCATION_MOUNTAINS:
          case LOCATION_VOLCANO:
          case LOCATION_FLOWERS:
          case LOCATION_ROCK:
          case LOCATION_LAKE:
          case LOCATION_MANDRAKE:
          case LOCATION_DEAD_TREE:
          case LOCATION_STUMP:
          case LOCATION_CRATER:
          case LOCATION_CACTUS:
          case LOCATION_MOUND:
          case LOCATION_DUNE:
          case LOCATION_LAVA_POOL:
          case LOCATION_SHRUB:
          case LOCATION_HOLE:
          case LOCATION_OUTCROPPING:
            v35 = 0;
            break;
          default:
            goto LABEL_95;
        }
      }
    }
    goto LABEL_95;
  }
  advManager::StopCursor(this, 1);
  advManager::CompleteDraw(this, this->viewX, this->viewY, 0, 1);
  advManager::UpdateScreen(this, 0, 0);
  hro->remainingMobility -= cost;
  if ( hro->remainingMobility < v36 )
    hro->remainingMobility = 0;
  v35 = toCell;
LABEL_95:
  advManager::UpdateRadar(this, 1, 1);
  gbHeroMoving = 0;
  if ( !a9 && (hro->x != v32 || hro->y != v30) )
  {
    if ( *(&mapRevealed[hro->x] + MAP_WIDTH * hro->y) & 0x80
      && !(hro->flags & 0x80)
      && (!v35 || (v35->objType & 0x7F) != 43) )
    {
      advManager::CheckAdjacentMon(this, a8);
      if ( hro->ownerIdx != giCurPlayer )
        v35 = 0;
    }
  }
  if ( gbThisNetHumanPlayer[giCurPlayer] )
    SetNoDialogMenus(1);
  if ( mapEvent )
  {
    if ( arg14 )
    {
      if ( *((_BYTE *)mapEvent + 31) )
      {
        for ( k = 0; k < 7; ++k )
        {
          gpGame->players[giCurPlayer].resources[k] += *(_DWORD *)((char *)mapEvent + 4 * k + 1);
          if ( gpGame->players[giCurPlayer].resources[k] < 0 )
            gpGame->players[giCurPlayer].resources[k] = 0;
        }
        if ( *(_WORD *)((char *)mapEvent + 29) != -1 && hero::NumArtifacts(hro) < 14 )
          GiveArtifact(hro, (ARTIFACT)*(_WORD *)((char *)mapEvent + 29), 1, -1);
        if ( *((_BYTE *)mapEvent + 32) )
          *((_BYTE *)mapEvent + 37) = 0;
      }
    }
    else
    {
      img1Type = -1;
      img1Arg = 0;
      img2Type = -1;
      img2Arg = 0;
      for ( l = 0; l < 7; ++l )
      {
        v22 = *(_DWORD *)((char *)mapEvent + 4 * l + 1);
        if ( gpGame->players[giCurPlayer].resources[l] < -v22 )
          v22 = -gpGame->players[giCurPlayer].resources[l];
        gpGame->players[giCurPlayer].resources[l] += *(_DWORD *)((char *)mapEvent + 4 * l + 1);
        if ( gpGame->players[giCurPlayer].resources[l] < 0 )
          gpGame->players[giCurPlayer].resources[l] = 0;
        if ( v22 )
        {
          if ( img1Type != -1 )
          {
            img2Type = img1Type;
            img2Arg = img1Arg;
          }
          img1Type = l;
          img1Arg = v22;
        }
      }
      if ( *(_WORD *)((char *)mapEvent + 29) != -1 && hero::NumArtifacts(hro) < 14 )
      {
        GiveArtifact(hro, (ARTIFACT)*(_WORD *)((char *)mapEvent + 29), 1, -1);
        if ( img1Type != -1 )
        {
          img2Type = img1Type;
          img2Arg = img1Arg;
        }
        img1Type = 7;
        img1Arg = *(_WORD *)((char *)mapEvent + 29);
      }
      if ( *((_BYTE *)mapEvent + 32) )
        *((_BYTE *)mapEvent + 37) = 0;
      if ( img1Type >= 0 && img1Type <= 6 && img1Arg < 0 )
        img1Arg -= 100000;
      if ( img2Type >= 0 && img2Type <= 6 && img2Arg < 0 )
        img2Arg -= 100000;
      NormalDialog((char *)mapEvent + 49, 1, -1, -1, img1Type, img1Arg, img2Type, img2Arg, -1, 0);
      gbHitEvent = 1;
    }
  }
  return v35;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F2E80: using guessed type int dword_4F2E80;
// 4F2E84: using guessed type int gbEnlargeScreenBlit;
// 4F3084: using guessed type int gbHeroMoving;
// 4F4BC0: using guessed type int giDeferObjDrawX;
// 4F4BC4: using guessed type int giDeferObjDrawY;
// 51E180: using guessed type int bMoveSoundMade;
// 51E188: using guessed type int dword_51E188[];
// 51E1A0: using guessed type int giStepDelay[];
// 51E1BC: using guessed type int EveryOther;
// 51E1C4: using guessed type int dword_51E1C4[];
// 5230F8: using guessed type struct SAMPLE2 NULL_SAMPLE2;
// 523ECC: using guessed type int gbHitEvent;
// 5240A8: using guessed type int gpSoundManager;
// 5247A8: using guessed type int gbMoveShown;
// 524C14: using guessed type int bShowIt;

//----- (004C1B30) --------------------------------------------------------
signed int __thiscall advManager::CheckAdjacentMon(void *this, signed int a2)
{
  char *v2; // eax@1
  signed int result; // eax@1
  void *thisa; // [sp+Ch] [bp-1Ch]@1
  mapCell *cell; // [sp+10h] [bp-18h]@2
  mapCell *a3; // [sp+14h] [bp-14h]@2
  signed int a5; // [sp+18h] [bp-10h]@1
  int a4; // [sp+1Ch] [bp-Ch]@1
  int row; // [sp+20h] [bp-8h]@1
  int a8; // [sp+24h] [bp-4h]@1

  thisa = this;
  v2 = (char *)gpGame + 250 * gpCurPlayer->curHeroIdx;
  a4 = (int)(v2 + 10180);
  a5 = 0;
  result = advManager::FindAdjacentMonster(
             this,
             *(_DWORD *)(v2 + 10205),
             *(_DWORD *)(v2 + 10209),
             (int)&a8,
             (int)&row,
             -1,
             -1);
  if ( result )
  {
    advManager::StopCursor((advManager *)thisa, 1);
    advManager::CompleteDraw(
      (advManager *)thisa,
      *(_DWORD *)((char *)thisa + 470),
      *(_DWORD *)((char *)thisa + 474),
      0,
      1);
    advManager::UpdateScreen((advManager *)thisa, 0, 0);
    cell = advManager::GetCell((advManager *)thisa, a8, row);
    a3 = advManager::GetCell((advManager *)thisa, *(_DWORD *)(a4 + 25), *(_DWORD *)(a4 + 29));
    if ( gbThisNetHumanPlayer[giCurPlayer] )
      advManager::PlayerMonsterInteract(
        thisa,
        cell,
        a3,
        (hero *)a4,
        (heroWindow *)&a5,
        *(_QWORD *)(a4 + 25),
        1,
        __PAIR__(row, a8));
    else
      advManager::ComputerMonsterInteract((int)cell, a4, (int)&a5);
    if ( a5 )
    {
      advManager::EraseObj((advManager *)thisa, cell, a8, row);
      if ( gbThisNetHumanPlayer[giCurPlayer] )
        advManager::FizzleCenter(thisa, 0);
    }
    result = a2;
    *(_DWORD *)a2 = 1;
  }
  return result;
}

//----- (004C1CB0) --------------------------------------------------------
signed int __thiscall advManager::ValidMoveWithEvent(int this, int a2, int a3)
{
  signed int result; // eax@5
  int v4; // [sp+14h] [bp-14h]@1
  int v5; // [sp+18h] [bp-10h]@1
  int v6; // [sp+24h] [bp-4h]@6

  v5 = normalDirTable[4 * a3] + *(_DWORD *)(a2 + 25);
  v4 = byte_4F1DC1[4 * a3] + *(_DWORD *)(a2 + 29);
  if ( v5 >= 0 && MAP_WIDTH - 1 >= v5 && v4 >= 0 && MAP_HEIGHT - 1 >= v4 )
  {
    v6 = **(_DWORD **)(this + 174) + 12 * v4 * *(_DWORD *)(*(_DWORD *)(this + 174) + 8) + 12 * v5;
    if ( (*(_BYTE *)(v6 + 9) & 0x7F) == 42 )
    {
      if ( *(_BYTE *)(a2 + 227) & 0x80 )
        result = (gpGame->heroes[(unsigned __int8)((unsigned __int8)(*(_WORD *)(v6 + 4) >> 8) >> -5)].flags & 0x80) != 0;
      else
        result = 1;
    }
    else
    {
      result = advManager::ValidMove((advManager *)this, a3, 1);
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (004C1E00) --------------------------------------------------------
signed int __thiscall advManager::ValidMove(advManager *this, int a2, int a3)
{
  signed int result; // eax@3
  advManager *v4; // [sp+Ch] [bp-3Ch]@1
  int v5; // [sp+10h] [bp-38h]@45
  mapCell *v6; // [sp+14h] [bp-34h]@31
  int v7; // [sp+18h] [bp-30h]@1
  int v8; // [sp+1Ch] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-28h]@1
  int v10; // [sp+24h] [bp-24h]@1
  mapCell *v11; // [sp+28h] [bp-20h]@7
  int v12; // [sp+34h] [bp-14h]@1
  int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+40h] [bp-8h]@1
  int v15; // [sp+44h] [bp-4h]@7

  v4 = this;
  v10 = normalDirTable[4 * a2];
  v8 = byte_4F1DC1[4 * a2];
  v12 = v10 + this->viewX;
  v14 = v8 + this->viewY;
  v9 = this->viewX + 7;
  v7 = this->viewY + 7;
  v13 = v12 + 7;
  if ( v12 < -7 || MAP_WIDTH - 8 < v12 )
    return 0;
  if ( v14 < -7 || MAP_HEIGHT - 8 < v14 )
    return 0;
  v15 = (int)(&this->map->tiles[(v14 + 7) * this->map->width] + v13);
  v11 = &this->map->tiles[v7 * this->map->width] + v9;
  if ( *(_BYTE *)(v15 + 8) & 8 )
    return 0;
  if ( giGroundToTerrain[*(_WORD *)v15] )
  {
    if ( this->field_27A == 6 && *(_BYTE *)(v15 + 9) != 28 )
      return 0;
  }
  else
  {
    if ( this->field_27A != 6 && *(_BYTE *)(v15 + 9) != 171 && *(_BYTE *)(v15 + 9) != 160 )
      return 0;
    if ( !giGroundToTerrain[v11->groundIndex]
      && normalDirTable[4 * a2]
      && byte_4F1DC1[4 * a2]
      && (giGroundToTerrain[*(&this->map->tiles[v7 * this->map->width].groundIndex + 6 * (v10 + v9))]
       || giGroundToTerrain[*(&this->map->tiles[(v7 + v8) * this->map->width].groundIndex + 6 * v9)]) )
      return 0;
  }
  if ( (1 << a2) & 0x83 )
  {
    if ( v11->objectIndex != 255
      && (((unsigned __int8)v11->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 47
      && !(v11->displayFlags & 0x80)
      && v11->objType != 167 )
      return 0;
    if ( *(_BYTE *)(v15 + 7) != 255 )
    {
      v6 = &this->map->tiles[(v14 + 8) * this->map->width] + v13;
      if ( v6->objectIndex != 255 )
      {
        if ( (((unsigned __int8)v6->bitfield_1_hasObject_1_isRoad_6_objTileset >> 2) & 0x3F) != 47
          && !(v6->displayFlags & 0x80) )
          return 0;
      }
    }
  }
  if ( !((1 << a2) & 0x38) )
    goto LABEL_53;
  if ( *(_BYTE *)(v15 + 3) != 255
    && ((*(_BYTE *)(v15 + 2) >> 2) & 0x3F) != 47
    && !(*(_BYTE *)(v15 + 8) & 0x80)
    && *(_BYTE *)(v15 + 9) != 167
    && (!a3 || !(*(_BYTE *)(v15 + 9) & 0x80) || !StopOnTrigger(v15)) )
    return 0;
  if ( v11->overlayIndex == 255
    || (v5 = (int)(&v4->map->tiles[v4->viewX + v4->field_292] + v4->map->width * (v4->viewY + v4->field_29A + 1)),
        *(_BYTE *)(v5 + 3) == 255)
    || ((*(_BYTE *)(v5 + 2) >> 2) & 0x3F) == 47
    || *(_BYTE *)(v5 + 8) & 0x80
    || *(_BYTE *)(v5 + 9) & 0x80 )
LABEL_53:
    result = 1;
  else
    result = 0;
  return result;
}
// 4F0A00: using guessed type int MAP_WIDTH;
// 4F0A04: using guessed type int MAP_HEIGHT;

//----- (004C2300) --------------------------------------------------------
int __thiscall advManager::MoveOrigin(int this, int a2, int a3)
{
  int v3; // ST1C_4@3
  int v4; // ST18_4@3
  int v5; // ST14_4@4
  int v6; // eax@4
  int result; // eax@5
  int v8; // [sp+28h] [bp-8h]@1
  int v9; // [sp+2Ch] [bp-4h]@1
  int v10; // [sp+38h] [bp+8h]@1
  int v11; // [sp+3Ch] [bp+Ch]@1

  v9 = *(_DWORD *)(this + 470);
  v8 = *(_DWORD *)(this + 474);
  *(_DWORD *)(this + 470) += a2;
  *(_DWORD *)(this + 474) += a3;
  v10 = v9 - *(_DWORD *)(this + 470);
  v11 = v8 - *(_DWORD *)(this + 474);
  if ( v9 != *(_DWORD *)(this + 470) || v8 != *(_DWORD *)(this + 474) )
  {
    v3 = **(_DWORD **)(this + 174)
       + 12 * (v9 + *(_DWORD *)(this + 658))
       + 12 * *(_DWORD *)(*(_DWORD *)(this + 174) + 8) * (v8 + *(_DWORD *)(this + 666));
    *(_BYTE *)(v3 + 8) &= 0xBFu;
    *(_DWORD *)(this + 658) += v10;
    *(_DWORD *)(this + 666) += v11;
    v4 = **(_DWORD **)(this + 174)
       + 12 * (*(_DWORD *)(this + 474) + *(_DWORD *)(this + 666)) * *(_DWORD *)(*(_DWORD *)(this + 174) + 8)
       + 12 * (*(_DWORD *)(this + 470) + *(_DWORD *)(this + 658));
    *(_BYTE *)(v4 + 8) |= 0x40u;
    if ( *(_DWORD *)(this + 662) != -1 )
    {
      v5 = **(_DWORD **)(this + 174)
         + 12 * (v9 + *(_DWORD *)(this + 662))
         + 12 * *(_DWORD *)(*(_DWORD *)(this + 174) + 8) * (v8 + *(_DWORD *)(this + 670));
      *(_BYTE *)(v5 + 8) &= 0xBFu;
      *(_DWORD *)(this + 662) += v10;
      *(_DWORD *)(this + 670) += v11;
      v6 = **(_DWORD **)(this + 174)
         + 12 * (*(_DWORD *)(this + 474) + *(_DWORD *)(this + 670)) * *(_DWORD *)(*(_DWORD *)(this + 174) + 8)
         + 12 * (*(_DWORD *)(this + 470) + *(_DWORD *)(this + 662));
      *(_BYTE *)(v6 + 8) |= 0x40u;
    }
  }
  result = this;
  *(_DWORD *)(this + 686) = 1;
  return result;
}

//----- (004C2550) --------------------------------------------------------
void __thiscall advManager::ProcessMapChange(void *ecx0, unsigned int arg0, __int64 a3)
{
  mapCell *v3; // ST38_4@26
  int v4; // [sp+Ch] [bp-2Ch]@11
  void *this; // [sp+14h] [bp-24h]@1
  int trigY; // [sp+20h] [bp-18h]@10
  int a4; // [sp+24h] [bp-14h]@10
  mapCell *a2; // [sp+28h] [bp-10h]@10
  hero *hro; // [sp+2Ch] [bp-Ch]@7
  signed int a8; // [sp+30h] [bp-8h]@10
  int a6; // [sp+34h] [bp-4h]@10

  this = ecx0;
  *(_DWORD *)&giMapChangeCtr = *(_DWORD *)((char *)&a3 + 3) + 1;
  if ( SBYTE2(a3) != giCurPlayer )
  {
    advManager::DeactivateCurrTown();
    advManager::DeactivateCurrHero(gpAdvManager);
  }
  if ( SBYTE2(a3) >= 0 && SBYTE2(a3) < 6 )
  {
    giCurPlayer = SBYTE2(a3);
    gpCurPlayer = &gpGame->players[SBYTE2(a3)];
    giCurPlayerBit = 1 << SBYTE2(a3);
  }
  switch ( (unsigned __int8)arg0 )
  {
    case 1u:
      LogInt(
        (int)"MC Move Hero",
        SBYTE1(arg0),
        BYTE2(arg0),
        BYTE3(arg0),
        (char)a3,
        *(int *)((char *)&a3 + 3),
        gpGame->heroes[SBYTE1(arg0)].x,
        gpGame->heroes[SBYTE1(arg0)].y);
      hro = &gpGame->heroes[SBYTE1(arg0)];
      if ( BYTE2(arg0) == gpGame->heroes[SBYTE1(arg0)].x && BYTE3(arg0) == hro->y )
      {
        advManager::SetHeroContext(gpAdvManager, SBYTE1(arg0), 0);
        a2 = advManager::MoveHero(
               (advManager *)this,
               (char)a3,
               SBYTE1(a3),
               &a4,
               &trigY,
               (int)&a6,
               1,
               (signed int)&a8,
               1);
        if ( a2 )
        {
          v4 = a2->objType & 0x7F;
          if ( v4 == 28 || v4 == 43 )
            advManager::DoAIEvent((int)this, a2, hro, __PAIR__(trigY, a4));
        }
      }
      else
      {
        sprintf(
          gText,
          "Data miscommunication in hero position, first %d, %d, second %d, %d.  Please give Phil a copy of  your Autosave and, if possible, instructions to recreate this error",
          hro->x,
          hro->y,
          BYTE2(arg0),
          BYTE3(arg0));
        LogStr(gText);
      }
      break;
    case 0xBu:
      LogInt((int)"MC My Turn", BYTE2(arg0), BYTE3(arg0), -999, -999, -999, -999, -999);
      break;
    case 9u:
      LogInt((int)"MC Teleport Hero", BYTE2(arg0), BYTE3(arg0), -999, -999, -999, -999, -999);
      hro = &gpGame->heroes[SBYTE1(arg0)];
      advManager::TeleportTo((advManager *)this, &gpGame->heroes[SBYTE1(arg0)], BYTE2(arg0), BYTE3(arg0), 0, 1);
      break;
    case 8u:
      LogInt((int)"MC ClaimMine", -999, -999, -999, -999, -999, -999, -999);
      game::ClaimMine(gpGame, SBYTE1(arg0), SBYTE2(a3));
      advManager::CompleteDraw((advManager *)this, 0);
      advManager::UpdateScreen((advManager *)this, 0, 0);
      break;
    case 7u:
      LogInt((int)"MC ClaimTown", -999, -999, -999, -999, -999, -999, -999);
      game::ClaimTown(gpGame, SBYTE1(arg0), SBYTE2(a3), 1);
      advManager::CompleteDraw((advManager *)this, 0);
      advManager::UpdateScreen((advManager *)this, 0, 0);
      break;
    case 4u:
      LogInt((int)"MC BuildBoat", -999, -999, -999, -999, -999, -999, -999);
      game::CreateBoat(gpGame, BYTE2(arg0), BYTE3(arg0), 1);
      advManager::CompleteDraw((advManager *)this, 0);
      advManager::UpdateScreen((advManager *)this, 0, 0);
      break;
    case 5u:
      LogInt((int)"MC Erase Object", BYTE2(arg0), BYTE3(arg0), -999, -999, -999, -999, -999);
      a2 = advManager::GetCell((advManager *)this, BYTE2(arg0), BYTE3(arg0));
      advManager::EraseObj((advManager *)this, a2, BYTE2(arg0), BYTE3(arg0));
      advManager::CompleteDraw((advManager *)this, 0);
      advManager::UpdateScreen((advManager *)this, 0, 0);
      break;
    case 6u:
      LogStr("MC DeadHero");
      hro = &gpGame->heroes[SBYTE1(arg0)];
      if ( BYTE2(arg0) == gpGame->heroes[SBYTE1(arg0)].x && BYTE3(arg0) == hro->y )
      {
        hero::Deallocate(hro, 1);
        advManager::CompleteDraw((advManager *)this, 0);
        advManager::UpdateScreen((advManager *)this, 0, 0);
      }
      break;
    case 3u:
      LogStr("MC RecruitHero");
      hro = &gpGame->heroes[SBYTE1(arg0)];
      gpGame->heroes[SBYTE1(arg0)].x = BYTE2(arg0);
      hro->y = BYTE3(arg0);
      hro->flags = 0;
      HIBYTE(hro->field_2B) = 2;
      hro->occupiedObjType = *(&gpGame->map.tiles[gpGame->map.width * BYTE3(arg0)].objType + 12 * BYTE2(arg0));
      hro->occupiedObjVal = (unsigned __int8)((unsigned __int8)(*(&gpGame->map.tiles[gpGame->map.width * BYTE3(arg0)].field_4_1_1_isShadow_1_13_extraInfo
                                                                + 6 * BYTE2(arg0)) >> 8) >> -5);
      hro->ownerIdx = BYTE2(a3);
      *(&gpGame->map.tiles[gpGame->map.width * BYTE3(arg0)].objType + 12 * BYTE2(arg0)) = -86;
      v3 = &gpGame->map.tiles[BYTE2(arg0)] + gpGame->map.width * BYTE3(arg0);
      v3->field_4_1_1_isShadow_1_13_extraInfo = v3->field_4_1_1_isShadow_1_13_extraInfo & 7 | 8 * SBYTE1(arg0);
      advManager::SetHeroContext(gpAdvManager, SBYTE1(arg0), 0);
      advManager::CompleteDraw((advManager *)this, 0);
      advManager::UpdateScreen((advManager *)this, 0, 0);
      break;
    case 0xAu:
      LogStr("Dead Player");
      sprintf(gText, "%s has been vanquished!", cPlayerNames[SBYTE1(arg0)]);
      NormalDialog(gText, 1, -1, -1, 9, gpGame->players[SBYTE1(arg0)].color, -1, -1, -1, 5000);
      break;
    case 2u:
      return;
  }
}
// 532C5C: using guessed type char giCurPlayerBit;

//----- (004C2CA0) --------------------------------------------------------
int __thiscall advManager::ProcessIncomingSingleMapChange(void *this, int a2)
{
  int result; // eax@1
  int v3; // ecx@2
  int v4; // ecx@3
  __int64 v5; // ST10_8@3
  char *v6; // ecx@13
  void *v7; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@4
  signed int j; // [sp+10h] [bp-4h]@10

  v7 = this;
  result = a2;
  if ( *(_DWORD *)(a2 + 7) >= *(_DWORD *)&giMapChangeCtr )
  {
    v3 = *(_DWORD *)&giMapChangeCtr;
    if ( *(_DWORD *)(a2 + 7) == *(_DWORD *)&giMapChangeCtr )
    {
      LOBYTE(v3) = *(_BYTE *)(a2 + 10);
      v4 = v3 << 16;
      LOWORD(v4) = *(_WORD *)(a2 + 8);
      HIDWORD(v5) = v4;
      LODWORD(v5) = *(_DWORD *)(a2 + 4);
      advManager::ProcessMapChange(v7, *(_DWORD *)a2, v5);
    }
    else
    {
LABEL_4:
      for ( i = 0; ; ++i )
      {
        if ( i >= 196 )
        {
          for ( j = 0; j < 196; ++j )
          {
            if ( !*((_BYTE *)&sMapChangeQueue + 11 * j) )
            {
              LogInt((int)"SQ", *(_DWORD *)(a2 + 7), *(int *)&giMapChangeCtr, -999, -999, -999, -999, -999);
              v6 = (char *)&sMapChangeQueue + 11 * j;
              *(_DWORD *)v6 = *(_DWORD *)a2;
              *((_DWORD *)v6 + 1) = *(_DWORD *)(a2 + 4);
              *((_WORD *)v6 + 4) = *(_WORD *)(a2 + 8);
              v6[10] = *(_BYTE *)(a2 + 10);
              goto LABEL_16;
            }
          }
          advManager::UnwindMapChangeQueue(v7, 1, 1);
          goto LABEL_4;
        }
        if ( *((_BYTE *)&sMapChangeQueue + 11 * i) && *(int *)((char *)&dword_523667 + 11 * i) == *(_DWORD *)(a2 + 7) )
          break;
      }
      LogInt((int)"OQ", *(_DWORD *)(a2 + 7), *(int *)&giMapChangeCtr, -999, -999, -999, -999, -999);
    }
LABEL_16:
    result = advManager::UnwindMapChangeQueue(v7, 0, 1);
  }
  return result;
}
// 523667: using guessed type int dword_523667;

//----- (004C2E60) --------------------------------------------------------
void __thiscall advManager::ProcessIncomingGroupMapChange(void *this, const void *a2)
{
  void *v2; // [sp+Ch] [bp-18h]@1
  int v3; // [sp+14h] [bp-10h]@3
  void *buf; // [sp+18h] [bp-Ch]@1
  signed int i; // [sp+1Ch] [bp-8h]@1

  v2 = this;
  buf = BaseAlloc(0x2Cu, "F:\\h2xsrc\\Source\\CURSOR.CPP", word_51E33C + 7);
  memcpy(buf, a2, 0x2Cu);
  for ( i = 3; i >= 0; --i )
  {
    v3 = (int)((char *)buf + 11 * i);
    if ( *((_BYTE *)buf + 11 * i) )
    {
      if ( *(_DWORD *)(v3 + 7) >= *(_DWORD *)&giMapChangeCtr )
        advManager::ProcessIncomingSingleMapChange(v2, v3);
    }
  }
  BaseFree(buf, (int)"F:\\h2xsrc\\Source\\CURSOR.CPP", word_51E33C + 25);
}
// 51E33C: using guessed type __int16 word_51E33C;

//----- (004C2F30) --------------------------------------------------------
int __thiscall advManager::PurgeMapChangeQueue(advManager *this)
{
  int result; // eax@3
  signed int i; // [sp+10h] [bp-4h]@1
  signed int j; // [sp+10h] [bp-4h]@4

  for ( i = 0; i < 196; ++i )
  {
    result = 5 * i;
    *((_BYTE *)&sMapChangeQueue + 11 * i) = 0;
  }
  for ( j = 0; j < 4; ++j )
  {
    result = 5 * j;
    sMapChangeLastFew[11 * j] = 0;
  }
  return result;
}

//----- (004C2FB0) --------------------------------------------------------
int __thiscall advManager::UnwindMapChangeQueue(void *this, int a2, int a3)
{
  int result; // eax@3
  signed int v4; // ecx@12
  char *v5; // eax@12
  __int64 v6; // ST04_8@12
  signed int v7; // ecx@22
  char *v8; // eax@22
  __int64 v9; // ST04_8@22
  void *v10; // [sp+Ch] [bp-1Ch]@1
  signed int v11; // [sp+10h] [bp-18h]@4
  int v12; // [sp+14h] [bp-14h]@1
  signed int i; // [sp+18h] [bp-10h]@4
  signed int j; // [sp+18h] [bp-10h]@17
  signed int v15; // [sp+1Ch] [bp-Ch]@1
  int v16; // [sp+20h] [bp-8h]@4
  signed int v17; // [sp+24h] [bp-4h]@15

  v10 = this;
  v15 = 999;
  v12 = 0;
  while ( v15 > 0 )
  {
    result = a2;
    if ( v12 >= a2 )
      break;
    v11 = -1;
    v16 = 999999999;
    v15 = 0;
    for ( i = 0; i < 196; ++i )
    {
      result = 5 * i;
      if ( *((_BYTE *)&sMapChangeQueue + 11 * i) )
      {
        ++v15;
        result = 5 * i;
        if ( *(int *)((char *)&dword_523667 + 11 * i) < v16 )
        {
          v16 = *(int *)((char *)&dword_523667 + 11 * i);
          result = i;
          v11 = i;
        }
      }
    }
    if ( v11 != -1 )
    {
      --v15;
      if ( a3 )
      {
        v4 = v11;
        v5 = (char *)&sMapChangeQueue + 11 * v11;
        LOBYTE(v4) = v5[10];
        v4 <<= 16;
        LOWORD(v4) = *((_WORD *)v5 + 4);
        HIDWORD(v6) = v4;
        LODWORD(v6) = *((_DWORD *)v5 + 1);
        advManager::ProcessMapChange(v10, *(_DWORD *)v5, v6);
      }
      result = 5 * v11;
      *((_BYTE *)&sMapChangeQueue + 11 * v11) = 0;
      ++v12;
    }
  }
  v17 = 1;
  while ( v17 )
  {
    v17 = 0;
    for ( j = 0; j < 196; ++j )
    {
      result = 5 * j;
      if ( *((_BYTE *)&sMapChangeQueue + 11 * j) )
      {
        result = 5 * j;
        if ( *(int *)((char *)&dword_523667 + 11 * j) == *(_DWORD *)&giMapChangeCtr )
        {
          if ( a3 )
          {
            v7 = j;
            v8 = (char *)&sMapChangeQueue + 11 * j;
            LOBYTE(v7) = v8[10];
            v7 <<= 16;
            LOWORD(v7) = *((_WORD *)v8 + 4);
            HIDWORD(v9) = v7;
            LODWORD(v9) = *((_DWORD *)v8 + 1);
            advManager::ProcessMapChange(v10, *(_DWORD *)v8, v9);
          }
          result = 5 * j;
          *((_BYTE *)&sMapChangeQueue + 11 * j) = 0;
          v17 = 1;
        }
      }
    }
  }
  return result;
}
// 523667: using guessed type int dword_523667;

//----- (004C3190) --------------------------------------------------------
void __fastcall SendMapChange(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4, int a5, char a6, char a7)
{
  int v7; // edx@5
  void *v8; // ecx@5
  char v9; // [sp+Ch] [bp-14h]@1
  char v11[13]; // [sp+14h] [bp-Ch]@5

  v9 = a2;
  if ( gbThisNetGotAdventureControl && gbRemoteOn )
  {
    if ( a5 == -999 )
      a5 = giCurPlayer;
    LogInt((int)"Send Map Change", a1, a2, a3, a4, -999, -999, -999);
    memset(v11, 0, 0xBu);
    v11[0] = a1;
    v11[1] = v9;
    v11[2] = a3;
    v11[3] = a4;
    v11[6] = a5;
    v11[5] = a6;
    v11[4] = a7;
    *(_DWORD *)&v11[7] = (*(_DWORD *)&giMapChangeCtr)++;
    memmove(v8, v7, &sMapChangeLastFew[11], sMapChangeLastFew, 0x21u);
    *(_DWORD *)sMapChangeLastFew = *(_DWORD *)v11;
    *(_DWORD *)&sMapChangeLastFew[4] = *(_DWORD *)&v11[4];
    *(_WORD *)&sMapChangeLastFew[8] = *(_WORD *)&v11[8];
    sMapChangeLastFew[10] = v11[10];
    TransmitRemoteData(sMapChangeLastFew, 127, 0x2Cu, 41, 0, 1, -1);
  }
}
// 4F7494: using guessed type int gbRemoteOn;
// 523ED4: using guessed type int gbThisNetGotAdventureControl;

//----- (004C32B0) --------------------------------------------------------
void __stdcall combatManager::NoShowCombatLog(char *msg)
{
  char str; // [sp+10h] [bp-2BCh]@1

  sprintf(&str, "NC: %s", msg);
  LogStr(&str);
}

//----- (004C3300) --------------------------------------------------------
void __thiscall combatManager::ClearCombatMessages(combatManager *this, int a2)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  this->couldBeShouldResetCombatMessage = 0;
  if ( strlen(this->combatMessageRow2) > 1 || strlen(thisa->combatMessageRow1) > 1 )
  {
    if ( a2 || KBTickCount() > thisa->combatMessageRelatedTime )
    {
      strcpy(thisa->combatMessageRow1, byte_51E390);
      strcpy(thisa->combatMessageRow2, byte_51E394);
      thisa->otherCombatMessageRelatedTime = 0;
      thisa->combatMessageRelatedTime = thisa->otherCombatMessageRelatedTime;
      combatManager::CombatMessage(thisa, byte_51E398, 1, 0, 0);
    }
  }
}

//----- (004C33E0) --------------------------------------------------------
void __thiscall combatManager::CheckUpdateCombatMessages(combatManager *this)
{
  combatManager *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( this->couldBeShouldResetCombatMessage && this->combatMessageRelatedTime )
  {
    if ( KBTickCount() > this->combatMessageRelatedTime )
      combatManager::CombatMessage(thisa, possiblyAlwaysBlankCombatMessage1, 1, 0, 1);
  }
}

//----- (004C3440) --------------------------------------------------------
void __thiscall combatManager::CombatMessage(combatManager *this, char *message, int a3, int a4, int a5)
{
  combatManager *thisa; // [sp+Ch] [bp-1BCh]@1
  char buf[400]; // [sp+10h] [bp-1B8h]@17
  char *newline; // [sp+1A0h] [bp-28h]@16
  tag_message a2; // [sp+1A4h] [bp-24h]@26
  int v9; // [sp+1C0h] [bp-8h]@26
  int v10; // [sp+1C4h] [bp-4h]@26

  thisa = this;
  if ( gbNoShowCombat )
  {
    if ( a4 )
      combatManager::NoShowCombatLog(message);
  }
  else if ( this->field_F42F && !this->field_F357 )
  {
    if ( a5 )
    {
      strcpy(this->combatMessageRow1, byte_51E3A0);
      strcpy(thisa->combatMessageRow2, message);
      thisa->otherCombatMessageRelatedTime = 0;
      thisa->combatMessageRelatedTime = thisa->otherCombatMessageRelatedTime;
      thisa->couldBeShouldResetCombatMessage = 0;
    }
    else
    {
      if ( a4 )
      {
        if ( this->combatMessageRelatedTime )
          strcpy(this->combatMessageRow1, this->combatMessageRow2);
        else
          strcpy(this->combatMessageRow1, byte_51E3A8);
        thisa->otherCombatMessageRelatedTime = thisa->combatMessageRelatedTime;
        thisa->combatMessageRelatedTime = KBTickCount() + 2500;
      }
      else
      {
        if ( KBTickCount() < this->combatMessageRelatedTime )
          return;
        strcpy(thisa->combatMessageRow1, byte_51E3A4);
        thisa->otherCombatMessageRelatedTime = 0;
        thisa->combatMessageRelatedTime = thisa->otherCombatMessageRelatedTime;
      }
      newline = FindToken(message, '\n');
      if ( newline )
      {
        *newline = 0;
        strcpy(buf, message);
        if ( message >= newline || *(newline - 1) != '.' )
          strcat(buf, L" ");
        else
          strcat(buf, "  ");
        strcat(buf, newline + 1);
        if ( font::LineLength(bigFont, buf, 474) > 1 )
        {
          strcpy(thisa->combatMessageRow1, message);
          strcpy(thisa->combatMessageRow2, newline + 1);
        }
        else
        {
          strcpy(thisa->combatMessageRow2, buf);
        }
        *newline = '\n';
      }
      else
      {
        strcpy(thisa->combatMessageRow2, message);
      }
    }
    a2.eventCode = INPUT_GUI_MESSAGE_CODE;
    a2.xCoordOrKeycode = 3;
    a2.yCoordOrFieldID = 12;
    a2.payload = thisa->combatMessageRow1;
    heroWindow::BroadcastMessage(thisa->window, &a2);
    a2.yCoordOrFieldID = 13;
    a2.payload = thisa->combatMessageRow2;
    heroWindow::BroadcastMessage(thisa->window, &a2);
    v9 = gbComputeExtent;
    v10 = gbLimitToExtent;
    gbLimitToExtent = 0;
    gbComputeExtent = 0;
    heroWindow::DrawWindow(thisa->window, 0, 10, 13);
    combatManager::SaveCombatBorder();
    if ( a3 )
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 83, 446, 0x1DAu, 33);
    gbComputeExtent = v9;
    gbLimitToExtent = v10;
  }
}
// 4F7480: using guessed type int gbComputeExtent;
// 4F7488: using guessed type int gbLimitToExtent;
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004C3820) --------------------------------------------------------
void __thiscall combatManager::CombatMessage(combatManager *this, int a2)
{
  army *v2; // eax@4
  int creatIdx; // [sp+14h] [bp-10h]@3
  int creatIdxa; // [sp+14h] [bp-10h]@28
  char *v6; // [sp+1Ch] [bp-8h]@3
  int v7; // [sp+20h] [bp-4h]@3

  if ( this->field_F42F && !gbNoShowCombat )
  {
    creatIdx = this->creatures[this->activeStackOwner][this->activeStack].creatureIdx;
    v6 = 0;
    v7 = 0;
    if ( *(_QWORD *)&this->creatures[this->activeStackOwner][this->activeStack].targetOwner >= 0i64 )
    {
      v2 = (army *)((char *)this
                  + 24234 * this->creatures[this->activeStackOwner][this->activeStack].targetOwner
                  + 1154 * this->creatures[this->activeStackOwner][this->activeStack].targetStackIdx);
      v6 = &v2[11].frameInfo.animationFrameToImgIdx[23][11];
      v7 = *(_DWORD *)&v2[11].frameInfo.animationFrameToImgIdx[31][1];
    }
    switch ( a2 )
    {
      case 0:
        if ( this->creatures[this->activeStackOwner][this->activeStack].creature.creature_flags & 4
          && !this->creatures[this->activeStackOwner][this->activeStack].creature.shots
          && v6 )
          strcpy(gText, off_4F65D0);
        else
          strcpy(gText, off_4F65B0);
        break;
      case 1:
        sprintf(gText, off_4F65B4, gArmyNames[creatIdx]);
        break;
      case 2:
        sprintf(gText, off_4F65B8, gArmyNames[creatIdx]);
        break;
      case 7:
        sprintf(gText, off_4F65BC, gArmyNames[v7]);
        break;
      case 3:
      case 15:
        sprintf(
          gText,
          off_4F65C0,
          gArmyNames[v7],
          this->creatures[this->activeStackOwner][this->activeStack].creature.shots);
        break;
      case 4:
        if ( this->heroes[this->currentActionSide] && this->heroes[this->currentActionSide]->isCaptain )
          strcpy(gText, off_4F65D4);
        else
          strcpy(gText, off_4F65C4);
        break;
      case 13:
        if ( this->heroes[1 - this->currentActionSide] && this->heroes[1 - this->currentActionSide]->isCaptain )
          strcpy(gText, off_4F65D8);
        else
          strcpy(gText, off_4F65C8);
        break;
      case 5:
        if ( this->field_F2C3 == 77 )
        {
          sprintf(gText, off_4F65DC);
        }
        else
        {
          creatIdxa = this->creatures[this->activeStackOwner][this->combatGrid[this->field_F2C3].stackIdx].creatureIdx;
          if ( creatIdxa < 0 )
            sprintf(gText, byte_51E3B4);
          else
            sprintf(gText, off_4F65CC, gArmyNames[creatIdxa]);
        }
        break;
      default:
        break;
    }
    combatManager::CombatMessage(this, gText, 1, 0, 0);
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004C3C30) --------------------------------------------------------
void __thiscall combatManager::ResetLimitCreature(combatManager *this)
{
  spellpower_offset j; // [sp+10h] [bp-8h]@3
  signed int i; // [sp+14h] [bp-4h]@1

  for ( i = 0; i < 2; ++i )
  {
    for ( j = 0; j < MAX_STACKS; ++j )
    {
      if ( this->creatures[i][j].creature.creature_flags & DEAD )
        this->limitCreature[i][j] = -1;
      else
        this->limitCreature[i][j] = 0;
    }
  }
  this->field_F41F[0] = 0;
  this->field_F41F[1] = 0;
  this->field_F427[0] = 0;
  this->field_F427[1] = 0;
  giMaxExtentY = 0;
  giMaxExtentX = 0;
  giMinExtentX = 639;
  giMinExtentY = 442;
}
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004C3D60) --------------------------------------------------------
void __thiscall combatManager::UpdateCombatArea(combatManager *this)
{
  if ( !gbNoShowCombat )
  {
    if ( this->field_F42F )
    {
      gbEnlargeScreenBlit = 0;
      heroWindowManager::UpdateScreenRegion(gpWindowManager, 0, 0, 640u, 443);
      gbEnlargeScreenBlit = 1;
    }
  }
}
// 4F2E84: using guessed type int gbEnlargeScreenBlit;
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004C3DD0) --------------------------------------------------------
void __thiscall combatManager::SetupGridForArmy(combatManager *this, army *stack)
{
  int v2; // ST24_4@3
  int v3; // ST28_4@3
  combatManager *thisa; // [sp+Ch] [bp-14h]@1
  int v5; // [sp+10h] [bp-10h]@3
  signed int i; // [sp+14h] [bp-Ch]@3

  thisa = this;
  if ( !gbNoShowCombat && combatShadeLevel >= 1 )
  {
    v5 = army::GetAttackMask(stack, stack->occupiedHex, 2, -1);
    memset(thisa->field_49F, 0, 0x75u);
    v2 = stack->targetOwner;
    v3 = stack->targetStackIdx;
    stack->targetOwner = -1;
    stack->targetStackIdx = -1;
    searchArray::SeedCombatPosition(stack);
    stack->targetOwner = v2;
    stack->targetStackIdx = v3;
    for ( i = 0; i < 117; ++i )
    {
      if ( stack->occupiedHex == i )
      {
        thisa->field_49F[i] = 1;
      }
      else if ( thisa->combatGrid[i].field_41 )
      {
        if ( thisa->combatGrid[i].unitOwner == -1 )
        {
          thisa->field_49F[i] = 3;
        }
        else if ( thisa->combatGrid[i].unitOwner != stack->owningSide )
        {
          thisa->field_49F[i] = 1;
        }
      }
      else if ( thisa->combatGrid[i].unitOwner != -1
  && thisa->combatGrid[i].unitOwner != 1 - thisa->currentActionSide
  && (1 << thisa->combatGrid[i].stackIdx) & v5 )
      {
        thisa->field_49F[i] = 1;
      }
    }
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004C3FF0) --------------------------------------------------------
signed int __fastcall combatManager::UpdateGrid(combatManager *this, int edx0, int a2, int a3)
{
  combatManager *thisa; // [sp+Ch] [bp-28h]@1
  signed int v6; // [sp+10h] [bp-24h]@14
  signed int i; // [sp+14h] [bp-20h]@15
  signed int j; // [sp+14h] [bp-20h]@30
  signed int k; // [sp+14h] [bp-20h]@53
  signed int l; // [sp+14h] [bp-20h]@61
  signed int v11; // [sp+18h] [bp-1Ch]@14
  signed int v12; // [sp+1Ch] [bp-18h]@14
  signed int v13; // [sp+20h] [bp-14h]@14
  signed int v14; // [sp+24h] [bp-10h]@14
  signed int v15; // [sp+28h] [bp-Ch]@14
  int targY; // [sp+2Ch] [bp-8h]@14
  int targX; // [sp+30h] [bp-4h]@14

  thisa = this;
  if ( gbNoShowCombat )
    return 0;
  if ( a3 )
  {
    if ( this->playerID[this->currentActionSide] != -1
      && gbThisNetHumanPlayer[this->playerID[this->currentActionSide]]
      && !this->field_F2B3 )
      combatManager::SetupGridForArmy(this, &this->creatures[this->activeStackOwner][this->activeStack]);
    else
      memset(this->field_49F, 0, 0x75u);
  }
  if ( a2 )
    bGridWasShowing = 0;
  if ( combatShadeLevel < 1 && !*(_DWORD *)&showCombatGrid )
    return 0;
  v11 = 0;
  targX = 639;
  targY = 442;
  v14 = 0;
  v13 = 0;
  v6 = 0;
  v12 = 0;
  v15 = 0;
  if ( combatShadeLevel < 1 )
    goto LABEL_58;
  for ( i = 0; i < 117; ++i )
  {
    if ( thisa->field_42A[i] != thisa->field_49F[i] )
      v15 = 1;
    if ( thisa->field_49F[i] )
      v6 = 1;
    if ( thisa->field_42A[i] )
      v12 = 1;
  }
  if ( !a2 )
  {
    if ( !v15 )
      return 0;
    if ( v12 )
    {
      for ( j = 0; j < 117; ++j )
      {
        if ( thisa->field_42A[j] != thisa->field_49F[j] || thisa->field_49F[j] )
        {
          if ( thisa->combatGrid[j].leftX < targX )
            targX = thisa->combatGrid[j].leftX;
          if ( thisa->combatGrid[j].topY < targY )
            targY = thisa->combatGrid[j].topY;
          if ( thisa->combatGrid[j].rightX > v14 )
            v14 = thisa->combatGrid[j].rightX;
          if ( thisa->combatGrid[j].otherY2 > v13 )
            v13 = thisa->combatGrid[j].otherY2;
        }
      }
      if ( targX < 67 )
        targX = 67;
      if ( targY < 63 )
        targY = 63;
      if ( v14 > 573 )
        v14 = 573;
      if ( v13 > 442 )
        v13 = 442;
      bitmap::CopyToCareful(
        thisa->couldBeBitmapForFieldItself,
        thisa->probablyBitmapForCombatScreen,
        targX,
        targY,
        targX - 67,
        targY - 63,
        v14 - targX + 1,
        v13 - targY + 1);
      v11 = 1;
    }
    goto LABEL_52;
  }
  if ( v6 )
  {
LABEL_52:
    if ( v6 )
    {
      for ( k = 0; k < 117; ++k )
      {
        if ( thisa->field_49F[k] )
        {
          DimIconToBitmap(
            thisa->combatScreenIcons[9],
            (int)thisa->probablyBitmapForCombatScreen,
            thisa->combatGrid[k].leftX,
            thisa->combatGrid[k].topY,
            1,
            thisa->field_49F[k] - 1,
            1,
            0,
            0,
            640,
            443);
          v11 = 1;
        }
      }
    }
  }
LABEL_58:
  if ( *(_DWORD *)&showCombatGrid && (!bGridWasShowing || v11) )
  {
    for ( l = 0; l < 117; ++l )
    {
      if ( l % 13 && l % 13 != 12 )
        MonoIconToBitmap(
          thisa->combatScreenIcons[9],
          thisa->probablyBitmapForCombatScreen,
          thisa->combatGrid[l].leftX,
          thisa->combatGrid[l].topY,
          0,
          -30,
          1,
          0,
          0,
          0x280u,
          443);
    }
    v11 = 1;
    bGridWasShowing = 1;
  }
  memcpy(thisa->field_42A, thisa->field_49F, 0x75u);
  return v11;
}
// 518CFC: using guessed type int gbNoShowCombat;
// 51E3B8: using guessed type int bGridWasShowing;

//----- (004C45F0) --------------------------------------------------------
void __thiscall combatManager::DrawBackground(combatManager *this)
{
  icon *v1; // ST3C_4@3
  icon *v2; // ST3C_4@4
  int v3; // edx@18
  combatManager *thisa; // [sp+Ch] [bp-10h]@1
  icon *res; // [sp+18h] [bp-4h]@6
  icon *resa; // [sp+18h] [bp-4h]@11

  thisa = this;
  if ( !gbNoShowCombat && !this->zeroedAfterAnimatingDeathAndHolySpells )
  {
    v1 = resourceManager::GetIcon(gpResourceManager, this->combatBackgroundFilename);
    IconToBitmap(v1, thisa->probablyBitmapForCombatScreen, 0, 0, 0, 1, 0, 0, 0x280u, 443, 0);
    resourceManager::Dispose(gpResourceManager, (resource *)v1);
    if ( thisa->combatFieldCoverID )
    {
      sprintf(gText, "covr%04d.icn", thisa->combatFieldCoverID);
      v2 = resourceManager::GetIcon(gpResourceManager, gText);
      IconToBitmap(v2, thisa->probablyBitmapForCombatScreen, 0, 0, 0, 0, 0, 0, 0x280u, 443, 0);
      resourceManager::Dispose(gpResourceManager, (resource *)v2);
    }
    if ( thisa->combatFieldFringeID != -1 )
    {
      sprintf(gText, "frng%04d.icn", thisa->combatFieldFringeID);
      res = resourceManager::GetIcon(gpResourceManager, gText);
      if ( thisa->isCastleBattle )
        IconToBitmap(res, thisa->probablyBitmapForCombatScreen, 0, 0, 0, 1, 0, 0, 0x140u, 443, 0);
      else
        IconToBitmap(res, thisa->probablyBitmapForCombatScreen, 0, 0, 0, 0, 0, 0, 0x280u, 443, 0);
      resourceManager::Dispose(gpResourceManager, (resource *)res);
    }
    if ( thisa->isCastleBattle )
    {
      sprintf(gText, "castbkg%c.icn", cHeroTypeInitial[thisa->castles[1]->factionID]);
      resa = resourceManager::GetIcon(gpResourceManager, gText);
      IconToBitmap(resa, thisa->probablyBitmapForCombatScreen, 0, 0, 1, 0, 0, 0, 0x280u, 443, 0);
      if ( thisa->hasMoat )
        IconToBitmap(
          thisa->combatScreenIcons[14],
          thisa->probablyBitmapForCombatScreen,
          0,
          0,
          0,
          0,
          0,
          0,
          0x280u,
          443,
          0);
      if ( thisa->castles[1]->factionID || !(BYTE1(thisa->castles[1]->buildingsBuiltFlags) & 0x20) )
        IconToBitmap(resa, thisa->probablyBitmapForCombatScreen, 0, 0, 3, 0, 0, 0, 0x280u, 443, 0);
      else
        IconToBitmap(resa, thisa->probablyBitmapForCombatScreen, 0, 0, 4, 0, 0, 0, 0x280u, 443, 0);
      resourceManager::Dispose(gpResourceManager, (resource *)resa);
    }
    bitmap::CopyToCareful(
      thisa->probablyBitmapForCombatScreen,
      thisa->couldBeBitmapForFieldItself,
      0,
      0,
      67,
      63,
      507,
      380);
    combatManager::UpdateGrid(thisa, v3, 1, 0);
    bitmap::CopyToCareful(thisa->probablyBitmapForCombatScreen, gpWindowManager->screenBuffer, 0, 0, 0, 0, 640, 443);
    thisa->zeroedAfterAnimatingDeathAndHolySpells = 1;
  }
}
// 518CFC: using guessed type int gbNoShowCombat;

//----- (004C4960) --------------------------------------------------------
void __thiscall combatManager::UpdateMouseGrid(combatManager *this, signed int hexIdx, int a3)
{
  bitmap *v4; // [sp+10h] [bp-20h]@13
  int v5; // [sp+14h] [bp-1Ch]@26
  int v6; // [sp+18h] [bp-18h]@26
  int v7; // [sp+1Ch] [bp-14h]@26
  int v8; // [sp+20h] [bp-10h]@26
  int height; // [sp+24h] [bp-Ch]@18
  int heighta; // [sp+24h] [bp-Ch]@23
  int v11; // [sp+28h] [bp-8h]@26
  int v12; // [sp+2Ch] [bp-4h]@26

  if ( !this->field_F357 && !gbNoShowCombat && *(_DWORD *)&showCombatMouseHex && (!gbProcessingCombatAction || a3) )
  {
    if ( hexIdx < 0 || hexIdx >= 117 || !(hexIdx % 13) || hexIdx % 13 == 12 )
      hexIdx = -1;
    if ( this->shadedHex != hexIdx )
    {
      if ( !this->bitmap1 )
      {
        v4 = (bitmap *)operator new(26);
        if ( v4 )
          this->bitmap1 = bitmap::bitmap(v4, 0, 44, 52);
        else
          this->bitmap1 = 0;
      }
      if ( this->shadedHex != -1 )
      {
        if ( this->combatGrid[this->shadedHex].topY + 51 <= 442 )
          height = 52;
        else
          height = 442 - this->combatGrid[this->shadedHex].topY + 1;
        bitmap::CopyToCareful(
          this->bitmap1,
          this->probablyBitmapForCombatScreen,
          this->combatGrid[this->shadedHex].leftX,
          this->combatGrid[this->shadedHex].topY,
          0,
          0,
          44,
          height);
      }
      if ( hexIdx != -1 )
      {
        if ( this->combatGrid[hexIdx].topY + 51 <= 442 )
          heighta = 52;
        else
          heighta = 442 - this->combatGrid[hexIdx].topY + 1;
        bitmap::CopyToCareful(
          this->probablyBitmapForCombatScreen,
          this->bitmap1,
          0,
          0,
          this->combatGrid[hexIdx].leftX,
          this->combatGrid[hexIdx].topY,
          44,
          heighta);
        DimIconToBitmap(
          this->combatScreenIcons[9],
          (int)this->probablyBitmapForCombatScreen,
          this->combatGrid[hexIdx].leftX,
          this->combatGrid[hexIdx].topY,
          1,
          2,
          1,
          0,
          0,
          640,
          443);
      }
      v11 = giMinExtentX;
      v12 = giMinExtentY;
      v5 = giMaxExtentX;
      v6 = giMaxExtentY;
      v7 = gbLimitToExtent;
      v8 = gbComputeExtent;
      if ( this->shadedHex == -1 )
      {
        giMinExtentX = 640;
        giMinExtentY = 480;
        giMaxExtentX = 0;
        giMaxExtentY = 0;
      }
      else
      {
        giMinExtentX = this->combatGrid[this->shadedHex].leftX;
        giMinExtentY = this->combatGrid[this->shadedHex].topY;
        giMaxExtentX = this->combatGrid[this->shadedHex].leftX + 43;
        giMaxExtentY = this->combatGrid[this->shadedHex].topY + 51;
      }
      if ( hexIdx != -1 )
      {
        if ( this->combatGrid[hexIdx].leftX < giMinExtentX )
          giMinExtentX = this->combatGrid[hexIdx].leftX;
        if ( this->combatGrid[hexIdx].topY < giMinExtentY )
          giMinExtentY = this->combatGrid[hexIdx].topY;
        if ( this->combatGrid[hexIdx].leftX + 43 > giMaxExtentX )
          giMaxExtentX = this->combatGrid[hexIdx].leftX + 43;
        if ( this->combatGrid[hexIdx].topY + 51 > giMaxExtentY )
          giMaxExtentY = this->combatGrid[hexIdx].topY + 51;
      }
      if ( giMaxExtentY > 442 )
        giMaxExtentY = 442;
      gbLimitToExtent = 1;
      gbComputeExtent = 1;
      bitmap::CopyTo(
        this->probablyBitmapForCombatScreen,
        gpWindowManager->screenBuffer,
        giMinExtentX,
        giMinExtentY,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      combatManager::DrawFrame(this, 0, 0, 0, 0, 75, 1, 1);
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      giMinExtentX = v11;
      giMinExtentY = v12;
      giMaxExtentX = v5;
      giMaxExtentY = v6;
      gbLimitToExtent = v7;
      gbComputeExtent = v8;
      this->shadedHex = hexIdx;
    }
  }
}
// 4F31B0: using guessed type int gbProcessingCombatAction;
// 4F7480: using guessed type int gbComputeExtent;
// 4F7488: using guessed type int gbLimitToExtent;
// 518CFC: using guessed type int gbNoShowCombat;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004C4FB0) --------------------------------------------------------
void __thiscall combatManager::DrawFrame(combatManager *this, int redrawAll, int a3, int a4, int a5, signed int delay, int a7, int waitUntilItIsTime)
{
  int v8; // ecx@127
  int v9; // ST50_4@148
  int v10; // eax@146
  combatManager *thisa; // [sp+20h] [bp-C8h]@1
  int offsetX; // [sp+24h] [bp-C4h]@22
  int offsetY; // [sp+28h] [bp-C0h]@19
  int offY; // [sp+34h] [bp-B4h]@96
  int imageIdx; // [sp+38h] [bp-B0h]@96
  int offX; // [sp+3Ch] [bp-ACh]@96
  unsigned __int8 v17[7]; // [sp+44h] [bp-A4h]@94
  Point16 v18[6][4]; // [sp+4Ch] [bp-9Ch]@94
  int v19; // [sp+ACh] [bp-3Ch]@151
  int colBound; // [sp+B0h] [bp-38h]@55
  int v21; // [sp+B4h] [bp-34h]@72
  int deltaX; // [sp+B8h] [bp-30h]@55
  int colStart; // [sp+BCh] [bp-2Ch]@55
  int i; // [sp+C0h] [bp-28h]@7
  int v25; // [sp+D4h] [bp-14h]@5
  int l; // [sp+DCh] [bp-Ch]@5
  int j; // [sp+E0h] [bp-8h]@47
  int k; // [sp+E4h] [bp-4h]@78

  thisa = this;
  if ( this->field_F357 || gbNoShowCombat || !this->field_F42F )
    return;
  PollSound();
  gpMouseManager->couldBeShowMouse = 0;
  if ( a3 )
  {
    v25 = 0;
    for ( l = 0; l < 2; ++l )
    {
      for ( i = 0; i < 20; ++i )
      {
        if ( thisa->limitCreature[l][i] > 0 )
        {
          v25 = 1;
          gbComputeExtent = 1;
          gbSaveBiggestExtent = 1;
          gbReturnAfterComputeExtent = 1;
          army::DrawToBuffer(
            &thisa->creatures[l][i],
            thisa->combatGrid[thisa->creatures[l][i].occupiedHex].centerX,
            thisa->combatGrid[thisa->creatures[l][i].occupiedHex].occupyingCreatureBottomY,
            0);
          gbReturnAfterComputeExtent = 0;
          gbComputeExtent = 0;
          gbSaveBiggestExtent = 0;
        }
      }
    }
    for ( l = 0; l < 2; ++l )
    {
      if ( thisa->field_F41F[l] )
      {
        v25 = 1;
        gbComputeExtent = 1;
        gbSaveBiggestExtent = 1;
        gbReturnAfterComputeExtent = 1;
        icon::CombatClipDrawToBuffer(
          thisa->heroIcon[l],
          (unsigned int)l < 1 ? 30 : 610,
          (unsigned int)l < 1 ? 183 : 148,
          sCmbtHero[thisa->heroType[l]].frameIndex[thisa->heroAnimationType[l]][thisa->heroAnimationFrameCount[l]],
          &thisa->heroBounds[l],
          1,
          0,
          0,
          0);
        gbReturnAfterComputeExtent = 0;
        gbComputeExtent = 0;
        gbSaveBiggestExtent = 0;
      }
      if ( thisa->field_F427[l] )
      {
        v25 = 1;
        gbComputeExtent = 1;
        gbSaveBiggestExtent = 1;
        gbReturnAfterComputeExtent = 1;
        if ( l )
          offsetY = (unsigned int)thisa->heroes[l]->isCaptain < 1 ? 148 : 135;
        else
          offsetY = 183;
        if ( l )
          offsetX = (unsigned int)thisa->heroes[l]->isCaptain < 1 ? 610 : 103;
        else
          offsetX = 30;
        icon::CombatClipDrawToBuffer(
          thisa->heroFlagIcon[l],
          offsetX,
          offsetY,
          thisa->heroFlagIconIdx[l],
          &thisa->heroFlagBounds[l],
          1,
          0,
          0,
          0);
        gbReturnAfterComputeExtent = 0;
        gbComputeExtent = 0;
        gbSaveBiggestExtent = 0;
      }
    }
    if ( a5 || !v25 )
      goto LABEL_168;
    --giMinExtentX;
    --giMinExtentY;
    ++giMaxExtentX;
    ++giMaxExtentY;
    if ( giMinExtentX < 0 )
      giMinExtentX = 0;
    if ( giMinExtentY < 0 )
      giMinExtentY = 0;
    if ( giMaxExtentX > 639 )
      giMaxExtentX = 639;
    if ( giMaxExtentY > 442 )
      giMaxExtentY = 442;
  }
  if ( a7 )
  {
    if ( thisa->zeroedAfterAnimatingDeathAndHolySpells )
    {
      if ( a3 || a4 || gbLimitToExtent )
        bitmap::CopyTo(
          thisa->probablyBitmapForCombatScreen,
          gpWindowManager->screenBuffer,
          giMinExtentX,
          giMinExtentY,
          giMinExtentX,
          giMinExtentY,
          giMaxExtentX - giMinExtentX + 1,
          giMaxExtentY - giMinExtentY + 1);
      else
        bitmap::CopyTo(thisa->probablyBitmapForCombatScreen, gpWindowManager->screenBuffer, 0, 0, 0, 0, 640u, 443);
    }
    else
    {
      combatManager::DrawBackground(thisa);
    }
  }
  if ( a3 )
  {
    gbLimitToExtent = 1;
    gbComputeExtent = 1;
  }
  for ( j = 0; j < 9; ++j )
  {
    if ( j == 1 && thisa->heroes[1] )
    {
      icon::CombatClipDrawToBuffer(
        thisa->heroIcon[1],
        (unsigned int)thisa->heroes[1]->isCaptain < 1 ? 610 : 103,
        (unsigned int)thisa->heroes[1]->isCaptain < 1 ? 148 : 0x87u,
        sCmbtHero[thisa->heroType[1]].frameIndex[thisa->heroAnimationType[1]][thisa->heroAnimationFrameCount[1]],
        &thisa->heroBounds[1],
        1,
        0,
        0,
        0);
      icon::CombatClipDrawToBuffer(
        thisa->heroFlagIcon[1],
        610,
        148,
        thisa->heroFlagIconIdx[1],
        &thisa->heroFlagBounds[1],
        1,
        0,
        0,
        0);
    }
    if ( j == 2 && thisa->heroes[0] )
    {
      icon::CombatClipDrawToBuffer(
        thisa->heroIcon[0],
        30,
        183,
        sCmbtHero[thisa->heroType[0]].frameIndex[thisa->heroAnimationType[0]][thisa->heroAnimationFrameCount[0]],
        thisa->heroBounds,
        0,
        0,
        0,
        0);
      icon::CombatClipDrawToBuffer(
        thisa->heroFlagIcon[0],
        30,
        183,
        thisa->heroFlagIconIdx[0],
        thisa->heroFlagBounds,
        0,
        0,
        0,
        0);
    }
    colStart = 1;
    colBound = 12;
    deltaX = 1;
    if ( thisa->isCastleBattle && j >= 5 )
    {
      colStart = 11;
      colBound = 0;
      deltaX = -1;
    }
    if ( thisa->isCastleBattle && j == 7 )
      icon::CombatClipDrawToBuffer(
        thisa->combatScreenIcons[3],
        22,
        390,
        thisa->probablyCatapultImgIdx[0],
        &thisa->catapultBounds,
        0,
        0,
        0,
        0);
    if ( thisa->isCastleBattle && j == 4 && thisa->drawBridgePosition != 4 )
      icon::CombatClipDrawToBuffer(
        thisa->combatScreenIcons[5],
        0,
        0,
        thisa->drawBridgePosition + 21,
        &thisa->drawbridgeBounds,
        0,
        0,
        0,
        0);
    if ( thisa->isCastleBattle && j == 5 && !thisa->drawBridgePosition )
      icon::CombatClipDrawToBuffer(thisa->combatScreenIcons[5], 0, 0, 25, &thisa->field_F303, 0, 0, 0, 0);
    if ( thisa->isCastleBattle && j == 6 )
      icon::CombatClipDrawToBuffer(
        thisa->combatScreenIcons[5],
        0,
        0,
        (unsigned int)thisa->ballistaDestroyed < 1 ? 20 : 26,
        &thisa->ballistaBounds,
        0,
        0,
        0,
        0);
    v21 = 0;
    if ( thisa->isCastleBattle && thisa->wallStatus[3] != 2 && thisa->wallStatus[3] != 6 )
    {
      v21 = 1;
      for ( l = 0; l < 4; ++l )
      {
        hexcell::DrawOccupant(&thisa->combatGrid[114], l, 0);
        hexcell::DrawOccupant(&thisa->combatGrid[115], l, 0);
      }
    }
    for ( k = colStart; k != colBound; k += deltaX )
      hexcell::DrawLowerDeadOccupants(&thisa->combatGrid[13 * j] + k);
    for ( k = colStart; k != colBound; k += deltaX )
      hexcell::DrawUpperDeadOccupant(&thisa->combatGrid[13 * j] + k);
    for ( l = 0; l < 4; ++l )
    {
      if ( l == 1 )
      {
        for ( k = colStart; k != colBound; k += deltaX )
        {
          if ( thisa->combatGrid[k + 13 * j].combatObjIdx != -1 )
            hexcell::DrawObstacle(&thisa->combatGrid[13 * j] + k);
        }
      }
      for ( k = colStart; k != colBound; k += deltaX )
      {
        v18[0][0].x = 443;
        v18[0][0].y = 153;
        v18[0][1].x = 399;
        v18[0][1].y = 237;
        v18[0][2].x = 399;
        v18[0][2].y = 321;
        v18[0][3].x = 443;
        v18[0][3].y = 405;
        v18[1][0].x = 443;
        v18[1][0].y = 153;
        v18[1][1].x = 399;
        v18[1][1].y = 237;
        v18[1][2].x = 399;
        v18[1][2].y = 321;
        v18[1][3].x = 443;
        v18[1][3].y = 405;
        v18[2][0].x = 443;
        v18[2][0].y = 153;
        v18[2][1].x = 399;
        v18[2][1].y = 237;
        v18[2][2].x = 399;
        v18[2][2].y = 321;
        v18[2][3].x = 443;
        v18[2][3].y = 405;
        v18[3][0].x = 443;
        v18[3][0].y = 153;
        v18[3][1].x = 399;
        v18[3][1].y = 237;
        v18[3][2].x = 399;
        v18[3][2].y = 321;
        v18[3][3].x = 443;
        v18[3][3].y = 405;
        v18[4][0].x = 443;
        v18[4][0].y = 153;
        v18[4][1].x = 399;
        v18[4][1].y = 237;
        v18[4][2].x = 399;
        v18[4][2].y = 321;
        v18[4][3].x = 443;
        v18[4][3].y = 405;
        v18[5][0].x = 443;
        v18[5][0].y = 153;
        v18[5][1].x = 399;
        v18[5][1].y = 237;
        v18[5][2].x = 399;
        v18[5][2].y = 321;
        v18[5][3].x = 443;
        v18[5][3].y = 405;
        v17[0] = 0;
        v17[1] = 4;
        v17[2] = 8;
        v17[3] = 23;
        v17[4] = 27;
        v17[5] = 35;
        v17[6] = 31;
        if ( thisa->isCastleBattle && !l )
        {
          imageIdx = 0;
          offX = 0;
          offY = 0;
          switch ( k + 13 * j )
          {
            case 9:
              imageIdx = v17[thisa->wallStatus[0]] + 5;
              break;
            case 34:
              imageIdx = v17[thisa->wallStatus[1]] + 6;
              break;
            case 86:
              imageIdx = v17[thisa->wallStatus[2]] + 7;
              break;
            case 113:
              imageIdx = v17[thisa->wallStatus[3]] + 8;
              break;
            case 22:
              imageIdx = thisa->turretStatus[0] + 17;
              offX = *(_DWORD *)v18[thisa->castles[1]->factionID] & 0xFFFF;
              offY = v18[thisa->castles[1]->factionID][0].y;
              break;
            case 47:
              imageIdx = thisa->turretStatus[1] + 17;
              offX = v18[thisa->castles[1]->factionID][1].x;
              offY = v18[thisa->castles[1]->factionID][1].y;
              break;
            case 73:
              imageIdx = thisa->turretStatus[2] + 17;
              offX = v18[thisa->castles[1]->factionID][2].x;
              offY = v18[thisa->castles[1]->factionID][2].y;
              break;
            case 100:
              imageIdx = thisa->turretStatus[3] + 17;
              offX = v18[thisa->castles[1]->factionID][3].x;
              offY = v18[thisa->castles[1]->factionID][3].y;
              break;
            case 59:
              if ( thisa->drawBridgePosition != 3 )
                imageIdx = 4;
              break;
            default:
              break;
          }
          if ( imageIdx )
            icon::CombatClipDrawToBuffer(
              thisa->combatScreenIcons[5],
              offX,
              offY,
              imageIdx,
              (H2RECT *)((char *)&thisa->combatGrid[13 * j].drawingBounds + 98 * k),
              0,
              0,
              0,
              0);
        }
        if ( !v21 || k + 13 * j != 114 && k + 13 * j != 115 )
          hexcell::DrawOccupant(&thisa->combatGrid[13 * j] + k, l, 0);
      }
    }
    if ( thisa->isCastleBattle
      && BYTE1(thisa->castles[1]->buildingsBuiltFlags) & 0x10
      && (j != 4 || thisa->drawBridgePosition == 4) )
    {
      if ( moatCell[j] != giWalkingTo
        && moatCell[j] != giWalkingTo2
        && moatCell[j] != giWalkingFrom
        && moatCell[j] != giWalkingFrom2 )
      {
        if ( thisa->combatGrid[moatCell[j]].unitOwner != -1 )
          goto LABEL_150;
      }
      else
      {
        if ( abs(giWalkingTo - giWalkingFrom) <= 1 )
          goto LABEL_150;
        v8 = giWalkingFrom / 13;
        if ( giWalkingFrom / 13 <= giWalkingTo / 13 )
          v8 = giWalkingTo / 13;
        if ( v8 == j )
        {
          if ( gpCombatManager->drawBridgePosition == 4 || giWalkingTo / 13 != 4 && giWalkingFrom / 13 != 4 )
          {
            v10 = giWalkingFrom;
            if ( giWalkingFrom <= giWalkingTo )
              v10 = giWalkingTo;
            v9 = giWalkingYMod + thisa->combatGrid[giWalkingFrom].occupyingCreatureBottomY - 9;
            IconToBitmap(
              thisa->combatScreenIcons[14],
              gpWindowManager->screenBuffer,
              0,
              0,
              0,
              1,
              0,
              v9,
              0x280u,
              thisa->combatGrid[v10].occupyingCreatureBottomY + 5 - v9 + 1,
              0);
          }
          else if ( (giWalkingTo / 13 != 4 || giWalkingFrom / 13 != 3) && (giWalkingTo / 13 != 3 || giWalkingFrom / 13 != 4) )
          {
            if ( giWalkingFrom <= giWalkingTo )
            {
              if ( moatCell[j] == giWalkingTo || moatCell[j] == giWalkingTo2 )
              {
LABEL_150:
                icon::CombatClipDrawToBuffer(
                  thisa->combatScreenIcons[13],
                  0,
                  0,
                  j,
                  &thisa->moatPartBounds[j],
                  0,
                  0,
                  0,
                  0);
                hexcell::DrawOccupant((hexcell *)&thisa->field_49F[98 * moatCell[j] + 19], 100, 1);
                hexcell::DrawOccupant(&thisa->combatGrid[moatCell[j]], 100, 1);
                hexcell::DrawOccupant(&thisa->combatGrid[moatCell[j] + 1], 100, 1);
                goto LABEL_151;
              }
            }
            else if ( moatCell[j] == giWalkingFrom || moatCell[j] == giWalkingFrom2 )
            {
              goto LABEL_150;
            }
          }
        }
      }
    }
LABEL_151:
    v19 = 0;
  }
  if ( *(_DWORD *)&combatArmyInfoLevel > 0 && *(_DWORD *)&thisa->_15[100] != -1 )
  {
    combatManager::DrawSmallView(thisa, 0, 0);
    combatManager::DrawSmallView(thisa, 1, 0);
  }
  gpMouseManager->couldBeShowMouse = 1;
  PollSound();
  if ( a3 || a4 )
  {
    gbLimitToExtent = 0;
    gbComputeExtent = 0;
    if ( waitUntilItIsTime )
      DelayTil(&glTimers);
    glTimers = (signed __int64)((double)KBTickCount() + (double)delay * gfCombatSpeedMod[giCombatSpeed]);
    gbFullCombatScreenDrawn = 0;
    if ( redrawAll == 1 )
    {
      if ( giMaxExtentY > 442 )
        giMaxExtentY = 442;
      gbEnlargeScreenBlit = 0;
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      gbEnlargeScreenBlit = 1;
    }
  }
  else if ( redrawAll == 1 )
  {
    if ( waitUntilItIsTime )
      DelayTil(&glTimers);
    gbFullCombatScreenDrawn = 1;
    glTimers = (signed __int64)((double)KBTickCount() + (double)delay * gfCombatSpeedMod[giCombatSpeed]);
    combatManager::UpdateCombatArea(thisa);
  }
LABEL_168:
  gpMouseManager->couldBeShowMouse = 1;
  PollSound();
}
/* Orphan comments:
row by row to get perspective right
*/
// 4F1998: using guessed type int gbReturnAfterComputeExtent;
// 4F2E84: using guessed type int gbEnlargeScreenBlit;
// 4F5464: using guessed type int giWalkingFrom;
// 4F5468: using guessed type int giWalkingFrom2;
// 4F546C: using guessed type int giWalkingTo;
// 4F5470: using guessed type int giWalkingTo2;
// 4F5474: using guessed type int giWalkingYMod;
// 4F745C: using guessed type int gbFullCombatScreenDrawn;
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 4F7488: using guessed type int gbLimitToExtent;
// 518CFC: using guessed type int gbNoShowCombat;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004C66F0) --------------------------------------------------------
void __thiscall combatManager::DrawSmallView(combatManager *this, int a2, int a3)
{
  signed int v3; // ST54_4@41
  signed int v4; // eax@72
  int v5; // ST34_4@82
  int v6; // ST44_4@82
  IconEntry *v7; // eax@82
  signed int v9; // [sp+10h] [bp-78h]@74
  int y; // [sp+14h] [bp-74h]@80
  int spriteIdx; // [sp+18h] [bp-70h]@74
  int offsetY; // [sp+1Ch] [bp-6Ch]@19
  int j; // [sp+20h] [bp-68h]@49
  int i; // [sp+20h] [bp-68h]@54
  int l; // [sp+20h] [bp-68h]@60
  int k; // [sp+20h] [bp-68h]@65
  signed int m; // [sp+20h] [bp-68h]@74
  int offsetX; // [sp+28h] [bp-60h]@17
  int offsetXa; // [sp+28h] [bp-60h]@41
  int offsetXb; // [sp+28h] [bp-60h]@83
  char *v21; // [sp+30h] [bp-58h]@41
  char v22; // [sp+3Ch] [bp-4Ch]@1
  char v23; // [sp+3Dh] [bp-4Bh]@1
  char v24; // [sp+3Eh] [bp-4Ah]@1
  char v25; // [sp+3Fh] [bp-49h]@1
  char v26; // [sp+40h] [bp-48h]@1
  char v27; // [sp+41h] [bp-47h]@1
  char v28; // [sp+42h] [bp-46h]@1
  char v29; // [sp+43h] [bp-45h]@1
  char v30; // [sp+44h] [bp-44h]@1
  char v31; // [sp+45h] [bp-43h]@1
  char v32; // [sp+46h] [bp-42h]@1
  char v33; // [sp+47h] [bp-41h]@1
  char v34; // [sp+48h] [bp-40h]@1
  char v35; // [sp+49h] [bp-3Fh]@1
  char v36; // [sp+4Ah] [bp-3Eh]@1
  char v37; // [sp+4Bh] [bp-3Dh]@1
  char v38; // [sp+4Ch] [bp-3Ch]@1
  char v39; // [sp+4Dh] [bp-3Bh]@1
  char v40; // [sp+4Eh] [bp-3Ah]@1
  char v41; // [sp+4Fh] [bp-39h]@1
  char v42; // [sp+50h] [bp-38h]@1
  char v43; // [sp+51h] [bp-37h]@1
  char v44; // [sp+52h] [bp-36h]@1
  char v45; // [sp+53h] [bp-35h]@1
  char v46; // [sp+54h] [bp-34h]@1
  char v47; // [sp+55h] [bp-33h]@1
  char v48; // [sp+56h] [bp-32h]@1
  char v49; // [sp+57h] [bp-31h]@1
  char v50; // [sp+58h] [bp-30h]@1
  char v51; // [sp+59h] [bp-2Fh]@1
  char v52; // [sp+5Ah] [bp-2Eh]@1
  char v53; // [sp+5Bh] [bp-2Dh]@1
  char v54; // [sp+5Ch] [bp-2Ch]@1
  char v55; // [sp+5Dh] [bp-2Bh]@1
  char v56; // [sp+5Eh] [bp-2Ah]@1
  char v57; // [sp+5Fh] [bp-29h]@1
  char v58; // [sp+60h] [bp-28h]@1
  char v59; // [sp+61h] [bp-27h]@1
  char v60; // [sp+62h] [bp-26h]@1
  char v61; // [sp+63h] [bp-25h]@1
  char v62; // [sp+64h] [bp-24h]@1
  char v63; // [sp+65h] [bp-23h]@1
  char v64; // [sp+66h] [bp-22h]@1
  char v65; // [sp+67h] [bp-21h]@1
  char v66; // [sp+68h] [bp-20h]@1
  char v67; // [sp+69h] [bp-1Fh]@1
  char v68; // [sp+6Ah] [bp-1Eh]@1
  char v69; // [sp+6Bh] [bp-1Dh]@1
  char v70; // [sp+6Ch] [bp-1Ch]@1
  char v71; // [sp+6Dh] [bp-1Bh]@1
  char v72; // [sp+6Eh] [bp-1Ah]@1
  char v73; // [sp+6Fh] [bp-19h]@1
  char v74; // [sp+70h] [bp-18h]@1
  char v75; // [sp+71h] [bp-17h]@1
  char v76; // [sp+72h] [bp-16h]@1
  char v77; // [sp+73h] [bp-15h]@1
  char v78; // [sp+74h] [bp-14h]@1
  char v79; // [sp+75h] [bp-13h]@1
  char v80; // [sp+76h] [bp-12h]@1
  char v81; // [sp+77h] [bp-11h]@1
  char v82; // [sp+78h] [bp-10h]@1
  char v83; // [sp+79h] [bp-Fh]@1
  char v84; // [sp+7Ah] [bp-Eh]@1
  char v85; // [sp+7Bh] [bp-Dh]@1
  char v86; // [sp+7Ch] [bp-Ch]@1
  char v87; // [sp+7Dh] [bp-Bh]@1
  char v88; // [sp+7Eh] [bp-Ah]@1
  char v89; // [sp+7Fh] [bp-9h]@1
  char v90; // [sp+80h] [bp-8h]@1
  char v91; // [sp+81h] [bp-7h]@1
  char v92; // [sp+82h] [bp-6h]@1
  char v93; // [sp+83h] [bp-5h]@1
  int v94; // [sp+84h] [bp-4h]@39

  v22 = 22;
  v23 = 10;
  v24 = -1;
  v25 = -1;
  v26 = -1;
  v27 = -1;
  v28 = -1;
  v29 = -1;
  v30 = -1;
  v31 = -1;
  v32 = -1;
  v33 = -1;
  v34 = 11;
  v35 = 10;
  v36 = 32;
  v37 = 10;
  v38 = -1;
  v39 = -1;
  v40 = -1;
  v41 = -1;
  v42 = -1;
  v43 = -1;
  v44 = -1;
  v45 = -1;
  v46 = 1;
  v47 = 10;
  v48 = 22;
  v49 = 10;
  v50 = 43;
  v51 = 10;
  v52 = -1;
  v53 = -1;
  v54 = -1;
  v55 = -1;
  v56 = -1;
  v57 = -1;
  v58 = 11;
  v59 = 0;
  v60 = 32;
  v61 = 0;
  v62 = 11;
  v63 = 21;
  v64 = 32;
  v65 = 21;
  v66 = -1;
  v67 = -1;
  v68 = -1;
  v69 = -1;
  v70 = 1;
  v71 = 0;
  v72 = 22;
  v73 = 0;
  v74 = 43;
  v75 = 0;
  v76 = 11;
  v77 = 21;
  v78 = 32;
  v79 = 21;
  v80 = -1;
  v81 = -1;
  v82 = 1;
  v83 = 0;
  v84 = 22;
  v85 = 0;
  v86 = 43;
  v87 = 0;
  v88 = 1;
  v89 = 21;
  v90 = 22;
  v91 = 21;
  v92 = 43;
  v93 = 21;
  if ( !gbNoShowCombat && this->field_F42F && *(_DWORD *)&combatArmyInfoLevel && !gbInDrawSmallView )
  {
    gbInDrawSmallView = 1;
    if ( *(_DWORD *)&this->_15[4 * a2 + 100] != -1
      && (*(&this->field_F553 + a2) != 5 || *(_DWORD *)&this->_15[4 * a2 + 100] != 1)
      && (*(&this->field_F553 + a2) != 555 || *(_DWORD *)&this->_15[4 * a2 + 100]) )
      goto LABEL_88;
    if ( *(&this->field_F553 + a2) >= 0 )
    {
      gbLimitToExtent = 1;
      giMinExtentX = *(&this->field_F553 + a2);
      giMinExtentY = *(_DWORD *)&this->_16[4 * a2];
      giMaxExtentX = *(&this->field_F553 + a2) + *(_DWORD *)&this->_16[4 * a2 + 8] - 1;
      giMaxExtentY = *(_DWORD *)&this->_16[4 * a2] + *(_DWORD *)&this->_16[4 * a2 + 16] - 1;
      combatManager::DrawFrame(this, 0, 0, 0, 0, 0, 1, 1);
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        giMinExtentX,
        giMinExtentY,
        giMaxExtentX - giMinExtentX + 1,
        giMaxExtentY - giMinExtentY + 1);
      gbLimitToExtent = 0;
      *(&this->field_F553 + a2) = -1;
    }
    if ( *(_DWORD *)&this->_15[4 * a2 + 100] != -1 )
    {
LABEL_88:
      if ( *(_DWORD *)&combatArmyInfoLevel == 2 )
      {
        if ( a2 )
        {
          if ( *(_DWORD *)&this->_15[4 * a2 + 100] )
            offsetX = 555;
          else
            offsetX = 5;
          if ( *(_DWORD *)&this->_15[104] == *(_DWORD *)&this->_15[100] )
            offsetY = 154;
          else
            offsetY = 299;
        }
        else
        {
          if ( *(_DWORD *)&this->_15[100] )
            offsetX = 555;
          else
            offsetX = 5;
          offsetY = 299;
        }
        *(_DWORD *)&this->_16[4 * a2 + 8] = 83;
        *(_DWORD *)&this->_16[4 * a2 + 16] = 141;
      }
      else
      {
        if ( a2 )
        {
          if ( *(_DWORD *)&this->_15[4 * a2 + 100] )
            offsetX = 555;
          else
            offsetX = 5;
          if ( *(_DWORD *)&this->_15[104] == *(_DWORD *)&this->_15[100] )
            offsetY = 288;
          else
            offsetY = 366;
        }
        else
        {
          if ( *(_DWORD *)&this->_15[100] )
            offsetX = 555;
          else
            offsetX = 5;
          offsetY = 366;
        }
        *(_DWORD *)&this->_16[4 * a2 + 8] = 83;
        *(_DWORD *)&this->_16[4 * a2 + 16] = 74;
      }
      *(&this->field_F553 + a2) = offsetX;
      *(_DWORD *)&this->_16[4 * a2] = offsetY;
      v94 = gbLimitToExtent;
      if ( a3 )
        gbLimitToExtent = 0;
      v21 = (char *)&this->creatures[*(_DWORD *)&this->_15[4 * a2 + 100]][*(_DWORD *)&this->_15[4 * a2 + 108]];
      v3 = icon::CombatClipDrawToBuffer(
             this->combatScreenIcons[10],
             offsetX,
             offsetY,
             *(_DWORD *)&combatArmyInfoLevel != 2,
             (H2RECT *)&this->_15[68],
             0,
             0,
             0,
             0);
      offsetXa = offsetX + 6;
      if ( v3 )
      {
        if ( *(_DWORD *)(v21 + 150) <= 1 )
          sprintf(gText, off_4F6FC4, *(_DWORD *)(v21 + 150));
        else
          sprintf(gText, cMiniViewText, *(_DWORD *)(v21 + 150));
        font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 7, 57, 12, 1, 1);
        if ( *(_DWORD *)&combatArmyInfoLevel == 2 )
        {
          font::DrawBoundedString(smallFont, off_4F6FC8, offsetXa + 8, offsetY + 20, 57, 12, 1, 0);
          font::DrawBoundedString(smallFont, off_4F6FCC, offsetXa + 8, offsetY + 29, 57, 12, 1, 0);
          font::DrawBoundedString(smallFont, off_4F6FD0, offsetXa + 8, offsetY + 38, 57, 12, 1, 0);
          font::DrawBoundedString(smallFont, off_4F6FD4, offsetXa + 8, offsetY + 47, 57, 12, 1, 0);
          font::DrawBoundedString(smallFont, off_4F6FD8, offsetXa + 8, offsetY + 56, 57, 12, 1, 0);
          font::DrawBoundedString(smallFont, off_4F6FDC, offsetXa + 8, offsetY + 65, 57, 12, 1, 0);
          if ( v21[208] & 4 )
            font::DrawBoundedString(smallFont, off_4F6FE0, offsetXa + 8, offsetY + 74, 57, 12, 1, 0);
          sprintf(gText, "%d", v21[198]);
          font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 20, 57, 12, 1, 2);
          sprintf(gText, "%d", v21[199]);
          font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 29, 57, 12, 1, 2);
          sprintf(gText, "%d", *((_WORD *)v21 + 97));
          font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 38, 57, 12, 1, 2);
          sprintf(gText, "%d-%d", v21[200], v21[201]);
          font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 47, 57, 12, 1, 2);
          if ( *(_DWORD *)(v21 + 242) <= 0 )
          {
            if ( *(_DWORD *)(v21 + 242) >= 0 )
            {
              icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 45, offsetY + 56, 5, 0);
            }
            else
            {
              for ( i = 0; -*(_DWORD *)(v21 + 242) > i; ++i )
                icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 57 - 10 * i, offsetY + 56, 3, 0);
            }
          }
          else
          {
            for ( j = 0; *(_DWORD *)(v21 + 242) > j; ++j )
              icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 57 - 10 * j, offsetY + 56, 4, 0);
          }
          if ( *(_DWORD *)(v21 + 246) <= 0 )
          {
            if ( *(_DWORD *)(v21 + 246) >= 0 )
            {
              icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 50, offsetY + 65, 2, 0);
            }
            else
            {
              for ( k = 0; -*(_DWORD *)(v21 + 246) > k; ++k )
                icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 57 - 10 * k, offsetY + 65, 0, 0);
            }
          }
          else
          {
            for ( l = 0; *(_DWORD *)(v21 + 246) > l; ++l )
              icon::DrawToBuffer(this->combatScreenIcons[11], offsetXa + 57 - 10 * l, offsetY + 65, 1, 0);
          }
          if ( v21[208] & 4 )
          {
            sprintf(gText, "%d", v21[202]);
            font::DrawBoundedString(smallFont, gText, offsetXa + 8, offsetY + 74, 57, 12, 1, 2);
          }
        }
        v4 = *(_DWORD *)(v21 + 262);
        if ( v4 >= 6 )
          v4 = 6;
        v9 = v4;
        spriteIdx = -1;
        for ( m = 0; m < v9; ++m )
        {
          ++spriteIdx;
          while ( !v21[spriteIdx + 266] )
            ++spriteIdx;
          if ( *(_DWORD *)&combatArmyInfoLevel == 2 )
            y = offsetY + 86;
          else
            y = offsetY + 19;
          v5 = (unsigned __int8)*(&v23 + 4 * (3 * v9 - 3) + 2 * m) + y;
          v6 = ((19 - GetIconEntry(this->combatScreenIcons[12], spriteIdx)->width) >> 1)
             + (unsigned __int8)*(&v22 + 4 * (3 * v9 - 3) + 2 * m)
             + offsetXa
             + 6;
          v7 = GetIconEntry(this->combatScreenIcons[12], spriteIdx);
          icon::DrawToBuffer(this->combatScreenIcons[12], v6, ((19 - v7->height) >> 1) + v5, spriteIdx, 0);
        }
      }
      gbLimitToExtent = v94;
      offsetXb = offsetXa - 6;
      if ( a3 )
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          offsetXb,
          offsetY,
          *(_DWORD *)&this->_16[4 * a2 + 8],
          *(_DWORD *)&this->_16[4 * a2 + 16]);
      gbInDrawSmallView = 0;
    }
    else
    {
      gbInDrawSmallView = 0;
    }
  }
}
// 4F7488: using guessed type int gbLimitToExtent;
// 518CFC: using guessed type int gbNoShowCombat;
// 51E3EC: using guessed type int gbInDrawSmallView;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004C7320) --------------------------------------------------------
void __thiscall CycleColors(int this)
{
  int a1a; // ebx@1
  int v2; // eax@12
  int v3; // esi@14
  unsigned int v4; // ecx@14
  int v5; // edx@15
  signed __int8 *v6; // edx@15
  void *v7; // ecx@17
  int v8; // eax@22
  signed __int8 *v9; // edx@24
  int v10; // edx@26
  int v11; // ecx@27
  int a1; // [sp+10h] [bp-Ch]@17
  char v13; // [sp+14h] [bp-8h]@14
  char v14; // [sp+15h] [bp-7h]@14
  char v15; // [sp+16h] [bp-6h]@14
  char v16; // [sp+17h] [bp-5h]@14
  char v17; // [sp+18h] [bp-4h]@14
  char v18; // [sp+19h] [bp-3h]@14
  char v19; // [sp+1Ah] [bp-2h]@14
  char v20; // [sp+1Bh] [bp-1h]@14

  ++iCycle1Count;
  a1a = this;
  if ( gpWindowManager && gpBufferPalette && gpWindowManager->ready == 1 && (gpWindowManager->cycleColors || this) )
  {
    if ( giCycleType )
      gbEveryOtherCycle = 1 - gbEveryOtherCycle;
    else
      gbEveryOtherCycle = 1;
    if ( gbEveryOtherCycle )
    {
      if ( giCycleType == 2 )
      {
        iCombatCycleFrame = (((unsigned __int64)(iCombatCycleFrame + 1) >> 32) ^ abs(iCombatCycleFrame + 1) & 7)
                          - ((unsigned __int64)(iCombatCycleFrame + 1) >> 32);
        if ( iCombatCycleFrame < 5 )
          v2 = iCombatCycleFrame;
        else
          v2 = 8 - iCombatCycleFrame;
        v13 = -104;
        v14 = 67;
        v15 = 89;
        v16 = -75;
        v17 = 112;
        v3 = 0;
        v4 = (unsigned int)&gCyclePal;
        v18 = -37;
        v19 = -121;
        v20 = 16;
        do
        {
          v4 += 3;
          v5 = 3 * v2 + (unsigned __int8)*(&v13 + v3++);
          v6 = &gpBufferPalette->contents[3 * v5];
          *(_WORD *)(v4 - 3) = *(_WORD *)v6;
          *(_BYTE *)(v4 - 1) = v6[2];
        }
        while ( v4 < (unsigned int)((char *)&gCyclePal + 24) );
        goto LABEL_31;
      }
      v7 = (char *)&gCyclePal + 9;
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 9);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 11);
      LOBYTE(v7) = BYTE2(a1);
      memmove(v7, (unsigned __int16)&a1, (char *)&gCyclePal + 3, &gCyclePal, 9u);
      *(_WORD *)&gCyclePal = a1;
      *((_BYTE *)&gCyclePal + 2) = BYTE2(a1);
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 21);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 23);
      memmove(&a1, *(_WORD *)((char *)&gCyclePal + 21), (char *)&gCyclePal + 15, (char *)&gCyclePal + 12, 9u);
      *((_WORD *)&gCyclePal + 6) = a1;
      *((_BYTE *)&gCyclePal + 14) = BYTE2(a1);
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 51);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 53);
      memmove(&a1, *(_WORD *)((char *)&gCyclePal + 51), (char *)&gCyclePal + 51, (char *)&gCyclePal + 54, 0xCu);
      *(_WORD *)((char *)&gCyclePal + 63) = a1;
      *((_BYTE *)&gCyclePal + 65) = BYTE2(a1);
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 81);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 83);
      memmove(&a1, *(_WORD *)((char *)&gCyclePal + 81), (char *)&gCyclePal + 75, (char *)&gCyclePal + 72, 9u);
      *((_WORD *)&gCyclePal + 36) = a1;
      *((_BYTE *)&gCyclePal + 74) = BYTE2(a1);
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 93);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 95);
      memmove(&a1, *(_WORD *)((char *)&gCyclePal + 93), (char *)&gCyclePal + 87, (char *)&gCyclePal + 84, 9u);
      *((_WORD *)&gCyclePal + 42) = a1;
      *((_BYTE *)&gCyclePal + 86) = BYTE2(a1);
    }
    if ( !giCycleType )
    {
      LOWORD(a1) = *(_WORD *)((char *)&gCyclePal + 69);
      BYTE2(a1) = *((_BYTE *)&gCyclePal + 71);
      memmove(&a1, *(_WORD *)((char *)&gCyclePal + 69), (char *)&gCyclePal + 69, (char *)&gCyclePal + 66, 3u);
      *((_WORD *)&gCyclePal + 33) = a1;
      *((_BYTE *)&gCyclePal + 68) = BYTE2(a1);
      goto LABEL_31;
    }
    if ( giCycleType == 1 )
    {
      iCombatCycleFrame = (((unsigned __int64)(iCombatCycleFrame + 1) >> 32) ^ abs(iCombatCycleFrame + 1) & 7)
                        - ((unsigned __int64)(iCombatCycleFrame + 1) >> 32);
      if ( iCombatCycleFrame < 5 )
        v8 = iCombatCycleFrame;
      else
        v8 = 8 - iCombatCycleFrame;
      v9 = &gpBufferPalette->contents[12 * v8 + 330];
    }
    else
    {
      if ( giCycleType != 3 )
        goto LABEL_31;
      v10 = (iCombatCycleFrame + 1) % 6;
      iCombatCycleFrame = v10;
      if ( v10 < 4 )
        v11 = iCombatCycleFrame;
      else
        v11 = 6 - v10;
      v9 = &gpBufferPalette->contents[21 * v11 + 324];
    }
    *((_WORD *)&gCyclePal + 33) = *(_WORD *)v9;
    *((_BYTE *)&gCyclePal + 68) = v9[2];
LABEL_31:
    memcpy(gpBufferPalette->contents + 642, &gCyclePal, 84u);
    ++iCycle2Count;
    if ( !a1a )
    {
      ++iCycle3Count;
      UpdatePalette((#72 *)gpBufferPalette->contents);
    }
  }
}
// 4F19A0: using guessed type int giCycleType;
// 51E408: using guessed type int iCombatCycleFrame;
// 51E40C: using guessed type int gbEveryOtherCycle;
// 51E410: using guessed type int iCycle1Count;
// 51E414: using guessed type int iCycle2Count;
// 51E418: using guessed type int iCycle3Count;

//----- (004C76D0) --------------------------------------------------------
heroWindowManager *__thiscall heroWindowManager::heroWindowManager(heroWindowManager *this)
{
  baseManager::baseManager((baseManager *)this);
  this->vtable = &heroWindowManager::_vftable_;
  this->ready = NULL;
  this->nextTopmostWindow = NULL;
  this->topmostWindow = NULL;
  this->lastWindow = NULL;
  this->firstWindow = NULL;
  this->screenBuffer = NULL;
  this->cycleColors = NULL;
  this->fizzleSource = NULL;
  this->numScreenshots = 1;
  this->field_4E = NULL;
  this->hoveredFieldID = -1;
  this->buttonPressedCode = -1;
  return this;
}

//----- (004C7720) --------------------------------------------------------
int __thiscall heroWindowManager::Open(heroWindowManager *this, int a2)
{
  heroWindowManager *thisa; // ebx@1
  bitmap *v3; // eax@1

  thisa = this;
  InitVideo();
  memset(gpBufferPalette->contents, 0, 0x300u);
  SetPalette(gpBufferPalette->contents, 1);
  v3 = (bitmap *)operator new(26);
  if ( v3 )
    thisa->screenBuffer = bitmap::bitmap(v3);
  else
    thisa->screenBuffer = 0;
  if ( !thisa->screenBuffer )
    MemError();
  thisa->screenBuffer->setInConstructor = 33;
  thisa->screenBuffer->width = 640;
  thisa->screenBuffer->height = 480;
  thisa->screenBuffer->contents = (signed __int8 *)lpInitWin;
  memset(thisa->screenBuffer->contents, 0x24u, 0x4B000u);
  thisa->idx = a2;
  thisa->type = 32;
  thisa->ready = 1;
  strcpy(thisa->name, "heroWindowManager");
  return 0;
}

//----- (004C7800) --------------------------------------------------------
void __thiscall heroWindowManager::Close(heroWindowManager *this)
{
  heroWindowManager *thisa; // esi@1
  heroWindow *v2; // eax@2
  heroWindow *v3; // edi@3
  bitmap *v4; // ecx@4

  thisa = this;
  if ( this->ready == 1 )
  {
    v2 = this->lastWindow;
    if ( v2 )
    {
      do
      {
        v3 = v2->prevWindow;
        heroWindowManager::RemoveWindow(thisa, v2);
        v2 = v3;
      }
      while ( v3 );
    }
    thisa->screenBuffer->contents = 0;
    v4 = thisa->screenBuffer;
    if ( v4 )
      ((void (__stdcall *)(_DWORD))v4->vtable->scalarDeletingDestructor)(1);
    thisa->ready = 0;
  }
}

//----- (004C7850) --------------------------------------------------------
int __thiscall heroWindowManager::Main(heroWindowManager *this, tag_message *evt)
{
  int result; // eax@1
  heroWindow *i; // edi@1

  result = 0;
  for ( i = this->lastWindow; i; i = i->prevWindow )
  {
    result = heroWindow::BroadcastMessage(i, evt);
    if ( result >= 1 && result <= 2 )
      break;
  }
  return result;
}

//----- (004C7880) --------------------------------------------------------
int __thiscall heroWindowManager::ConvertToHover(heroWindowManager *this, tag_message *a2)
{
  return ((int (__thiscall *)(baseManager *, tag_message *))this->vtable->Main)((baseManager *)this, a2);
}

//----- (004C7890) --------------------------------------------------------
int __thiscall heroWindowManager::BroadcastMessage(heroWindowManager *this, INPUT_EVENT_CODE code, int messageType, int fieldID, int payload)
{
  tag_message evt; // [sp+4h] [bp-1Ch]@1

  evt.eventCode = code;
  evt.xCoordOrKeycode = messageType;
  evt.yCoordOrFieldID = fieldID;
  evt.payload = (void *)payload;
  return ((int (__thiscall *)(baseManager *, tag_message *))this->vtable->Main)((baseManager *)this, &evt);
}

//----- (004C78D0) --------------------------------------------------------
void __thiscall heroWindowManager::AddWindow(heroWindowManager *this, heroWindow *window, int idx, int redraw)
{
  heroWindow *lastWindow; // ebx@1
  heroWindowManager *thisa; // edi@1
  int idxToPlace; // ebp@1
  heroWindow *v7; // eax@13
  heroWindow *v8; // ecx@13
  heroWindow *v9; // eax@16

  lastWindow = this->lastWindow;
  thisa = this;
  idxToPlace = 0;
  if ( !(window->flags1 & 1) )
    idxToPlace = idx;
  if ( idxToPlace == -1 )
  {
    idxToPlace = 0;
    if ( lastWindow )
      idxToPlace = lastWindow->idx + 1;
  }
  if ( (!idxToPlace || this->firstWindow) && !heroWindow::Open(window, idxToPlace, redraw) )
  {
    if ( !lastWindow )
      goto LABEL_21;
    do
    {
      if ( lastWindow->idx <= idxToPlace )
        break;
      lastWindow = lastWindow->prevWindow;
    }
    while ( lastWindow );
    if ( lastWindow )
    {
      if ( lastWindow->nextWindow )
      {
        window->prevWindow = lastWindow;
        window->nextWindow = lastWindow->nextWindow;
        lastWindow->nextWindow->prevWindow = window;
        lastWindow->nextWindow = window;
      }
      else
      {
        v9 = thisa->lastWindow;
        window->nextWindow = 0;
        window->prevWindow = v9;
        thisa->lastWindow->nextWindow = window;
        thisa->lastWindow = window;
      }
    }
    else
    {
LABEL_21:
      v7 = thisa->firstWindow;
      window->prevWindow = 0;
      window->nextWindow = v7;
      v8 = thisa->lastWindow;
      thisa->firstWindow = window;
      if ( !v8 )
        thisa->lastWindow = window;
    }
    thisa->nextTopmostWindow = thisa->topmostWindow;
    thisa->topmostWindow = window;
  }
}

//----- (004C7990) --------------------------------------------------------
void __thiscall heroWindowManager::RemoveWindow(heroWindowManager *this, heroWindow *window)
{
  heroWindowManager *thisa; // esi@1
  heroWindow *v3; // eax@3
  heroWindow *prev; // eax@6
  heroWindow *v5; // eax@10
  heroWindow *v6; // eax@14

  thisa = this;
  if ( window )
  {
    heroWindow::Close(window);
    if ( thisa->firstWindow == window )
    {
      v3 = window->nextWindow;
      thisa->firstWindow = v3;
      if ( v3 )
        v3->prevWindow = 0;
      else
        thisa->lastWindow = 0;
    }
    else
    {
      prev = window->prevWindow;
      if ( thisa->lastWindow == window )
      {
        thisa->lastWindow = prev;
        prev->nextWindow = 0;
      }
      else
      {
        if ( prev )
          prev->nextWindow = window->nextWindow;
        v5 = window->nextWindow;
        if ( v5 )
          v5->prevWindow = window->prevWindow;
      }
    }
    if ( thisa->nextTopmostWindow == window )
      thisa->nextTopmostWindow = 0;
    v6 = thisa->nextTopmostWindow;
    if ( v6 )
      thisa->topmostWindow = v6;
    else
      thisa->topmostWindow = thisa->lastWindow;
  }
}

//----- (004C7A20) --------------------------------------------------------
int __thiscall heroWindowManager::DoDialog(heroWindowManager *this, heroWindow *window, int (__fastcall *a3)(tag_message *), int a4)
{
  heroWindowManager *v5; // esi@6
  int v6; // edi@8
  signed int v7; // ebp@9
  int evt; // [sp+10h] [bp-38h]@10
  int v10; // [sp+14h] [bp-34h]@15
  int v11; // [sp+18h] [bp-30h]@16
  tag_message a2; // [sp+2Ch] [bp-1Ch]@10

  gbInDialog = 1;
  if ( !iDialogNestCount )
    SetNoDialogMenus(0);
  ++iDialogNestCount;
  this->hoveredFieldID = -1;
  if ( window )
    heroWindowManager::AddWindow(this, window, -1, 1);
  if ( a4 )
  {
    v5 = gpWindowManager;
    if ( gPalette )
      SetPalette(gPalette->contents, 0);
    v6 = v5->cycleColors;
    v5->cycleColors = 0;
    PollSound();
    FadeIn(8);
    v5->cycleColors = v6 | dword_532E54;
    PollSound();
  }
  v7 = 0;
  inputManager::Flush(gpInputManager);
  this->buttonPressedCode = -1;
  do
  {
    PollSound();
    Process1WindowsMessage();
    memcpy(&evt, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
    (*(void (__stdcall **)(int *))(LODWORD(gpMouseManager->vtable) + 8))(&evt);
    if ( window
      && (evt != 4 || gbSendMouseMoveMessages)
      && heroWindow::BroadcastMessage(window, (tag_message *)&evt) == 2
      && evt == 512
      && v10 == 10 )
    {
      v7 = 1;
      this->buttonPressedCode = v11;
    }
    if ( ((int (__thiscall *)(int *))a3)(&evt) == 2 && evt == 512 && v10 == 10 )
      v7 = 1;
  }
  while ( !v7 );
  if ( window )
    heroWindowManager::RemoveWindow(this, window);
  inputManager::Flush(gpInputManager);
  gbInDialog = 0;
  --iDialogNestCount;
  if ( !iDialogNestCount )
    SetNoDialogMenus(1);
  return 0;
}
// 4F19AC: using guessed type int gbSendMouseMoveMessages;
// 4F2E8C: using guessed type int gbInDialog;
// 51E41C: using guessed type int iDialogNestCount;
// 532E54: using guessed type int dword_532E54;

//----- (004C7BF0) --------------------------------------------------------
void __thiscall heroWindowManager::UpdateScreen(heroWindowManager *this)
{
  heroWindowManager *thisa; // esi@1

  thisa = this;
  PollSound();
  BitmapToScreen(thisa->screenBuffer);
  PollSound();
}

//----- (004C7C10) --------------------------------------------------------
void __thiscall heroWindowManager::UpdateScreenRegion(heroWindowManager *this, int offsetX, int offsetY, unsigned int width, int height)
{
  heroWindowManager *thisa; // esi@1

  thisa = this;
  gpMouseManager->couldBeShowMouse = 0;
  PollSound();
  BlitBitmapToScreen(thisa->screenBuffer, offsetX, offsetY, width, height, offsetX, offsetY);
  gpMouseManager->couldBeShowMouse = 1;
  PollSound();
}

//----- (004C7C60) --------------------------------------------------------
void __thiscall heroWindowManager::FadeScreen(heroWindowManager *this, int flag, signed int a3, palette *pal)
{
  heroWindowManager *thisa; // esi@1
  int v5; // edi@6

  thisa = this;
  if ( pal )
    SetPalette(pal->contents, 0);
  if ( flag )
  {
    if ( flag == 1 )
    {
      dword_532E54 = thisa->cycleColors;
      thisa->cycleColors = 0;
      PollSound();
      FadeOut(a3);
      PollSound();
    }
    else
    {
      PollSound();
    }
  }
  else
  {
    v5 = thisa->cycleColors;
    thisa->cycleColors = 0;
    PollSound();
    FadeIn(a3);
    thisa->cycleColors = v5 | dword_532E54;
    PollSound();
  }
}
// 532E54: using guessed type int dword_532E54;

//----- (004C7CE0) --------------------------------------------------------
int __thiscall heroWindowManager::ScreenShot(heroWindowManager *this)
{
  heroWindowManager *v1; // esi@1
  char filename; // [sp+4h] [bp-10h]@1

  v1 = this;
  sprintf(&filename, "SHOT%04d.PCX", this->numScreenshots);
  CreatePCXFile(&filename, v1->screenBuffer->contents, 640, 480, gPalette->contents);
  ++v1->numScreenshots;
  return inputManager::Flush(gpInputManager);
}

//----- (004C7D40) --------------------------------------------------------
void __thiscall heroWindowManager::SaveFizzleSource(heroWindowManager *this, int x, int y, int width, int height)
{
  heroWindowManager *thisa; // ebp@1
  int left; // eax@2
  int actualWidth; // edi@2
  int top; // esi@4
  int actualHeight; // ebx@4
  resource *v10; // ecx@12
  bitmap *v11; // ecx@14

  thisa = this;
  if ( bShowIt )
  {
    left = x;
    actualWidth = width;
    if ( x < 0 )
    {
      x = 0;
      actualWidth = left + width;
    }
    top = y;
    actualHeight = height;
    if ( y < 0 )
    {
      actualHeight = y + height;
      top = 0;
    }
    if ( actualWidth + x > 640 )
      actualWidth = 640 - x;
    if ( top + actualHeight > 480 )
      actualHeight = 480 - top;
    if ( actualWidth > 0 && actualHeight > 0 )
    {
      v10 = (resource *)this->fizzleSource;
      if ( v10 )
        v10->vtable->scalarDeletingDestructor(v10, 1);
      v11 = (bitmap *)operator new(26);
      if ( v11 )
        thisa->fizzleSource = bitmap::bitmap(v11, 0, actualWidth, actualHeight);
      else
        thisa->fizzleSource = 0;
      BlitBitmap(gpWindowManager->screenBuffer, x, top, actualWidth, actualHeight, thisa->fizzleSource, 0, 0);
    }
  }
}
// 524C14: using guessed type int bShowIt;

//----- (004C7E00) --------------------------------------------------------
void __thiscall heroWindowManager::FizzleForward(heroWindowManager *this, int x, int y, int width, int height, int delay, const void *a7, int a8)
{
  int v8; // ecx@2
  int v9; // eax@4
  int v10; // eax@12
  bitmap *v11; // eax@14
  void *v12; // ebp@17
  int v13; // eax@18
  signed __int8 *v14; // eax@20
  signed __int8 *v15; // esi@20
  int v16; // ecx@20
  int v17; // edi@21
  __int16 v18; // dx@22
  __int16 v19; // bx@22
  signed int v20; // esi@25
  __int64 v21; // qax@26
  resource *v22; // ecx@29
  bitmap **v24; // [sp+14h] [bp-28h]@15
  signed int v25; // [sp+18h] [bp-24h]@17
  int v26; // [sp+1Ch] [bp-20h]@18
  void *pal; // [sp+20h] [bp-1Ch]@14
  int v28; // [sp+24h] [bp-18h]@19
  int v29; // [sp+28h] [bp-14h]@19
  int v30; // [sp+2Ch] [bp-10h]@2
  int v31; // [sp+30h] [bp-Ch]@17
  int v32; // [sp+38h] [bp-4h]@12

  if ( bShowIt )
  {
    v8 = x;
    gbEnlargeScreenBlit = 0;
    v30 = 0;
    if ( x < 0 )
    {
      x = 0;
      width += v8;
    }
    v9 = y;
    if ( y < 0 )
    {
      y = 0;
      height += v9;
    }
    if ( x + width > 640 )
      width = 640 - x;
    if ( y + height > 480 )
      height = 480 - y;
    if ( width > 0 && height > 0 )
    {
      v10 = this->cycleColors;
      this->cycleColors = 0;
      v32 = v10;
      if ( delay == -1 )
        delay = 150;
      pal = BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\WINMGR.CPP", 808);
      v11 = (bitmap *)operator new(sizeof(bitmap));
      if ( v11 )
      {
        v24 = &this->field_4E;
        this->field_4E = bitmap::bitmap(v11, 0, width, height);
      }
      else
      {
        this->field_4E = 0;
        v24 = &this->field_4E;
      }
      v12 = BaseAlloc(0x10000u, "F:\\h2xsrc\\Base\\WINMGR.CPP", 810);
      BlitBitmap(this->screenBuffer, x, y, width, height, *v24, 0, 0);
      v25 = 0;
      v31 = height + y;
      do
      {
        sprintf(gText, "CCYCLE%02d.BIN", v25);
        v13 = resourceManager::MakeId(gpResourceManager, gText, 1);
        resourceManager::PointToFile(gpResourceManager, v13);
        resourceManager::ReadBlock(gpResourceManager, v12, 0x10000u);
        v26 = y;
        if ( y < v31 )
        {
          v28 = 640 * y;
          v29 = 0;
          do
          {
            v14 = &this->fizzleSource->contents[this->fizzleSource->width * (v26 - y)];
            v15 = &this->screenBuffer->contents[x] + v28;
            v16 = (int)&(*v24)->contents[v29];
            if ( x < width + x )
            {
              v17 = width;
              do
              {
                v18 = *(_BYTE *)v16;
                v19 = (unsigned __int8)*v14++ << 8;
                ++v16;
                ++v15;
                --v17;
                *(v15 - 1) = *((_BYTE *)v12 + (unsigned __int16)(v18 | v19));
              }
              while ( v17 );
            }
            v28 += 640;
            v29 += width;
            ++v26;
          }
          while ( v26 < v31 );
        }
        PollSound();
        DelayTilMilli(v30 + delay);
        v30 = KBTickCount();
        BlitBitmapToScreen(this->screenBuffer, x, y, width, height, x, y);
        if ( a7 )
        {
          memcpy(pal, a7, 0x300u);
          v20 = 0;
          do
          {
            v21 = (v25 + 1) * ((signed int)*(_BYTE *)(a8 + v20) - (signed int)*((_BYTE *)a7 + v20));
            ++v20;
            *((_BYTE *)pal + v20 - 1) += ((BYTE4(v21) & 7) + (signed int)v21) >> 3;
          }
          while ( v20 < 768 );
          UpdatePalette((#72 *)pal);
        }
        PollSound();
        ++v25;
      }
      while ( v25 < 8 );
      DelayTilMilli(v30 + delay);
      BlitBitmap(*v24, 0, 0, width, height, this->screenBuffer, x, y);
      BlitBitmapToScreen(this->screenBuffer, x, y, width, height, x, y);
      gbEnlargeScreenBlit = 1;
      this->cycleColors = v32;
      v22 = (resource *)this->fizzleSource;
      if ( v22 )
        v22->vtable->scalarDeletingDestructor(v22, 1);
      this->fizzleSource = 0;
      if ( *v24 )
        (*v24)->vtable->scalarDeletingDestructor((resource *)*v24, 1);
      *v24 = 0;
      BaseFree(v12, (int)"F:\\h2xsrc\\Base\\WINMGR.CPP", 897);
      BaseFree(pal, (int)"F:\\h2xsrc\\Base\\WINMGR.CPP", 898);
    }
  }
}
// 4F2E84: using guessed type int gbEnlargeScreenBlit;
// 524C14: using guessed type int bShowIt;

//----- (004C8210) --------------------------------------------------------
int __thiscall heroWindowManager::ReleaseFizzleSource(heroWindowManager *this)
{
  resource *v2; // ecx@1
  int result; // eax@2

  v2 = (resource *)this->fizzleSource;
  if ( v2 )
    result = v2->vtable->scalarDeletingDestructor(v2, 1);
  this->fizzleSource = 0;
  return result;
}

//----- (004C8240) --------------------------------------------------------
bitmap *__thiscall bitmap::bitmap(bitmap *this)
{
  bitmap *thisa; // esi@1
  bitmap *result; // eax@1

  thisa = this;
  resource::resource((resource *)this, 0, 0, -1, 0u);
  thisa->setInConstructor = 0;
  thisa->vtable = &bitmap::_vftable_;
  thisa->width = 0;
  result = thisa;
  thisa->height = 0;
  thisa->contents = 0;
  return result;
}

//----- (004C8270) --------------------------------------------------------
int __thiscall bitmap::_scalar_deleting_destructor_(bitmap *this, char a2)
{
  bitmap *thisa; // esi@1
  void *v3; // ecx@1

  this->vtable = &bitmap::_vftable_;
  thisa = this;
  v3 = this->contents;
  if ( v3 )
    BaseFree(v3, (int)"F:\\h2xsrc\\Base\\BITMAP.CPP", 51);
  thisa->contents = 0;
  resource::_resource(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return (int)thisa;
}

//----- (004C82C0) --------------------------------------------------------
bitmap *__thiscall bitmap::bitmap(bitmap *this, __int16 a2, __int16 width, __int16 height)
{
  bitmap *thisa; // esi@1

  thisa = this;
  resource::resource((resource *)this, 0, 0, -1, 0);
  thisa->vtable = &bitmap::_vftable_;
  thisa->setInConstructor = a2;
  thisa->width = width;
  thisa->height = height;
  thisa->contents = (signed __int8 *)BaseAlloc(width * height, "F:\\h2xsrc\\Base\\BITMAP.CPP", 21);
  return thisa;
}

//----- (004C8320) --------------------------------------------------------
bitmap *__thiscall bitmap::bitmap(bitmap *this, int fileID)
{
  bitmap *thisa; // edi@1
  __int16 height; // ax@1
  DWORD size; // esi@1

  thisa = this;
  resource::resource((resource *)this, 0, fileID, 1, 0);
  thisa->vtable = &bitmap::_vftable_;
  resourceManager::PointToFile(gpResourceManager, fileID);
  thisa->setInConstructor = resourceManager::ReadWord(gpResourceManager);
  thisa->width = resourceManager::ReadWord(gpResourceManager);
  height = resourceManager::ReadWord(gpResourceManager);
  thisa->height = height;
  size = thisa->width * height;
  thisa->contents = (signed __int8 *)BaseAlloc(thisa->width * height, "F:\\h2xsrc\\Base\\BITMAP.CPP", 37);
  PollSound();
  resourceManager::ReadBlock(gpResourceManager, thisa->contents, size);
  PollSound();
  return thisa;
}

//----- (004C83B0) --------------------------------------------------------
void __thiscall bitmap::DrawToBufferCareful(bitmap *from, __int16 x, __int16 y)
{
  bitmap *thisa; // esi@1
  bitmap *screenBuf; // edx@2
  int screenWidth; // ebx@2
  int thisRight; // eax@2
  unsigned __int8 v7; // zf@2
  unsigned __int8 v8; // sf@2
  unsigned __int8 v9; // of@2
  __int16 v10; // ax@2
  unsigned int v11; // edx@7
  int v12; // edi@7
  unsigned int v13; // ecx@7
  int v14; // ebx@10
  int v15; // eax@12
  int v16; // eax@14
  bitmap *to; // [sp+14h] [bp-4h]@12

  thisa = from;
  if ( x < 0 )
  {
    v10 = y;
  }
  else
  {
    screenBuf = gpWindowManager->screenBuffer;
    screenWidth = screenBuf->width;
    thisRight = x + from->width;
    v9 = __OFSUB__(thisRight, screenWidth);
    v7 = thisRight == screenWidth;
    v8 = thisRight - screenWidth < 0;
    v10 = y;
    if ( (unsigned __int8)(v8 ^ v9) | v7 && y >= 0 && y + from->height <= screenBuf->height )
    {
      PollSound();
      BlitBitmap(thisa, 0, 0, thisa->width, thisa->height, gpWindowManager->screenBuffer, x, y);
      PollSound();
      return;
    }
  }
  v11 = from->width;
  v12 = from->height;
  v13 = x;
  if ( x < 0 )
  {
    v11 += x;
    v13 = 0;
  }
  if ( v10 >= 0 )
  {
    v14 = v10;
  }
  else
  {
    v12 += v10;
    v14 = 0;
  }
  v15 = gpWindowManager->screenBuffer->width;
  to = gpWindowManager->screenBuffer;
  if ( (signed int)(v13 + v11) > v15 )
    v11 = v15 - v13;
  v16 = to->height;
  if ( v12 + v14 > v16 )
    v12 = v16 - v14;
  if ( (signed int)v11 >= 0 )
  {
    if ( v12 >= 0 )
      BlitBitmap(thisa, 0, 0, v11, v12, to, v13, v14);
  }
}

//----- (004C84B0) --------------------------------------------------------
void __thiscall bitmap::DrawToBuffer(bitmap *from, __int16 x, __int16 y)
{
  bitmap *thisa; // esi@1

  thisa = from;
  PollSound();
  BlitBitmap(thisa, 0, 0, thisa->width, thisa->height, gpWindowManager->screenBuffer, x, y);
  PollSound();
}

//----- (004C84F0) --------------------------------------------------------
void __thiscall bitmap::GrabScreen(bitmap *to, __int16 xOff, __int16 yOff)
{
  BlitBitmap(gpWindowManager->screenBuffer, xOff, yOff, to->width, to->height, to, 0, 0);
}

//----- (004C8520) --------------------------------------------------------
void __thiscall bitmap::GrabBitmap(bitmap *to, bitmap *from, __int16 x, __int16 y)
{
  BlitBitmap(from, x, y, to->width, to->height, to, 0, 0);
}

//----- (004C8550) --------------------------------------------------------
void __thiscall bitmap::GrabBitmapCareful(bitmap *this, bitmap *fromBMP, __int16 x, __int16 y)
{
  unsigned int width; // esi@2
  bitmap *froma; // ecx@2
  int height; // edi@4
  Dimension32 modDim; // qdi@7
  int xAlt; // edx@8
  int yAlt; // ebx@11
  int origWidth; // eax@13
  int origHeight; // eax@15
  bitmap *thisa; // [sp+10h] [bp-Ch]@1

  thisa = this;
  if ( x < 0 )
  {
    froma = fromBMP;
  }
  else
  {
    width = this->width;
    froma = fromBMP;
    if ( fromBMP->width >= (signed int)(x + width) )
    {
      if ( y >= 0 )
      {
        height = thisa->height;
        if ( fromBMP->height >= y + height )
        {
          BlitBitmap(fromBMP, x, y, width, height, thisa, 0, 0);
          return;
        }
      }
    }
  }
  modDim.width = thisa->width;
  modDim.height = thisa->height;
  if ( x >= 0 )
  {
    xAlt = x;
  }
  else
  {
    modDim.width += x;
    xAlt = 0;
  }
  if ( y >= 0 )
  {
    yAlt = y;
  }
  else
  {
    modDim.height += y;
    yAlt = 0;
  }
  origWidth = froma->width;
  if ( modDim.width + xAlt > origWidth )
    modDim.width = origWidth - xAlt;
  origHeight = froma->height;
  if ( yAlt + modDim.height > origHeight )
    modDim.height = origHeight - yAlt;
  if ( *(signed __int64 *)&modDim >= 0 )
    BlitBitmap(froma, xAlt, yAlt, modDim.width, modDim.height, thisa, 0, 0);
}

//----- (004C8640) --------------------------------------------------------
void __thiscall bitmap::CopyTo(bitmap *this, bitmap *buf, int xTarg, int yTarg, int xFrom, int yFrom, unsigned int width, int height)
{
  int v8; // ebx@2
  int v9; // ebp@3
  int v10; // eax@3
  const void *v11; // esi@4
  bitmap *thisa; // [sp+10h] [bp-4h]@1

  thisa = this;
  PollSound();
  if ( width == 640 )
  {
    memcpy(&buf->contents[640 * yTarg] + xTarg, &thisa->contents[640 * yFrom] + xFrom, 640 * height);
  }
  else
  {
    v8 = height;
    if ( height > 0 )
    {
      v9 = 640 * yFrom;
      v10 = 640 * yTarg;
      do
      {
        v11 = &thisa->contents[xFrom] + v9;
        v9 += 640;
        memcpy(&buf->contents[xTarg] + v10, v11, width);
        v10 += 640;
        --v8;
      }
      while ( v8 );
    }
  }
  PollSound();
}

//----- (004C8710) --------------------------------------------------------
void __thiscall bitmap::CopyToCareful(bitmap *this, bitmap *target, int targX, int targY, int offX, int offY, int width, int height)
{
  bitmap *thisa; // ebx@1
  int i; // ebp@2
  signed __int8 *fromRow; // ecx@3
  int targRow; // esi@3

  thisa = this;
  if ( width >= 1 )
  {
    i = 0;
    while ( height > i )
    {
      fromRow = &thisa->contents[thisa->width * (i + offY)];
      targRow = i++ + targY;
      memcpy(&target->contents[target->width * targRow] + targX, &fromRow[offX], width);
    }
  }
}

//----- (004C8780) --------------------------------------------------------
// Memory management system
// ;Also maintains a pool of MemoryBlockInfo's which track all files loaded by this function
LPVOID __fastcall BaseAlloc(size_t a1, char *a2, int caller_lineno)
{
  DWORD v3; // ebx@1
  LPVOID result; // eax@2
  signed int v5; // eax@4
  LPVOID v6; // ebp@6
  signed int v7; // ecx@8
  int v8; // edx@9
  char *v9; // eax@9
  const char *v10; // edi@10
  unsigned int v11; // ecx@10
  int v12; // ebx@14
  char v13[4]; // [sp+10h] [bp-2BCh]@1
  char OutputString[4]; // [sp+D8h] [bp-1F4h]@10

  *(_DWORD *)v13 = a2;
  v3 = a1;
  if ( a1 )
  {
    if ( !gpMemEntry )
    {
      LogInt((int)"IME", iMemEntries, -999, -999, -999, -999, -999, -999);
      gpMemEntry = malloc(0x24220u);
      v5 = 0;
      do
      {
        v5 += 74;
        *((_BYTE *)gpMemEntry + v5 - 74) = 0;
      }
      while ( v5 < 148000 );
    }
    giTotalMemAllocated += v3;
    v6 = malloc(v3);
    if ( !v6 )
      MemError();
    v7 = 0;
    ++iMemEntries;
    do
    {
      v8 = 74 * v7;
      v9 = (char *)gpMemEntry + 74 * v7;
      if ( !*v9 )
      {
        *v9 = 1;
        v10 = *(const char **)v13;
        *(_DWORD *)((char *)gpMemEntry + v8 + 1) = v6;
        *(_DWORD *)((char *)gpMemEntry + v8 + 5) = v3;
        v11 = strlen(v10) + 1;
        *(_DWORD *)OutputString = v11;
        memcpy((char *)gpMemEntry + v8 + 9, v10, v11);
        *(_DWORD *)((char *)gpMemEntry + v8 + 70) = caller_lineno;
        v7 = 99999;
      }
      ++v7;
    }
    while ( v7 < 2000 );
    if ( giDebugLevel == 4 )
    {
      sprintf(v13, "KBAlloc    Size %d   Ptr %d   File %s  Line %d", v3, v6, *(_DWORD *)v13, caller_lineno);
      if ( giDebugLevel >= 2 )
      {
        v12 = fopen("KB.LOG", (int)"at+");
        if ( v12 )
        {
          strcpy(OutputString, v13);
          *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
          fputs(OutputString, v12);
          fclose(v12);
          if ( giDebugLevel == 4 )
            OutputDebugStringA(OutputString);
        }
      }
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFD8: using guessed type __int16 word_51EFD8;

//----- (004C8990) --------------------------------------------------------
void __fastcall BaseFree(void *a1, int a2, int caller_lineno)
{
  signed int v3; // eax@2
  int v4; // ebx@8
  int v5; // eax@11
  signed int v6; // ecx@13
  int v7; // ebx@14
  char *v8; // edx@14
  int v9; // ebp@17
  int v10; // ebx@24
  int v11; // [sp+10h] [bp-2C4h]@1
  int v12; // [sp+14h] [bp-2C0h]@1
  char OutputString[500]; // [sp+18h] [bp-2BCh]@9
  char v14; // [sp+20Ch] [bp-C8h]@16

  v12 = a2;
  v11 = (int)a1;
  if ( !gpMemEntry )
  {
    LogInt((int)"IME", iMemEntries, -999, -999, -999, -999, -999, -999);
    gpMemEntry = malloc(0x24220u);
    v3 = 0;
    do
    {
      v3 += 74;
      *((_BYTE *)gpMemEntry + v3 - 74) = 0;
    }
    while ( v3 < 148000 );
  }
  if ( giDebugLevel == 4 )
    LogInt((int)"Free ", v11, -999, -999, -999, -999, -999, -999);
  if ( v11 )
  {
    v5 = iMemEntries-- - 1;
    if ( iMemEntries < 0 )
      LogInt((int)"MemEntries Below 0", v5, -999, -999, -999, -999, -999, -999);
    v6 = 0;
    do
    {
      v7 = 74 * v6;
      v8 = (char *)gpMemEntry + 74 * v6;
      if ( *(_DWORD *)(v8 + 1) == v11 )
      {
        if ( giDebugLevel == 4 )
        {
          sprintf(
            &v14,
            "KBFree    Size %d   Ptr %d   File %s  Line %d",
            *(_DWORD *)(v8 + 5),
            v11,
            v8 + 9,
            *(_DWORD *)(v8 + 70));
          if ( giDebugLevel >= 2 )
          {
            v9 = fopen("KB.LOG", (int)"at+");
            if ( v9 )
            {
              strcpy(OutputString, &v14);
              *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
              fputs(OutputString, v9);
              fclose(v9);
              if ( giDebugLevel == 4 )
                OutputDebugStringA(OutputString);
            }
          }
        }
        *((_BYTE *)gpMemEntry + v7) = 0;
        v6 = 99999;
        giTotalMemAllocated -= *(_DWORD *)((char *)gpMemEntry + v7 + 5);
      }
      ++v6;
    }
    while ( v6 < 2000 );
    if ( v6 >= 99999 )
    {
      free(v11);
    }
    else
    {
      sprintf(gText, "Bad Delete,  File '%13s'  Line % 4d, ptr %12d", v12, caller_lineno, v11);
      if ( giDebugLevel >= 2 )
      {
        v10 = fopen("KB.LOG", (int)"at+");
        if ( v10 )
        {
          strcpy(OutputString, gText);
          *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
          fputs(OutputString, v10);
          fclose(v10);
          if ( giDebugLevel == 4 )
            OutputDebugStringA(OutputString);
        }
      }
    }
  }
  else if ( giDebugLevel >= 2 )
  {
    v4 = fopen("KB.LOG", (int)"at+");
    if ( v4 )
    {
      strcpy(OutputString, "NULL POINTER");
      *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
      fputs(OutputString, v4);
      fclose(v4);
      if ( giDebugLevel == 4 )
        OutputDebugStringA(OutputString);
    }
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFD8: using guessed type __int16 word_51EFD8;
// 4C8990: using guessed type char OutputString[500];

//----- (004C8D10) --------------------------------------------------------
void __cdecl PrintMemoryLeaks()
{
  signed int v0; // ebx@3
  int v1; // ebp@6
  char OutputString[500]; // [sp+10h] [bp-1F4h]@7

  if ( giDebugLevel >= 1 && gpMemEntry )
  {
    v0 = 0;
    LogInt((int)"Total Memory Leaks", iMemEntries, -999, -999, -999, -999, -999, -999);
    do
    {
      if ( *((_BYTE *)gpMemEntry + v0) )
      {
        sprintf(
          gText,
          "Memory Leak,  File '%13s'  Line % 4d, ptr %12d   size %6d",
          (char *)gpMemEntry + v0 + 9,
          *(_DWORD *)((char *)gpMemEntry + v0 + 70),
          *(_DWORD *)((char *)gpMemEntry + v0 + 1),
          *(_DWORD *)((char *)gpMemEntry + v0 + 5));
        if ( giDebugLevel >= 2 )
        {
          v1 = fopen("KB.LOG", (int)"at+");
          if ( v1 )
          {
            strcpy(OutputString, gText);
            *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
            fputs(OutputString, v1);
            fclose(v1);
            if ( giDebugLevel == 4 )
              OutputDebugStringA(OutputString);
          }
        }
      }
      v0 += 74;
    }
    while ( v0 < 148000 );
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFD8: using guessed type __int16 word_51EFD8;
// 4C8D10: using guessed type char OutputString[500];

//----- (004C8E50) --------------------------------------------------------
unsigned int __thiscall MAKEFILEID(const char *this)
{
  const char *v1; // edx@1
  int v2; // ebx@1
  unsigned int v3; // esi@1
  unsigned int i; // ecx@1
  char v5; // al@2
  int v6; // eax@5

  v1 = this;
  v2 = 0;
  v3 = 0;
  for ( i = strlen(this) - 1; (signed int)i >= 0; --i )
  {
    v5 = v1[i];
    if ( v5 >= 'a' && v5 <= 'z' )
      v1[i] = v5 & 0xDF;
    v6 = v1[i];
    v2 += v6;
    v3 = v2 + v6 + 32 * v3 + (v3 >> 25);
  }
  return v3;
}

//----- (004C8EA0) --------------------------------------------------------
void __fastcall FadeIn(int a1)
{
  palette *pal; // ebx@1
  palette *v2; // eax@1
  signed int hit63; // ebp@5
  signed int i; // esi@7
  signed __int8 *contents; // ecx@12
  signed int j; // edx@13
  int left; // eax@13
  int stride; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@11

  stride = a1;
  pal = 0;
  v2 = (palette *)operator new(20);
  if ( v2 )
    pal = palette::palette(v2);
  if ( !pal )
    MemError();
  hit63 = 0;
  if ( !*(&bMenu + 7 * giCurExe + 5) )
    stride *= 2;
  memset(pal->contents, 0, 0x300u);
  for ( i = 0; ; i += stride )
  {
    if ( i < 64 )
      goto LABEL_11;
    if ( hit63 )
      break;
    i = 63;
LABEL_11:
    v8 = KBTickCount() + 20;
    PollSound();
    if ( i == 63 )
    {
      hit63 = 1;
      contents = gpBufferPalette->contents;
    }
    else
    {
      j = 0;
      left = 63 - i;
      do
      {
        if ( gpBufferPalette->contents[j] > left )
          pal->contents[j] = gpBufferPalette->contents[j] - left;
        ++j;
      }
      while ( j < 768 );
      contents = pal->contents;
    }
    UpdatePalette((#72 *)contents);
    DelayTil(&v8);
  }
  if ( pal )
    pal->vtable->scalarDeletingDestructor((resource *)pal, 1);
}
// 4F2E88: using guessed type int giCurExe;

//----- (004C8F90) --------------------------------------------------------
int __fastcall FadeOut(signed int a1)
{
  signed int v1; // ebx@1
  palette *v2; // ebp@1
  palette *v3; // ecx@1
  signed int v4; // esi@7
  int result; // eax@9
  signed int v6; // edx@13
  RGB *v7; // eax@14
  char *v8; // ecx@14
  char v9; // al@14
  signed int v10; // [sp+10h] [bp-8h]@5
  int this; // [sp+14h] [bp-4h]@11

  v1 = a1;
  v2 = 0;
  v3 = (palette *)operator new(20);
  if ( v3 )
    v2 = palette::palette(v3);
  if ( !v2 )
    MemError();
  v10 = 0;
  if ( !*(&bMenu + 7 * giCurExe + 5) )
    v1 *= 2;
  memcpy(v2->contents, gpBufferPalette->contents, 0x300u);
  v4 = 0;
  while ( 1 )
  {
    if ( v4 < 64 )
      goto LABEL_11;
    result = v10;
    if ( v10 )
      break;
    v4 = 63;
LABEL_11:
    this = KBTickCount() + 20;
    PollSound();
    if ( v4 == 63 )
      v10 = 1;
    v6 = 0;
    do
    {
      v7 = (RGB *)v2->contents;
      v8 = (char *)v7 + v6;
      v9 = *(&v7->red + v6);
      if ( v9 > 0 )
      {
        if ( v9 <= v1 )
          *v8 = 0;
        else
          *v8 = v9 - v1;
      }
      ++v6;
    }
    while ( v6 < 768 );
    v4 += v1;
    UpdatePalette((#72 *)v2->contents);
    DelayTil(&this);
  }
  if ( v2 )
    result = v2->vtable->scalarDeletingDestructor((resource *)v2, 1);
  return result;
}
// 4F2E88: using guessed type int giCurExe;

//----- (004C9080) --------------------------------------------------------
int __fastcall Random(int a1, int a2)
{
  int result; // eax@2

  if ( a2 == a1 )
  {
    result = a2;
  }
  else if ( a2 >= a1 )
  {
    result = a1 + (signed int)rand() % (a2 - a1 + 1);
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (004C90B0) --------------------------------------------------------
// Displays message on fail
void __fastcall ProcessAssert(int a1, char *a2, int lineno)
{
  char *v3; // esi@1

  v3 = a2;
  if ( !a1 )
  {
    mouseManager::SetColorMice(gpMouseManager, 0);
    SetFullScreenStatus(0);
    sprintf(gText, "Assert statement failed in module %s, line %d.  Do you wish to abort the program?", v3, lineno);
    if ( MessageBoxA(hwndApp, gText, "Assert Failure", 0x14u) != 7 )
      ShutDown(0);
  }
}

//----- (004C9110) --------------------------------------------------------
int __fastcall FindStringInString(const char *a1, const char *a2)
{
  const char *v2; // ebp@1
  unsigned int v3; // kr04_4@1
  unsigned int v4; // kr0C_4@1
  int v5; // edi@1
  int v6; // ebx@1
  int result; // eax@4
  int v8; // [sp+10h] [bp-4h]@1

  v8 = (int)a2;
  v2 = a1;
  v3 = strlen(a1) + 1;
  v4 = strlen(a2) + 1;
  v5 = 0;
  v6 = v3 - 1 - (v4 - 1) + 1;
  if ( v6 <= 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( strncmp((int)&v2[v5], v8, v4 - 1) )
    {
      ++v5;
      if ( v5 >= v6 )
        goto LABEL_4;
    }
    result = (int)&v2[v5];
  }
  return result;
}

//----- (004C9180) --------------------------------------------------------
char *__fastcall FindToken(const char *str, char chr)
{
  const char *s; // esi@1
  unsigned int v3; // kr04_4@1
  int i; // eax@1
  char *result; // eax@4

  s = str;
  v3 = strlen(str) + 1;
  i = 0;
  if ( (signed int)(v3 - 1) <= 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( s[i] != chr )
    {
      ++i;
      if ( (signed int)(v3 - 1) <= i )
        goto LABEL_4;
    }
    result = (char *)&s[i];
  }
  return result;
}

//----- (004C91C0) --------------------------------------------------------
int __fastcall FindLastToken(const char *a1, char a2)
{
  const char *v2; // esi@1
  unsigned int v3; // ecx@1
  int result; // eax@4

  v2 = a1;
  v3 = strlen(a1) - 1;
  if ( (signed int)v3 < 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( v2[v3] != a2 )
    {
      --v3;
      if ( (signed int)v3 < 0 )
        goto LABEL_4;
    }
    result = (int)&v2[v3];
  }
  return result;
}

//----- (004C91F0) --------------------------------------------------------
int __cdecl SetGameDefaults()
{
  void *v0; // eax@1
  signed int v1; // ebx@2
  signed int v2; // eax@6
  int v3; // esi@6
  signed int v4; // esi@6
  int v5; // edi@6
  signed int v6; // esi@6
  int v7; // edi@6
  int v8; // eax@6
  signed __int64 v9; // qax@6
  int result; // eax@6
  signed __int64 v11; // qt2@6

  v0 = &bMenu + 5;
  *(_DWORD *)&Data = 1;
  *(_DWORD *)&soundVolume = 1;
  *(_DWORD *)&shouldAutosave = 1;
  *(_DWORD *)&showRoute = 1;
  do
  {
    v1 = giMainVideoModeWidth;
    *((_DWORD *)v0 - 5) = 1;
    *((_DWORD *)v0 - 4) = 10;
    *((_DWORD *)v0 - 3) = 10;
    *((_DWORD *)v0 + 1) = 0;
    *(_DWORD *)v0 = 1;
    if ( v1 > 640 )
    {
      *((_DWORD *)v0 - 2) = 640;
      *((_DWORD *)v0 - 1) = 480;
    }
    else
    {
      *((_DWORD *)v0 - 2) = 480;
      *((_DWORD *)v0 - 1) = 360;
    }
    v0 = (char *)v0 + 28;
  }
  while ( v0 < &showCombatGrid );
  *(_DWORD *)&showCombatGrid = 0;
  *(_DWORD *)&showCombatMouseHex = 0;
  combatShadeLevel = 0;
  *(_DWORD *)&combatArmyInfoLevel = 0;
  *(_DWORD *)&evilInterfaceUsage = 0;
  *(_DWORD *)&useOpera = 1;
  *(_DWORD *)&quickCombatLevel = 0;
  giCombatSpeed = 0;
  *(_DWORD *)&autoCombatUseSpells = 0;
  *(_DWORD *)&blackoutComputer = 0;
  *(_DWORD *)&currentMapOffset = 0;
  v2 = rand();
  *(_DWORD *)&showObjectBoxes = 0;
  *(_DWORD *)&editorScreenAnimation = 0;
  *(_DWORD *)&editorPaletteCycling = 0;
  *(_DWORD *)&firstMapOffset = v2 % 32001;
  gbFirstTimeThrough = 1;
  *(_DWORD *)&slowVideo = 3;
  *(_DWORD *)&gConfig = 3;
  *(_DWORD *)&walkSpeed = 2;
  strcpy((char *)&networkDefaultName, "The Unknown Hero");
  *(_DWORD *)&uniqueSystemID = 0;
  v3 = (signed int)rand() % 999999 + 1;
  v4 = KBTickCount() + v3;
  *(&uniqueSystemID + 2) = byte_51E6E4[v4 % 36];
  v5 = (signed int)rand() % 999999 + 1;
  v6 = v5 + KBTickCount() + v4;
  *(&uniqueSystemID + 1) = byte_51E6E4[v6 % 36];
  v7 = (signed int)rand() % 999999 + 1;
  v8 = KBTickCount();
  byte_5248D7 = 0;
  v9 = v6 + v7 + v8;
  v11 = v9 % 26;
  result = v9 / 26;
  uniqueSystemID = v11 + 65;
  return result;
}
// 4F0A18: using guessed type int giMainVideoModeWidth;
// 4F7464: using guessed type int gbFirstTimeThrough;
// 5248D7: using guessed type char byte_5248D7;

//----- (004C93B0) --------------------------------------------------------
void __cdecl ReadPrefsFromRegistry()
{
  int v0; // ecx@8
  DWORD cbData; // [sp+Ch] [bp-D4h]@2
  HKEY hKey; // [sp+10h] [bp-D0h]@1
  DWORD Type; // [sp+14h] [bp-CCh]@2
  const CHAR SubKey; // [sp+18h] [bp-C8h]@1
  char v5; // [sp+7Ch] [bp-64h]@1

  strcpy(&v5, (const char *)&unk_51E728);
  strcpy((char *)&SubKey, "SOFTWARE\\New World Computing\\Heroes of Might and Magic 2\\1.0");
  hKey = 0;
  if ( !RegCreateKeyA(HKEY_LOCAL_MACHINE, &SubKey, &hKey) )
  {
    cbData = 4;
    if ( RegQueryValueExA(hKey, "Music Volume", 0, &Type, &Data, &cbData) )
    {
      *(&gConfig + 412) = 0;
      memset(&gConfig, 0, 0x19Cu);
      *(&gConfig + 412) = 0;
      strcpy((char *)&unk_5248BC, "AUTO");
      strcpy((char *)&unk_5248C9, "AUTO");
      *(_DWORD *)&useCDMusic = 1;
      SetGameDefaults();
      RegCloseKey(hKey);
      UpdateSystemOptionsMenu();
      WritePrefsToRegistry();
    }
    else
    {
      RegQueryValueExA(hKey, "Music Volume", 0, &Type, &Data, &cbData);
      RegQueryValueExA(hKey, "Sound Volume", 0, &Type, &soundVolume, &cbData);
      RegQueryValueExA(hKey, "Walk Speed", 0, &Type, &walkSpeed, &cbData);
      RegQueryValueExA(hKey, "Computer Walk Speed", 0, &Type, &gConfig, &cbData);
      RegQueryValueExA(hKey, "Show Route", 0, &Type, &showRoute, &cbData);
      RegQueryValueExA(hKey, "Blackout Computer", 0, &Type, &blackoutComputer, &cbData);
      RegQueryValueExA(hKey, "Sound Quality", 0, &Type, &useCDMusic, &cbData);
      RegQueryValueExA(hKey, "Use Opera", 0, &Type, &useOpera, &cbData);
      RegQueryValueExA(hKey, "Direct Connect Com Port", 0, &Type, &directConnectComPort, &cbData);
      RegQueryValueExA(hKey, "Direct Connect Baud Rate", 0, &Type, &directConnectBaudRate, &cbData);
      RegQueryValueExA(hKey, "Modem Com Port", 0, &Type, &modemComPort, &cbData);
      RegQueryValueExA(hKey, "Modem Baud Rate", 0, &Type, &modemBaudRate, &cbData);
      cbData = 99;
      RegQueryValueExA(hKey, "Modem Init String", 0, &Type, &modemInitString, &cbData);
      cbData = 4;
      RegQueryValueExA(hKey, "Unique System ID", 0, &Type, &uniqueSystemID, &cbData);
      *(&uniqueSystemID + 3) = 0;
      cbData = 31;
      RegQueryValueExA(hKey, "Network Default Name", 0, &Type, &networkDefaultName, &cbData);
      cbData = 4;
      RegQueryValueExA(hKey, "Autosave", 0, &Type, &shouldAutosave, &cbData);
      RegQueryValueExA(hKey, "Slow Video", 0, &Type, &slowVideo, &cbData);
      RegQueryValueExA(hKey, "Show Combat Grid", 0, &Type, &showCombatGrid, &cbData);
      RegQueryValueExA(hKey, "Show Combat Mouse Hex", 0, &Type, &showCombatMouseHex, &cbData);
      RegQueryValueExA(hKey, "Combat Shade Level", 0, &Type, (LPBYTE)&combatShadeLevel, &cbData);
      RegQueryValueExA(hKey, "Combat Army Info Level", 0, &Type, &combatArmyInfoLevel, &cbData);
      RegQueryValueExA(hKey, "Evil Interface Usage", 0, &Type, &evilInterfaceUsage, &cbData);
      RegQueryValueExA(hKey, "Quick Combat Level", 0, &Type, &quickCombatLevel, &cbData);
      RegQueryValueExA(hKey, "Combat Speed", 0, &Type, (LPBYTE)&giCombatSpeed, &cbData);
      RegQueryValueExA(hKey, "Auto Combat Use Spells", 0, &Type, &autoCombatUseSpells, &cbData);
      RegQueryValueExA(hKey, "First Map Offset", 0, &Type, &firstMapOffset, &cbData);
      RegQueryValueExA(hKey, "Current Map Offset", 0, &Type, &currentMapOffset, &cbData);
      RegQueryValueExA(hKey, "Show Object Boxes", 0, &Type, &showObjectBoxes, &cbData);
      RegQueryValueExA(hKey, "Editor Screen Animation", 0, &Type, &editorScreenAnimation, &cbData);
      RegQueryValueExA(hKey, "Editor Palette Cycling", 0, &Type, &editorPaletteCycling, &cbData);
      RegQueryValueExA(hKey, "Main Game Show Menu", 0, &Type, (LPBYTE)&bMenu, &cbData);
      RegQueryValueExA(hKey, "Main Game X", 0, &Type, (LPBYTE)&bMenu + 4, &cbData);
      RegQueryValueExA(hKey, "Main Game Y", 0, &Type, (LPBYTE)&bMenu + 8, &cbData);
      RegQueryValueExA(hKey, "Main Game Width", 0, &Type, (LPBYTE)&bMenu + 12, &cbData);
      RegQueryValueExA(hKey, "Main Game Height", 0, &Type, (LPBYTE)&bMenu + 16, &cbData);
      RegQueryValueExA(hKey, "Main Game Full Screen", 0, &Type, (LPBYTE)&bMenu + 20, &cbData);
      RegQueryValueExA(hKey, "Main Game Color Mouse Cursor", 0, &Type, (LPBYTE)&bMenu + 24, &cbData);
      RegQueryValueExA(hKey, "Editor Show Menu", 0, &Type, (LPBYTE)&bMenu + 28, &cbData);
      RegQueryValueExA(hKey, "Editor X", 0, &Type, (LPBYTE)&bMenu + 32, &cbData);
      RegQueryValueExA(hKey, "Editor Y", 0, &Type, (LPBYTE)&bMenu + 36, &cbData);
      RegQueryValueExA(hKey, "Editor Width", 0, &Type, (LPBYTE)&bMenu + 40, &cbData);
      RegQueryValueExA(hKey, "Editor Height", 0, &Type, (LPBYTE)&bMenu + 44, &cbData);
      RegQueryValueExA(hKey, "Editor Full Screen", 0, &Type, (LPBYTE)&bMenu + 48, &cbData);
      RegQueryValueExA(hKey, "Editor Color Mouse Cursor", 0, &Type, (LPBYTE)&bMenu + 52, &cbData);
      cbData = 99;
      if ( RegQueryValueExA(hKey, "AppPath", 0, &Type, &gcRegAppPath, &cbData) )
        strcpy((char *)&gcRegAppPath, (const char *)&unk_51EAC8);
      if ( RegQueryValueExA(hKey, "CDDrive", 0, &Type, &gcRegCDRomPath, &cbData) )
        strcpy((char *)&gcRegCDRomPath, (const char *)&unk_51EAD4);
      RegCloseKey(hKey);
      v0 = 28 * giCurExe;
      if ( *(&bMenu + 7 * giCurExe + 3) <= 0 )
        *(BOOL *)((char *)&bMenu + v0 + 12) = 320;
      if ( *(BOOL *)((char *)&bMenu + v0 + 16) <= 0 )
        *(BOOL *)((char *)&bMenu + v0 + 16) = 240;
      if ( *(BOOL *)((char *)&bMenu + v0 + 4) < 0 )
        *(BOOL *)((char *)&bMenu + v0 + 4) = 0;
      if ( *(BOOL *)((char *)&bMenu + v0 + 4) > giMainVideoModeHeight - 200 )
        *(BOOL *)((char *)&bMenu + v0 + 4) = giMainVideoModeHeight - 200;
      if ( *(BOOL *)((char *)&bMenu + v0 + 8) < 0 )
        *(BOOL *)((char *)&bMenu + v0 + 8) = 0;
      if ( *(BOOL *)((char *)&bMenu + v0 + 8) > giMainVideoModeWidth - 200 )
        *(BOOL *)((char *)&bMenu + v0 + 8) = giMainVideoModeWidth - 200;
    }
  }
}
// 4F0A18: using guessed type int giMainVideoModeWidth;
// 4F0A1C: using guessed type int giMainVideoModeHeight;
// 4F2E88: using guessed type int giCurExe;

//----- (004C9B60) --------------------------------------------------------
int __cdecl ReadPrefs()
{
  memset(&gConfig, 0, 412u);
  *(&gConfig + 412) = 0;
  ReadPrefsFromRegistry();
  sprintf(byte_52497A, "RMT%sRL.BIN", &uniqueSystemID);
  sprintf(byte_524987, "RMT%sRC.BIN", &uniqueSystemID);
  sprintf(byte_524994, "RMT%sRD.BIN", &uniqueSystemID);
  sprintf(byte_5249A1, "RMT%sSL.BIN", &uniqueSystemID);
  sprintf(byte_5249AE, "RMT%sSC.BIN", &uniqueSystemID);
  return sprintf(byte_5249BB, "RMT%sSD.BIN", &uniqueSystemID);
}

//----- (004C9C10) --------------------------------------------------------
void __cdecl WritePrefsToRegistry()
{
  HKEY hKey; // [sp+Ch] [bp-CCh]@1
  const CHAR SubKey; // [sp+10h] [bp-C8h]@1
  char v2; // [sp+74h] [bp-64h]@1

  strcpy(&v2, (const char *)&unk_51EB30);
  strcpy((char *)&SubKey, "SOFTWARE\\New World Computing\\Heroes of Might and Magic 2\\1.0");
  hKey = 0;
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, &SubKey, 0, 0xF003Fu, &hKey) )
  {
    RegSetValueExA(hKey, "Music Volume", 0, REG_DWORD, &Data, 4u);
    RegSetValueExA(hKey, "Sound Volume", 0, REG_DWORD, &soundVolume, 4u);
    RegSetValueExA(hKey, "Walk Speed", 0, REG_DWORD, &walkSpeed, 4u);
    RegSetValueExA(hKey, "Computer Walk Speed", 0, REG_DWORD, &gConfig, 4u);
    RegSetValueExA(hKey, "Show Route", 0, REG_DWORD, &showRoute, 4u);
    RegSetValueExA(hKey, "Blackout Computer", 0, REG_DWORD, &blackoutComputer, 4u);
    RegSetValueExA(hKey, "Sound Quality", 0, REG_DWORD, &useCDMusic, 4u);
    RegSetValueExA(hKey, "Use Opera", 0, REG_DWORD, &useOpera, 4u);
    RegSetValueExA(hKey, "Direct Connect Com Port", 0, REG_DWORD, &directConnectComPort, 4u);
    RegSetValueExA(hKey, "Direct Connect Baud Rate", 0, REG_DWORD, &directConnectBaudRate, 4u);
    RegSetValueExA(hKey, "Modem Com Port", 0, REG_DWORD, &modemComPort, 4u);
    RegSetValueExA(hKey, "Modem Baud Rate", 0, REG_DWORD, &modemBaudRate, 4u);
    RegSetValueExA(hKey, "Modem Init String", 0, REG_SZ, &modemInitString, 98u);
    RegSetValueExA(hKey, "Unique System ID", 0, REG_SZ, &uniqueSystemID, 4u);
    RegSetValueExA(hKey, "Network Default Name", 0, REG_SZ, &networkDefaultName, 30u);
    RegSetValueExA(hKey, "Autosave", 0, REG_DWORD, &shouldAutosave, 4u);
    RegSetValueExA(hKey, "Slow Video", 0, REG_DWORD, &slowVideo, 4u);
    RegSetValueExA(hKey, "Show Combat Grid", 0, REG_DWORD, &showCombatGrid, 4u);
    RegSetValueExA(hKey, "Show Combat Mouse Hex", 0, REG_DWORD, &showCombatMouseHex, 4u);
    RegSetValueExA(hKey, "Combat Shade Level", 0, REG_DWORD, (const BYTE *)&combatShadeLevel, 4u);
    RegSetValueExA(hKey, "Combat Army Info Level", 0, REG_DWORD, &combatArmyInfoLevel, 4u);
    RegSetValueExA(hKey, "Evil Interface Usage", 0, REG_DWORD, &evilInterfaceUsage, 4u);
    RegSetValueExA(hKey, "Quick Combat Level", 0, REG_DWORD, &quickCombatLevel, 4u);
    RegSetValueExA(hKey, "Combat Speed", 0, REG_DWORD, (const BYTE *)&giCombatSpeed, 4u);
    RegSetValueExA(hKey, "Auto Combat Use Spells", 0, REG_DWORD, &autoCombatUseSpells, 4u);
    RegSetValueExA(hKey, "First Map Offset", 0, REG_DWORD, &firstMapOffset, 4u);
    RegSetValueExA(hKey, "Current Map Offset", 0, REG_DWORD, &currentMapOffset, 4u);
    RegSetValueExA(hKey, "Show Object Boxes", 0, REG_DWORD, &showObjectBoxes, 4u);
    RegSetValueExA(hKey, "Editor Screen Animation", 0, REG_DWORD, &editorScreenAnimation, 4u);
    RegSetValueExA(hKey, "Editor Palette Cycling", 0, REG_DWORD, &editorPaletteCycling, 4u);
    RegSetValueExA(hKey, "Main Game Show Menu", REG_NONE, 4u, (const BYTE *)&bMenu, 4u);
    RegSetValueExA(hKey, "Main Game X", 0, REG_DWORD, (const BYTE *)&bMenu + 4, 4u);
    RegSetValueExA(hKey, "Main Game Y", 0, REG_DWORD, (const BYTE *)&bMenu + 8, 4u);
    RegSetValueExA(hKey, "Main Game Width", 0, REG_DWORD, (const BYTE *)&bMenu + 12, 4u);
    RegSetValueExA(hKey, "Main Game Height", 0, REG_DWORD, (const BYTE *)&bMenu + 16, 4u);
    RegSetValueExA(hKey, "Main Game Full Screen", 0, REG_DWORD, (const BYTE *)&bMenu + 20, 4u);
    RegSetValueExA(hKey, "Main Game Color Mouse Cursor", 0, REG_DWORD, (const BYTE *)&bMenu + 24, 4u);
    RegSetValueExA(hKey, "Editor Show Menu", 0, REG_DWORD, (const BYTE *)&bMenu + 28, 4u);
    RegSetValueExA(hKey, "Editor X", 0, REG_DWORD, (const BYTE *)&bMenu + 32, 4u);
    RegSetValueExA(hKey, "Editor Y", 0, REG_DWORD, (const BYTE *)&bMenu + 36, 4u);
    RegSetValueExA(hKey, "Editor Width", 0, REG_DWORD, (const BYTE *)&bMenu + 40, 4u);
    RegSetValueExA(hKey, "Editor Height", 0, REG_DWORD, (const BYTE *)&bMenu + 44, 4u);
    RegSetValueExA(hKey, "Editor Full Screen", 0, REG_DWORD, (const BYTE *)&bMenu + 48, 4u);
    RegSetValueExA(hKey, "Editor Color Mouse Cursor", 0, REG_DWORD, (const BYTE *)&bMenu + 52, 4u);
    RegCloseKey(hKey);
  }
}

//----- (004CA0B0) --------------------------------------------------------
void __cdecl WritePrefs()
{
  UpdateSystemOptionsMenu();
  WritePrefsToRegistry();
}

//----- (004CA0C0) --------------------------------------------------------
signed int __cdecl SetupCDDrive()
{
  UINT v0; // eax@1
  signed int result; // eax@3
  DWORD v2; // esi@6
  signed int v3; // ebx@6
  UINT v4; // eax@12
  signed int v5; // ebx@15
  int v6; // eax@18
  unsigned int v7; // edi@18
  int v8; // eax@26
  char v9; // [sp+13h] [bp-2EDh]@11
  signed int v10; // [sp+14h] [bp-2ECh]@14
  HKEY hKey; // [sp+18h] [bp-2E8h]@9
  char v12[28]; // [sp+1Ch] [bp-2E4h]@6
  _DWORD buf[64]; // [sp+38h] [bp-2C8h]@6
  CHAR String; // [sp+138h] [bp-1C8h]@26
  CHAR strCommand; // [sp+19Ch] [bp-164h]@16
  const CHAR SubKey; // [sp+29Ch] [bp-64h]@25

  sprintf(gText, ".\\DATA\\HEROES2.AGG");
  v0 = open(gText, 32768);
  if ( v0 != -1 )
    goto LABEL_30;
  if ( _chdir((const char *)&gcRegAppPath) == -1 )
    return 3;
  v0 = open(gText, 32768);
  if ( v0 != -1 )
  {
LABEL_30:
    _close(v0);
    v2 = GetLogicalDrives();
    buf[0] = 0;
    memset(v12, 0, 0x18u);
    *(_WORD *)&v12[24] = 0;
    v3 = 2;
    do
    {
      if ( (1 << v3) & v2 )
      {
        sprintf(gText, "A:\\");
        gText[0] += v3;
        if ( GetDriveTypeA(gText) == 5 )
        {
          ++buf[0];
          *((_BYTE *)&hKey + buf[0] + 3) = v3;
        }
      }
      ++v3;
    }
    while ( v3 < 26 );
    v9 = LOBYTE(buf[0]);
    if ( strlen((const char *)&gcRegCDRomPath) == 0
      || (sprintf(gText, "%s\\heroes2\\anim\\voy24.smk", &gcRegCDRomPath), v4 = open(gText, 32768), v4 == -1) )
    {
      v10 = 0;
      while ( 1 )
      {
        v5 = 0;
        if ( v9 > 0 )
          break;
LABEL_20:
        Sleep(0xBB8u);
        ++v10;
        if ( v10 >= 2 )
          return 2;
      }
      while ( 1 )
      {
        _wsprintfA(&strCommand, "open %c: type cdaudio alias CD", v12[v5] + 65);
        if ( !mciSendStringA(&strCommand, (LPSTR)buf, 0xFFu, 0) )
        {
          _wsprintfA(&strCommand, "info CD UPC wait");
          mciSendStringA(&strCommand, (LPSTR)buf, 0xFFu, 0);
          _wsprintfA(&strCommand, "close CD");
          mciSendStringA(&strCommand, (LPSTR)buf, 0xFFu, 0);
        }
        sprintf(gText, "%c:\\heroes2\\anim\\voy24.smk", v12[v5] + 65);
        v6 = open(gText, 32768);
        v7 = v6;
        if ( v6 != -1 )
          break;
        ++v5;
        if ( v9 <= v5 )
          goto LABEL_20;
      }
      if ( _lseek(v6, 0, 2u) != -1 && _lseek(v7, -100, 1u) != -1 )
        _read(v7, buf, 0x64u);
      _close(v7);
      strcpy((char *)&SubKey, "SOFTWARE\\New World Computing\\Heroes of Might and Magic 2\\1.0");
      hKey = 0;
      if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20006u, &hKey) )
      {
        _wsprintfA(&String, "%c:", v12[v5] + 65);
        v8 = lstrlenA(&String);
        RegSetValueExA(hKey, "CDDrive", 0, 1u, (const BYTE *)&String, v8 + 1);
        RegCloseKey(hKey);
      }
      sprintf(gText, "%c:%s", v12[v5] + 65, "\\HEROES2\\ANIM\\");
      strcpy("\\HEROES2\\ANIM\\", gText);
      result = 0;
    }
    else
    {
      _close(v4);
      sprintf(&gText[2], "%s", "\\HEROES2\\ANIM\\");
      strcpy("\\HEROES2\\ANIM\\", gText);
      result = 0;
    }
  }
  else
  {
    result = 4;
  }
  return result;
}
// 4CA0C0: using guessed type char var_2E4[28];

//----- (004CA4B0) --------------------------------------------------------
void __thiscall BitmapToScreen(bitmap *this)
{
  BlitBitmapToScreen(this, 0, 0, this->width, this->height, 0, 0);
}

//----- (004CA4D0) --------------------------------------------------------
#error "4CA4D0: undefined or illegal type '#72' (funcsize=22)"

//----- (004CA510) --------------------------------------------------------
void __fastcall BlitBitmapToScreenNoMouseCheck(int a1, int a2, int a3, unsigned int a4, int a5, int a6, signed int a7)
{
  BlitBitmapToScreenVesa((bitmap *)a1, a2, a3, a4, a5, a6, a7);
}

//----- (004CA540) --------------------------------------------------------
void __fastcall BlitBitmapToScreen(bitmap *bmp, int xOff, int yOff, unsigned int width, int height, int screenX, int screenY)
{
  unsigned int v7; // ebp@5
  int v8; // ebx@5
  int v9; // ecx@12
  int x; // [sp+10h] [bp-8h]@1
  bitmap *bmpa; // [sp+14h] [bp-4h]@1

  x = xOff;
  bmpa = bmp;
  if ( gbColorMice )
  {
    if ( giScrollX || giScrollY )
    {
      v7 = 448;
      v8 = giScrollY + 16;
      x = giScrollX + 16;
      height = 448;
    }
    else
    {
      v8 = yOff;
      v7 = width;
    }
    dword_532E78 = v7 + screenX - 1;
    dword_532E70 = screenY + height - 1;
    if ( mouseManager::IsVis(gpMouseManager)
      && gpMouseManager->cursorTopLeftX <= dword_532E78
      && gpMouseManager->field_6E >= screenX
      && gpMouseManager->cursorTopLeftY <= dword_532E70
      && gpMouseManager->field_72 >= screenY )
    {
      mouseManager::SaveAndDraw(gpMouseManager);
      BlitBitmapToScreenVesa(bmpa, x, v8, v7, height, screenX, screenY);
      v9 = gpMouseManager->field_6E;
      if ( v9 > dword_532E78
        || gpMouseManager->cursorTopLeftX < screenX
        || gpMouseManager->field_72 > dword_532E70
        || gpMouseManager->cursorTopLeftY < screenY )
        BlitBitmapToScreenVesa(
          bmpa,
          gpMouseManager->cursorTopLeftX,
          gpMouseManager->cursorTopLeftY,
          v9 - gpMouseManager->cursorTopLeftX + 1,
          gpMouseManager->field_72 - gpMouseManager->cursorTopLeftY + 1,
          gpMouseManager->cursorTopLeftX,
          gpMouseManager->cursorTopLeftY);
      mouseManager::RestoreUnderlying(gpMouseManager);
    }
    else
    {
      BlitBitmapToScreenVesa(bmpa, x, v8, v7, height, screenX, screenY);
    }
  }
  else
  {
    BlitBitmapToScreenVesa(bmp, xOff, yOff, width, height, screenX, screenY);
  }
}
// 4F19B0: using guessed type int gbColorMice;
// 4F2E78: using guessed type int giScrollX;
// 4F2E7C: using guessed type int giScrollY;
// 532E70: using guessed type int dword_532E70;
// 532E78: using guessed type int dword_532E78;

//----- (004CA6D0) --------------------------------------------------------
void __cdecl LogTruncate()
{
  int v0; // ebx@2
  char v1[500]; // [sp+Ch] [bp-1F4h]@3

  if ( giDebugLevel >= 2 )
  {
    v0 = open("KB.LOG", 17153, 128);
    if ( v0 != -1 )
    {
      strcpy(v1, "===========New Log==========");
      *(_WORD *)&v1[strlen(v1)] = word_51EFC8;
      _write(v0, v1, strlen(v1));
      _close(v0);
    }
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFC8: using guessed type __int16 word_51EFC8;
// 4CA6D0: using guessed type char var_1F4[500];

//----- (004CA780) --------------------------------------------------------
void __thiscall LogStr(void *msg)
{
  const char *msga; // edi@1
  int v2; // ebx@2
  char OutputString[500]; // [sp+Ch] [bp-1F4h]@3

  msga = (const char *)msg;
  if ( giDebugLevel >= 2 )
  {
    v2 = fopen("KB.LOG", (int)"at+");
    if ( v2 )
    {
      strcpy(OutputString, msga);
      *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
      fputs(OutputString, v2);
      fclose(v2);
      if ( giDebugLevel == 4 )
        OutputDebugStringA(OutputString);
    }
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFD8: using guessed type __int16 word_51EFD8;
// 4CA780: using guessed type char OutputString[500];

//----- (004CA820) --------------------------------------------------------
// Debug-logs a string followed by 7 integers.
// ;To log less than 7, fill some of the arguments with -999.
// ;What logging is done depends on debugLogLevel
void __fastcall LogInt(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // ebx@15
  char v9; // [sp+10h] [bp-2BCh]@2
  char OutputString[500]; // [sp+D8h] [bp-1F4h]@16

  if ( a8 == -999 )
  {
    if ( a7 == -999 )
    {
      if ( a6 == -999 )
      {
        if ( a5 == -999 )
        {
          if ( a4 == -999 )
          {
            if ( a3 == -999 )
              sprintf(&v9, "%s : % 8d", a1, a2);
            else
              sprintf(&v9, "%s : % 8d % 8d", a1, a2, a3);
          }
          else
          {
            sprintf(&v9, "%s : % 8d % 8d % 8d", a1, a2, a3, a4);
          }
        }
        else
        {
          sprintf(&v9, "%s : % 8d % 8d % 8d % 8d", a1, a2, a3, a4, a5);
        }
      }
      else
      {
        sprintf(&v9, "%s : % 8d % 8d % 8d % 8d % 8d", a1, a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sprintf(&v9, "%s : % 8d % 8d % 8d % 8d % 8d % 8d", a1, a2, a3, a4, a5, a6, a7);
    }
  }
  else
  {
    sprintf(&v9, "%s : % 8d % 8d % 8d % 8d % 8d % 8d % 8d", a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if ( giDebugLevel >= 2 )
  {
    v8 = fopen("KB.LOG", (int)"at+");
    if ( v8 )
    {
      strcpy(OutputString, &v9);
      *(_WORD *)&OutputString[strlen(OutputString)] = word_51EFD8;
      fputs(OutputString, v8);
      fclose(v8);
      if ( giDebugLevel == 4 )
        OutputDebugStringA(OutputString);
    }
  }
}
// 4F21F0: using guessed type int giDebugLevel;
// 51EFD8: using guessed type __int16 word_51EFD8;
// 4CA820: using guessed type char OutputString[500];

//----- (004CAA50) --------------------------------------------------------
void __thiscall AiPrint(void *this)
{
  void *v1; // esi@1

  v1 = this;
  if ( giDebugLevel >= 2 )
  {
    FillBitmapArea(gpWindowManager->screenBuffer, 0, 460, 0x280u, 20, 0);
    font::DrawBoundedString(smallFont, (char *)v1, 0, 464, 640, 16, 1, 0);
    BlitBitmapToScreen(gpWindowManager->screenBuffer, 0, 460, 0x280u, 20, 0, 460);
  }
}
// 4F21F0: using guessed type int giDebugLevel;

//----- (004CAAC0) --------------------------------------------------------
#error "4CAAC0: undefined or illegal type '#72' (funcsize=77)"

//----- (004CABC0) --------------------------------------------------------
void __fastcall CreatePCXFile(const char *filename, _BYTE *bmpContents, int width, int height, _BYTE *palContents)
{
  _BYTE *bmpContentsa; // esi@1
  _BYTE *row; // ebp@2
  int v7; // eax@4
  int v8; // ebx@4
  char v9; // cl@5
  int i; // edi@5
  int v11; // edi@9
  _BYTE *denormalizedPalletteContents; // esi@15
  signed int v13; // ecx@15
  char v14; // dl@16
  char v15; // [sp+13h] [bp-89h]@15
  int fd; // [sp+14h] [bp-88h]@1
  int v17; // [sp+18h] [bp-84h]@3
  char pcxHeader[128]; // [sp+1Ch] [bp-80h]@1

  bmpContentsa = bmpContents;
  memset(pcxHeader, 0, sizeof(pcxHeader));
  pcxHeader[0] = 10;
  *(_WORD *)&pcxHeader[8] = width - 1;
  pcxHeader[2] = 1;
  *(_WORD *)&pcxHeader[66] = width;
  *(_WORD *)&pcxHeader[10] = height - 1;
  pcxHeader[65] = 1;
  *(_WORD *)&pcxHeader[68] = 1;
  pcxHeader[1] = 5;
  pcxHeader[3] = 8;
  fd = open(filename, 33537, 128);
  if ( fd != -1 )
  {
    _write(fd, pcxHeader, 128);
    row = BaseAlloc(2 * width, "F:\\h2xsrc\\Base\\Misc.cpp", 1480);
    if ( height > 0 )
    {
      v17 = height;
      do
      {
        v7 = 0;
        v8 = 0;
        while ( v7 < width )
        {
          v9 = bmpContentsa[v7];
          for ( i = v7; i < width; ++i )
          {
            if ( bmpContentsa[i] != v9 )
              break;
            if ( i - v7 + 1 >= 64 )
              break;
          }
          v11 = i - v7;
          if ( v11 > 1 || (v9 & 0xC0) == -64 )
          {
            v8 += 2;
            v7 += v11;
            row[v8 - 2] = v11 | 0xC0;
            row[v8 - 1] = v9;
          }
          else
          {
            row[v8++] = v9;
            ++v7;
          }
        }
        _write(fd, row, v8);
        bmpContentsa += width;
        --v17;
      }
      while ( v17 );
    }
    BaseFree(row, (int)"F:\\h2xsrc\\Base\\Misc.cpp", 1520);
    v15 = 12;
    _write(fd, &v15, 1);
    denormalizedPalletteContents = BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\Misc.cpp", 1526);
    v13 = 0;
    do
    {
      v14 = palContents[v13++];
      denormalizedPalletteContents[v13 - 1] = 4 * v14;
    }
    while ( v13 < 768 );
    _write(fd, denormalizedPalletteContents, 768);
    BaseFree(denormalizedPalletteContents, (int)"F:\\h2xsrc\\Base\\Misc.cpp", 1531);
    _close(fd);
  }
}

//----- (004CADB0) --------------------------------------------------------
int __thiscall FileSize(const char *this)
{
  void *v1; // esi@1
  int v2; // edi@1
  int v3; // esi@3

  v1 = (void *)this;
  v2 = fopen((char *)this, (int)"r+b");
  if ( !v2 )
    FileError(v1);
  fseek(v2, 0, 2);
  v3 = ftell(v2);
  fseek(v2, 0, 0);
  fclose(v2);
  return v3;
}

//----- (004CAE10) --------------------------------------------------------
IconEntry *__fastcall GetIconEntry(icon *a1, int idx)
{
  return &a1->headersAndImageData[idx];
}

//----- (004CAE20) --------------------------------------------------------
int __fastcall SRandom(int low, int high)
{
  int v2; // esi@1
  int result; // eax@2
  signed int v4; // eax@5
  int v5; // ecx@5
  unsigned int v6; // edi@5
  signed int v7; // ecx@5

  v2 = low;
  if ( high == low )
  {
    result = high;
  }
  else if ( high >= low )
  {
    v4 = 0;
    v5 = ((((13 * (_BYTE)high + -3 * (_BYTE)low + -96 * (_BYTE)high + (_BYTE)iLastSeed) & 0x3F) << 8)
        + (13 * (_WORD)high & 0xFF)
        + 13233 * (13 * (_WORD)low & 0xFF)
        + 32 * (13 * (_WORD)high & 0xFF)
        + (_WORD)iLastSeed) & 0xFFF;
    iLastSeed = v5;
    v6 = ((7 * (_WORD)v5 & 0xFF0u) >> 4) + 7 * v5;
    v7 = 31;
    do
    {
      if ( v6 & (1 << v7) )
        v4 |= 1 << v7;
      --v7;
    }
    while ( v7 >= 0 );
    iLastSeed = v2 + v6 + 8 * high;
    result = v2 + v4 % (high - v2 + 1);
  }
  else
  {
    result = low;
  }
  return result;
}
// 51E538: using guessed type int iLastSeed;

//----- (004CAEE0) --------------------------------------------------------
LPVOID __thiscall SRand(unsigned int this)
{
  iLastSeed = this;
  return srand(this);
}
// 51E538: using guessed type int iLastSeed;

//----- (004CAEF0) --------------------------------------------------------
void __fastcall GetDataEntry(const char *a1, int a2, int a3, const char *a4, unsigned int a5, int a6)
{
  int v6; // ebx@1
  int v7; // edx@1
  int v8; // ebp@1
  int v9; // eax@3
  int v10; // eax@5
  int v11; // ebp@7
  heroWindow *v12; // eax@7
  const char *v13; // edi@12
  int v14; // esi@16
  int v15; // ecx@16
  int evt; // [sp+10h] [bp-9Ch]@12
  int v17; // [sp+14h] [bp-98h]@12
  int v18; // [sp+18h] [bp-94h]@12
  char *v19; // [sp+28h] [bp-84h]@12
  char *msg; // [sp+2Ch] [bp-80h]@1
  signed int protoCategory; // [sp+30h] [bp-7Ch]@1
  int spriteIdx; // [sp+34h] [bp-78h]@1
  char filnam; // [sp+38h] [bp-74h]@7
  char v24; // [sp+48h] [bp-64h]@14
  int v25; // [sp+B8h] [bp+Ch]@14

  msg = (char *)a1;
  v6 = a2;
  v7 = gpMouseManager->spriteIdx;
  v8 = gpMouseManager->cursorDisabled;
  protoCategory = gpMouseManager->cursorCategory;
  spriteIdx = v7;
  if ( v8 )
  {
    do
      mouseManager::ShowColorPointer(gpMouseManager);
    while ( gpMouseManager->cursorDisabled );
  }
  mouseManager::SetPointer(gpMouseManager, "advmice.mse", 0, -999);
  cDEDest = (char *)v6;
  iDEMaxLen = a3;
  strcpy((char *)v6, (const char *)&unk_51F104);
  v9 = 16 * font::LineLength(bigFont, msg, 240);
  if ( a5 )
    v9 += 39;
  v10 = (v9 + 15) / 45;
  if ( v10 > 6 )
    v10 = 6;
  v11 = 45 * v10 - (a5 < 1 ? 0 : 0x1E) + 95;
  sprintf(&filnam, "evntwin%d.bin", v10);
  v12 = (heroWindow *)operator new(68);
  if ( v12 )
    DataEntryWin = heroWindow::heroWindow(v12, 177, 20, &filnam);
  else
    DataEntryWin = 0;
  if ( !DataEntryWin )
    MemError();
  v19 = msg;
  evt = 512;
  v17 = 3;
  v18 = 1;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  v13 = a4;
  if ( !a4 )
    v13 = (const char *)&unk_51F118;
  strcpy(&v24, v13);
  v19 = &v24;
  v18 = 10;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  strcpy((char *)v6, &v24);
  v17 = 6;
  v19 = (char *)6;
  evt = 512;
  v18 = 30721;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  v18 = 30727;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  v18 = 30728;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  v18 = 30725;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  v18 = 30726;
  heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  if ( !v25 )
  {
    v18 = 30722;
    heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, (tag_message *)&evt);
  }
  v14 = 0;
  v15 = (int)operator new(78);
  if ( v15 )
    v14 = textEntryWidget::textEntryWidget(
            v15,
            35,
            v11,
            251,
            20,
            a3,
            v6,
            "bigfont.fnt",
            0,
            "buybuild.icn",
            3,
            10,
            0,
            4,
            10,
            3);
  if ( !v14 )
    MemError();
  inBoxX = 213;
  inBoxY = v11 + 23;
  heroWindow::AddWidget((heroWindow *)DataEntryWin, (widget *)v14, -1);
  if ( a6 )
  {
    bDataEntryTime = 0;
    gbAllowTextEntryEscape = 0;
  }
  else
  {
    bDataEntryTime = 2;
  }
  heroWindowManager::DoDialog(
    gpWindowManager,
    (heroWindow *)DataEntryWin,
    (int (__fastcall *)(tag_message *))DataEntryWindowHandler,
    0);
  operator delete(DataEntryWin);
  mouseManager::SetPointer(gpMouseManager, byte_51F138, spriteIdx, protoCategory);
  gbAllowTextEntryEscape = 1;
}
// 4F199C: using guessed type int gbAllowTextEntryEscape;
// 532E5C: using guessed type int bDataEntryTime;
// 532E60: using guessed type int inBoxY;
// 532E64: using guessed type int inBoxX;
// 532E74: using guessed type int iDEMaxLen;

//----- (004CB280) --------------------------------------------------------
signed int __thiscall DataEntryWindowHandler(tag_message *evt)
{
  tag_message *v1; // esi@1
  signed int result; // eax@2
  int v3; // eax@6

  v1 = evt;
  if ( !bDataEntryTime )
  {
    ++bDataEntryTime;
    evt->eventCode = 8;
    evt->xCoordOrKeycode = inBoxX;
    evt->yCoordOrFieldID = inBoxY;
    heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, evt);
    return 1;
  }
  if ( bDataEntryTime == 1 )
  {
    ++bDataEntryTime;
LABEL_10:
    evt->eventCode = 512;
    evt->yCoordOrFieldID = 10;
    evt->xCoordOrKeycode = 7;
    heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, evt);
    if ( strlen((const char *)v1->payload) != 0 )
    {
      memset(cDEDest, 0, iDEMaxLen);
      strncpy(cDEDest, (const char *)v1->payload, iDEMaxLen - 1);
      v1->eventCode = 512;
      v1->xCoordOrKeycode = 3;
      v1->yCoordOrFieldID = 10;
      v1->payload = cDEDest;
      heroWindow::BroadcastMessage((heroWindow *)DataEntryWin, v1);
      heroWindow::DrawWindow((heroWindow *)DataEntryWin, 1, 10, 10);
      if ( !gbTextEntryEscaped )
      {
        gpWindowManager->buttonPressedCode = v1->yCoordOrFieldID;
        result = 2;
        v1->yCoordOrFieldID = 10;
        v1->xCoordOrKeycode = 10;
        return result;
      }
    }
    return EventWindowHandler(v1);
  }
  if ( evt->eventCode != 512 )
    return EventWindowHandler(v1);
  v3 = evt->xCoordOrKeycode;
  if ( v3 == 12 )
  {
    if ( evt->yCoordOrFieldID != 10 )
      return EventWindowHandler(v1);
    goto LABEL_10;
  }
  if ( v3 != 13 || evt->yCoordOrFieldID != 30722 )
    return EventWindowHandler(v1);
  result = 2;
  evt->yCoordOrFieldID = 10;
  evt->xCoordOrKeycode = 10;
  return result;
}
// 523ED0: using guessed type int gbTextEntryEscaped;
// 532E5C: using guessed type int bDataEntryTime;
// 532E60: using guessed type int inBoxY;
// 532E64: using guessed type int inBoxX;
// 532E74: using guessed type int iDEMaxLen;

//----- (004CB400) --------------------------------------------------------
baseManager *__thiscall baseManager::baseManager(baseManager *this)
{
  this->next = 0;
  this->prev = 0;
  this->vtable = &baseManager::_vftable_;
  this->idx = -1;
  this->type = -1;
  this->ready = 0;
  strcpy(this->name, "Unknown");
  return this;
}
// 4EAF18: using guessed type managerVtable baseManager___vftable_;

//----- (004CB450) --------------------------------------------------------
void __thiscall soundManager::MIDIStartup(soundManager *this)
{
  soundManager *thisa; // ebx@1
  int v2; // esi@3

  thisa = this;
  LogStr("MS1");
  if ( !gbNoSound )
  {
    LODWORD(thisa->field_6AA) = 1;
    if ( !gbDontTryMIDI )
    {
      LogStr("MS2");
      memset(pMIDIWrap, 0, 0xF0u);
      memset(&hSequence, 0, 0xF0u);
      thisa->usingRedbookRelated = 1;
      LogStr("MS6b");
      v2 = AIL_midiOutOpen(&hMDI, 0, -1);
      LogInt((int)"MS6c", v2, -999, -999, -999, -999, -999, -999);
      if ( v2 )
        thisa->usingRedbookRelated = 0;
    }
  }
}
// 4F1C94: using guessed type int gbDontTryMIDI;
// 523F24: using guessed type int gbNoSound;

//----- (004CB510) --------------------------------------------------------
void __thiscall soundManager::MIDIShutdown(soundManager *this)
{
  soundManager *thisa; // esi@1
  int v2; // eax@2
  struct _SEQUENCE *v3; // eax@10
  int v4; // eax@15
  resource *v5; // eax@15
  HSEQUENCE *v6; // edi@19
  resource **v7; // esi@23

  thisa = this;
  if ( !gbNoSound )
  {
    v2 = this->usingRedbookRelated;
    if ( v2 )
    {
      if ( !gbNoSound && v2 && CurrentMidiFile != -1 )
      {
        if ( !gbNoSound )
        {
          if ( *(_DWORD *)&Data )
          {
            if ( v2 )
            {
              if ( CurrentMidiFile != -1 )
              {
                v3 = *(&hSequence + CurrentMidiFile);
                if ( v3 )
                {
                  if ( AIL_sequence_status(v3) == 4 )
                  {
                    if ( *(&hSequence + CurrentMidiFile) )
                    {
                      AIL_stop_sequence(*(&hSequence + CurrentMidiFile));
                      if ( gbLowMemory || !*((_BYTE *)&bSaveMusicPosition + CurrentMidiFile) )
                      {
                        AIL_release_sequence_handle(*(&hSequence + CurrentMidiFile));
                        v4 = CurrentMidiFile;
                        *(HSEQUENCE *)((char *)&hSequence + v4 * 4) = 0;
                        v5 = (resource *)pMIDIWrap[v4];
                        if ( v5 )
                          resourceManager::Dispose(gpResourceManager, v5);
                        pMIDIWrap[CurrentMidiFile] = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        CurrentMidiFile = -1;
        thisa->currentTrack = -1;
      }
      v6 = &hSequence;
      LogStr("MS1");
      do
      {
        if ( *v6 )
          AIL_release_sequence_handle(*v6);
        *v6 = 0;
        ++v6;
      }
      while ( (unsigned int)v6 < (unsigned int)lastPositionZ );
      LogStr("MS2");
      AIL_midiOutClose(hMDI);
      hMDI = 0;
      thisa->usingRedbookRelated = 0;
      v7 = (resource **)pMIDIWrap;
      do
      {
        if ( *v7 )
          resourceManager::Dispose(gpResourceManager, *v7);
        *v7 = 0;
        ++v7;
      }
      while ( (unsigned int)v7 < (unsigned int)&hSequence );
      LogStr("MS4");
    }
  }
}
// 4F74A8: using guessed type int gbLowMemory;
// 51F14C: using guessed type int CurrentMidiFile;
// 523F24: using guessed type int gbNoSound;

//----- (004CB6C0) --------------------------------------------------------
void __thiscall soundManager::MIDIPlay(soundManager *this, signed int track)
{
  soundManager *thisa; // esi@1
  signed int seqIdx; // ebx@4
  int v4; // eax@8
  struct _SEQUENCE *v5; // eax@14
  int v6; // eax@19
  resource *v7; // eax@19
  int v8; // eax@25
  struct _SEQUENCE *v9; // eax@31
  int v10; // eax@36
  resource *v11; // eax@36
  struct _SEQUENCE *v12; // eax@41
  MIDIWrap *seq; // eax@43
  struct _SEQUENCE *v14; // edx@43
  signed int v15; // eax@46
  signed int v16; // ecx@46
  signed int v17; // eax@48
  signed int v18; // ecx@48
  signed __int32 volume; // eax@51
  char buf[1]; // [sp+Ch] [bp-10h]@40

  thisa = this;
  if ( gbNoSound || !this->usingRedbookRelated || !*(_DWORD *)&Data )
    return;
  LogStr("MP1a");
  seqIdx = track;
  if ( !bGotMidi[track] )
    seqIdx = -1;
  if ( seqIdx == -1 )
  {
    if ( !gbNoSound )
    {
      v4 = thisa->usingRedbookRelated;
      if ( v4 )
      {
        if ( CurrentMidiFile != -1 )
        {
          if ( !gbNoSound )
          {
            if ( *(_DWORD *)&Data )
            {
              if ( v4 )
              {
                if ( CurrentMidiFile != -1 )
                {
                  v5 = *(&hSequence + CurrentMidiFile);
                  if ( v5 )
                  {
                    if ( AIL_sequence_status(v5) == 4 )
                    {
                      if ( *(&hSequence + CurrentMidiFile) )
                      {
                        AIL_stop_sequence(*(&hSequence + CurrentMidiFile));
                        if ( gbLowMemory || !*((_BYTE *)&bSaveMusicPosition + CurrentMidiFile) )
                        {
                          AIL_release_sequence_handle(*(&hSequence + CurrentMidiFile));
                          v6 = CurrentMidiFile;
                          *(HSEQUENCE *)((char *)&hSequence + v6 * 4) = 0;
                          v7 = (resource *)pMIDIWrap[v6];
                          if ( v7 )
                            resourceManager::Dispose(gpResourceManager, v7);
                          pMIDIWrap[CurrentMidiFile] = 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          CurrentMidiFile = -1;
          thisa->currentTrack = -1;
        }
      }
    }
    return;
  }
  if ( CurrentMidiFile == seqIdx )
    return;
  if ( !gbNoSound )
  {
    v8 = thisa->usingRedbookRelated;
    if ( v8 )
    {
      if ( CurrentMidiFile != -1 )
      {
        if ( !gbNoSound )
        {
          if ( *(_DWORD *)&Data )
          {
            if ( v8 )
            {
              if ( CurrentMidiFile != -1 )
              {
                v9 = *(&hSequence + CurrentMidiFile);
                if ( v9 )
                {
                  if ( AIL_sequence_status(v9) == 4 )
                  {
                    if ( *(&hSequence + CurrentMidiFile) )
                    {
                      AIL_stop_sequence(*(&hSequence + CurrentMidiFile));
                      if ( gbLowMemory || !*((_BYTE *)&bSaveMusicPosition + CurrentMidiFile) )
                      {
                        AIL_release_sequence_handle(*(&hSequence + CurrentMidiFile));
                        v10 = CurrentMidiFile;
                        *(HSEQUENCE *)((char *)&hSequence + v10 * 4) = 0;
                        v11 = (resource *)pMIDIWrap[v10];
                        if ( v11 )
                          resourceManager::Dispose(gpResourceManager, v11);
                        pMIDIWrap[CurrentMidiFile] = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        CurrentMidiFile = -1;
        thisa->currentTrack = -1;
      }
    }
  }
  sprintf(buf, "MIDI%04d.XMI", seqIdx);
  if ( *(&hSequence + seqIdx) )
  {
    AIL_resume_sequence(*(&hSequence + seqIdx));
LABEL_56:
    CurrentMidiFile = seqIdx;
    thisa->currentTrack = seqIdx;
    return;
  }
  v12 = AIL_allocate_sequence_handle(hMDI);
  *(&hSequence + seqIdx) = v12;
  if ( !v12 )
    soundManager::MIDIShutdown(thisa);
  seq = resourceManager::GetMIDIWrap(gpResourceManager, buf);
  v14 = *(&hSequence + seqIdx);
  pMIDIWrap[seqIdx] = seq;
  if ( AIL_init_sequence(v14, seq->contents, 0) )
  {
    if ( !gbNoSound && thisa->usingRedbookRelated )
    {
      v15 = 127;
      v16 = thisa->volRelated;
      if ( v16 > 0 )
      {
        if ( v16 > 10 )
        {
          v17 = 127 * (v16 - 10);
          v18 = 6;
        }
        else
        {
          v17 = 127 * (11 - v16);
          v18 = 11;
        }
        v15 = v17 / v18;
      }
      volume = soundManager::ConvertVolume(v15, 101);
      AIL_set_XMIDI_master_volume(hMDI, volume);
    }
    AIL_start_sequence(*(&hSequence + seqIdx));
    if ( bMusicIsLooping[seqIdx] )
      AIL_set_sequence_loop_count(*(&hSequence + seqIdx), 0);
    else
      AIL_set_sequence_loop_count(*(&hSequence + seqIdx), 1);
    goto LABEL_56;
  }
}
// 4F74A8: using guessed type int gbLowMemory;
// 51F14C: using guessed type int CurrentMidiFile;
// 523F24: using guessed type int gbNoSound;

//----- (004CBA70) --------------------------------------------------------
signed int __thiscall soundManager::MIDIStop(int this)
{
  signed int result; // eax@1
  int v2; // esi@1
  struct _SEQUENCE *v3; // eax@8
  int v4; // eax@13
  resource *v5; // eax@13

  result = gbNoSound;
  v2 = this;
  if ( !gbNoSound )
  {
    result = *(_DWORD *)(this + 1698);
    if ( result )
    {
      if ( CurrentMidiFile != -1 )
      {
        if ( !gbNoSound )
        {
          if ( *(_DWORD *)&Data )
          {
            if ( result )
            {
              if ( CurrentMidiFile != -1 )
              {
                v3 = *(&hSequence + CurrentMidiFile);
                if ( v3 )
                {
                  if ( AIL_sequence_status(v3) == 4 )
                  {
                    if ( *(&hSequence + CurrentMidiFile) )
                    {
                      AIL_stop_sequence(*(&hSequence + CurrentMidiFile));
                      if ( gbLowMemory || !*((_BYTE *)&bSaveMusicPosition + CurrentMidiFile) )
                      {
                        AIL_release_sequence_handle(*(&hSequence + CurrentMidiFile));
                        v4 = CurrentMidiFile;
                        *(HSEQUENCE *)((char *)&hSequence + v4 * 4) = 0;
                        v5 = (resource *)pMIDIWrap[v4];
                        if ( v5 )
                          resourceManager::Dispose(gpResourceManager, v5);
                        pMIDIWrap[CurrentMidiFile] = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        result = -1;
        CurrentMidiFile = -1;
        *(_BYTE *)(v2 + 1404) = -1;
      }
    }
  }
  return result;
}
// 4F74A8: using guessed type int gbLowMemory;
// 51F14C: using guessed type int CurrentMidiFile;
// 523F24: using guessed type int gbNoSound;

//----- (004CBB80) --------------------------------------------------------
bool __thiscall soundManager::MIDIIsPlaying(soundManager *this)
{
  struct _SEQUENCE *v1; // eax@5
  bool result; // eax@6

  if ( !gbNoSound
    && *(_DWORD *)&Data
    && this->usingRedbookRelated
    && CurrentMidiFile != -1
    && (v1 = *(&hSequence + CurrentMidiFile)) != 0 )
    result = AIL_sequence_status(v1) == 4;
  else
    result = 0;
  return result;
}
// 51F14C: using guessed type int CurrentMidiFile;
// 523F24: using guessed type int gbNoSound;

//----- (004CBBD0) --------------------------------------------------------
void __thiscall soundManager::MIDISetVolume(soundManager *this)
{
  signed int v1; // eax@3
  int v2; // edx@3
  signed int v3; // esi@5
  signed int v4; // eax@5
  signed __int32 v5; // eax@8

  if ( !gbNoSound && this->usingRedbookRelated )
  {
    v1 = 127;
    v2 = this->volRelated;
    if ( v2 > 0 )
    {
      if ( v2 > 10 )
      {
        v3 = 6;
        v4 = 127 * (v2 - 10);
      }
      else
      {
        v3 = 11;
        v4 = 127 * (11 - v2);
      }
      v1 = v4 / v3;
    }
    v5 = soundManager::ConvertVolume(v1, 101);
    AIL_set_XMIDI_master_volume(hMDI, v5);
  }
}
// 523F24: using guessed type int gbNoSound;

//----- (004CBC40) --------------------------------------------------------
heroWindow *__thiscall heroWindow::heroWindow(heroWindow *this, int x, int y, int width, int height, int flags)
{
  heroWindow *thisa; // ST14_4@1

  thisa = this;
  strcpy(this->filename, "Dynamic Construct");
  thisa->prevWindow = 0;
  thisa->nextWindow = thisa->prevWindow;
  thisa->idx = -1;
  thisa->xOffset = x;
  thisa->yOffset = y;
  thisa->width = width;
  thisa->height = height;
  thisa->flags1 = flags;
  thisa->flags2 = 0;
  thisa->firstWidget = 0;
  thisa->lastWidget = thisa->firstWidget;
  thisa->bitmap = 0;
  return thisa;
}

//----- (004CBCF0) --------------------------------------------------------
heroWindow *__thiscall heroWindow::heroWindow(heroWindow *ecx0, int xOff, int yOff, char *filnam)
{
  int fileID; // ST78_4@1
  __int16 code; // ax@3
  listBox *v8; // [sp+14h] [bp-60h]@49
  int v9; // [sp+18h] [bp-5Ch]@45
  int v10; // [sp+1Ch] [bp-58h]@41
  int v11; // [sp+20h] [bp-54h]@37
  int v12; // [sp+24h] [bp-50h]@33
  int v13; // [sp+28h] [bp-4Ch]@29
  int v14; // [sp+2Ch] [bp-48h]@25
  textWidget *v15; // [sp+30h] [bp-44h]@21
  int v16; // [sp+34h] [bp-40h]@17
  iconWidget *v17; // [sp+38h] [bp-3Ch]@13
  button *v18; // [sp+3Ch] [bp-38h]@9
  border *this; // [sp+40h] [bp-34h]@5
  widget *guiObj; // [sp+44h] [bp-30h]@3
  textWidget *v21; // [sp+48h] [bp-2Ch]@22
  textEntryWidget *v22; // [sp+4Ch] [bp-28h]@26
  textEntryWidget *v23; // [sp+4Ch] [bp-28h]@30
  textEntryWidget *v24; // [sp+4Ch] [bp-28h]@34
  textEntryWidget *v25; // [sp+4Ch] [bp-28h]@38
  textEntryWidget *v26; // [sp+4Ch] [bp-28h]@42
  iconWidget *icn; // [sp+50h] [bp-24h]@14
  button *v28; // [sp+54h] [bp-20h]@10
  int v29; // [sp+58h] [bp-1Ch]@46
  border *bg; // [sp+5Ch] [bp-18h]@6
  int v31; // [sp+64h] [bp-10h]@18
  listBox *v32; // [sp+68h] [bp-Ch]@50
  signed int done; // [sp+6Ch] [bp-8h]@1

  strcpy(ecx0->filename, filnam);
  fileID = resourceManager::MakeId(gpResourceManager, filnam, 1);
  resourceManager::PointToFile(gpResourceManager, fileID);
  ecx0->bitmap = NULL;
  ecx0->prevWindow = NULL;
  ecx0->nextWindow = ecx0->prevWindow;
  ecx0->flags2 = 0;
  ecx0->idx = -1;
  ecx0->xOffset = xOff;
  ecx0->yOffset = yOff;
  ecx0->width = resourceManager::ReadWord(gpResourceManager);
  ecx0->height = resourceManager::ReadWord(gpResourceManager);
  ecx0->flags1 = resourceManager::ReadWord(gpResourceManager);
  ecx0->flags1 |= 0x4000u;
  ecx0->firstWidget = NULL;
  ecx0->lastWidget = ecx0->firstWidget;
  done = 0;
  while ( !done )
  {
    PollSound();
    code = resourceManager::ReadWord(gpResourceManager);
    guiObj = 0;
    if ( code > 8 )
    {
      if ( code > 64 )
      {
        if ( code > 513 )
        {
          switch ( code )
          {
            case 514:
              v12 = (int)operator new(sizeof(textEntryWidget));
              if ( v12 )
                v24 = textEntryWidget::textEntryWidget(v12);
              else
                v24 = 0;
              textEntryWidget::Read(v24, 3);
              guiObj = (widget *)v24;
              break;
            case 516:
              v11 = (int)operator new(78);
              if ( v11 )
                v25 = textEntryWidget::textEntryWidget(v11);
              else
                v25 = 0;
              textEntryWidget::Read(v25, 4);
              guiObj = (widget *)v25;
              break;
            case 518:
              v10 = (int)operator new(78);
              if ( v10 )
                v26 = textEntryWidget::textEntryWidget(v10);
              else
                v26 = 0;
              textEntryWidget::Read(v26, 5);
              guiObj = (widget *)v26;
              break;
            case 515:
              v9 = (int)operator new(180);
              if ( v9 )
                v29 = dropListWidget::dropListWidget(v9);
              else
                v29 = 0;
              dropListWidget::Read(v29);
              guiObj = (widget *)v29;
              break;
            case 517:
              v8 = (listBox *)operator new(146);
              if ( v8 )
                v32 = listBoxWidget::listBoxWidget(v8);
              else
                v32 = 0;
              listBoxWidget::Read(v32);
              guiObj = (widget *)v32;
              break;
            default:
              break;
          }
        }
        else if ( code == 513 )
        {
          v13 = (int)operator new(sizeof(textEntryWidget));
          if ( v13 )
            v23 = textEntryWidget::textEntryWidget(v13);
          else
            v23 = 0;
          textEntryWidget::Read(v23, 2);
          guiObj = (widget *)v23;
        }
        else if ( code == 256 )
        {
          v14 = (int)operator new(sizeof(textEntryWidget));
          if ( v14 )
            v22 = textEntryWidget::textEntryWidget(v14);
          else
            v22 = 0;
          textEntryWidget::Read(v22, 1);
          guiObj = (widget *)v22;
        }
      }
      else if ( code == 64 )
      {
        v16 = (int)operator new(32);
        if ( v16 )
          v31 = dimmerWidget::dimmerWidget(v16);
        else
          v31 = 0;
        dimmerWidget::Read(v31);
        guiObj = (widget *)v31;
      }
      else if ( code == 16 )
      {
        v17 = (iconWidget *)operator new(0x2Du);
        if ( v17 )
          icn = iconWidget::iconWidget(v17);
        else
          icn = 0;
        iconWidget::Read(icn);
        guiObj = (widget *)icn;
      }
    }
    else if ( code == 8 )
    {
      v15 = (textWidget *)operator new(43);
      if ( v15 )
        v21 = textWidget::textWidget(v15);
      else
        v21 = 0;
      textWidget::Read(v21);
      guiObj = (widget *)v21;
    }
    else if ( code )
    {
      if ( code == 1 )
      {
        this = (border *)operator new(42);
        if ( this )
          bg = border::border(this);
        else
          bg = 0;
        border::Read(bg);
        guiObj = (widget *)bg;
      }
      else if ( code == 2 )
      {
        v18 = (button *)operator new(48);
        if ( v18 )
          v28 = button::button(v18);
        else
          v28 = 0;
        button::Read(v28);
        guiObj = (widget *)v28;
      }
    }
    else
    {
      done = 1;
    }
    if ( !done )
    {
      if ( guiObj )
        heroWindow::AddWidget(ecx0, guiObj, -1);
    }
  }
  return ecx0;
}

//----- (004CC220) --------------------------------------------------------
signed int __thiscall heroWindow::Open(heroWindow *this, int idx, int redraw)
{
  signed int result; // eax@2
  heroWindow *thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  if ( this->flags2 & 1 )
  {
    result = 3;
  }
  else if ( this->flags1 & 2 && heroWindow::SaveBackground(this) )
  {
    result = 3;
  }
  else
  {
    thisa->idx = idx;
    heroWindow::DrawWindow(thisa, redraw);
    thisa->flags2 |= 1u;
    result = 0;
  }
  return result;
}

//----- (004CC2A0) --------------------------------------------------------
void __thiscall heroWindow::RemoveAndDeleteWidget(heroWindow *this, int id)
{
  heroWindow *thisa; // [sp+Ch] [bp-14h]@1
  widget *next; // [sp+18h] [bp-8h]@3
  widget *cur; // [sp+1Ch] [bp-4h]@1

  thisa = this;
  for ( cur = this->firstWidget; cur; cur = next )
  {
    next = cur->nextInLinkedList;
    if ( cur->fieldID == id )
    {
      heroWindow::RemoveWidget(thisa, cur);
      if ( BYTE1(thisa->flags1) & 0x40 )
      {
        if ( cur )
          cur->vtable->cleanUp(cur, 1);
      }
    }
  }
}

//----- (004CC330) --------------------------------------------------------
heroWindow *__thiscall heroWindow::Close(heroWindow *this)
{
  heroWindow *result; // eax@10
  heroWindow *thisa; // [sp+Ch] [bp-14h]@1
  widget *next; // [sp+18h] [bp-8h]@6
  widget *cur; // [sp+1Ch] [bp-4h]@4

  thisa = this;
  if ( this->flags1 & 2 && this->flags2 & 1 )
    heroWindow::RestoreBackground(this);
  for ( cur = thisa->firstWidget; cur; cur = next )
  {
    next = cur->nextInLinkedList;
    heroWindow::RemoveWidget(thisa, cur);
    if ( BYTE1(thisa->flags1) & 0x40 )
    {
      if ( cur )
        ((void (__thiscall *)(_DWORD))cur->vtable->cleanUp)(cur);
    }
  }
  result = thisa;
  thisa->flags2 = 0;
  return result;
}

//----- (004CC3E0) --------------------------------------------------------
void __thiscall heroWindow::AddWidget(heroWindow *this, widget *guiObj, int index)
{
  heroWindow *thisa; // [sp+Ch] [bp-8h]@1
  widget *component; // [sp+10h] [bp-4h]@1

  thisa = this;
  component = this->firstWidget;
  if ( index == -1 )
  {
    if ( component )
      index = component->componentIndex + 1;
    else
      index = 0;
  }
  if ( !widget::Open(guiObj, index, this) )
  {
    while ( component && component->componentIndex > index )
      component = component->nextInLinkedList;
    if ( component )
    {
      if ( component->prevInLinkedList )
      {
        guiObj->nextInLinkedList = component;
        guiObj->prevInLinkedList = component->prevInLinkedList;
        component->prevInLinkedList->nextInLinkedList = guiObj;
        component->prevInLinkedList = guiObj;
      }
      else
      {
        guiObj->nextInLinkedList = thisa->firstWidget;
        guiObj->prevInLinkedList = NULL;
        thisa->firstWidget->prevInLinkedList = guiObj;
        thisa->firstWidget = guiObj;
      }
    }
    else
    {
      guiObj->prevInLinkedList = thisa->lastWidget;
      guiObj->nextInLinkedList = NULL;
      thisa->lastWidget = guiObj;
      if ( !thisa->firstWidget )
        thisa->firstWidget = guiObj;
    }
  }
}

//----- (004CC520) --------------------------------------------------------
void __thiscall heroWindow::RemoveWidget(heroWindow *this, widget *comp)
{
  heroWindow *thisa; // [sp+Ch] [bp-8h]@1
  widget *v3; // [sp+10h] [bp-4h]@10

  thisa = this;
  if ( comp )
  {
    widget::Close();
    if ( thisa->lastWidget == comp )
    {
      thisa->lastWidget = comp->prevInLinkedList;
      if ( thisa->lastWidget )
        thisa->lastWidget->nextInLinkedList = 0;
      else
        thisa->firstWidget = 0;
    }
    else if ( thisa->firstWidget == comp )
    {
      thisa->firstWidget = comp->nextInLinkedList;
      thisa->firstWidget->prevInLinkedList = 0;
    }
    else
    {
      comp->nextInLinkedList->prevInLinkedList = comp->prevInLinkedList;
      comp->prevInLinkedList->nextInLinkedList = comp->nextInLinkedList;
    }
    v3 = comp->nextInLinkedList;
    if ( v3 )
    {
      v3->prevInLinkedList = comp->prevInLinkedList;
      if ( v3->prevInLinkedList )
        v3->prevInLinkedList->nextInLinkedList = v3;
    }
    else
    {
      thisa->firstWidget = 0;
      thisa->lastWidget = thisa->firstWidget;
    }
  }
}

//----- (004CC640) --------------------------------------------------------
int __thiscall heroWindow::BroadcastMessage(heroWindow *this, tag_message *evt)
{
  widget *guiComp; // [sp+14h] [bp-8h]@1
  int v4; // [sp+18h] [bp-4h]@1

  v4 = 0;
  for ( guiComp = this->firstWidget; guiComp; guiComp = guiComp->nextInLinkedList )
  {
    v4 = guiComp->vtable->handleEvent(guiComp, evt);
    if ( v4 && v4 >= 1 && v4 <= 2 )
      return v4;
  }
  return v4;
}

//----- (004CC6E0) --------------------------------------------------------
void __thiscall heroWindow::DrawWindow(heroWindow *this)
{
  heroWindow::DrawWindow(this, 1);
}

//----- (004CC700) --------------------------------------------------------
void __thiscall heroWindow::DrawWindow(heroWindow *this, int updateScreen)
{
  heroWindow::DrawWindow(this, updateScreen, -65535, 65535);
}

//----- (004CC730) --------------------------------------------------------
void __thiscall heroWindow::DrawWindow(heroWindow *this, int updateScreen, signed int lowID, signed int highID)
{
  heroWindow *thisa; // [sp+Ch] [bp-24h]@1
  tag_message evt; // [sp+10h] [bp-20h]@1
  widget *comp; // [sp+2Ch] [bp-4h]@1

  thisa = this;
  gpMouseManager->couldBeShowMouse = 0;
  comp = this->lastWidget;
  evt.eventCode = INPUT_GUI_MESSAGE_CODE;
  evt.xCoordOrKeycode = 2;
  while ( comp )
  {
    PollSound();
    if ( lowID == -65535 && highID == 65535 )
    {
      comp->vtable->handleEvent(comp, &evt);
    }
    else if ( comp->fieldID >= lowID )
    {
      if ( comp->fieldID <= highID )
        comp->vtable->handleEvent(comp, &evt);
    }
    comp = comp->prevInLinkedList;
  }
  PollSound();
  if ( updateScreen && (thisa->flags1 & 0x7FFF) != 1 )
  {
    heroWindowManager::UpdateScreenRegion(gpWindowManager, thisa->xOffset, thisa->yOffset, thisa->width, thisa->height);
    PollSound();
  }
  gpMouseManager->couldBeShowMouse = 1;
}

//----- (004CC850) --------------------------------------------------------
int __thiscall heroWindow::SaveBackground(heroWindow *this)
{
  heroWindow *thisa; // [sp+Ch] [bp-8h]@1
  bitmap *bmp; // [sp+10h] [bp-4h]@1

  thisa = this;
  bmp = (bitmap *)operator new(26);
  if ( bmp )
    thisa->bitmap = bitmap::bitmap(bmp, 33, thisa->width, thisa->height);
  else
    thisa->bitmap = 0;
  PollSound();
  bitmap::GrabScreen(thisa->bitmap, thisa->xOffset, thisa->yOffset);
  PollSound();
  return 0;
}

//----- (004CC8D0) --------------------------------------------------------
heroWindow *__thiscall heroWindow::RestoreBackground(heroWindow *this)
{
  heroWindow *result; // eax@5
  heroWindow *thisa; // [sp+Ch] [bp-Ch]@1
  bitmap *bmp; // [sp+14h] [bp-4h]@3

  thisa = this;
  if ( gbDrawWindowBackground )
  {
    bitmap::DrawToBuffer(this->bitmap, this->xOffset, this->yOffset);
    heroWindowManager::UpdateScreenRegion(gpWindowManager, thisa->xOffset, thisa->yOffset, thisa->width, thisa->height);
  }
  bmp = thisa->bitmap;
  if ( bmp )
    ((void (__thiscall *)(_DWORD))bmp->vtable->scalarDeletingDestructor)(bmp);
  result = thisa;
  thisa->bitmap = NULL;
  return result;
}
// 4F1CC4: using guessed type int gbDrawWindowBackground;

//----- (004CC970) --------------------------------------------------------
void __thiscall heroWindow::MoveWindow(heroWindow *this, int deltaX, int deltaY)
{
  heroWindow *thisa; // [sp+Ch] [bp-1Ch]@1
  int width; // [sp+10h] [bp-18h]@1
  unsigned int widtha; // [sp+10h] [bp-18h]@9
  int oldY; // [sp+14h] [bp-14h]@1
  int oldX; // [sp+18h] [bp-10h]@1
  int height; // [sp+1Ch] [bp-Ch]@1
  int heighta; // [sp+1Ch] [bp-Ch]@9
  int newY; // [sp+20h] [bp-8h]@1
  int newX; // [sp+24h] [bp-4h]@1

  thisa = this;
  oldX = this->xOffset;
  oldY = this->yOffset;
  width = this->width;
  height = this->height;
  newX = deltaX + this->xOffset;
  newY = deltaY + this->yOffset;
  if ( newX < 0 )
    newX = 0;
  if ( newY < 0 )
    newY = 0;
  if ( newX + this->width > 640 )
    newX = 640 - this->width;
  if ( newY + this->height > 480 )
    newY = 480 - this->height;
  bitmap::DrawToBuffer(this->bitmap, this->xOffset, this->yOffset);
  thisa->xOffset = newX;
  thisa->yOffset = newY;
  bitmap::GrabBitmap(thisa->bitmap, gpWindowManager->screenBuffer, thisa->xOffset, thisa->yOffset);
  heroWindow::DrawWindow(thisa, 0);
  widtha = abs(thisa->xOffset - oldX) + width;
  heighta = abs(thisa->yOffset - oldY) + height;
  if ( thisa->xOffset < oldX )
    oldX = thisa->xOffset;
  if ( thisa->yOffset < oldY )
    oldY = thisa->yOffset;
  heroWindowManager::UpdateScreenRegion(gpWindowManager, oldX, oldY, widtha, heighta);
}

//----- (004CCB00) --------------------------------------------------------
resourceManager *__thiscall resourceManager::resourceManager(resourceManager *this)
{
  int i; // [sp+10h] [bp-4h]@1

  baseManager::baseManager((baseManager *)this);
  this->vtable = &resourceManager::_vftable_;
  this->ready = 0;
  this->firstLoadedResource = NULL;
  this->expunging = 0;
  strcpy(this->resourceToLoad, unk_51F1F8);
  this->fileID = 0;
  for ( i = 0; i < NUM_AGG_FILES; ++i )
  {
    this->fileDescriptors[i] = -1;
    this->aggContentInfo[i] = NULL;
    this->numberOfFilesInAGG[i] = 0;
  }
  this->numOpenAGGFiles = 0;
  this->curHandleIdx = 0;
  return this;
}
// 4EAF28: using guessed type managerVtable resourceManager___vftable_;

//----- (004CCBE0) --------------------------------------------------------
void __thiscall resourceManager::GetBackdrop(resourceManager *this, const char *filename, bitmap *screenBuf, int isICN)
{
  icon *icn; // ST20_4@2
  unsigned int bmpHash; // eax@3

  if ( isICN )
  {
    icn = resourceManager::GetIcon(this, filename);
    icon::DrawToBuffer(icn, 0, 0, 0, 0);
    resourceManager::Dispose(this, (resource *)icn);
  }
  else
  {
    bmpHash = resourceManager::MakeId(this, filename, 1);
    resourceManager::PointToFile(this, bmpHash);
    resourceManager::ReadWord(this);
    resourceManager::ReadWord(this);
    resourceManager::ReadWord(this);
    resourceManager::ReadBlock(this, screenBuf->contents, screenBuf->width * screenBuf->height);
  }
}

//----- (004CCC90) --------------------------------------------------------
resource *__thiscall resourceManager::GetPalette(resourceManager *this, char *filename)
{
  palette *pal; // eax@2 MAPDST
  unsigned int fileID; // [sp+14h] [bp-8h]@1

  fileID = resourceManager::MakeId(this, filename, 1);
  pal = (palette *)resourceManager::Query(this, fileID);
  if ( pal )
  {
    ++pal->referenceCount;
  }
  else
  {
    pal = (palette *)operator new(sizeof(palette));
    if ( pal )
      pal = palette::palette(pal, fileID);
    else
      pal = NULL;
    resourceManager::AddResource(this, (resource *)pal);
  }
  return (resource *)pal;
}

//----- (004CCD30) --------------------------------------------------------
bitmap *__thiscall resourceManager::GetBitmap(resourceManager *this, const char *filename)
{
  bitmap *result; // eax@2
  bitmap *newBitmapMem; // [sp+10h] [bp-Ch]@3
  bitmap *loadedBmp; // [sp+14h] [bp-8h]@1
  bitmap *newBitmap; // [sp+14h] [bp-8h]@4
  unsigned int hash; // [sp+18h] [bp-4h]@1

  hash = resourceManager::MakeId(this, filename, 1);
  loadedBmp = (bitmap *)resourceManager::Query(this, hash);
  if ( loadedBmp )
  {
    ++loadedBmp->referenceCount;
    result = loadedBmp;
  }
  else
  {
    newBitmapMem = (bitmap *)operator new(sizeof(bitmap));
    if ( newBitmapMem )
      newBitmap = bitmap::bitmap(newBitmapMem, hash);
    else
      newBitmap = NULL;
    resourceManager::AddResource(this, (resource *)newBitmap);
    result = newBitmap;
  }
  return result;
}

//----- (004CCDD0) --------------------------------------------------------
icon *__thiscall resourceManager::GetIcon(resourceManager *this, const char *filename)
{
  unsigned int hash; // eax@1

  hash = resourceManager::MakeId(this, filename, 1);
  return resourceManager::GetIcon(this, hash);
}

//----- (004CCE00) --------------------------------------------------------
icon *__thiscall resourceManager::GetIcon(resourceManager *this, int fileID)
{
  icon *icn; // eax@2 MAPDST

  icn = (icon *)resourceManager::Query(this, fileID);
  if ( icn )
  {
    ++icn->referenceCount;
  }
  else
  {
    icn = (icon *)operator new(sizeof(icon));
    if ( icn )
      icn = icon::icon(icn, fileID);
    else
      icn = NULL;
    resourceManager::AddResource(this, (resource *)icn);
  }
  return icn;
}

//----- (004CCE90) --------------------------------------------------------
tileset *__thiscall resourceManager::GetTileset(resourceManager *this, const char *filename)
{
  tileset *tiles; // eax@2 MAPDST
  unsigned int hash; // [sp+14h] [bp-8h]@1

  hash = resourceManager::MakeId(this, filename, 1);
  tiles = (tileset *)resourceManager::Query(this, hash);
  if ( tiles )
  {
    ++tiles->referenceCount;
  }
  else
  {
    tiles = (tileset *)operator new(sizeof(tileset));
    if ( tiles )
      tiles = tileset::tileset(tiles, hash);
    else
      tiles = NULL;
    resourceManager::AddResource(this, (resource *)tiles);
  }
  return tiles;
}

//----- (004CCF30) --------------------------------------------------------
font *__thiscall resourceManager::GetFont(resourceManager *this, const char *filename)
{
  font *result; // eax@2
  font *newFontMem; // [sp+10h] [bp-Ch]@3
  font *loadedFont; // [sp+14h] [bp-8h]@1
  font *newFont; // [sp+14h] [bp-8h]@4
  unsigned int hash; // [sp+18h] [bp-4h]@1

  hash = resourceManager::MakeId(this, filename, 1);
  loadedFont = (font *)resourceManager::Query(this, hash);
  if ( loadedFont )
  {
    ++loadedFont->referenceCount;
    result = loadedFont;
  }
  else
  {
    newFontMem = (font *)operator new(sizeof(font));
    if ( newFontMem )
      newFont = font::font(newFontMem, hash);
    else
      newFont = 0;
    resourceManager::AddResource(this, (resource *)newFont);
    result = newFont;
  }
  return result;
}

//----- (004CCFD0) --------------------------------------------------------
sample *__thiscall resourceManager::GetSample(resourceManager *this, const char *filename)
{
  unsigned int hash; // ST28_4@1
  sample *sample; // eax@2 MAPDST

  hash = resourceManager::MakeId(this, filename, 1);
  sample = (sample *)resourceManager::Query(this, hash);
  if ( sample )
  {
    ++sample->referenceCount;
  }
  else
  {
    sample = (sample *)operator new(sizeof(sample));
    if ( sample )
      sample = sample::sample(sample, filename, 0, 127, 1);
    else
      sample = NULL;
    resourceManager::AddResource(this, (resource *)sample);
  }
  return sample;
}

//----- (004CD070) --------------------------------------------------------
MIDIWrap *__thiscall resourceManager::GetMIDIWrap(resourceManager *this, const char *filename)
{
  unsigned int hash; // ST20_4@1
  MIDIWrap *sequence; // eax@2 MAPDST

  hash = resourceManager::MakeId(this, filename, 1);
  sequence = (MIDIWrap *)resourceManager::Query(this, hash);
  if ( sequence )
  {
    ++sequence->referenceCount;
  }
  else
  {
    sequence = (MIDIWrap *)operator new(sizeof(MIDIWrap));
    if ( sequence )
      sequence = MIDIWrap::MIDIWrap(sequence, filename);
    else
      sequence = NULL;
    resourceManager::AddResource(this, (resource *)sequence);
  }
  return sequence;
}

//----- (004CD110) --------------------------------------------------------
void __thiscall resourceManager::Dispose(resourceManager *this, resource *res)
{
  if ( !this->expunging )
  {
    if ( res )
    {
      --res->referenceCount;
      if ( res->referenceCount <= 0 )
      {
        resourceManager::RemoveResource(this, res);
        if ( res )
          res->vtable->scalarDeletingDestructor(res, 1);
      }
    }
  }
}

//----- (004CD1A0) --------------------------------------------------------
void __thiscall resourceManager::AddResource(resourceManager *this, resource *res)
{
  if ( this->firstLoadedResource )
  {
    res->next = this->firstLoadedResource;
    this->firstLoadedResource = res;
  }
  else
  {
    this->firstLoadedResource = res;
    this->firstLoadedResource->next = NULL;
  }
}

//----- (004CD200) --------------------------------------------------------
void __thiscall resourceManager::Expunge(resourceManager *this)
{
  resource *fil; // [sp+18h] [bp-8h]@1
  resource *next; // [sp+1Ch] [bp-4h]@3

  this->expunging = 1;
  for ( fil = this->firstLoadedResource; fil; fil = next )
  {
    next = fil->next;
    resourceManager::RemoveResource(this, fil);
    if ( fil )
      fil->vtable->scalarDeletingDestructor(fil, 1);
  }
  this->expunging = 0;
}

//----- (004CD290) --------------------------------------------------------
resource *__thiscall resourceManager::Query(resourceManager *this, unsigned int hash)
{
  resource *cur; // [sp+10h] [bp-4h]@1

  for ( cur = this->firstLoadedResource; cur && cur->fileID != hash; cur = cur->next )
    ;
  return cur;
}

//----- (004CD2E0) --------------------------------------------------------
int __thiscall resourceManager::Main(resourceManager *this, tag_message *a1)
{
  return MANAGER_SUCCESS;
}

//----- (004CD300) --------------------------------------------------------
MANAGER_RETURN_CODE __thiscall resourceManager::Open(resourceManager *this, int idx)
{
  MANAGER_RETURN_CODE result; // eax@2

  if ( resourceManager::LoadAggregateHeader(this, EXPANSION_AGGREGATE_NAME) )
  {
    result = MANAGER_FAILED;
  }
  else if ( resourceManager::LoadAggregateHeader(this, DEFAULT_AGGREGATE_NAME) )
  {
    result = MANAGER_FAILED;
  }
  else
  {
    this->type = MANAGER_TYPE_RESOURCE_MAMANGER;
    this->idx = idx;
    this->ready = 1;
    strcpy(this->name, "resourceManager");
    this->firstLoadedResource = NULL;
    result = MANAGER_SUCCESS;
  }
  return result;
}

//----- (004CD3B0) --------------------------------------------------------
void __thiscall resourceManager::RemoveResource(resourceManager *this, resource *res)
{
  resource *cur; // [sp+10h] [bp-4h]@3

  if ( this->firstLoadedResource == res )
  {
    this->firstLoadedResource = res->next;
  }
  else
  {
    for ( cur = this->firstLoadedResource; cur && cur->next != res; cur = cur->next )
      ;
    if ( cur )
      cur->next = res->next;
  }
}

//----- (004CD440) --------------------------------------------------------
void __thiscall resourceManager::Close(resourceManager *this)
{
  int i; // [sp+10h] [bp-4h]@2

  if ( this->ready == 1 )
  {
    resourceManager::Expunge(this);
    this->firstLoadedResource = 0;
    for ( i = 0; i < NUM_AGG_FILES; ++i )
    {
      if ( this->aggContentInfo[i] )
        BaseFree(this->aggContentInfo[i], (int)"F:\\h2xsrc\\Base\\RESMGR.CPP", 474);
      if ( this->fileDescriptors[i] != -1 )
      {
        _close(this->fileDescriptors[i]);
        this->fileDescriptors[i] = -1;
      }
    }
    this->numOpenAGGFiles = 0;
    this->ready = 0;
  }
}

//----- (004CD510) --------------------------------------------------------
MANAGER_RETURN_CODE __thiscall resourceManager::LoadAggregateHeader(resourceManager *this, const char *filename)
{
  MANAGER_RETURN_CODE result; // eax@2
  int headerSize; // ST1C_4@5
  __int16 numFiles; // [sp+14h] [bp-8h]@5
  int fd; // [sp+18h] [bp-4h]@3

  if ( this->numOpenAGGFiles < NUM_AGG_FILES )
  {
    fd = open(filename, O_BINARY);
    if ( fd == -1 )
    {
      sprintf(gText, "Can't open file: %s", filename);
      ShutDown(gText);
      result = MANAGER_FAILED;
    }
    else
    {
      this->curHandleIdx = this->numOpenAGGFiles++;
      this->fileDescriptors[this->curHandleIdx] = fd;
      _read(this->fileDescriptors[this->curHandleIdx], &numFiles, 2u);
      this->numberOfFilesInAGG[this->curHandleIdx] = numFiles;
      headerSize = 12 * this->numberOfFilesInAGG[this->curHandleIdx];
      this->aggContentInfo[this->curHandleIdx] = (AggregateHeader *)BaseAlloc(
                                                                      headerSize,
                                                                      "F:\\h2xsrc\\Base\\RESMGR.CPP",
                                                                      542);
      _read(this->fileDescriptors[this->curHandleIdx], this->aggContentInfo[this->curHandleIdx], headerSize);
      result = MANAGER_SUCCESS;
    }
  }
  else
  {
    sprintf(gText, "Only %d .AGG files can be used at once.", NUM_AGG_FILES);
    ShutDown(gText);
    result = MANAGER_FAILED;
  }
  return result;
}

//----- (004CD660) --------------------------------------------------------
signed int __thiscall resourceManager::PointToFile(resourceManager *this, int id)
{
  char found; // [sp+10h] [bp-10h]@1
  int j; // [sp+14h] [bp-Ch]@0
  int i; // [sp+18h] [bp-8h]@1

  found = 0;
  for ( i = 0; ; ++i )
  {
    if ( i < NUM_AGG_FILES )
    {
      if ( this->aggContentInfo[i] )
      {
        for ( j = 0; this->numberOfFilesInAGG[i] > j; ++j )
        {
          if ( this->aggContentInfo[i][j].id == id )
          {
            found = 1;
            this->curHandleIdx = i;
            break;
          }
        }
      }
      if ( !found )
        continue;
    }
    break;
  }
  if ( !found )
  {
    sprintf(
      gText,
      "ResMgr::PointToFile failure!  ThisFileId:%d  LastFileId:%d  LastFileName:%s",
      id,
      this->fileID,
      this->resourceToLoad);
    ShutDown(gText);
  }
  return _lseek(this->fileDescriptors[this->curHandleIdx], this->aggContentInfo[this->curHandleIdx][j].off, SEEK_SET);
}

//----- (004CD780) --------------------------------------------------------
unsigned __int32 __thiscall resourceManager::GetFileSize(resourceManager *this, int fileHash)
{
  char found; // [sp+10h] [bp-10h]@1
  int j; // [sp+14h] [bp-Ch]@0
  RESOURCEMGR_CONSTANTS i; // [sp+18h] [bp-8h]@1
  RESOURCEMGR_CONSTANTS containingAGG; // [sp+1Ch] [bp-4h]@0

  found = 0;
  for ( i = 0; ; ++i )
  {
    if ( i < NUM_AGG_FILES )
    {
      if ( this->aggContentInfo[i] )
      {
        for ( j = 0; this->numberOfFilesInAGG[i] > j; ++j )
        {
          if ( this->aggContentInfo[i][j].id == fileHash )
          {
            found = 1;
            containingAGG = i;
            break;
          }
        }
      }
      if ( !found )
        continue;
    }
    break;
  }
  if ( !found )
  {
    sprintf(
      gText,
      "ResMgr::PointToFile failure!  ThisFileId:%d  LastFileId:%d  LastFileName:%s",
      fileHash,
      this->fileID,
      this->resourceToLoad);
    ShutDown(gText);
  }
  return this->aggContentInfo[containingAGG][j].length;
}

//----- (004CD880) --------------------------------------------------------
void __thiscall resourceManager::SavePosition(resourceManager *this)
{
  lastPositionZ[iSaveCtr] = tell(this->fileDescriptors[this->curHandleIdx]);
  lastAggZ[iSaveCtr++] = this->curHandleIdx;
}
// 51F1F4: using guessed type int iSaveCtr;

//----- (004CD8E0) --------------------------------------------------------
void __thiscall resourceManager::RestorePosition(resourceManager *this)
{
  --iSaveCtr;
  this->curHandleIdx = lastAggZ[iSaveCtr];
  _lseek(this->fileDescriptors[this->curHandleIdx], lastPositionZ[iSaveCtr], SEEK_SET);
}
// 51F1F4: using guessed type int iSaveCtr;

//----- (004CD940) --------------------------------------------------------
__int16 __thiscall resourceManager::ReadWord(resourceManager *this)
{
  int err; // ST1C_4@2
  __int16 buf; // [sp+18h] [bp-8h]@1
  int success; // [sp+1Ch] [bp-4h]@1

  ProcessAssert(this->fileDescriptors[this->curHandleIdx] != -1, "F:\\h2xsrc\\Base\\RESMGR.CPP", 732);
  buf = 0;
  success = _read(this->fileDescriptors[this->curHandleIdx], &buf, 2u);
  if ( !success )
    err = *_errno();
  return buf;
}

//----- (004CD9D0) --------------------------------------------------------
int __thiscall resourceManager::ReadLong(resourceManager *this)
{
  int err; // ST1C_4@2
  int buf; // [sp+18h] [bp-8h]@1
  int success; // [sp+1Ch] [bp-4h]@1

  ProcessAssert(this->fileDescriptors[this->curHandleIdx] != 0xFFFFFFFF, "F:\\h2xsrc\\Base\\RESMGR.CPP", 760);
  buf = 0;
  success = _read(this->fileDescriptors[this->curHandleIdx], &buf, 4u);
  if ( !success )
    err = *_errno();
  return buf;
}

//----- (004CDA60) --------------------------------------------------------
unsigned int __thiscall resourceManager::MakeId(resourceManager *this, const char *filename, int useEvilersion)
{
  int evilMatches; // eax@5
  unsigned int result; // eax@8
  int i; // [sp+10h] [bp-8h]@3

  strcpy(this->resourceToLoad, filename);
  if ( gbUseEvilInterface && useEvilersion )
  {
    for ( i = 0; i < NUM_GOOD_EVIL_ICONS; ++i )
    {
      LOBYTE(evilMatches) = stricmp(this->resourceToLoad, cEvilTranslate[i][0]);
      if ( !evilMatches )
        strcpy(this->resourceToLoad, cEvilTranslate[i][1]);
    }
  }
  result = MAKEFILEID(this->resourceToLoad);
  this->fileID = result;
  return result;
}
// 4F19D4: using guessed type int gbUseEvilInterface;

//----- (004CDB50) --------------------------------------------------------
void __thiscall resourceManager::Read13(resourceManager *this, char *buf)
{
  resourceManager::ReadBlock(this, buf, MAX_FILENAME_LENGTH);
}

//----- (004CDB80) --------------------------------------------------------
void __thiscall resourceManager::ReadBlock(resourceManager *this, void *buf, DWORD ntoread)
{
  int err1; // ST28_4@2
  int *err2; // eax@2
  signed int nread; // [sp+18h] [bp-4h]@1

  ProcessAssert(this->fileDescriptors[this->curHandleIdx] != 0xFFFFFFFF, "F:\\h2xsrc\\Base\\RESMGR.CPP", 816);
  PollSound();
  nread = _read(this->fileDescriptors[this->curHandleIdx], buf, ntoread);
  if ( nread != ntoread )
  {
    err1 = *_errno();
    err2 = _errno();
    sprintf(
      gText,
      "File error - bytes read %d, bytes requested %d, errno %d, last file '%s'",
      nread,
      ntoread,
      *err2,
      this->resourceToLoad);
    LogStr(gText);
  }
  PollSound();
}

//----- (004CDC40) --------------------------------------------------------
mouseManager *__thiscall mouseManager::mouseManager(mouseManager *this)
{
  mouseManager *v1; // ebx@1
  signed int i; // edx@1
  mouseManager *result; // eax@7

  v1 = this;
  baseManager::baseManager((baseManager *)this);
  i = 0;
  LODWORD(v1->vtable) = &mouseManager::_vftable_;
  v1->bitmap = 0;
  v1->ready = 0;
  v1->cursorCategory = -1;
  strcpy(v1->name, "mouseManager");
  v1->spriteIdx = 0;
  v1->couldBeShowMouse = 1;
  v1->cursorIcon = 0;
  memset(hbmpAndMask, 0, 0x180u);
  memset(&hMouseCursor, 0, 0x180u);
  memset(cColorBits, 0, sizeof(cColorBits));
  memset(cAndBits, 0, 0x180u);
  do
  {
    if ( iHotSpot[i].x == -1 )
      iHotSpot[i].x = iMouseSize[i].height / 2;
    if ( iHotSpot[i].y == -1 )
      iHotSpot[i].y = iMouseSize[i].height / 2;
    ++i;
  }
  while ( i < 96 );
  result = v1;
  v1->cursorDisabled = 1;
  return result;
}

//----- (004CDD20) --------------------------------------------------------
int __thiscall mouseManager::Open(mouseManager *this, int a2)
{
  mouseManager *thisa; // esi@1
  bitmap *v3; // eax@1

  this->field_7E = 0;
  thisa = this;
  v3 = (bitmap *)operator new(26);
  if ( v3 )
    thisa->bitmap = bitmap::bitmap(v3, 33, 66, 64);
  else
    thisa->bitmap = 0;
  thisa->cursorTopLeftX = 319;
  thisa->cursorTopLeftY = 239;
  thisa->field_6E = 320;
  thisa->field_66 = 319;
  thisa->field_6A = 239;
  thisa->field_56 = 320;
  thisa->cursorIdx = 0;
  thisa->field_4A = 0;
  thisa->field_72 = 240;
  thisa->field_5A = 240;
  if ( gbColorMice )
    ShowCursor(0);
  thisa->type = 64;
  thisa->ready = 1;
  thisa->idx = a2;
  return 0;
}
// 4F19B0: using guessed type int gbColorMice;

//----- (004CDDC0) --------------------------------------------------------
void __thiscall mouseManager::Close(mouseManager *this)
{
  mouseManager *v1; // esi@1
  bitmap *v2; // ecx@2
  signed int i; // edi@4
  HCURSOR v4; // eax@4
  void *v5; // ecx@7
  void *v6; // ecx@9

  v1 = this;
  if ( this->ready == 1 )
  {
    this->ready = 0;
    v2 = this->bitmap;
    if ( v2 )
      ((void (__stdcall *)(_DWORD))v2->vtable->scalarDeletingDestructor)(1);
    i = 0;
    v1->bitmap = 0;
    v4 = LoadCursorA(0, (LPCSTR)0x7F00);
    SetCursor(v4);
    do
    {
      if ( *(HCURSOR *)((char *)&hMouseCursor + i * 4) )
        DestroyIcon(*(HCURSOR *)((char *)&hMouseCursor + i * 4));
      *(HCURSOR *)((char *)&hMouseCursor + i * 4) = NULL;
      v5 = cAndBits[i];
      if ( v5 )
        BaseFree(v5, (int)"F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 330);
      cAndBits[i] = NULL;
      v6 = cColorBits[i];
      if ( v6 )
        BaseFree(v6, (int)"F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 334);
      cColorBits[i] = 0;
      if ( hbmpAndMask[i] )
        DeleteObject(hbmpAndMask[i]);
      hbmpAndMask[i] = 0;
      ++i;
    }
    while ( i < 96 );
    if ( v1->cursorIcon )
      resourceManager::Dispose(gpResourceManager, (resource *)v1->cursorIcon);
    v1->cursorIcon = 0;
  }
}

//----- (004CDEB0) --------------------------------------------------------
int __stdcall mouseManager::Main(int a1)
{
  return 0;
}

//----- (004CDEC0) --------------------------------------------------------
void __thiscall mouseManager::SetPointer(mouseManager *this, char *mse, int spriteIdx, signed int protoCategory)
{
  mouseManager *thisa; // esi@1
  signed int category; // eax@2
  char firstLetter; // al@4
  int v7; // edi@13
  icon *oldIcon; // eax@13
  MOUSE_CURSOR_CATEGORY v9; // eax@15
  int spriteIdxa; // ebx@20
  const char *v11; // [sp-4h] [bp-20h]@16
  char filename[1]; // [sp+Ch] [bp-10h]@20

  thisa = this;
  if ( !this->field_7E )
  {
    ++gbPutzingWithMouseCtr;
    resourceManager::SavePosition(gpResourceManager);
    category = protoCategory;
    if ( protoCategory == -999 )
    {
      if ( giCurExe == 1 || (firstLetter = *mse, *mse == 'a') || firstLetter == 'A' )
      {
        category = MOUSE_CURSOR_CATEGORY_ADVENTURE;
      }
      else if ( firstLetter == 's' || firstLetter == 'S' )
      {
        category = MOUSE_CURSOR_CATEGORY_SPELL;
      }
      else
      {
        category = MOUSE_CURSOR_CATEGORY_COMBAT;
      }
    }
    if ( thisa->cursorCategory != category && (thisa->cursorCategory = category, gbColorMice) )
    {
      v7 = thisa->couldBeShowMouse;
      oldIcon = thisa->cursorIcon;
      thisa->couldBeShowMouse = 0;
      if ( oldIcon )
        resourceManager::Dispose(gpResourceManager, (resource *)oldIcon);
      v9 = thisa->cursorCategory;
      if ( v9 )
      {
        if ( v9 == MOUSE_CURSOR_CATEGORY_SPELL )
          v11 = "SPELCO.ICN";
        else
          v11 = "CMSECO.ICN";
      }
      else
      {
        v11 = "ADVMCO.ICN";
      }
      sprintf(filename, v11);
      spriteIdxa = spriteIdx;
      thisa->cursorIcon = resourceManager::GetIcon(gpResourceManager, filename);
      ProcessAssert(spriteIdx != 1000, "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 410);
      thisa->spriteIdx = -1;
      thisa->couldBeShowMouse = v7;
    }
    else
    {
      spriteIdxa = spriteIdx;
    }
    mouseManager::SetPointer(thisa, spriteIdxa);
    resourceManager::RestorePosition(gpResourceManager);
    --gbPutzingWithMouseCtr;
  }
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;
// 4F2E88: using guessed type int giCurExe;

//----- (004CE000) --------------------------------------------------------
void __thiscall mouseManager::SetPointer(mouseManager *this, int spriteIdxArg)
{
  int spriteIdx; // esi@2
  int v3; // eax@11
  char v4; // sf@11
  int v5; // eax@11
  int v6; // ecx@12
  int v7; // edi@16
  MOUSE_CURSOR_CATEGORY v8; // eax@17
  int fileID; // eax@22
  signed int v10; // eax@22
  int v11; // edi@22
  signed int v12; // esi@23
  int v13; // ebx@24
  void *v14; // ecx@24
  DWORD v15; // edx@31
  int cursorIdxa; // eax@31
  const char *v17; // [sp-8h] [bp-2Ch]@18
  int v18; // [sp-4h] [bp-28h]@18
  mouseManager *thisa; // [sp+10h] [bp-14h]@1
  char filename; // [sp+14h] [bp-10h]@22

  thisa = this;
  if ( !this->field_7E )
  {
    spriteIdx = spriteIdxArg;
    if ( spriteIdxArg >= 0 )
    {
      if ( this->ready == 1 && this->spriteIdx != spriteIdxArg && !gbInSetPointer )
      {
        gbInSetPointer = 1;
        ++gbPutzingWithMouseCtr;
        resourceManager::SavePosition(gpResourceManager);
        if ( giCurExe == 1 )
          thisa->cursorCategory = 0;
        if ( spriteIdxArg == 1000 )
          spriteIdx = thisa->spriteIdx;
        else
          thisa->spriteIdx = spriteIdxArg;
        v3 = iMouseOffset[thisa->cursorCategory];
        v4 = spriteIdx + v3 < 0;
        v5 = spriteIdx + v3;
        thisa->cursorIdx = v5;
        if ( v4 || (v6 = 1, v5 >= 96) )
          v6 = 0;
        ProcessAssert(v6, "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 458);
        if ( gbColorMice )
        {
          mouseManager::NewUpdate(thisa, 1);
        }
        else
        {
          v7 = thisa->cursorIdx;
          if ( !*(HCURSOR *)((char *)&hMouseCursor + v7 * 4) )
          {
            cColorBits[v7] = BaseAlloc(0x400u, "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 480);
            cAndBits[thisa->cursorIdx] = BaseAlloc(0x100u, "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 481);
            v8 = thisa->cursorCategory;
            if ( v8 )
            {
              if ( v8 == 2 )
              {
                v18 = spriteIdx;
                v17 = "SPELBW%02d.BMP";
              }
              else
              {
                v18 = spriteIdx + 1;
                v17 = "CMSEBW%02d.BMP";
              }
            }
            else
            {
              v18 = spriteIdx + 1;
              v17 = "ADVMBW%02d.BMP";
            }
            sprintf(&filename, v17, v18);
            fileID = resourceManager::MakeId(gpResourceManager, &filename, 1);
            resourceManager::PointToFile(gpResourceManager, fileID);
            resourceManager::ReadBlock(gpResourceManager, cColorBits[thisa->cursorIdx], 6u);
            resourceManager::ReadBlock(gpResourceManager, cColorBits[thisa->cursorIdx], 0x400u);
            v10 = 0;
            memset(cAndBits[thisa->cursorIdx], 0, 0x100u);
            v11 = 0;
            do
            {
              v12 = 0;
              do
              {
                v13 = thisa->cursorIdx;
                v14 = cColorBits[v13];
                if ( *((_BYTE *)v14 + v12 + v10) )
                {
                  if ( *((_BYTE *)v14 + v12 + v10) == 1 )
                    *((_BYTE *)cAndBits[v13] + (v12 >> 3) + v11 + 128) |= 1 << (7 - (v12 & 7));
                }
                else
                {
                  *((_BYTE *)cAndBits[v13] + (v12 >> 3) + v11) |= 1 << (7 - (v12 & 7));
                }
                ++v12;
              }
              while ( v12 < 32 );
              v11 += 4;
              v10 += 32;
            }
            while ( v10 < 1024 );
            *(&bmpAndMask.bmType + 6 * thisa->cursorIdx) = 0;
            dword_5330BC[6 * thisa->cursorIdx] = 32;
            dword_5330C0[6 * thisa->cursorIdx] = 64;
            dword_5330C4[6 * thisa->cursorIdx] = 4;
            word_5330C8[12 * thisa->cursorIdx] = 1;
            word_5330CA[12 * thisa->cursorIdx] = 1;
            dword_5330C4[6 * thisa->cursorIdx] = 4;
            dword_5330CC[6 * thisa->cursorIdx] = (int)cAndBits[thisa->cursorIdx];
            hbmpAndMask[thisa->cursorIdx] = CreateBitmapIndirect(&bmpAndMask + thisa->cursorIdx);
            ProcessAssert((int)hbmpAndMask[thisa->cursorIdx], "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 514);
            IconInfo[thisa->cursorIdx].fIcon = 0;
            if ( thisa->cursorCategory == 2 )
            {
              v15 = 15;
              IconInfo[thisa->cursorIdx].xHotspot = 15;
              cursorIdxa = thisa->cursorIdx;
            }
            else
            {
              IconInfo[thisa->cursorIdx].xHotspot = iHotSpot[thisa->cursorIdx].x;
              cursorIdxa = thisa->cursorIdx;
              v15 = iHotSpot[cursorIdxa].y;
            }
            IconInfo[cursorIdxa].yHotspot = v15;
            IconInfo[thisa->cursorIdx].hbmMask = hbmpAndMask[thisa->cursorIdx];
            IconInfo[thisa->cursorIdx].hbmColor = 0;
            *(&hMouseCursor + thisa->cursorIdx) = CreateIconIndirect(&IconInfo[thisa->cursorIdx]);
            ProcessAssert((int)*(&hMouseCursor + thisa->cursorIdx), "F:\\h2xsrc\\Base\\MOUSEMGR.CPP", 533);
          }
          SetCursor(*(&hMouseCursor + thisa->cursorIdx));
        }
        resourceManager::RestorePosition(gpResourceManager);
        gbInSetPointer = 0;
        --gbPutzingWithMouseCtr;
      }
    }
  }
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;
// 4F2E88: using guessed type int giCurExe;
// 51F3D8: using guessed type int iMouseOffset[];
// 51F568: using guessed type int gbInSetPointer;
// 5330BC: using guessed type int dword_5330BC[];
// 5330C0: using guessed type int dword_5330C0[];
// 5330C4: using guessed type int dword_5330C4[];
// 5330C8: using guessed type __int16 word_5330C8[];
// 5330CA: using guessed type __int16 word_5330CA[];
// 5330CC: using guessed type int dword_5330CC[];

//----- (004CE410) --------------------------------------------------------
void __thiscall mouseManager::NewUpdate(mouseManager *this, int a2)
{
  mouseManager *thisa; // esi@1
  __int32 v3; // eax@7
  __int32 v4; // edx@7
  int v5; // edx@10
  int v6; // edi@12
  int v7; // edx@12
  int v8; // ecx@12
  int v9; // edx@12
  int v10; // ebx@12
  int v11; // eax@12
  int v12; // ecx@24
  int v13; // ecx@32
  int v14; // eax@34
  int v15; // ecx@51
  int v16; // ebx@51
  int *v17; // edi@51
  int v18; // edx@51
  int v19; // ebp@54
  int v20; // edx@54
  int *v21; // ebx@54

  thisa = this;
  if ( (!this->cursorDisabled || a2) && this->couldBeShowMouse && !bInNewMouseUpdate )
  {
    bInNewMouseUpdate = 1;
    ++gbPutzingWithMouseCtr;
    if ( !a2 )
    {
      if ( !gbColorMice )
        goto LABEL_61;
      GetCursorPos(&Point);
      ScreenToClient(hwndApp, &Point);
      v3 = 640 * Point.x / iMainWinScreenWidth;
      thisa->field_56 = v3;
      v4 = 480 * Point.y / iMainWinScreenHeight;
      thisa->field_5A = v4;
      CheckChangeCursor(v3, v4, 0);
    }
    if ( gbColorMice )
    {
      if ( a2
        || (v5 = thisa->cursorIdx, thisa->field_56 - iHotSpot[v5].x != thisa->field_66)
        || thisa->field_5A - iHotSpot[v5].y != thisa->field_6A )
      {
        dword_5330B0 = thisa->cursorTopLeftX;
        dword_533B38 = thisa->cursorTopLeftY;
        dword_533B3C = thisa->field_6E;
        dword_534748 = thisa->field_72;
        v6 = thisa->cursorIdx;
        v7 = thisa->field_5A;
        v8 = thisa->field_56 - iHotSpot[v6].x;
        thisa->field_66 = v8;
        v9 = v7 - iHotSpot[v6].y;
        thisa->field_6A = v9;
        v10 = iMouseSize[v6].width + v8 - 1;
        thisa->field_6E = v10;
        v11 = iMouseSize[v6].height + v9 - 1;
        thisa->field_72 = v11;
        if ( v10 > 639 )
          thisa->field_6E = 639;
        if ( v11 > 479 )
          thisa->field_72 = 479;
        thisa->cursorTopLeftX = 0;
        if ( v8 >= 0 )
          thisa->cursorTopLeftX = v8;
        thisa->cursorTopLeftY = 0;
        if ( v9 >= 0 )
          thisa->cursorTopLeftY = v9;
        if ( dword_5330B0 <= 639 && dword_533B38 <= 479 && dword_533B3C >= 0 && dword_534748 >= 0 )
        {
          v12 = thisa->cursorTopLeftX;
          if ( dword_533B3C >= v12
            && thisa->field_6E >= dword_5330B0
            && thisa->cursorTopLeftY <= dword_534748
            && thisa->field_72 >= dword_533B38 )
          {
            if ( dword_5330B0 > v12 )
              dword_5330B0 = thisa->cursorTopLeftX;
            if ( dword_533B38 > thisa->cursorTopLeftY )
              dword_533B38 = thisa->cursorTopLeftY;
            v13 = thisa->cursorTopLeftX;
            if ( dword_533B3C < iMouseSize[thisa->cursorIdx].width + v13 - 1 )
              dword_533B3C = iMouseSize[thisa->cursorIdx].width + v13 - 1;
            v14 = iMouseSize[thisa->cursorIdx].height + thisa->cursorTopLeftY - 1;
            if ( dword_534748 >= v14 )
              goto LABEL_43;
            goto LABEL_42;
          }
          if ( dword_533B3C > 639 )
            dword_533B3C = 639;
          if ( dword_534748 > 479 )
            dword_534748 = 479;
          BlitBitmapToScreenNoMouseCheck(
            (int)gpWindowManager->screenBuffer,
            dword_5330B0,
            dword_533B38,
            dword_533B3C - dword_5330B0 + 1,
            dword_534748 - dword_533B38 + 1,
            dword_5330B0,
            dword_533B38);
        }
        dword_5330B0 = thisa->cursorTopLeftX;
        dword_533B38 = thisa->cursorTopLeftY;
        dword_533B3C = thisa->cursorTopLeftX + iMouseSize[thisa->field_4A].width - 1;
        v14 = thisa->cursorTopLeftY + iMouseSize[thisa->field_4A].height - 1;
LABEL_42:
        dword_534748 = v14;
LABEL_43:
        if ( dword_5330B0 <= 639 && dword_533B38 <= 479 && dword_533B3C >= 0 && dword_534748 >= 0 )
        {
          if ( dword_533B3C > 639 )
            dword_533B3C = 639;
          if ( dword_534748 > 479 )
            dword_534748 = 479;
          v15 = thisa->cursorTopLeftX;
          v16 = thisa->cursorIdx;
          v17 = &thisa->cursorWidth;
          v18 = iMouseSize[v16].width;
          if ( v15 + v18 <= 640 )
            *v17 = v18;
          else
            *v17 = 640 - v15;
          v19 = iMouseSize[v16].height;
          v20 = thisa->cursorTopLeftY;
          v21 = &thisa->cursorHeight;
          if ( v20 + v19 <= 480 )
            *v21 = v19;
          else
            *v21 = 480 - v20;
          bitmap::CopyToCareful(gpWindowManager->screenBuffer, thisa->bitmap, 0, 0, v15, v20, *v17, *v21);
          if ( !thisa->cursorDisabled )
            IconToBitmap(
              thisa->cursorIcon,
              gpWindowManager->screenBuffer,
              thisa->field_66,
              thisa->field_6A,
              thisa->spriteIdx,
              1,
              0,
              0,
              0x280u,
              480,
              0);
          BlitBitmapToScreenNoMouseCheck(
            (int)gpWindowManager->screenBuffer,
            dword_5330B0,
            dword_533B38,
            dword_533B3C - dword_5330B0 + 1,
            dword_534748 - dword_533B38 + 1,
            dword_5330B0,
            dword_533B38);
          bitmap::CopyToCareful(
            thisa->bitmap,
            gpWindowManager->screenBuffer,
            thisa->cursorTopLeftX,
            thisa->cursorTopLeftY,
            0,
            0,
            *v17,
            *v21);
        }
        thisa->field_4A = thisa->cursorIdx;
        goto LABEL_61;
      }
    }
LABEL_61:
    bInNewMouseUpdate = 0;
    --gbPutzingWithMouseCtr;
  }
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;
// 51F56C: using guessed type int bInNewMouseUpdate;
// 5330B0: using guessed type int dword_5330B0;
// 533B38: using guessed type int dword_533B38;
// 533B3C: using guessed type int dword_533B3C;
// 534748: using guessed type int dword_534748;

//----- (004CE890) --------------------------------------------------------
void __stdcall mouseManager::MouseCoords(int *x, int *y)
{
  GetCursorPos(&retrieveVirtualCursorCoordinates_lppoint);
  ScreenToClient(hwndApp, &retrieveVirtualCursorCoordinates_lppoint);
  *x = 640 * retrieveVirtualCursorCoordinates_lppoint.x / iMainWinScreenWidth;
  *y = 480 * retrieveVirtualCursorCoordinates_lppoint.y / iMainWinScreenHeight;
}

//----- (004CE8F0) --------------------------------------------------------
int __thiscall mouseManager::SaveAndDraw(mouseManager *this)
{
  int v1; // edx@1
  mouseManager *thisa; // esi@1
  int cursorIdx; // edi@1
  int newCursorWidth; // eax@1
  int *widthPtr; // ecx@1
  int v6; // eax@3
  int v7; // edi@3
  int *heightPtr; // edx@3
  int width; // ecx@5

  v1 = this->field_66;
  thisa = this;
  cursorIdx = this->cursorIdx;
  newCursorWidth = iMouseSize[cursorIdx].width;
  widthPtr = &this->cursorWidth;
  if ( v1 + newCursorWidth > 640 )
    newCursorWidth = 640 - v1;
  *widthPtr = newCursorWidth;
  v6 = iMouseSize[cursorIdx].height;
  v7 = thisa->field_6A;
  heightPtr = &thisa->cursorHeight;
  if ( v7 + v6 > 480 )
    v6 = 480 - v7;
  width = *widthPtr;
  *heightPtr = v6;
  bitmap::CopyToCareful(
    gpWindowManager->screenBuffer,
    thisa->bitmap,
    0,
    0,
    thisa->cursorTopLeftX,
    thisa->cursorTopLeftY,
    width,
    *heightPtr);
  return IconToBitmap(
           thisa->cursorIcon,
           gpWindowManager->screenBuffer,
           thisa->field_66,
           thisa->field_6A,
           thisa->spriteIdx,
           1,
           0,
           0,
           640u,
           480,
           0);
}

//----- (004CE9A0) --------------------------------------------------------
void __thiscall mouseManager::RestoreUnderlying(mouseManager *this)
{
  bitmap::CopyToCareful(
    this->bitmap,
    gpWindowManager->screenBuffer,
    this->cursorTopLeftX,
    this->cursorTopLeftY,
    0,
    0,
    this->cursorWidth,
    this->cursorHeight);
}

//----- (004CE9D0) --------------------------------------------------------
void __thiscall mouseManager::ReallyHidePointer(mouseManager *this)
{
  int v1; // eax@2

  if ( gbColorMice )
  {
    v1 = this->cursorDisabled + 1;
    this->cursorDisabled = v1;
    if ( v1 == 1 )
      mouseManager::NewUpdate(this, 1);
  }
  else
  {
    ShowCursor(0);
  }
}
// 4F19B0: using guessed type int gbColorMice;

//----- (004CEA00) --------------------------------------------------------
int __thiscall mouseManager::ReallyShowPointer(mouseManager *this)
{
  mouseManager *thisa; // esi@1
  int result; // eax@2
  __int32 v3; // eax@5
  __int32 v4; // edx@5

  thisa = this;
  if ( gbColorMice )
  {
    result = this->cursorDisabled;
    if ( result > 0 )
    {
      --result;
      this->cursorDisabled = result;
      if ( !result )
      {
        ++gbPutzingWithMouseCtr;
        if ( gbColorMice )
        {
          GetCursorPos(&Point);
          ScreenToClient(hwndApp, &Point);
          v3 = 640 * Point.x / iMainWinScreenWidth;
          thisa->field_56 = v3;
          v4 = 480 * Point.y / iMainWinScreenHeight;
          thisa->field_5A = v4;
          CheckChangeCursor(v3, v4, 0);
        }
        mouseManager::NewUpdate(thisa, 1);
        result = gbPutzingWithMouseCtr-- - 1;
      }
    }
  }
  else
  {
    result = ShowCursor(1);
  }
  return result;
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;

//----- (004CEAC0) --------------------------------------------------------
void __thiscall mouseManager::HideColorPointer(mouseManager *this)
{
  int v1; // eax@1

  v1 = this->cursorDisabled + 1;
  this->cursorDisabled = v1;
  if ( v1 == 1 )
    mouseManager::NewUpdate(this, 1);
}

//----- (004CEAE0) --------------------------------------------------------
void __thiscall mouseManager::ShowColorPointer(mouseManager *this)
{
  int v1; // eax@1
  mouseManager *thisa; // esi@1
  int v3; // eax@2
  __int32 v4; // eax@4
  __int32 v5; // edx@4

  v1 = this->cursorDisabled;
  thisa = this;
  if ( v1 > 0 )
  {
    v3 = v1 - 1;
    this->cursorDisabled = v3;
    if ( !v3 )
    {
      ++gbPutzingWithMouseCtr;
      if ( gbColorMice )
      {
        GetCursorPos(&Point);
        ScreenToClient(hwndApp, &Point);
        v4 = 640 * Point.x / iMainWinScreenWidth;
        thisa->field_56 = v4;
        v5 = 480 * Point.y / iMainWinScreenHeight;
        thisa->field_5A = v5;
        CheckChangeCursor(v4, v5, 0);
      }
      mouseManager::NewUpdate(thisa, 1);
      --gbPutzingWithMouseCtr;
    }
  }
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;

//----- (004CEB80) --------------------------------------------------------
bool __thiscall mouseManager::IsVis(mouseManager *this)
{
  return this->cursorDisabled < 1u;
}

//----- (004CEB90) --------------------------------------------------------
int __thiscall mouseManager::SetColorMice(mouseManager *this, int a2)
{
  int result; // eax@1
  mouseManager *v3; // edi@1
  int v4; // esi@2
  int v5; // ebx@2
  int v6; // eax@3
  int v7; // ecx@6
  signed int v8; // edx@6
  int v9; // ebp@6
  int v10; // eax@7
  int v11; // eax@8
  __int32 v12; // eax@10
  __int32 v13; // edx@10

  result = a2;
  v3 = this;
  if ( a2 != gbColorMice )
  {
    v4 = gpWindowManager->cycleColors;
    gpWindowManager->cycleColors = 0;
    v5 = bInNewMouseUpdate;
    ++gbPutzingWithMouseCtr;
    bInNewMouseUpdate = 0;
    if ( gbColorMice )
    {
      v6 = this->cursorDisabled + 1;
      this->cursorDisabled = v6;
      if ( v6 == 1 )
        mouseManager::NewUpdate(this, 1);
    }
    else
    {
      ShowCursor(0);
    }
    v7 = v3->spriteIdx;
    v8 = v3->cursorCategory;
    v9 = v3->field_7E;
    v3->couldBeShowMouse = 0;
    gbColorMice = a2;
    v3->spriteIdx = -99;
    v3->cursorCategory = -1;
    v3->field_7E = 0;
    mouseManager::SetPointer(v3, byte_51F6B4, v7, v8);
    v3->couldBeShowMouse = 1;
    v3->field_7E = v9;
    if ( gbColorMice )
    {
      v10 = v3->cursorDisabled;
      if ( v10 > 0 )
      {
        v11 = v10 - 1;
        v3->cursorDisabled = v11;
        if ( !v11 )
        {
          ++gbPutzingWithMouseCtr;
          if ( gbColorMice )
          {
            GetCursorPos(&Point);
            ScreenToClient(hwndApp, &Point);
            v12 = 640 * Point.x / iMainWinScreenWidth;
            v3->field_56 = v12;
            v13 = 480 * Point.y / iMainWinScreenHeight;
            v3->field_5A = v13;
            CheckChangeCursor(v12, v13, 0);
          }
          mouseManager::NewUpdate(v3, 1);
          --gbPutzingWithMouseCtr;
        }
      }
    }
    else
    {
      ShowCursor(1);
    }
    result = gbPutzingWithMouseCtr - 1;
    bInNewMouseUpdate = v5;
    --gbPutzingWithMouseCtr;
    gpWindowManager->cycleColors = v4;
  }
  return result;
}
// 4F19B0: using guessed type int gbColorMice;
// 4F1C8C: using guessed type int gbPutzingWithMouseCtr;
// 51F56C: using guessed type int bInNewMouseUpdate;

//----- (004CED20) --------------------------------------------------------
border *__thiscall border::border(border *this)
{
  border *v1; // esi@1
  border *result; // eax@1

  v1 = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  result = v1;
  v1->vtable = &border::_vftable_;
  v1->bitmap = 0;
  v1->icon = 0;
  v1->color = 0;
  return result;
}

//----- (004CED60) --------------------------------------------------------
border *__thiscall border::_scalar_deleting_destructor_(border *this, char a2)
{
  resource *v2; // eax@1
  border *thisa; // esi@1

  v2 = (resource *)this->bitmap;
  this->vtable = &border::_vftable_;
  thisa = this;
  if ( v2 )
    resourceManager::Dispose(gpResourceManager, v2);
  if ( thisa->icon )
    resourceManager::Dispose(gpResourceManager, (resource *)thisa->icon);
  widget::_widget(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}

//----- (004CEDB0) --------------------------------------------------------
border *__thiscall border::border(border *this, __int16 x, __int16 y, __int16 width, __int16 height, __int16 fieldID, __int16 a7, __int16 color, const char *filename)
{
  border *thisa; // esi@1

  thisa = this;
  widget::widget((widget *)this, x, y, width, height, fieldID, a7);
  thisa->vtable = &border::_vftable_;
  if ( filename )
    thisa->bitmap = resourceManager::GetBitmap(gpResourceManager, filename);
  else
    thisa->bitmap = 0;
  thisa->icon = 0;
  thisa->color = color;
  return thisa;
}

//----- (004CEE20) --------------------------------------------------------
void __thiscall border::Read(border *this)
{
  border *thisa; // esi@1
  BACKGROUND_TYPE file_type; // ax@1
  char buf; // [sp+4h] [bp-10h]@2

  thisa = this;
  this->offsetX = resourceManager::ReadWord(gpResourceManager);
  thisa->offsetY = resourceManager::ReadWord(gpResourceManager);
  thisa->width = resourceManager::ReadWord(gpResourceManager);
  thisa->height = resourceManager::ReadWord(gpResourceManager);
  thisa->fieldID = resourceManager::ReadWord(gpResourceManager);
  file_type = resourceManager::ReadWord(gpResourceManager);
  thisa->bitmap = NULL;
  thisa->icon = NULL;
  thisa->backgroundType = file_type;
  if ( file_type == BACKGROUND_IS_FROM_FILE )
  {
    resourceManager::Read13(gpResourceManager, &buf);
    resourceManager::SavePosition(gpResourceManager);
    thisa->bitmap = resourceManager::GetBitmap(gpResourceManager, &buf);
    resourceManager::RestorePosition(gpResourceManager);
  }
  else if ( file_type == (BACKGROUND_IS_FROM_FILE|BACKGROUND_IS_ICON) )
  {
    resourceManager::Read13(gpResourceManager, &buf);
    resourceManager::SavePosition(gpResourceManager);
    thisa->icon = resourceManager::GetIcon(gpResourceManager, &buf);
    resourceManager::RestorePosition(gpResourceManager);
  }
  else
  {
    thisa->color = (unsigned __int8)resourceManager::ReadWord(gpResourceManager);
  }
}

//----- (004CEF30) --------------------------------------------------------
signed int __thiscall border::Main(border *this, tag_message *evt)
{
  __int16 v2; // si@1
  INPUT_EVENT_CODE code; // eax@1
  signed int result; // eax@3
  heroWindow *v5; // eax@7
  __int16 x; // bx@7
  __int16 y; // di@7

  v2 = this->flagsRelatedToShouldDisplayAndPerhapsMouseCode;
  code = evt->eventCode;
  if ( v2 & 2 )
  {
    switch ( code )
    {
      default:
        result = widget::Main((widget *)this, (Event *)evt);
        break;
      case INPUT_LEFT_CLICK_EVENT_CODE:
      case INPUT_RIGHT_CLICK:
        v5 = this->parentWindow;
        x = evt->xCoordOrKeycode - LOWORD(v5->xOffset);
        y = evt->yCoordOrFieldID - LOWORD(v5->yOffset);
        if ( this->offsetX > x
          || this->offsetY > y
          || this->offsetX + this->width <= x
          || this->offsetY + this->height <= y )
        {
          result = 0;
        }
        else
        {
          if ( evt->eventCode == INPUT_RIGHT_CLICK )
          {
            evt->inputTypeBitmask = INPUT_GUI_MESSAGE_CODE;
            evt->xCoordOrKeycode = 14;
          }
          else
          {
            this->flagsRelatedToShouldDisplayAndPerhapsMouseCode = v2 | 1;
            evt->xCoordOrKeycode = 12;
          }
          evt->eventCode = 512;
          evt->yCoordOrFieldID = this->fieldID;
          result = 2;
        }
        break;
      case INPUT_LEFT_UP_EVENT_CODE:
      case INPUT_RIGHT_UP_EVENT_CODE:
        if ( v2 & 1 )
        {
          this->flagsRelatedToShouldDisplayAndPerhapsMouseCode = v2 & 0xFFFE;
          evt->eventCode = 512;
          evt->xCoordOrKeycode = 13;
          evt->yCoordOrFieldID = this->fieldID;
          result = 2;
        }
        else
        {
          result = 0;
        }
        break;
    }
  }
  else if ( code == 512 )
  {
    result = widget::Main((widget *)this, (Event *)evt);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004CF0C0) --------------------------------------------------------
void __thiscall border::Draw(border *this)
{
  heroWindow *window; // eax@1
  border *thisa; // esi@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@1
  __int16 x; // di@1
  __int16 y; // bx@1

  window = this->parentWindow;
  thisa = this;
  v3 = window->yOffset;
  v4 = window->xOffset;
  v5 = this->backgroundType;
  x = this->offsetX + v4;
  y = this->offsetY + v3;
  switch ( v5 )
  {
    case BACKGROUND_IS_SOLID:
      FillBitmapArea(gpWindowManager->screenBuffer, x, y, this->width, this->height, this->color);
      break;
    case BACKGROUND_IS_FROM_FILE:
      PollSound();
      BlitBitmap(thisa->bitmap, 0, 0, thisa->width, thisa->height, gpWindowManager->screenBuffer, x, y);
      PollSound();
      break;
    case BACKGROUND_IS_FROM_FILE|BACKGROUND_IS_ICON:
      icon::DrawToBuffer(this->icon, x, y, 0, 0);
      break;
  }
}

//----- (004CF170) --------------------------------------------------------
icon *__thiscall icon::icon(icon *this, int fileID)
{
  icon *thisa; // edi@1
  int totalSize; // eax@1
  DWORD totalSizea; // esi@1
  IconEntry *data; // eax@1

  thisa = this;
  resource::resource((resource *)this, RESOURCE_TYPE_ICN, fileID, 1, NULL);
  thisa->vtable = &icon::_vftable_;
  resourceManager::PointToFile(gpResourceManager, fileID);
  thisa->numSprites = resourceManager::ReadWord(gpResourceManager);
  totalSize = resourceManager::ReadLong(gpResourceManager);
  totalSizea = totalSize;
  data = (IconEntry *)BaseAlloc(totalSize, "F:\\h2xsrc\\Base\\ICON.CPP", 18);
  thisa->headersAndImageData = data;
  resourceManager::ReadBlock(gpResourceManager, data, totalSizea);
  return thisa;
}

//----- (004CF1E0) --------------------------------------------------------
icon *__thiscall icon::_scalar_deleting_destructor_(icon *this, char shouldDelete)
{
  icon *thisa; // esi@1

  this->vtable = &icon::_vftable_;
  thisa = this;
  BaseFree(this->headersAndImageData, (int)"F:\\h2xsrc\\Base\\ICON.CPP", 26);
  resource::_resource(thisa);
  if ( shouldDelete & 1 )
    operator delete(thisa);
  return thisa;
}

//----- (004CF220) --------------------------------------------------------
int __thiscall icon::DrawToBuffer(icon *this, int x, int y, int spriteIdx, int mirror)
{
  bitmap *screenBuf; // edx@1
  int result; // eax@2

  screenBuf = gpWindowManager->screenBuffer;
  if ( mirror )
    result = FlipIconToBitmap(this, screenBuf, x, y, spriteIdx, 0, 0, 0, 640, 480, 0);
  else
    result = IconToBitmap(this, screenBuf, x, y, spriteIdx, 0, 0, 0, 640u, 480, 0);
  return result;
}

//----- (004CF270) --------------------------------------------------------
signed int __thiscall icon::CombatClipDrawToBuffer(icon *this, int offsetX, int offsetY, int imageIdx, H2RECT *rect, int mirrored, int a11, char *paletteSubstitution, int a12)
{
  int idx; // edx@2
  int headerOffset; // ebx@2
  LONG right; // esi@3
  H2RECT *recta; // edi@3
  int imgOffsetY; // eax@3
  LONG left; // esi@4
  int offY; // esi@5
  bitmap *screenBuf; // edx@25
  int v18; // [sp-24h] [bp-34h]@35
  int v19; // [sp-20h] [bp-30h]@25
  int v20; // [sp-20h] [bp-30h]@35
  int v21; // [sp-1Ch] [bp-2Ch]@35
  signed int v22; // [sp-18h] [bp-28h]@35
  int v23; // [sp-14h] [bp-24h]@35
  int v24; // [sp-10h] [bp-20h]@35
  int v25; // [sp-Ch] [bp-1Ch]@35
  int v26; // [sp-8h] [bp-18h]@35
  int v27; // [sp-4h] [bp-14h]@33

  if ( gbComputeExtent )
  {
    idx = imageIdx;
    headerOffset = imageIdx;
    if ( mirrored )
    {
      right = offsetX - this->headersAndImageData[headerOffset].offsetX;
      recta = rect;
      rect->right = right;
      rect->left = right - this->headersAndImageData[headerOffset].width + 1;
      imgOffsetY = this->headersAndImageData[headerOffset].offsetY;
    }
    else
    {
      recta = rect;
      left = offsetX + this->headersAndImageData[headerOffset].offsetX;
      rect->left = left;
      rect->right = left + this->headersAndImageData[headerOffset].width - 1;
      imgOffsetY = this->headersAndImageData[headerOffset].offsetY;
    }
    offY = offsetY;
    recta->top = imgOffsetY + offsetY;
    recta->bottom = imgOffsetY + offsetY + this->headersAndImageData[headerOffset].height - 1;
    if ( gbSaveBiggestExtent )
    {
      if ( giMinExtentX > recta->left )
        giMinExtentX = recta->left;
      if ( giMinExtentY > recta->top )
        giMinExtentY = recta->top;
      if ( recta->right > giMaxExtentX )
        giMaxExtentX = recta->right;
      if ( recta->bottom > giMaxExtentY )
        giMaxExtentY = recta->bottom;
    }
    if ( gbReturnAfterComputeExtent )
      return 0;
  }
  else
  {
    offY = offsetY;
    idx = imageIdx;
    recta = rect;
  }
  if ( gbLimitToExtent
    && (!gbCurrArmyDrawn
     || recta->left > giMaxExtentX
     || recta->right < giMinExtentX
     || recta->top > giMaxExtentY
     || recta->bottom < giMinExtentY) )
    return 0;
  if ( a12 )
  {
    v19 = idx;
    screenBuf = gpWindowManager->screenBuffer;
    if ( mirrored )
      FlipIconToBitmapYModify((int)this, (int)screenBuf, offsetX, offY, v19, 1, 0, 0, 640, 444, a11, a12);
    else
      IconToBitmapYModify(this, screenBuf, offsetX, offY, v19, 1, 0, 0, 640u, 444, a11, a12);
    return 1;
  }
  if ( paletteSubstitution )
  {
    if ( mirrored )
      FlipIconToBitmapColorTable(
        this,
        gpWindowManager->screenBuffer,
        offsetX,
        offY,
        idx,
        1,
        0,
        0,
        640,
        444,
        a11,
        paletteSubstitution);
    else
      IconToBitmapColorTable(
        this,
        gpWindowManager->screenBuffer,
        offsetX,
        offY,
        idx,
        1,
        0,
        0,
        640u,
        444,
        a11,
        paletteSubstitution,
        1);
    return 1;
  }
  if ( !gbLimitToExtent )
  {
    v27 = a11;
    v26 = 444;
    v25 = 640;
    v24 = 0;
    v23 = 0;
    v22 = 1;
    v21 = idx;
    v20 = offY;
    v18 = offsetX;
    if ( !mirrored )
    {
      IconToBitmap(this, gpWindowManager->screenBuffer, offsetX, offY, idx, 1, 0, 0, 0x280u, 444, a11);
      return 1;
    }
LABEL_38:
    FlipIconToBitmap(this, gpWindowManager->screenBuffer, v18, v20, v21, v22, v23, v24, v25, v26, v27);
    return 1;
  }
  v27 = a11;
  if ( mirrored )
  {
    v26 = giMaxExtentY - giMinExtentY + 1;
    v25 = giMaxExtentX - giMinExtentX + 1;
    v24 = giMinExtentY;
    v23 = giMinExtentX;
    v22 = 1;
    v21 = idx;
    v20 = offY;
    v18 = offsetX;
    goto LABEL_38;
  }
  IconToBitmap(
    this,
    gpWindowManager->screenBuffer,
    offsetX,
    offY,
    idx,
    1,
    giMinExtentX,
    giMinExtentY,
    giMaxExtentX - giMinExtentX + 1,
    giMaxExtentY - giMinExtentY + 1,
    a11);
  return 1;
}
// 4F1998: using guessed type int gbReturnAfterComputeExtent;
// 4F7480: using guessed type int gbComputeExtent;
// 4F7484: using guessed type int gbSaveBiggestExtent;
// 4F7488: using guessed type int gbLimitToExtent;
// 4F748C: using guessed type int gbCurrArmyDrawn;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004CF530) --------------------------------------------------------
int __thiscall icon::ClipFillToBuffer(icon *this, int a2, int a3, int a4, char a5, int a6, int a7, int a8, unsigned int a9, int a10)
{
  return MonoIconToBitmap(this, gpWindowManager->screenBuffer, a2, a3, a4, a5, 1, a7, a8, a9, a10);
}

//----- (004CF570) --------------------------------------------------------
int __thiscall icon::FillToBuffer(icon *this, int x, int y, int idx, char color, int mirror, int a7)
{
  int result; // eax@2
  int v8; // edi@5
  int v9; // ebx@5
  int v10; // ebp@5

  if ( mirror )
  {
    result = FlipMonoIconToBitmap((int)this, (int)gpWindowManager->screenBuffer, x, y, idx, color, 0, 0, 0, 0, 0);
  }
  else if ( !gbLimitToExtent
  || !a7
  || (v8 = x + this->headersAndImageData[idx].offsetX,
      *(_DWORD *)a7 = v8,
      v9 = this->headersAndImageData[idx].width + v8 - 1,
      *(_DWORD *)(a7 + 4) = v9,
      v10 = y + this->headersAndImageData[idx].offsetY,
      *(_DWORD *)(a7 + 8) = v10,
      result = this->headersAndImageData[idx].height + v10 - 1,
      *(_DWORD *)(a7 + 12) = result,
      gbCurrArmyDrawn)
  && v8 <= giMaxExtentX
  && giMinExtentX <= v9
  && v10 <= giMaxExtentY
  && giMinExtentY <= result )
  {
    result = MonoIconToBitmap(this, gpWindowManager->screenBuffer, x, y, idx, color, 0, 0, 0, 0, 0);
  }
  return result;
}
// 4F7488: using guessed type int gbLimitToExtent;
// 4F748C: using guessed type int gbCurrArmyDrawn;
// 524734: using guessed type int giMaxExtentX;
// 524738: using guessed type int giMaxExtentY;

//----- (004CF680) --------------------------------------------------------
font *__thiscall font::font(font *ecx0, int fileID)
{
  font *this; // [sp+Ch] [bp-18h]@1
  char buf; // [sp+10h] [bp-14h]@4
  int v5; // [sp+20h] [bp-4h]@1

  this = ecx0;
  resource::resource((resource *)ecx0, RESOURCE_TYPE_FONT, fileID, 1, 0);
  this->vtable = &font::_vftable_;
  resourceManager::PointToFile(gpResourceManager, fileID);
  this->lineHeight = resourceManager::ReadWord(gpResourceManager);
  v5 = resourceManager::ReadWord(gpResourceManager);
  this->whetherFirstShortIsMoreThan13 = this->lineHeight >= 14;
  resourceManager::Read13(gpResourceManager, &buf);
  gbLoadingMonoIcon = 1;
  this->icon = resourceManager::GetIcon(gpResourceManager, &buf);
  gbLoadingMonoIcon = 0;
  return this;
}
// 4F2E70: using guessed type int gbLoadingMonoIcon;

//----- (004CF750) --------------------------------------------------------
int __thiscall font::_scalar_deleting_destructor_(int this, char a2)
{
  int thisa; // [sp+Ch] [bp-4h]@1

  thisa = this;
  font::_font((font *)this);
  if ( a2 & 1 )
    operator delete((void *)thisa);
  return thisa;
}

//----- (004CF790) --------------------------------------------------------
void __thiscall font::_font(font *this)
{
  font *v1; // ST10_4@1

  v1 = this;
  this->vtable = &font::_vftable_;
  resourceManager::Dispose(gpResourceManager, (resource *)this->icon);
  resource::_resource(v1);
}

//----- (004CF7D0) --------------------------------------------------------
int __thiscall font::DrawStringExecute(font *ecx0, char *a2, int a3, int a4, int a5, int a7, int a8, unsigned int regionWidth, int regionHeight)
{
  int result; // eax@2
  font *this; // [sp+Ch] [bp-10h]@1
  int x; // [sp+10h] [bp-Ch]@1
  int i; // [sp+14h] [bp-8h]@1
  char v13; // [sp+18h] [bp-4h]@3
  char v14; // [sp+18h] [bp-4h]@9

  this = ecx0;
  x = a3;
  for ( i = 0; ; ++i )
  {
    result = a2[i];
    if ( !a2[i] )
      break;
    v13 = a2[i];
    switch ( v13 )
    {
      case 31:
        x += font::GetCharacterWidth(this, a2[i]);
        break;
      case 123:
        this->field_18 = 1;
        break;
      case 125:
        this->field_18 = 0;
        break;
      default:
        v14 = v13 - 32;
        if ( v14 < 0 || v14 > 95 )
          v14 = 95;
        if ( v14 )
        {
          if ( a5 != 1 || this->field_18 )
          {
            if ( a5 == 2 || a5 == 1 && this->field_18 )
            {
              IconToBitmapColorTable(
                this->icon,
                gpWindowManager->screenBuffer,
                x,
                a4,
                v14,
                1,
                a7,
                a8,
                regionWidth,
                regionHeight,
                0,
                gColorTableYellow,
                1);
            }
            else if ( a5 == 4 )
            {
              IconToBitmapColorTable(
                this->icon,
                gpWindowManager->screenBuffer,
                x,
                a4,
                v14,
                1,
                a7,
                a8,
                regionWidth,
                regionHeight,
                0,
                gColorTableScenWin,
                0);
            }
            else
            {
              IconToBitmapColorTable(
                this->icon,
                gpWindowManager->screenBuffer,
                x,
                a4,
                v14,
                1,
                a7,
                a8,
                regionWidth,
                regionHeight,
                0,
                gColorTableDarkGray,
                1);
            }
          }
          else
          {
            IconToBitmap(this->icon, gpWindowManager->screenBuffer, x, a4, v14, 1, a7, a8, regionWidth, regionHeight, 0);
          }
        }
        x += font::GetCharacterWidth(this, a2[i]);
        break;
    }
  }
  return result;
}

//----- (004CFA20) --------------------------------------------------------
int __thiscall font::GetCharacterWidth(font *this, char chr)
{
  int result; // eax@3
  char spriteIdx; // [sp+18h] [bp+8h]@8

  if ( (unsigned __int8)chr != '{' && (unsigned __int8)chr != '}' )
  {
    if ( (unsigned __int8)chr == ' ' )
      chr = 'i';
    if ( (unsigned __int8)chr == '\x1F' )
      chr = '_';
    spriteIdx = chr - 32;
    if ( (signed int)(unsigned __int8)spriteIdx > 95 )
      spriteIdx = 95;
    result = this->whetherFirstShortIsMoreThan13 + this->icon->headersAndImageData[(unsigned __int8)spriteIdx].width;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (004CFAD0) --------------------------------------------------------
void __thiscall font::DrawBoundedString(font *this, char *str, int x, int y, signed int regionWidth, int regionHeight, int a7, int alignType)
{
  unsigned int len; // kr04_4@1
  font *thisa; // [sp+10h] [bp-48h]@1
  signed int v10; // [sp+14h] [bp-44h]@13
  int heightNeededToDisplay; // [sp+1Ch] [bp-3Ch]@2
  int v12; // [sp+24h] [bp-34h]@1
  signed int msgWidth; // [sp+28h] [bp-30h]@1
  int v14; // [sp+2Ch] [bp-2Ch]@14
  char v15; // [sp+40h] [bp-18h]@27
  int v16; // [sp+44h] [bp-14h]@1
  int i; // [sp+48h] [bp-10h]@1
  int msgOffset; // [sp+4Ch] [bp-Ch]@1

  thisa = this;
  len = strlen(str) + 1;
  msgOffset = 0;
  v16 = 0;
  v12 = 0;
  i = 0;
  msgWidth = 0;
  if ( alignType & 4 )
  {
    alignType -= 4;
    heightNeededToDisplay = font::LineLength(thisa, str, regionWidth) * thisa->lineHeight;
    if ( heightNeededToDisplay < regionHeight )
      v16 = (regionHeight - heightNeededToDisplay) / 2;
  }
  thisa->field_18 = 0;
  while ( i < (signed int)(len - 1) && str[i] && (v16 + thisa->lineHeight <= regionHeight || !v16) )
  {
    while ( str[i] && str[i] != '\n' && msgWidth <= regionWidth )
      msgWidth += font::GetCharacterWidth(thisa, str[i++]);
    v10 = msgWidth;
    if ( msgWidth > regionWidth )
    {
      --i;
      v14 = 0;
      while ( str[i] != ' ' )
      {
        if ( i < v12 )
          break;
        msgWidth -= font::GetCharacterWidth(thisa, str[i]);
        if ( v16 + 2 * thisa->lineHeight > regionHeight )
        {
          if ( msgWidth < regionWidth )
            break;
        }
        if ( !v14 )
        {
          if ( msgWidth < regionWidth )
            v14 = i;
        }
        --i;
      }
      if ( i <= v12 )
      {
        i = v14;
        msgWidth = v10;
      }
      if ( str[i] == ' ' )
        msgWidth -= font::GetCharacterWidth(thisa, str[i]);
    }
    v15 = str[i];
    str[i] = 0;
    if ( alignType )
    {
      if ( alignType == 1 )
      {
        msgOffset = (regionWidth - msgWidth) / 2;
      }
      else if ( alignType == 2 )
      {
        msgOffset = regionWidth - msgWidth;
      }
    }
    else
    {
      msgOffset = 0;
    }
    font::DrawStringExecute(thisa, &str[v12], msgOffset + x, v16 + y, a7, x, y, regionWidth, regionHeight);
    str[i] = v15;
    v16 += thisa->lineHeight;
    v12 = i++ + 1;
    msgWidth = 0;
  }
}

//----- (004CFDF0) --------------------------------------------------------
int __thiscall font::LineLength(font *this, const char *msg, int maxWidth)
{
  unsigned int len; // kr04_4@1
  int v4; // ST1C_4@19
  font *thisa; // [sp+Ch] [bp-38h]@1
  int v7; // [sp+14h] [bp-30h]@1
  int width; // [sp+18h] [bp-2Ch]@1
  int firstCharIdxNextLine; // [sp+1Ch] [bp-28h]@9
  int linesNeeded; // [sp+24h] [bp-20h]@1
  int i; // [sp+38h] [bp-Ch]@1

  thisa = this;
  len = strlen(msg) + 1;
  linesNeeded = 0;
  v7 = 0;
  i = 0;
  width = 0;
  while ( i < (signed int)(len - 1) && msg[i] )
  {
    while ( msg[i] && msg[i] != '\n' && maxWidth >= width )
      width += font::GetCharacterWidth(thisa, msg[i++]);
    if ( maxWidth < width )
    {
      --i;
      firstCharIdxNextLine = 0;
      while ( msg[i] != ' ' && i >= v7 )
      {
        width -= font::GetCharacterWidth(thisa, msg[i]);
        if ( !firstCharIdxNextLine )
        {
          if ( maxWidth > width )
            firstCharIdxNextLine = i;
        }
        --i;
      }
      if ( i <= v7 )
        i = firstCharIdxNextLine;
      if ( msg[i] == ' ' )
        v4 = width - font::GetCharacterWidth(thisa, msg[i]);
    }
    ++linesNeeded;
    v7 = i++ + 1;
    width = 0;
  }
  return linesNeeded;
}

//----- (004CFFB0) --------------------------------------------------------
int __thiscall font::LineWidth(font *this, const char *str)
{
  unsigned int v2; // kr04_4@1
  font *thisa; // [sp+Ch] [bp-2Ch]@1
  int width; // [sp+18h] [bp-20h]@1
  int i; // [sp+2Ch] [bp-Ch]@1

  thisa = this;
  v2 = strlen(str) + 1;
  i = 0;
  width = 0;
  while ( (signed int)(v2 - 1) > i && str[i] )
  {
    while ( str[i] && str[i] != '\n' )
      width += font::GetCharacterWidth(thisa, str[i++]);
  }
  return width;
}

//----- (004D0080) --------------------------------------------------------
iconWidget *__thiscall iconWidget::iconWidget(iconWidget *this)
{
  iconWidget *v1; // esi@1
  iconWidget *result; // eax@1

  v1 = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  v1->imgIdx = 0;
  v1->vtable = &iconWidget::_vftable_;
  v1->field_27 = 0;
  result = v1;
  v1->icon = 0;
  v1->mirror = 0;
  v1->iconFileID = 0;
  return result;
}
// 4EAF60: using guessed type widgetVtable iconWidget___vftable_;

//----- (004D00B0) --------------------------------------------------------
iconWidget *__thiscall iconWidget::_scalar_deleting_destructor_(iconWidget *this, char a2)
{
  resource *v2; // eax@1
  iconWidget *thisa; // esi@1

  v2 = (resource *)this->icon;
  this->vtable = &iconWidget::_vftable_;
  thisa = this;
  resourceManager::Dispose(gpResourceManager, v2);
  widget::_widget(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}
// 4EAF60: using guessed type widgetVtable iconWidget___vftable_;

//----- (004D00F0) --------------------------------------------------------
iconWidget *__thiscall iconWidget::iconWidget(iconWidget *this, __int16 x, __int16 y, __int16 width, __int16 height, const char *filename, __int16 imgIdx, char mirror, __int16 fieldID, __int16 a10, __int16 a11)
{
  iconWidget *thisa; // edi@1
  int v12; // eax@1
  iconWidget *result; // eax@1

  thisa = this;
  widget::widget((widget *)this, x, y, width, height, fieldID, a10);
  thisa->vtable = &iconWidget::_vftable_;
  v12 = resourceManager::MakeId(gpResourceManager, filename, 1);
  thisa->iconFileID = v12;
  thisa->icon = resourceManager::GetIcon(gpResourceManager, v12);
  thisa->imgIdx = imgIdx;
  thisa->mirror = mirror;
  thisa->field_27 = a11;
  result = thisa;
  thisa->field_14 = a10;
  return result;
}
// 4EAF60: using guessed type widgetVtable iconWidget___vftable_;

//----- (004D0170) --------------------------------------------------------
void __thiscall iconWidget::Read(iconWidget *this)
{
  iconWidget *thisa; // esi@1
  int v2; // eax@1
  char buf[16]; // [sp+4h] [bp-10h]@1

  thisa = this;
  this->offsetX = resourceManager::ReadWord(gpResourceManager);
  thisa->offsetY = resourceManager::ReadWord(gpResourceManager);
  thisa->width = resourceManager::ReadWord(gpResourceManager);
  thisa->height = resourceManager::ReadWord(gpResourceManager);
  resourceManager::Read13(gpResourceManager, buf);
  resourceManager::SavePosition(gpResourceManager);
  v2 = resourceManager::MakeId(gpResourceManager, buf, 1);
  thisa->iconFileID = v2;
  thisa->icon = resourceManager::GetIcon(gpResourceManager, v2);
  resourceManager::RestorePosition(gpResourceManager);
  thisa->imgIdx = resourceManager::ReadWord(gpResourceManager);
  thisa->mirror = resourceManager::ReadWord(gpResourceManager);
  thisa->fieldID = resourceManager::ReadWord(gpResourceManager);
  thisa->field_14 = resourceManager::ReadWord(gpResourceManager);
  thisa->field_27 = (unsigned __int8)resourceManager::ReadWord(gpResourceManager);
}

//----- (004D0250) --------------------------------------------------------
signed int __thiscall iconWidget::Main(iconWidget *this, tag_message *evt)
{
  iconWidget *thisa; // esi@1
  __int16 v3; // cx@1
  signed int result; // eax@4
  INPUT_EVENT_CODE evtCode; // edx@6
  heroWindow *parent; // ebp@14
  __int16 xRelParent; // ax@14
  __int16 yRelParent; // bx@14
  resource *v9; // ST00_4@36

  thisa = this;
  v3 = this->field_16;
  if ( !(v3 & 2) )
  {
    if ( evt->eventCode != 512 )
      return 0;
    if ( evt->xCoordOrKeycode != 60 )
      return widget::Main((widget *)thisa, (Event *)evt);
  }
  evtCode = evt->eventCode;
  if ( evt->eventCode <= INPUT_LEFT_UP_EVENT_CODE )
  {
    if ( evt->eventCode != INPUT_LEFT_UP_EVENT_CODE )
    {
      if ( evtCode != INPUT_LEFT_CLICK_EVENT_CODE )
        return widget::Main((widget *)thisa, (Event *)evt);
      goto LABEL_14;
    }
    goto LABEL_23;
  }
  if ( evtCode == INPUT_RIGHT_CLICK )
  {
LABEL_14:
    parent = thisa->parentWindow;
    xRelParent = evt->xCoordOrKeycode - LOWORD(parent->xOffset);
    yRelParent = evt->yCoordOrFieldID - LOWORD(parent->yOffset);
    if ( xRelParent < thisa->offsetX
      || yRelParent < thisa->offsetY
      || thisa->offsetX + thisa->width <= xRelParent
      || thisa->offsetY + thisa->height <= yRelParent )
    {
      result = 0;
    }
    else
    {
      if ( evtCode == INPUT_RIGHT_CLICK )
      {
        evt->inputTypeBitmask = INPUT_GUI_MESSAGE_CODE;
        evt->xCoordOrKeycode = 14;
      }
      else
      {
        LOBYTE(v3) = v3 | 1;
        thisa->field_16 = v3;
        evt->xCoordOrKeycode = 12;
      }
      evt->eventCode = INPUT_GUI_MESSAGE_CODE;
      evt->yCoordOrFieldID = thisa->fieldID;
      result = 2;
    }
    return result;
  }
  if ( evtCode == INPUT_RIGHT_UP_EVENT_CODE )
  {
LABEL_23:
    if ( v3 & 1 )
    {
      LOBYTE(v3) = v3 & 0xFE;
      thisa->field_16 = v3;
      evt->xCoordOrKeycode = GUI_MESSAGE_BUTTON_PRESSED;
      evt->eventCode = INPUT_GUI_MESSAGE_CODE;
      evt->yCoordOrFieldID = thisa->fieldID;
      result = 2;
    }
    else
    {
      result = 0;
    }
    return result;
  }
  if ( evtCode != INPUT_GUI_MESSAGE_CODE )
    return widget::Main((widget *)thisa, (Event *)evt);
  switch ( evt->xCoordOrKeycode )
  {
    default:
      return widget::Main((widget *)thisa, (Event *)evt);
    case GUI_MESSAGE_SET_IMG_IDX:
      if ( thisa->fieldID != evt->yCoordOrFieldID )
        return widget::Main((widget *)thisa, (Event *)evt);
      thisa->imgIdx = (__int16)evt->payload;
      return 1;
    case 8:
      if ( thisa->fieldID != evt->yCoordOrFieldID )
        return widget::Main((widget *)thisa, (Event *)evt);
      thisa->field_27 = (unsigned int)evt->payload & 0xFF;
      return 1;
    case GUI_MESSAGE_SET_ICON:
      if ( thisa->fieldID != evt->yCoordOrFieldID )
        return widget::Main((widget *)thisa, (Event *)evt);
      if ( thisa->icon )
      {
        resourceManager::Dispose(gpResourceManager, (resource *)thisa->icon);
        thisa->icon = resourceManager::GetIcon(gpResourceManager, (const char *)evt->payload);
      }
      result = 1;
      break;
    case GUI_MESSAGE_REPLACE_ICON:
      if ( evt->yCoordOrFieldID == thisa->iconFileID )
      {
        v9 = (resource *)thisa->icon;
        thisa->iconFileID = (int)evt->payload;
        resourceManager::Dispose(gpResourceManager, v9);
        thisa->icon = resourceManager::GetIcon(gpResourceManager, (int)evt->payload);
      }
      result = 0;
      break;
  }
  return result;
}

//----- (004D04F0) --------------------------------------------------------
void __thiscall iconWidget::Draw(iconWidget *this)
{
  heroWindow *window; // eax@1
  __int16 y; // bx@1
  __int16 x; // di@1
  iconWidget *thisa; // esi@1
  int v5; // eax@1
  IconEntry *imgHeader; // eax@6
  __int16 v7; // dx@6
  __int16 v8; // bx@6
  __int16 v9; // cx@6
  __int16 v10; // di@6

  window = this->parentWindow;
  y = LOWORD(window->yOffset) + this->offsetY;
  x = LOWORD(window->xOffset) + this->offsetX;
  thisa = this;
  v5 = this->field_14;
  switch ( v5 )
  {
    case 16:
      icon::DrawToBuffer(this->icon, x, y, this->imgIdx, this->mirror);
      break;
    case 17:
      imgHeader = GetIconEntry(this->icon, this->imgIdx);
      v7 = imgHeader->width;
      v8 = y - imgHeader->offsetY;
      v9 = thisa->width;
      v10 = x - imgHeader->offsetX;
      if ( v7 < v9 )
        v10 += (v9 - v7) >> 1;
      if ( imgHeader->height + 2 < thisa->height )
        v8 += thisa->height - imgHeader->height - 2;
      icon::DrawToBuffer(thisa->icon, v10, v8, thisa->imgIdx, thisa->mirror);
      break;
    case 128:
      icon::FillToBuffer(this->icon, x, y, this->imgIdx, this->field_27, this->mirror, 0);
      break;
  }
}

//----- (004D05D8) --------------------------------------------------------
bool __cdecl BitTest(char *bits, unsigned int i)
{
  return (*(_DWORD *)&bits[i >> 3] & (1 << (i & 7))) != 0;
}

//----- (004D0606) --------------------------------------------------------
// Sets the ith bit of bits
void __cdecl BitSet(char *bits, unsigned int i)
{
  *(_DWORD *)&bits[i >> 3] |= 1 << (i & 7);
}

//----- (004D0650) --------------------------------------------------------
signed int __fastcall KeyboardMessageHandler(HWND a1, int a2, int a3, unsigned int a4)
{
  tag_message *evt; // esi@5
  inputManager *v6; // eax@9
  int v7; // ecx@9
  int v8; // eax@20
  unsigned __int8 v9; // cf@30

  if ( !gpInputManager )
    return 1;
  if ( gpInputManager->ready != 1 )
    return 1;
  evt = &gpInputManager->inputInstances[gpInputManager->currentInfoField];
  evt->inputTypeBitmask = 0;
  evt->altYCoord = 0;
  evt->altXCoord = 0;
  evt->yCoordOrFieldID = 0;
  evt->xCoordOrKeycode = 0;
  evt->eventCode = 0;
  if ( a2 == 256 )
  {
    evt->eventCode = 1;
    evt->xCoordOrKeycode = (a4 >> 16) & 0xFF;
    evt->yCoordOrFieldID = 0;
    evt->inputTypeBitmask = 0;
    switch ( evt->xCoordOrKeycode )
    {
      case 0x1D:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask | 4;
        goto LABEL_18;
      case 0x2A:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask | 2;
        goto LABEL_18;
      case 0x36:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask | 1;
        goto LABEL_18;
      case 0x38:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask | 0x20;
LABEL_18:
        v6->forSettingBitmask = v7;
        break;
      default:
        break;
    }
  }
  else if ( a2 == 257 )
  {
    evt->eventCode = 2;
    evt->xCoordOrKeycode = (a4 >> 16) & 0xFF;
    evt->yCoordOrFieldID = 0;
    evt->inputTypeBitmask = 0;
    switch ( evt->xCoordOrKeycode )
    {
      case 0x1D:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask & 0xFFFB;
        goto LABEL_18;
      case 0x2A:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask & 0xFFFD;
        goto LABEL_18;
      case 0x36:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask & 0xFFFE;
        goto LABEL_18;
      case 0x38:
        v6 = gpInputManager;
        v7 = gpInputManager->forSettingBitmask & 0xFFDF;
        goto LABEL_18;
      default:
        break;
    }
  }
  if ( evt->eventCode == 0 )
    goto LABEL_33;
  evt->inputTypeBitmask = gpInputManager->forSettingBitmask;
  ++gpInputManager->currentInfoField;
  gpInputManager->currentInfoField = (((unsigned __int64)gpInputManager->currentInfoField >> 32) ^ abs(gpInputManager->currentInfoField) & 0x3F)
                                   - ((unsigned __int64)gpInputManager->currentInfoField >> 32);
  v8 = gpInputManager->currentInputEvt;
  if ( gpInputManager->currentInfoField == v8 )
  {
    gpInputManager->currentInputEvt = v8 + 1;
    gpInputManager->currentInputEvt = (((unsigned __int64)gpInputManager->currentInputEvt >> 32) ^ abs(gpInputManager->currentInputEvt) & 0x3F)
                                    - ((unsigned __int64)gpInputManager->currentInputEvt >> 32);
  }
  gpInputManager->field_85A = 0;
  if ( gpWindowManager->ready != 1 )
    goto LABEL_33;
  if ( evt->eventCode == INPUT_KEYDOWN_EVENT_CODE )
  {
    if ( evt->xCoordOrKeycode == 88 && evt->inputTypeBitmask & 3 )
      heroWindowManager::ScreenShot(gpWindowManager);
    if ( evt->eventCode != 1 )
      goto LABEL_33;
    if ( evt->xCoordOrKeycode == 59 )
    {
      SetFullScreenStatus(0);
      AppCommand(hwndApp, 0, 0x9C74u, 0);
    }
  }
  v9 = evt->eventCode < 1u;
  if ( evt->eventCode == 1 )
  {
    if ( evt->xCoordOrKeycode == 62 )
      SetFullScreenStatus((void *)(1 - *(&bMenu + 7 * giCurExe + 5)));
LABEL_33:
    v9 = evt->eventCode < 1u;
  }
  return v9;
}
// 4F2E88: using guessed type int giCurExe;

//----- (004D0960) --------------------------------------------------------
bool __fastcall MouseMessageHandler(HWND hWnd, int msg, int wParam, int lParam)
{
  int msga; // edi@1
  tag_message *evt; // esi@7
  int v7; // eax@20
  int v8; // eax@22
  int y; // edx@27
  int x; // edi@27
  int v11; // eax@44
  int v12; // [sp-4h] [bp-10h]@37

  msga = msg;
  if ( !gpInputManager )
    return 1;
  if ( gpInputManager->ready != 1 )
    return 1;
  if ( gpInputManager->readingInputMutex )
    return 1;
  gpInputManager->readingInputMutex = 1;
  evt = &gpInputManager->inputInstances[gpInputManager->currentInfoField];
  evt->inputTypeBitmask = 0;
  evt->altYCoord = 0;
  evt->altXCoord = 0;
  evt->yCoordOrFieldID = 0;
  evt->xCoordOrKeycode = 0;
  evt->eventCode = 0;
  switch ( msg )
  {
    case WM_MOUSEFIRST:
      evt->eventCode = INPUT_MOUSEMOVE_EVENT_CODE;
      goto LABEL_17;
    case WM_LBUTTONDOWN:
      evt->eventCode = INPUT_LEFT_CLICK_EVENT_CODE;
      SetCapture(hwndApp);
      goto LABEL_17;
    case WM_LBUTTONUP:
      evt->eventCode = INPUT_LEFT_UP_EVENT_CODE;
      if ( !ReleaseCapture() )
        LogStr("ReleaseCapture Failed");
      goto LABEL_17;
    case WM_LBUTTONDBLCLK:
      evt->eventCode = INPUT_LEFT_CLICK_EVENT_CODE;
      goto LABEL_17;
    case WM_RBUTTONDOWN:
      evt->eventCode = INPUT_RIGHT_CLICK;
      SetCapture(hwndApp);
      goto LABEL_17;
    case WM_RBUTTONUP:
      evt->eventCode = INPUT_RIGHT_UP_EVENT_CODE;
      if ( !ReleaseCapture() )
        LogStr("ReleaseCapture Failed");
      goto LABEL_17;
    case WM_RBUTTONDBLCLK:
      evt->eventCode = INPUT_RIGHT_CLICK;
LABEL_17:
      evt->xCoordOrKeycode = 640 * (signed __int16)lParam / iMainWinScreenWidth;
      evt->yCoordOrFieldID = 480 * SHIWORD(lParam) / iMainWinScreenHeight;
      evt->altXCoord = evt->xCoordOrKeycode;
      evt->altYCoord = evt->yCoordOrFieldID;
      if ( !*(&bMenu + 7 * giCurExe + 5) )
      {
        if ( !*(&bMenu + 7 * giCurExe + 6) )
        {
          if ( KBTickCount() > iLastBWOnScreenCheck )
          {
            v7 = evt->xCoordOrKeycode;
            if ( v7 > 3 )
            {
              if ( v7 < 636 )
              {
                v8 = evt->yCoordOrFieldID;
                if ( v8 > 3 )
                {
                  if ( v8 < 476 )
                  {
                    iLastBWOnScreenCheck = KBTickCount() + 500;
                    mouseManager::SetPointer(gpMouseManager, 1000);
                  }
                }
              }
            }
          }
        }
      }
      break;
    default:
      break;
  }
  if ( msga == WM_MOUSEMOVE )
  {
    if ( gpMouseManager )
    {
      y = evt->yCoordOrFieldID;
      x = evt->xCoordOrKeycode;
      if ( !bInCheckChangeCursor )
      {
        if ( !*(&bMenu + 7 * giCurExe + 5) && *(&bMenu + 7 * giCurExe + 6) )
        {
          bInCheckChangeCursor = 1;
          if ( x < 0 || x >= 640 || y < 0 || y >= 480 )
          {
            if ( bLastMouseOffscreen )
              goto LABEL_42;
            bLastMouseOffscreen = 1;
            bLastOnscreenMouseColor = gbColorMice;
            if ( !gbColorMice )
              goto LABEL_42;
            v12 = 0;
          }
          else
          {
            if ( bLastMouseOffscreen )
            {
              bLastMouseOffscreen = 0;
              mouseManager::SetPointer(gpMouseManager, 1000);
            }
            if ( bLastOnscreenMouseColor == gbColorMice )
              goto LABEL_42;
            v12 = 1;
          }
          mouseManager::SetColorMice(gpMouseManager, v12);
LABEL_42:
          bInCheckChangeCursor = 0;
          goto LABEL_43;
        }
      }
    }
  }
LABEL_43:
  if ( evt->eventCode )
  {
    evt->inputTypeBitmask = gpInputManager->forSettingBitmask;
    ++gpInputManager->currentInfoField;
    gpInputManager->currentInfoField = (((unsigned __int64)gpInputManager->currentInfoField >> 32) ^ abs(gpInputManager->currentInfoField) & 0x3F)
                                     - ((unsigned __int64)gpInputManager->currentInfoField >> 32);
    v11 = gpInputManager->currentInputEvt;
    if ( gpInputManager->currentInfoField == v11 )
    {
      gpInputManager->currentInputEvt = v11 + 1;
      gpInputManager->currentInputEvt = (((unsigned __int64)gpInputManager->currentInputEvt >> 32) ^ abs(gpInputManager->currentInputEvt) & 0x3F)
                                      - ((unsigned __int64)gpInputManager->currentInputEvt >> 32);
    }
  }
  gpInputManager->readingInputMutex = 0;
  return evt->eventCode < 1u;
}
// 4F19B0: using guessed type int gbColorMice;
// 4F2E88: using guessed type int giCurExe;
// 51F6EC: using guessed type int bLastMouseOffscreen;
// 51F6F0: using guessed type int bLastOnscreenMouseColor;
// 51F6F4: using guessed type int bInCheckChangeCursor;
// 534758: using guessed type int iLastBWOnScreenCheck;

//----- (004D0CD0) --------------------------------------------------------
inputManager *__thiscall inputManager::inputManager(int this)
{
  inputManager *v1; // esi@1

  v1 = (inputManager *)this;
  baseManager::baseManager((baseManager *)this);
  v1->vtable = &inputManager::_vftable_;
  v1->ready = 0;
  v1->readingInputMutex = 0;
  v1->field_852 = 1;
  v1->field_84E = 0;
  v1->field_742 = 0;
  v1->field_746 = 0;
  v1->field_74A = 1;
  v1->normalizingKeycodeRelated = 1;
  v1->field_866 = 0;
  v1->field_862 = -1;
  return v1;
}

//----- (004D0D30) --------------------------------------------------------
int __thiscall inputManager::Open(inputManager *this, int a2)
{
  inputManager *thisa; // ebx@1

  thisa = this;
  memset(this->inputInstances, 0, sizeof(this->inputInstances));
  this->currentInfoField = 0;
  this->currentInputEvt = 0;
  this->field_852 = a2;
  this->forSettingBitmask = 0;
  inputManager::MakeScanCodeTable(this);
  thisa->type = 4;
  thisa->idx = -1;
  thisa->ready = 1;
  strcpy(thisa->name, "inputManager");
  return 0;
}

//----- (004D0DB0) --------------------------------------------------------
int __thiscall inputManager::Close(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 50);
  if ( result == 1 )
  {
    result = 0;
    *(_DWORD *)(this + 1850) = 0;
    *(_DWORD *)(this + 1846) = 0;
    *(_DWORD *)(this + 2130) = 0;
    *(_DWORD *)(this + 50) = 0;
  }
  return result;
}

//----- (004D0DD0) --------------------------------------------------------
int __cdecl _getmbcp()
{
  return 0;
}
// 4D0DD0: inconsistent function type and number of purged bytes

//----- (004D0DE0) --------------------------------------------------------
int __thiscall inputManager::Flush(inputManager *this)
{
  int result; // eax@1

  result = 0;
  this->currentInfoField = 0;
  this->currentInputEvt = 0;
  return result;
}

//----- (004D0DF0) --------------------------------------------------------
tag_message *__thiscall inputManager::GetEvent(tag_message *this, inputManager *retstr)
{
  inputManager *thisa; // ebx@1
  int v3; // eax@2
  signed __int64 v4; // qax@3
  tag_message *result; // eax@7
  tag_message evt; // [sp+Ch] [bp-1Ch]@3

  thisa = (inputManager *)this;
  PollSound();
  if ( gpInputManager->ready != 1 || (v3 = thisa->currentInputEvt, thisa->currentInfoField == v3) )
  {
    evt.eventCode = 0;
    evt.yCoordOrFieldID = 0;
    evt.xCoordOrKeycode = 0;
    evt.inputTypeBitmask = 0;
  }
  else
  {
    memcpy(&evt, &thisa->inputInstances[v3], sizeof(evt));
    v4 = v3 + 1;
    thisa->currentInputEvt = v4;
    LODWORD(v4) = (HIDWORD(v4) ^ ((BYTE4(v4) ^ (unsigned __int8)v4) - BYTE4(v4)) & 0x3F) - HIDWORD(v4);// signed v4 &= 63
    HIDWORD(v4) = evt.eventCode;
    thisa->currentInputEvt = v4;
    if ( HIDWORD(v4) == INPUT_KEYDOWN_EVENT_CODE && !thisa->normalizingKeycodeRelated )
      inputManager::AsciiConvert(thisa, &evt);
  }
  result = (tag_message *)retstr;
  memcpy(retstr, &evt, 0x1Cu);
  return result;
}

//----- (004D0EA0) --------------------------------------------------------
void *__thiscall inputManager::PeekEvent(inputManager *this, void *a2)
{
  inputManager *thisa; // ebx@1
  int v3; // eax@2
  INPUT_EVENT_CODE v4; // edx@3
  void *result; // eax@7
  tag_message evt; // [sp+Ch] [bp-1Ch]@3

  thisa = this;
  PollSound();
  if ( gpInputManager->ready != 1 || (v3 = thisa->currentInputEvt, thisa->currentInfoField == v3) )
  {
    evt.eventCode = 0;
    evt.yCoordOrFieldID = 0;
    evt.xCoordOrKeycode = 0;
    evt.inputTypeBitmask = 0;
  }
  else
  {
    memcpy(&evt, &thisa->inputInstances[v3], sizeof(evt));
    v4 = (signed int)evt.eventCode;
    thisa->currentInputEvt = (((unsigned __int64)v3 >> 32) ^ abs(v3) & 0x3F) - ((unsigned __int64)v3 >> 32);
    if ( v4 == 1 && !thisa->normalizingKeycodeRelated )
      inputManager::AsciiConvert(thisa, &evt);
  }
  result = a2;
  memcpy(a2, &evt, 0x1Cu);
  return result;
}

//----- (004D0F50) --------------------------------------------------------
int __thiscall inputManager::SetKeyCodeType(inputManager *this, int a2)
{
  int result; // eax@1

  this->normalizingKeycodeRelated = a2;
  result = 0;
  this->currentInfoField = 0;
  this->currentInputEvt = 0;
  return result;
}

//----- (004D0F70) --------------------------------------------------------
void __thiscall inputManager::AsciiConvert(inputManager *this, tag_message *evt)
{
  int v2; // eax@1
  __int16 v3; // ax@5
  int v4; // eax@5
  int v5; // ecx@7
  int v6; // ecx@7
  int v7; // eax@8

  v2 = evt->xCoordOrKeycode;
  if ( v2 >= 59 && v2 <= 68 || v2 == 87 || v2 == 88 )
  {
    v4 = this->keycodeRelated[v2];
  }
  else
  {
    v3 = this->keycodeRelated[v2];
    v4 = (unsigned __int8)v3;
  }
  v5 = evt->inputTypeBitmask;
  evt->xCoordOrKeycode = v4;
  v6 = v5 & 3;
  if ( !v6 )
  {
    v7 = evt->xCoordOrKeycode;
    if ( v7 > 64 )
    {
      if ( v7 < 91 )
        evt->xCoordOrKeycode = v7 + 32;
    }
  }
  if ( v6 )
  {
    switch ( evt->xCoordOrKeycode )
    {
      case '\'':
        evt->xCoordOrKeycode = '"';
        break;
      case ',':
        evt->xCoordOrKeycode = '<';
        break;
      case '-':
        evt->xCoordOrKeycode = '_';
        break;
      case '.':
        evt->xCoordOrKeycode = '>';
        break;
      case '/':
        evt->xCoordOrKeycode = '?';
        break;
      case '0':
        evt->xCoordOrKeycode = ')';
        break;
      case '1':
        evt->xCoordOrKeycode = '!';
        break;
      case '2':
        evt->xCoordOrKeycode = '@';
        break;
      case '3':
        evt->xCoordOrKeycode = '#';
        break;
      case '4':
        evt->xCoordOrKeycode = '$';
        break;
      case '5':
        evt->xCoordOrKeycode = '%';
        break;
      case '6':
        evt->xCoordOrKeycode = '^';
        break;
      case '7':
        evt->xCoordOrKeycode = '&';
        break;
      case '8':
        evt->xCoordOrKeycode = '*';
        break;
      case '9':
        evt->xCoordOrKeycode = '(';
        break;
      case ';':
        evt->xCoordOrKeycode = ':';
        break;
      case '=':
        evt->xCoordOrKeycode = '+';
        break;
      case '[':
        evt->xCoordOrKeycode = '{';
        break;
      case '\\':
        evt->xCoordOrKeycode = '|';
        break;
      case ']':
        evt->xCoordOrKeycode = '}';
        break;
      default:
        return;
    }
  }
}

//----- (004D1140) --------------------------------------------------------
signed int __thiscall inputManager::MakeScanCodeTable(inputManager *this)
{
  unsigned int v1; // eax@1
  __int16 v2; // dx@2
  signed int result; // eax@3

  v1 = 0;
  do
  {
    v2 = v1++;
    *((_WORD *)&this->field_74A + v1 + 1) = v2 << 8;
  }
  while ( v1 < 0x80 );
  this->keycodeRelated[0] = 0;
  this->keycodeRelated[1] = 27;
  this->keycodeRelated[2] = 49;
  this->keycodeRelated[3] = 50;
  this->keycodeRelated[4] = 51;
  this->keycodeRelated[5] = 52;
  this->keycodeRelated[6] = 53;
  this->keycodeRelated[7] = 54;
  this->keycodeRelated[8] = 55;
  this->keycodeRelated[9] = 56;
  this->keycodeRelated[10] = 57;
  this->keycodeRelated[11] = 48;
  this->keycodeRelated[13] = 61;
  this->keycodeRelated[14] = 127;
  this->keycodeRelated[15] = 9;
  this->keycodeRelated[16] = 81;
  this->keycodeRelated[17] = 87;
  this->keycodeRelated[18] = 69;
  this->keycodeRelated[19] = 82;
  this->keycodeRelated[20] = 84;
  this->keycodeRelated[21] = 89;
  this->keycodeRelated[22] = 85;
  this->keycodeRelated[23] = 73;
  this->keycodeRelated[24] = 79;
  this->keycodeRelated[25] = 80;
  this->keycodeRelated[26] = 91;
  this->keycodeRelated[27] = 93;
  this->keycodeRelated[28] = 10;
  this->keycodeRelated[29] = 7424;
  this->keycodeRelated[30] = 65;
  this->keycodeRelated[31] = 83;
  this->keycodeRelated[32] = 68;
  this->keycodeRelated[33] = 70;
  this->keycodeRelated[34] = 71;
  this->keycodeRelated[35] = 72;
  result = 45;
  this->keycodeRelated[36] = 74;
  this->keycodeRelated[37] = 75;
  this->keycodeRelated[38] = 76;
  this->keycodeRelated[41] = 10496;
  this->keycodeRelated[42] = 10752;
  this->keycodeRelated[43] = 92;
  this->keycodeRelated[44] = 90;
  this->keycodeRelated[45] = 88;
  this->keycodeRelated[46] = 67;
  this->keycodeRelated[47] = 86;
  this->keycodeRelated[48] = 66;
  this->keycodeRelated[49] = 78;
  this->keycodeRelated[50] = 77;
  this->keycodeRelated[51] = 44;
  this->keycodeRelated[52] = 46;
  this->keycodeRelated[53] = 47;
  this->keycodeRelated[54] = 13824;
  this->keycodeRelated[55] = 42;
  this->keycodeRelated[56] = 14336;
  this->keycodeRelated[57] = 32;
  this->keycodeRelated[12] = 45;
  this->keycodeRelated[39] = 39;
  this->keycodeRelated[40] = 39;
  this->keycodeRelated[58] = 14848;
  this->keycodeRelated[59] = 15104;
  this->keycodeRelated[60] = 15360;
  this->keycodeRelated[61] = 15616;
  this->keycodeRelated[62] = 15872;
  this->keycodeRelated[63] = 16128;
  this->keycodeRelated[64] = 16384;
  this->keycodeRelated[65] = 16640;
  this->keycodeRelated[66] = 16896;
  this->keycodeRelated[67] = 17152;
  this->keycodeRelated[68] = 17408;
  this->keycodeRelated[69] = 17664;
  this->keycodeRelated[70] = 17920;
  this->keycodeRelated[71] = 18176;
  this->keycodeRelated[72] = 18432;
  this->keycodeRelated[73] = 18688;
  this->keycodeRelated[75] = 19200;
  this->keycodeRelated[76] = 19456;
  this->keycodeRelated[77] = 19712;
  this->keycodeRelated[78] = 43;
  this->keycodeRelated[79] = 20224;
  this->keycodeRelated[80] = 20480;
  this->keycodeRelated[81] = 20736;
  this->keycodeRelated[82] = 20992;
  this->keycodeRelated[83] = 21248;
  this->keycodeRelated[84] = 21504;
  this->keycodeRelated[85] = 21760;
  this->keycodeRelated[86] = 22016;
  this->keycodeRelated[87] = 22272;
  this->keycodeRelated[88] = 22528;
  this->keycodeRelated[74] = 45;
  return result;
}

//----- (004D1480) --------------------------------------------------------
int __fastcall CheckChangeCursor(signed int a1, signed int a2, int a3)
{
  int result; // eax@1
  int v4; // [sp-4h] [bp-Ch]@12

  result = bInCheckChangeCursor;
  if ( !bInCheckChangeCursor )
  {
    result = 28 * giCurExe;
    if ( !*(&bMenu + 7 * giCurExe + 5) || a3 )
    {
      if ( *(BOOL *)((char *)&bMenu + result + 24) )
      {
        bInCheckChangeCursor = 1;
        if ( a3 || a1 >= 0 && a1 < 640 && a2 >= 0 && a2 < 480 )
        {
          if ( bLastMouseOffscreen )
          {
            bLastMouseOffscreen = 0;
            mouseManager::SetPointer(gpMouseManager, 1000);
          }
          result = bLastOnscreenMouseColor;
          if ( bLastOnscreenMouseColor == gbColorMice )
            goto LABEL_18;
          v4 = 1;
        }
        else
        {
          result = bLastMouseOffscreen;
          if ( bLastMouseOffscreen )
            goto LABEL_18;
          bLastMouseOffscreen = 1;
          bLastOnscreenMouseColor = gbColorMice;
          if ( !gbColorMice )
            goto LABEL_18;
          v4 = 0;
        }
        result = mouseManager::SetColorMice(gpMouseManager, v4);
LABEL_18:
        bInCheckChangeCursor = 0;
        return result;
      }
    }
  }
  return result;
}
// 4F19B0: using guessed type int gbColorMice;
// 4F2E88: using guessed type int giCurExe;
// 51F6EC: using guessed type int bLastMouseOffscreen;
// 51F6F0: using guessed type int bLastOnscreenMouseColor;
// 51F6F4: using guessed type int bInCheckChangeCursor;

//----- (004D1570) --------------------------------------------------------
void __cdecl inputManager::ForceMouseMove()
{
  int *v0; // ebx@2
  int *v1; // edi@2
  tag_message *v2; // esi@2
  int *v3; // ST04_4@2
  int *v4; // ST00_4@2
  int v5; // ecx@2

  if ( !gpInputManager->readingInputMutex )
  {
    gpInputManager->readingInputMutex = 1;
    v0 = &gpInputManager->inputInstances[gpInputManager->currentInfoField].yCoordOrFieldID;
    v1 = &gpInputManager->inputInstances[gpInputManager->currentInfoField].xCoordOrKeycode;
    v2 = &gpInputManager->inputInstances[gpInputManager->currentInfoField];
    v3 = &gpInputManager->inputInstances[gpInputManager->currentInfoField].yCoordOrFieldID;
    v4 = &gpInputManager->inputInstances[gpInputManager->currentInfoField].xCoordOrKeycode;
    v2->eventCode = 4;
    mouseManager::MouseCoords(v4, v3);
    v2->altXCoord = *v1;
    v2->altYCoord = *v0;
    v2->inputTypeBitmask = gpInputManager->forSettingBitmask;
    ++gpInputManager->currentInfoField;
    gpInputManager->currentInfoField = (((unsigned __int64)gpInputManager->currentInfoField >> 32) ^ abs(gpInputManager->currentInfoField) & 0x3F)
                                     - ((unsigned __int64)gpInputManager->currentInfoField >> 32);
    v5 = gpInputManager->currentInputEvt;
    if ( gpInputManager->currentInfoField == v5 )
    {
      gpInputManager->currentInputEvt = v5 + 1;
      gpInputManager->currentInputEvt = (((unsigned __int64)gpInputManager->currentInputEvt >> 32) ^ abs(gpInputManager->currentInputEvt) & 0x3F)
                                      - ((unsigned __int64)gpInputManager->currentInputEvt >> 32);
    }
    gpInputManager->readingInputMutex = 0;
  }
}

//----- (004D1660) --------------------------------------------------------
executive *__thiscall executive::executive(executive *this)
{
  this->firstManager = 0;
  this->lastManager = 0;
  this->currentManager = 0;
  this->field_C = 0;
  return this;
}

//----- (004D1670) --------------------------------------------------------
int __thiscall executive::InitSystem(executive *this)
{
  if ( gpResourceManager->vtable->Open((baseManager *)gpResourceManager, -1) )
    ShutDown("Unable to initialize resources - possible disk problem.");
  if ( gpInputManager->vtable->Open((baseManager *)gpInputManager, -1) )
    ShutDown("Unable to initialize input devices - possible problem with mouse or keyboard.");
  if ( giCurExe == 1 && (**(int (__thiscall ***)(baseManager *, int))gpSoundManager)((baseManager *)gpSoundManager, -1) )
    ShutDown("Unable to initialize sound.");
  if ( executive::AddManager(this, (baseManager *)gpMouseManager, -1) )
    ShutDown("Unable to initialize mouse.");
  if ( executive::AddManager(this, (baseManager *)gpWindowManager, -1) )
    ShutDown("Unable to initialize windows - possible memory or disk error.");
  return 0;
}
// 4F2E88: using guessed type int giCurExe;
// 5240A8: using guessed type int gpSoundManager;

//----- (004D1710) --------------------------------------------------------
void __thiscall executive::ShutDownSystem(executive *this)
{
  executive *thisa; // esi@1
  baseManager *cur; // eax@1
  baseManager *next; // edi@2

  thisa = this;
  EarlyShutDownSystem();
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)gpSoundManager + 4))(gpSoundManager);
  cur = thisa->firstManager;
  if ( thisa->firstManager )
  {
    do
    {
      next = cur->next;
      if ( (baseManager *)gpWindowManager != cur && (baseManager *)gpMouseManager != cur )
        executive::RemoveManager(thisa, cur);
      cur = next;
    }
    while ( next );
  }
  if ( gpWindowManager->ready == 1 )
    executive::RemoveManager(thisa, (baseManager *)gpWindowManager);
  if ( gpMouseManager->ready == 1 )
    executive::RemoveManager(thisa, (baseManager *)gpMouseManager);
  gpInputManager->vtable->Close((baseManager *)gpInputManager);
  ((void (*)(void))gpResourceManager->vtable->Close)();
}
// 5240A8: using guessed type int gpSoundManager;

//----- (004D17A0) --------------------------------------------------------
int __thiscall executive::DoDialog(executive *this, baseManager *a2)
{
  int numMgrs; // esi@1
  executive *thisa; // edi@1
  baseManager *cur; // ecx@1
  int i; // eax@2
  int j; // edx@13
  baseManager *v7; // ecx@14
  baseManager *v8; // eax@14
  baseManager *v9; // ebx@14
  executive othMgrMgr; // [sp+Ch] [bp-100h]@1
  baseManager *mgrs[20]; // [sp+1Ch] [bp-F0h]@3
  baseManager *prevs[20]; // [sp+6Ch] [bp-A0h]@3
  baseManager *nexts[20]; // [sp+BCh] [bp-50h]@3

  numMgrs = 0;
  thisa = this;
  othMgrMgr.firstManager = 0;
  othMgrMgr.lastManager = 0;
  othMgrMgr.currentManager = 0;
  cur = this->firstManager;
  othMgrMgr.field_C = 0;
  if ( cur )
  {
    i = 0;
    do
    {
      mgrs[i] = cur;
      prevs[i] = cur->prev;
      cur = cur->next;
      nexts[i] = cur;
      ++i;
      ++numMgrs;
    }
    while ( cur );
  }
  if ( executive::AddManager(thisa, a2, -1) )
    ShutDown("Can't add manager!");
  if ( executive::AddManager(&othMgrMgr, (baseManager *)gpMouseManager, -1) )
    ShutDown("Can't add manager!");
  if ( executive::AddManager(&othMgrMgr, (baseManager *)gpWindowManager, -1) )
    ShutDown("Can't add manager!");
  if ( executive::AddManager(&othMgrMgr, a2, -1) )
    ShutDown("Can't add manager!");
  executive::MainLoop(&othMgrMgr);
  executive::RemoveManager(thisa, a2);
  if ( numMgrs > 0 )
  {
    j = 0;
    do
    {
      v7 = mgrs[j];
      v8 = prevs[j];
      v9 = nexts[j];
      ++j;
      --numMgrs;
      v7->prev = v8;
      v7->next = v9;
    }
    while ( numMgrs );
  }
  return othMgrMgr.field_C;
}

//----- (004D18A0) --------------------------------------------------------
signed int __thiscall executive::AddManager(executive *this, baseManager *mgr, int argIdx)
{
  executive *thisa; // edi@1
  signed int result; // eax@2
  int idx; // ebx@3
  baseManager *prevLastMan; // eax@4
  baseManager *last; // eax@9
  baseManager *cur; // ecx@9
  baseManager *v9; // eax@13
  baseManager *v10; // eax@15

  thisa = this;
  if ( !mgr )
    return 3;
  idx = argIdx;
  if ( argIdx == -1 )
  {
    prevLastMan = this->lastManager;
    idx = 0;
    if ( prevLastMan )
      idx = prevLastMan->idx + 1;
  }
  if ( !mgr->ready && ((int (__thiscall *)(_DWORD))mgr->vtable->Open)(mgr) )
    return 3;
  last = thisa->lastManager;
  cur = thisa->lastManager;
  if ( !cur )
    goto LABEL_23;
  do
  {
    if ( cur->idx <= idx )
      break;
    cur = cur->prev;
  }
  while ( cur );
  if ( cur )
  {
    if ( !cur->next )
    {
      mgr->next = 0;
      mgr->prev = last;
      thisa->lastManager->next = mgr;
      result = 0;
      thisa->lastManager = mgr;
      return result;
    }
    mgr->prev = cur;
    mgr->next = cur->next;
    cur->next->prev = mgr;
    cur->next = mgr;
  }
  else
  {
LABEL_23:
    v9 = thisa->firstManager;
    mgr->prev = 0;
    mgr->next = v9;
    if ( thisa->firstManager )
      thisa->firstManager->prev = mgr;
    v10 = thisa->lastManager;
    thisa->firstManager = mgr;
    if ( !v10 )
    {
      result = 0;
      thisa->lastManager = mgr;
      return result;
    }
  }
  return 0;
}

//----- (004D1970) --------------------------------------------------------
void __thiscall executive::RemoveManager(executive *this, baseManager *mgr)
{
  executive *thisa; // edi@1
  baseManager *prev; // ecx@2
  baseManager *v4; // eax@5
  baseManager *next; // eax@7

  thisa = this;
  if ( mgr )
  {
    mgr->vtable->Close(mgr);
    prev = mgr->prev;
    if ( prev )
    {
      next = mgr->next;
      prev->next = next;
      if ( next )
        next->prev = prev;
      else
        thisa->lastManager = prev;
      mgr->prev = 0;
      mgr->next = 0;
    }
    else
    {
      if ( thisa->firstManager == thisa->lastManager )
      {
        thisa->lastManager = 0;
        thisa->firstManager = 0;
      }
      else
      {
        v4 = mgr->next;
        thisa->firstManager = v4;
        v4->prev = 0;
      }
      mgr->prev = 0;
      mgr->next = 0;
    }
  }
}

//----- (004D19F0) --------------------------------------------------------
void __thiscall executive::CallManager(executive *this, baseManager *man)
{
  baseManager *v2; // ebx@1
  executive *v3; // edi@1

  v2 = this->currentManager;
  v3 = this;
  executive::RemoveManager(this, this->currentManager);
  if ( executive::AddManager(v3, man, -1) )
    ShutDown("Can't add manager!");
  executive::MainLoop(v3);
  executive::RemoveManager(v3, man);
  if ( executive::AddManager(v3, v2, -1) )
    ShutDown("Can't add manager!");
  v3->currentManager = v2;
}

//----- (004D1A50) --------------------------------------------------------
void __thiscall executive::MainLoop(executive *this)
{
  executive *v1; // ebx@1
  signed int v2; // ebp@1
  tag_message *v3; // edx@3
  signed int v4; // esi@3
  baseManager *v5; // eax@3
  baseManager *curMan; // ecx@6
  int v7; // eax@9
  baseManager *v8; // eax@21
  char v9; // [sp+Dh] [bp-3Bh]@0
  tag_message evt; // [sp+10h] [bp-38h]@3
  tag_message a2; // [sp+2Ch] [bp-1Ch]@3

  v1 = this;
  v2 = 0;
  if ( this->firstManager )
  {
    inputManager::Flush(gpInputManager);
    do
    {
      Process1WindowsMessage();
      memcpy(&evt, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), sizeof(evt));
      v4 = 1;
      v5 = v1->firstManager;
      v1->currentManager = v1->firstManager;
      if ( !v5 )
        return;
      while ( v4 )
      {
        if ( v2 )
          return;
        curMan = v1->currentManager;
        if ( curMan->ready != 1
          || evt.eventCode == INPUT_MOUSEMOVE_EVENT_CODE && (baseManager *)gpWindowManager == curMan )
          goto LABEL_21;
        v7 = curMan->vtable->Main(curMan, v3);
        if ( v7 == 1 )
        {
          v4 = 0;
          goto LABEL_21;
        }
        if ( v7 != 2 || !(v9 & 0x40) )
          goto LABEL_21;
        if ( evt.eventCode == 1 )
          goto LABEL_20;
        if ( evt.eventCode == INPUT_KEYUP_EVENT_CODE )
        {
          executive::RemoveManager(v1, v1->currentManager);
          v1->currentManager = 0;
          goto LABEL_21;
        }
        if ( evt.eventCode == 4 )
        {
          v1->field_C = evt.altYCoord;
LABEL_20:
          v2 = 1;
        }
LABEL_21:
        v8 = v1->currentManager;
        if ( v8 )
        {
          v1->currentManager = v8->next;
          if ( v1->currentManager )
            continue;
        }
        break;
      }
    }
    while ( !v2 );
  }
}

//----- (004D1B50) --------------------------------------------------------
textWidget *__thiscall textWidget::textWidget(textWidget *this)
{
  textWidget *thisa; // edi@1

  thisa = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  thisa->vtable = &textWidget::_vftable_;
  thisa->field_28 = 1;
  thisa->field_2A = 1;
  thisa->font = 0;
  thisa->content = 0;
  thisa->field_14 = 512;
  return thisa;
}

//----- (004D1B90) --------------------------------------------------------
textWidget *__thiscall textWidget::_scalar_deleting_destructor_(textWidget *this, char a2)
{
  font *font; // eax@1
  textWidget *thisa; // esi@1

  font = this->font;
  this->vtable = &textWidget::_vftable_;
  thisa = this;
  resourceManager::Dispose(gpResourceManager, (resource *)font);
  BaseFree(thisa->content, (int)"F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 85);
  widget::_widget(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}

//----- (004D1BE0) --------------------------------------------------------
textWidget *__thiscall textWidget::textWidget(textWidget *this, __int16 offsetX, __int16 offsetY, __int16 width, __int16 height, char *content, const char *fontName, __int16 a8, __int16 fieldID, __int16 a7, char a11)
{
  textWidget *thisa; // esi@1
  font *font; // eax@1

  thisa = this;
  widget::widget((widget *)this, offsetX, offsetY, width, height, fieldID, a7);
  thisa->vtable = &textWidget::_vftable_;
  font = resourceManager::GetFont(gpResourceManager, fontName);
  thisa->field_28 = a8;
  thisa->font = font;
  thisa->field_2A = a11;
  thisa->field_14 = 512;
  thisa->content = content;
  return thisa;
}

//----- (004D1C50) --------------------------------------------------------
__int16 __thiscall textWidget::Read(textWidget *this)
{
  textWidget *v1; // esi@1
  __int16 v2; // ax@1
  DWORD v3; // edi@1
  char *v4; // eax@1
  __int16 result; // ax@1
  char buf; // [sp+8h] [bp-10h]@1

  v1 = this;
  this->offsetX = resourceManager::ReadWord(gpResourceManager);
  v1->offsetY = resourceManager::ReadWord(gpResourceManager);
  v1->width = resourceManager::ReadWord(gpResourceManager);
  v1->height = resourceManager::ReadWord(gpResourceManager);
  v2 = resourceManager::ReadWord(gpResourceManager);
  v3 = v2;
  v4 = (char *)BaseAlloc(v2, "F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 57);
  v1->content = v4;
  resourceManager::ReadBlock(gpResourceManager, v4, v3);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  v1->font = resourceManager::GetFont(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  v1->field_28 = (unsigned __int8)resourceManager::ReadWord(gpResourceManager);
  v1->field_2A = resourceManager::ReadWord(gpResourceManager);
  v1->fieldID = resourceManager::ReadWord(gpResourceManager);
  result = resourceManager::ReadWord(gpResourceManager);
  v1->field_14 = 512;
  return result;
}

//----- (004D1D40) --------------------------------------------------------
void __thiscall textWidget::_textWidget(textWidget *this)
{
  resource *fnt; // eax@1
  textWidget *thisa; // esi@1

  fnt = (resource *)this->font;
  this->vtable = &textWidget::_vftable_;
  thisa = this;
  resourceManager::Dispose(gpResourceManager, fnt);
  BaseFree(thisa->content, (int)"F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 85);
  widget::_widget(thisa);
}

//----- (004D1D70) --------------------------------------------------------
signed int __thiscall textWidget::Main(textWidget *this, tag_message *evt)
{
  __int16 v2; // dx@1
  textWidget *thisa; // ebx@1
  INPUT_EVENT_CODE code; // eax@1
  signed int result; // eax@3
  __int16 v6; // bp@13
  heroWindow *v7; // edi@13
  __int16 v8; // ax@13
  __int16 v9; // si@13
  int v10; // eax@26
  __int16 v11; // ax@30
  void *msg; // esi@30
  unsigned int contentsLen; // ebp@33

  v2 = this->field_16;
  thisa = this;
  code = evt->eventCode;
  if ( !(v2 & 2) )
  {
    if ( code == 512 )
      result = widget::Main((widget *)this, (Event *)evt);
    else
      result = 0;
    return result;
  }
  if ( (signed int)code <= 16 )
  {
    if ( code != 16 )
    {
      if ( code != 8 )
        return widget::Main((widget *)this, (Event *)evt);
      goto LABEL_13;
    }
LABEL_21:
    if ( v2 & 1 )
    {
      LOBYTE(v2) = v2 & 0xFE;
      this->field_16 = v2;
      if ( evt->eventCode == INPUT_RIGHT_UP_EVENT_CODE )
        evt->inputTypeBitmask = 512;
      evt->eventCode = 512;
      evt->xCoordOrKeycode = 13;
      evt->yCoordOrFieldID = this->fieldID;
      result = 2;
    }
    else
    {
      result = 0;
    }
    return result;
  }
  if ( code == 32 )
  {
LABEL_13:
    v6 = this->offsetX;
    v7 = this->parentWindow;
    v8 = evt->xCoordOrKeycode - LOWORD(v7->xOffset);
    v9 = evt->yCoordOrFieldID - LOWORD(v7->yOffset);
    if ( v6 > v8 || this->offsetY > v9 || v6 + this->width <= v8 || this->offsetY + this->height <= v9 )
    {
      result = 0;
    }
    else
    {
      LOBYTE(v2) = v2 | 1;
      this->field_16 = v2;
      if ( evt->eventCode == 32 )
        evt->inputTypeBitmask = 512;
      evt->eventCode = 512;
      evt->xCoordOrKeycode = 12;
      evt->yCoordOrFieldID = this->fieldID;
      result = 2;
    }
    return result;
  }
  if ( code == INPUT_RIGHT_UP_EVENT_CODE )
    goto LABEL_21;
  if ( code != 512 )
    return widget::Main((widget *)this, (Event *)evt);
  v10 = evt->xCoordOrKeycode;
  if ( v10 != 3 )
  {
    if ( v10 == 8 && this->fieldID == evt->yCoordOrFieldID )
    {
      this->field_28 = (__int16)evt->payload;
      return 1;
    }
    return widget::Main((widget *)this, (Event *)evt);
  }
  if ( this->fieldID != evt->yCoordOrFieldID )
    return widget::Main((widget *)this, (Event *)evt);
  v11 = this->field_14;
  msg = evt->payload;
  if ( v11 == 512 || v11 == 16384 )
  {
    contentsLen = (unsigned __int16)strlen((const char *)evt->payload);
    if ( strlen(thisa->content) < contentsLen )
    {
      BaseFree(thisa->content, (int)"F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 211);
      thisa->content = (char *)BaseAlloc(contentsLen + 5, "F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 212);
    }
    strcpy(thisa->content, (const char *)msg);
    result = 1;
  }
  else
  {
    result = 1;
    this->content = (char *)msg;
  }
  return result;
}

//----- (004D1F80) --------------------------------------------------------
void __thiscall textWidget::Draw(textWidget *this)
{
  int v1; // eax@1

  v1 = 3;
  if ( !(this->field_16 & 8) )
    v1 = this->field_28;
  font::DrawBoundedString(
    this->font,
    this->content,
    this->parentWindow->xOffset + this->offsetX,
    this->parentWindow->yOffset + this->offsetY,
    this->width,
    this->height,
    v1,
    this->field_2A);
}

//----- (004D1FD0) --------------------------------------------------------
__int16 __thiscall textWidget::SetText(textWidget *this, const char *str)
{
  __int16 result; // ax@1
  textWidget *thisa; // ebx@1
  unsigned int len; // esi@4
  unsigned int v5; // ecx@6

  result = this->field_14;
  thisa = this;
  if ( result == 512 || result == 16384 )
  {
    len = (unsigned __int16)strlen(str);
    if ( strlen(thisa->content) < len )
    {
      BaseFree(thisa->content, (int)"F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 211);
      thisa->content = (char *)BaseAlloc(len + 5, "F:\\h2xsrc\\Base\\TEXTWDGT.CPP", 212);
    }
    v5 = strlen(str) + 1;
    result = v5;
    memcpy(thisa->content, str, v5);
  }
  else
  {
    this->content = (char *)str;
  }
  return result;
}

//----- (004D2080) --------------------------------------------------------
int __fastcall IconToBitmap(icon *icn, bitmap *bmp, int a3, int a4, int spriteIdx, signed int a6, int a7, int a8, unsigned int a9, int a10, int a11)
{
  IconEntry *imgData; // edi@1
  int header; // ecx@1
  int v13; // esi@1
  int v14; // eax@1
  int v15; // ebx@1
  int v16; // eax@5
  int v17; // esi@5
  signed __int8 *v18; // ebp@9
  int v19; // ecx@10
  int v20; // eax@10
  int result; // eax@12
  int v22; // edx@14
  int v23; // ecx@17
  int v24; // eax@18
  int v25; // eax@24
  int v26; // edi@24
  int v27; // eax@27
  unsigned int v28; // esi@27
  int v29; // ecx@29
  int v30; // edi@31
  int v31; // ecx@34
  unsigned int v32; // ecx@34
  int v33; // eax@40
  char *v34; // esi@40
  int v35; // ecx@41
  int v36; // eax@43
  int v37; // eax@47
  int v38; // ecx@52
  int v39; // eax@59
  unsigned int v40; // edx@63
  int v41; // edi@63
  int v42; // esi@63
  int v43; // ecx@66
  const void *v44; // esi@73
  unsigned int v45; // ecx@73
  int v46; // edi@73
  int v47; // esi@73
  int v48; // ecx@73

  imgData = icn->headersAndImageData;
  header = imgData[spriteIdx].offsetX;
  v13 = (int)&imgData[spriteIdx];
  v14 = (int)((char *)imgData + imgData[spriteIdx].off);
  dword_534784 = v13;
  dword_534760 = v14;
  v15 = header + a3;
  dword_534764 = header + a3;
  dword_53476C = bmp->width;
  dword_534788 = a4 + *(_WORD *)(v13 + 2);
  if ( !a6 )
    goto LABEL_9;
  if ( a7 > header + a3 || dword_534764 + *(_WORD *)(v13 + 4) > (signed int)(a7 + a9) || dword_534788 < a8 )
  {
    v17 = a10;
    goto LABEL_8;
  }
  v16 = dword_534788 + *(_WORD *)(v13 + 6);
  v17 = a10;
  if ( v16 > a10 + a8 )
  {
LABEL_8:
    a6 = 1;
    dword_53478C = a7 + a9 - 1;
    dword_534790 = a8 + v17 - 1;
    goto LABEL_9;
  }
  a6 = 0;
LABEL_9:
  v18 = &bmp->contents[dword_53476C * dword_534788];
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v19 = dword_534760 + 1;
        dword_534760 = v19;
        v20 = *(_BYTE *)(v19 - 1);
        if ( (char)v20 < 0 )
          break;
        dword_534780 = v15;
        dword_534770 = v20;
        if ( v20 )
        {
          if ( !a6 )
          {
            v40 = v20;
            v41 = (int)&v18[v15];
            v42 = dword_534760;
            goto LABEL_75;
          }
          if ( dword_534788 >= a8 )
          {
            if ( dword_534788 <= dword_534790 )
            {
              v43 = v20 + v15;
              v40 = v20;
              if ( a7 < v20 + v15 )
              {
                if ( v15 <= dword_53478C )
                {
                  if ( v15 < a7 )
                  {
                    if ( v43 > dword_53478C )
                    {
                      v40 = a9;
                      v41 = (int)&v18[a7];
                      v42 = dword_534760 - v15 + a7;
                      goto LABEL_75;
                    }
                    v44 = (const void *)(dword_534760 - v15 + a7);
                    v45 = (unsigned int)(v20 + v15 - a7) >> 2;
                    memcpy(&v18[a7], v44, 4 * v45);
                    v47 = (int)((char *)v44 + 4 * v45);
                    v46 = (int)(&v18[4 * v45] + a7);
                    v48 = v20 + v15 - a7;
                  }
                  else
                  {
                    if ( v43 > dword_53478C )
                    {
                      v41 = (int)&v18[v15];
                      v42 = dword_534760;
                      v40 = dword_53478C - v15 + 1;
                    }
                    else
                    {
                      v41 = (int)&v18[v15];
                      v42 = dword_534760;
                    }
LABEL_75:
                    memcpy((void *)v41, (const void *)v42, 4 * (v40 >> 2));
                    v47 = v42 + 4 * (v40 >> 2);
                    v46 = v41 + 4 * (v40 >> 2);
                    LOBYTE(v48) = v40;
                  }
                  memcpy((void *)v46, (const void *)v47, v48 & 3);
                  goto LABEL_77;
                }
              }
            }
          }
LABEL_77:
          v15 += v20;
          dword_534770 = v20;
          dword_534760 += v20;
        }
        else
        {
          v15 = dword_534764;
          v18 += dword_53476C;
          ++dword_534788;
        }
      }
      if ( !(v20 & 0x40) )
        break;
      dword_534770 = *(_BYTE *)(v19 - 1);
      v22 = v20 & 0x3F;
      if ( v20 & 0x3F )
      {
        if ( v20 == 193 )
        {
          ++dword_534760;
          v22 = *(_BYTE *)(dword_534760 - 1);
        }
        v23 = dword_534760 + 1;
        dword_534760 = v23;
        byte_534778 = *(_BYTE *)(v23 - 1);
LABEL_23:
        if ( !a6 )
        {
          LOBYTE(v23) = byte_534778;
          BYTE1(v23) = byte_534778;
          v25 = v23 << 16;
          LOWORD(v25) = v23;
          memset32(&v18[v15], v25, (unsigned int)v22 >> 2);
          v26 = (int)(&v18[4 * ((unsigned int)v22 >> 2)] + v15);
          LOBYTE(v23) = v22;
          goto LABEL_37;
        }
        if ( dword_534788 >= a8 )
        {
          if ( dword_534788 <= dword_534790 )
          {
            v27 = v22 + v15;
            v28 = v22;
            if ( a7 < v22 + v15 )
            {
              if ( v15 <= dword_53478C )
              {
                HIWORD(v29) = HIWORD(dword_53478C);
                if ( v15 < a7 )
                {
                  if ( v27 > dword_53478C )
                  {
                    v28 = a9;
                    LOBYTE(v29) = byte_534778;
                    v30 = (int)&v18[a7];
                    BYTE1(v29) = byte_534778;
                    v25 = v29 << 16;
                    LOWORD(v25) = v29;
                    goto LABEL_36;
                  }
                  HIWORD(v31) = HIWORD(a7);
                  LOBYTE(v31) = byte_534778;
                  BYTE1(v31) = byte_534778;
                  v25 = v31 << 16;
                  LOWORD(v25) = v31;
                  v32 = (unsigned int)(v22 + v15 - a7) >> 2;
                  memset32(&v18[a7], v25, v32);
                  v26 = (int)(&v18[4 * v32] + a7);
                  v23 = v22 + v15 - a7;
                }
                else
                {
                  if ( v27 > dword_53478C )
                  {
                    v28 = dword_53478C - v15 + 1;
                    LOBYTE(v29) = byte_534778;
                    BYTE1(v29) = byte_534778;
                    v30 = (int)&v18[v15];
                    v25 = v29 << 16;
                    LOWORD(v25) = v29;
                  }
                  else
                  {
                    v30 = (int)&v18[v15];
                    LOBYTE(v29) = byte_534778;
                    BYTE1(v29) = byte_534778;
                    v25 = v29 << 16;
                    LOWORD(v25) = v29;
                  }
LABEL_36:
                  memset32((void *)v30, v25, v28 >> 2);
                  v26 = v30 + 4 * (v28 >> 2);
                  LOBYTE(v23) = v28;
                }
LABEL_37:
                memset((void *)v26, v25, v23 & 3);
                goto LABEL_38;
              }
            }
          }
        }
LABEL_38:
        v15 += v22;
        dword_534770 = v22;
      }
      else
      {
        ++dword_534760;
        v24 = *(_BYTE *)(dword_534760 - 1);
        v22 = *(_BYTE *)(dword_534760 - 1) & 3;
        if ( !(*(_BYTE *)(dword_534760 - 1) & 3) )
        {
          ++dword_534760;
          v22 = *(_BYTE *)(dword_534760 - 1);
        }
        HIWORD(v23) = HIWORD(a11);
        dword_53477C = v22;
        if ( a11 )
        {
          dword_534770 = v24;
          if ( v24 & 0x80 )
          {
            dword_534794 = v22;
            byte_534778 = a11;
            goto LABEL_23;
          }
        }
        dword_534770 = v24;
        dword_534794 = v22;
        if ( v24 & 0x40 )
        {
          v33 = (v24 & 0x3C) << 6;
          v34 = (char *)uDimPal + v33;
          dword_534768 = (int)((char *)uDimPal + v33);
          if ( a6 )
          {
            dword_534794 = v22;
            if ( dword_534788 >= a8 )
            {
              if ( dword_534788 <= dword_534790 )
              {
                v37 = v22 + v15;
                if ( a7 < v22 + v15 )
                {
                  if ( v15 <= dword_53478C )
                  {
                    if ( v15 < a7 )
                    {
                      dword_534794 = v22;
                      if ( v37 > dword_53478C )
                        v22 = a9;
                      else
                        v22 = v15 + v22 - a7;
                      v38 = (int)&v18[a7];
                    }
                    else
                    {
                      if ( v37 > dword_53478C )
                        v22 = dword_53478C - v15 + 1;
                      v38 = (int)&v18[v15];
                    }
                    dword_534774 = v38;
                    dword_534768 = (int)v34;
                    dword_534794 = v22;
                    dword_53475C = 0;
                    if ( v22 > 0 )
                    {
                      dword_53475C = v22;
                      do
                      {
                        ++v38;
                        v39 = *(_BYTE *)(v38 - 1);
                        dword_534774 = v38;
                        --v22;
                        dword_534768 = (int)v34;
                        *(_BYTE *)(v38 - 1) = v34[v39];
                      }
                      while ( v22 );
                    }
                  }
                }
              }
            }
          }
          else
          {
            v35 = (int)&v18[v15];
            dword_534774 = (int)&v18[v15];
            dword_53475C = 0;
            if ( v22 > 0 )
            {
              dword_53475C = v22;
              do
              {
                ++v35;
                v36 = *(_BYTE *)(v35 - 1);
                dword_534774 = v35;
                --v22;
                dword_534768 = (int)v34;
                *(_BYTE *)(v35 - 1) = v34[v36];
              }
              while ( v22 );
            }
          }
        }
        v15 += dword_53477C;
      }
    }
    dword_534780 = v15;
    dword_534798 = (int)v18;
    dword_534770 = v20;
    result = v20 & 0x3F;
    if ( !result )
      return result;
    v15 += result;
  }
}
// 53475C: using guessed type int dword_53475C;
// 534760: using guessed type int dword_534760;
// 534764: using guessed type int dword_534764;
// 534768: using guessed type int dword_534768;
// 53476C: using guessed type int dword_53476C;
// 534770: using guessed type int dword_534770;
// 534774: using guessed type int dword_534774;
// 534778: using guessed type char byte_534778;
// 53477C: using guessed type int dword_53477C;
// 534780: using guessed type int dword_534780;
// 534784: using guessed type int dword_534784;
// 534788: using guessed type int dword_534788;
// 53478C: using guessed type int dword_53478C;
// 534790: using guessed type int dword_534790;
// 534794: using guessed type int dword_534794;
// 534798: using guessed type int dword_534798;

//----- (004D25F0) --------------------------------------------------------
void __cdecl initialiseCRC()
{
  globalCrc = -1;
}
// 53792C: using guessed type int globalCrc;

//----- (004D2610) --------------------------------------------------------
signed int __cdecl getFinalCRC()
{
  return ~globalCrc;
}
// 53792C: using guessed type int globalCrc;

//----- (004D2630) --------------------------------------------------------
int __cdecl getGlobalCRC()
{
  return globalCrc;
}
// 53792C: using guessed type int globalCrc;

//----- (004D2650) --------------------------------------------------------
void *__thiscall setGlobalCRC(void *this)
{
  void *result; // eax@1

  result = this;
  globalCrc = (int)this;
  return result;
}
// 53792C: using guessed type int globalCrc;

//----- (004D2670) --------------------------------------------------------
_UNKNOWN *__thiscall bsOpenReadStream(void *this)
{
  void *v2; // [sp+Ch] [bp-8h]@1

  v2 = this;
  if ( bsInUse )
    panic();
  bsInUse = 1;
  unk_537938 = v2;
  *((_DWORD *)&unk_537938 + 1) = 0;
  *((_DWORD *)&unk_537938 + 2) = 0;
  *((_BYTE *)&unk_537938 + 12) = 114;
  return &unk_537938;
}
// 537928: using guessed type int bsInUse;

//----- (004D26E0) --------------------------------------------------------
_UNKNOWN *__thiscall bsOpenWriteStream(void *this)
{
  void *v2; // [sp+Ch] [bp-8h]@1

  v2 = this;
  if ( bsInUse )
    panic();
  bsInUse = 1;
  unk_537938 = v2;
  *((_DWORD *)&unk_537938 + 1) = 0;
  *((_DWORD *)&unk_537938 + 2) = 0;
  *((_BYTE *)&unk_537938 + 12) = 119;
  return &unk_537938;
}
// 537928: using guessed type int bsInUse;

//----- (004D2750) --------------------------------------------------------
int __fastcall bsPutBit(int a1, char a2)
{
  int result; // eax@4
  char v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+10h] [bp-8h]@1

  v3 = a2;
  v4 = a1;
  if ( *(_DWORD *)(a1 + 8) == 8 )
  {
    if ( putc(*(_BYTE *)(a1 + 4), *(_DWORD *)a1) == -1 )
      ioError();
    ++bytesOut;
    *(_DWORD *)(v4 + 8) = 1;
    result = v3 & 1;
    *(_DWORD *)(v4 + 4) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 4) = a2 & 1 | 2 * *(_DWORD *)(a1 + 4);
    result = a1;
    ++*(_DWORD *)(result + 8);
  }
  return result;
}
// 534BDC: using guessed type int bytesOut;

//----- (004D27E0) --------------------------------------------------------
int __thiscall bsGetBit(int this)
{
  int result; // eax@2
  int v2; // [sp+Ch] [bp-8h]@1
  signed int v3; // [sp+10h] [bp-4h]@3

  v2 = this;
  if ( *(_DWORD *)(this + 8) <= 0 )
  {
    v3 = getc(*(_DWORD *)this);
    if ( v3 == -1 )
      compressedStreamEOF();
    *(_DWORD *)(v2 + 8) = 7;
    *(_DWORD *)(v2 + 4) = v3;
    if ( *(_DWORD *)(v2 + 4) == -1 )
      bitStreamEOF();
    result = (*(_DWORD *)(v2 + 4) >> 7) & 1;
  }
  else
  {
    --*(_DWORD *)(this + 8);
    result = (*(_DWORD *)(this + 4) >> *(_BYTE *)(this + 8)) & 1;
  }
  return result;
}

//----- (004D2880) --------------------------------------------------------
char __thiscall bsGetUChar(void *this)
{
  int v2; // [sp+Ch] [bp-Ch]@1
  signed int i; // [sp+10h] [bp-8h]@1
  int v4; // [sp+14h] [bp-4h]@1

  v2 = (int)this;
  v4 = 0;
  for ( i = 0; i <= 7; ++i )
    v4 = 2 * v4 | bsGetBit(v2);
  return v4;
}

//----- (004D28D0) --------------------------------------------------------
int __fastcall bsPutUChar(int a1, unsigned __int8 a2)
{
  int result; // eax@3
  unsigned __int8 v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+10h] [bp-8h]@1
  signed int i; // [sp+14h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  for ( i = 7; i >= 0; --i )
    result = bsPutBit(v4, ((unsigned int)v3 >> i) & 1);
  return result;
}

//----- (004D2920) --------------------------------------------------------
void __thiscall bsClose(void *this)
{
  void *v1; // [sp+Ch] [bp-8h]@1

  v1 = this;
  if ( !bsInUse )
    panic();
  bsInUse = 0;
  if ( *((_BYTE *)v1 + 12) == 119 )
  {
    while ( *((_DWORD *)v1 + 2) < 8 )
    {
      ++*((_DWORD *)v1 + 2);
      *((_DWORD *)v1 + 1) *= 2;
    }
    if ( putc(*((_BYTE *)v1 + 4), *(_DWORD *)v1) == -1 )
      ioError();
    ++bytesOut;
    if ( fflush(*(_DWORD *)v1) == -1 )
      ioError();
  }
  if ( *(_BYTE *)(*(_DWORD *)v1 + 12) & 0x20 )
    ioError();
  if ( fclose(*(_DWORD *)v1) == -1 )
    ioError();
}
// 534BDC: using guessed type int bytesOut;
// 537928: using guessed type int bsInUse;

//----- (004D2A10) --------------------------------------------------------
unsigned int __fastcall minUInt32(unsigned int a1, unsigned int a2)
{
  unsigned int result; // eax@2

  if ( a2 <= a1 )
    result = a2;
  else
    result = a1;
  return result;
}

//----- (004D2A50) --------------------------------------------------------
int __fastcall arithCodeBitPlusFollow(int a1, char a2)
{
  int result; // eax@1
  char v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  result = bsPutBit(a1, a2);
  while ( bitsOutstanding )
  {
    result = bsPutBit(v4, 1 - v3);
    --bitsOutstanding;
  }
  return result;
}
// 5347AC: using guessed type int bitsOutstanding;

//----- (004D2AA0) --------------------------------------------------------
void __cdecl arithCodeStartEncoding()
{
  bigL = 0;
  bigR = 33554432;
  bitsOutstanding = 0;
}
// 5347AC: using guessed type int bitsOutstanding;
// 534FF0: using guessed type int bigL;
// 534FF4: using guessed type int bigR;

//----- (004D2AE0) --------------------------------------------------------
int __thiscall arithCodeDoneEncoding(void *this)
{
  int result; // eax@3
  int v2; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  v2 = (int)this;
  for ( i = 26; i >= 1; --i )
    result = arithCodeBitPlusFollow(v2, ((unsigned int)bigL >> (i - 1)) & 1);
  return result;
}
// 534FF0: using guessed type int bigL;

//----- (004D2B30) --------------------------------------------------------
void __thiscall arithCodeStartDecoding(void *this)
{
  int v1; // [sp+Ch] [bp-8h]@1
  signed int i; // [sp+10h] [bp-4h]@1

  v1 = (int)this;
  bigL = 0;
  bigR = 33554432;
  bigD = 0;
  for ( i = 1; i <= 26; ++i )
    bigD = bsGetBit(v1) + 2 * bigD;
}
// 534FEC: using guessed type int bigD;
// 534FF0: using guessed type int bigL;
// 534FF4: using guessed type int bigR;

//----- (004D2BC0) --------------------------------------------------------
int __thiscall arithCodeRenormalise_Encode(void *this)
{
  int result; // eax@3
  int v2; // [sp+Ch] [bp-4h]@1

  v2 = (int)this;
  while ( (unsigned int)bigR <= 0x1000000 )
  {
    result = bigL + bigR;
    if ( (unsigned int)(bigL + bigR) > 0x2000000 )
    {
      if ( (unsigned int)bigL < 0x2000000 )
      {
        ++bitsOutstanding;
        bigL -= 16777216;
      }
      else
      {
        result = arithCodeBitPlusFollow(v2, 1);
        bigL -= 33554432;
      }
    }
    else
    {
      result = arithCodeBitPlusFollow(v2, 0);
    }
    bigL *= 2;
    bigR *= 2;
  }
  return result;
}
// 5347AC: using guessed type int bitsOutstanding;
// 534FF0: using guessed type int bigL;
// 534FF4: using guessed type int bigR;

//----- (004D2C60) --------------------------------------------------------
void __fastcall arithCodeSymbol(void *a1, int a2, signed int a3)
{
  int v3; // [sp+18h] [bp-14h]@4
  unsigned int v4; // [sp+20h] [bp-Ch]@1
  signed int i; // [sp+24h] [bp-8h]@1
  int v6; // [sp+28h] [bp-4h]@1

  v4 = *(_DWORD *)(a2 + 8);
  v6 = 0;
  for ( i = 1; a3 > i; ++i )
    v6 += *(_DWORD *)(a2 + 4 * i + 28);
  v3 = v6 + *(_DWORD *)(a2 + 4 * a3 + 28);
  bigL += v6 * (bigR / v4);
  if ( v4 <= v3 )
    bigR -= v6 * (bigR / v4);
  else
    bigR = bigR / v4 * (v3 - v6);
  arithCodeRenormalise_Encode(a1);
  if ( (unsigned int)bitsOutstanding > 0x1DCD6500 )
    panic();
}
// 5347AC: using guessed type int bitsOutstanding;
// 534FF0: using guessed type int bigL;
// 534FF4: using guessed type int bigR;

//----- (004D2D40) --------------------------------------------------------
int __fastcall arithDecodeSymbol(int a1, int a2)
{
  int v3; // [sp+Ch] [bp-24h]@1
  int v4; // [sp+10h] [bp-20h]@1
  unsigned int v5; // [sp+18h] [bp-18h]@1
  unsigned int i; // [sp+1Ch] [bp-14h]@1
  unsigned int v7; // [sp+20h] [bp-10h]@1
  unsigned int v8; // [sp+24h] [bp-Ch]@1
  int v9; // [sp+28h] [bp-8h]@1
  int v10; // [sp+2Ch] [bp-4h]@4

  v3 = a2;
  v4 = a1;
  v8 = *(_DWORD *)(a2 + 8);
  v7 = bigR / v8;
  v5 = minUInt32(v8 - 1, bigD / bigR / v8);
  v9 = 0;
  for ( i = 0; v5 >= i; i += *(_DWORD *)(v3 + 4 * v9 + 28) )
    ++v9;
  v10 = i - *(_DWORD *)(v3 + 4 * v9 + 28);
  bigD -= v10 * v7;
  if ( v8 <= i )
    bigR -= v10 * v7;
  else
    bigR = v7 * (i - v10);
  while ( (unsigned int)bigR <= 0x1000000 )
  {
    bigR *= 2;
    bigD = bsGetBit(v4) + 2 * bigD;
  }
  return v9;
}
// 534FEC: using guessed type int bigD;
// 534FF4: using guessed type int bigR;

//----- (004D2E40) --------------------------------------------------------
int __fastcall initModel(int a1, int a2, signed int a3, int a4, int a5)
{
  int result; // eax@9
  signed int j; // [sp+14h] [bp-4h]@2
  signed int i; // [sp+14h] [bp-4h]@6

  if ( a4 )
  {
    *(_DWORD *)(a1 + 8) = a3 * a4;
    for ( i = 1; i <= a3; ++i )
      *(_DWORD *)(a1 + 4 * i + 28) = a4;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a3;
    for ( j = 1; j <= a3; ++j )
      *(_DWORD *)(a1 + 4 * j + 28) = 1;
  }
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a5;
  *(_DWORD *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 4 * a3 + 32) = 0;
  result = a1;
  *(_DWORD *)a1 = 0;
  return result;
}

//----- (004D2F20) --------------------------------------------------------
void __thiscall dumpModelStats(void *this)
{
  sprintf(gText, "model %s:\t scalings %d\n", *((_DWORD *)this + 6), *(_DWORD *)this);
  LogStr(gText);
}

//----- (004D2F60) --------------------------------------------------------
int __fastcall updateModel(int a1, int a2)
{
  int result; // eax@1
  signed int i; // [sp+14h] [bp-4h]@2

  *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 4 * a2 + 28) += *(_DWORD *)(a1 + 16);
  result = a1;
  if ( *(_DWORD *)(a1 + 20) < *(_DWORD *)(a1 + 8) )
  {
    *(_DWORD *)(a1 + 8) = 0;
    ++*(_DWORD *)a1;
    for ( i = 1; ; ++i )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 12) < (unsigned int)i )
        break;
      *(_DWORD *)(a1 + 4 * i + 28) = (unsigned int)(*(_DWORD *)(a1 + 4 * i + 28) + 1) >> 1;
      *(_DWORD *)(a1 + 8) += *(_DWORD *)(a1 + 4 * i + 28);
    }
  }
  return result;
}

//----- (004D3000) --------------------------------------------------------
int __fastcall putSymbol(int a1, signed int a2, void *a3)
{
  int v3; // ST10_4@1
  int v4; // ST14_4@1

  v3 = a2;
  v4 = a1;
  arithCodeSymbol(a3, a1, a2);
  return updateModel(v4, v3);
}

//----- (004D3040) --------------------------------------------------------
int __fastcall getSymbol(int a1, int a2)
{
  int v2; // ST10_4@1
  int v3; // ST14_4@1

  v2 = a1;
  v3 = arithDecodeSymbol(a2, a1);
  updateModel(v2, v3);
  return v3;
}

//----- (004D3080) --------------------------------------------------------
int __cdecl initBogusModel()
{
  return initModel((int)&bogusModel, (int)"bogus", 256, 0, 256);
}

//----- (004D30B0) --------------------------------------------------------
int __fastcall putUChar(void *a1, unsigned __int8 a2)
{
  return putSymbol((int)&bogusModel, a2 + 1, a1);
}

//----- (004D30E0) --------------------------------------------------------
int __fastcall putInt32(void *a1, unsigned int a2)
{
  unsigned int v2; // ST0C_4@1
  void *v3; // ST10_4@1

  v2 = a2;
  v3 = a1;
  putUChar(a1, BYTE3(a2));
  putUChar(v3, v2 >> 16);
  putUChar(v3, BYTE1(v2));
  return putUChar(v3, v2);
}

//----- (004D3150) --------------------------------------------------------
int __fastcall putUInt32(void *a1, unsigned int a2)
{
  unsigned int v2; // ST0C_4@1
  void *v3; // ST10_4@1

  v2 = a2;
  v3 = a1;
  putUChar(a1, BYTE3(a2));
  putUChar(v3, v2 >> 16);
  putUChar(v3, BYTE1(v2));
  return putUChar(v3, v2);
}

//----- (004D31C0) --------------------------------------------------------
char __thiscall getUChar(int this)
{
  return getSymbol((int)&bogusModel, this) - 1;
}

//----- (004D31F0) --------------------------------------------------------
int __thiscall getInt32(int this)
{
  int v1; // ST0C_4@1
  int v2; // ST10_4@1
  int v3; // ST10_4@1
  int v4; // ST10_4@1

  v1 = this;
  v2 = ((unsigned __int8)getUChar(this) << 24) | 0;
  v3 = ((unsigned __int8)getUChar(v1) << 16) | v2;
  v4 = ((unsigned __int8)getUChar(v1) << 8) | v3;
  return (unsigned __int8)getUChar(v1) | v4;
}

//----- (004D3260) --------------------------------------------------------
int __thiscall getUInt32(int this)
{
  int v1; // ST0C_4@1
  int v2; // ST10_4@1
  int v3; // ST10_4@1
  int v4; // ST10_4@1

  v1 = this;
  v2 = ((unsigned __int8)getUChar(this) << 24) | 0;
  v3 = ((unsigned __int8)getUChar(v1) << 16) | v2;
  v4 = ((unsigned __int8)getUChar(v1) << 8) | v3;
  return (unsigned __int8)getUChar(v1) | v4;
}

//----- (004D32D0) --------------------------------------------------------
int __cdecl initModels()
{
  initModel((int)&models, (int)"basis", 11, 12, 1000);
  initModel((int)&unk_535C24, (int)"2-3", 2, 4, 1000);
  initModel((int)&unk_536048, (int)"4-7", 4, 3, 1000);
  initModel((int)&unk_53646C, (int)"8-15", 8, 3, 1000);
  initModel((int)&unk_536890, (int)"16-31", 16, 3, 1000);
  initModel((int)&unk_536CB4, (int)"32-63", 32, 3, 1000);
  initModel((int)&unk_5370D8, (int)"64-127", 64, 2, 1000);
  return initModel((int)&unk_5374FC, (int)"128-255", 128, 1, 1000);
}

//----- (004D33B0) --------------------------------------------------------
void __cdecl dumpAllModelStats()
{
  dumpModelStats(&bogusModel);
  dumpModelStats(&models);
  dumpModelStats(&unk_535C24);
  dumpModelStats(&unk_536048);
  dumpModelStats(&unk_53646C);
  dumpModelStats(&unk_536890);
  dumpModelStats(&unk_536CB4);
  dumpModelStats(&unk_5370D8);
  dumpModelStats(&unk_5374FC);
}

//----- (004D3430) --------------------------------------------------------
int __thiscall getMTFVal(int this)
{
  int v2; // [sp+Ch] [bp-Ch]@1
  int v3; // [sp+10h] [bp-8h]@1
  int v4; // [sp+14h] [bp-4h]@2

  v3 = this;
  v2 = getSymbol((int)&models, this) - 1;
  switch ( v2 )
  {
    case 10:
      v4 = 259;
      break;
    case 0:
      v4 = 257;
      break;
    case 1:
      v4 = 258;
      break;
    case 2:
      v4 = 1;
      break;
    case 3:
      v4 = getSymbol((int)&unk_535C24, v3) + 1;
      break;
    case 4:
      v4 = getSymbol((int)&unk_536048, v3) + 3;
      break;
    case 5:
      v4 = getSymbol((int)&unk_53646C, v3) + 7;
      break;
    case 6:
      v4 = getSymbol((int)&unk_536890, v3) + 15;
      break;
    case 7:
      v4 = getSymbol((int)&unk_536CB4, v3) + 31;
      break;
    case 8:
      v4 = getSymbol((int)&unk_5370D8, v3) + 63;
      break;
    default:
      v4 = getSymbol((int)&unk_5374FC, v3) + 127;
      break;
  }
  return v4;
}

//----- (004D3590) --------------------------------------------------------
void __fastcall sendMTFVal(void *a1, signed int a2)
{
  signed int v2; // [sp+Ch] [bp-8h]@1
  void *v3; // [sp+10h] [bp-4h]@1

  v2 = a2;
  v3 = a1;
  switch ( a2 )
  {
    case 257:
      putSymbol((int)&models, 1, a1);
      break;
    case 258:
      putSymbol((int)&models, 2, a1);
      break;
    case 259:
      putSymbol((int)&models, 11, a1);
      break;
    case 1:
      putSymbol((int)&models, 3, a1);
      break;
    default:
      if ( a2 < 2 || a2 > 3 )
      {
        if ( a2 < 4 || a2 > 7 )
        {
          if ( a2 < 8 || a2 > 15 )
          {
            if ( a2 < 16 || a2 > 31 )
            {
              if ( a2 < 32 || a2 > 63 )
              {
                if ( a2 < 64 || a2 > 127 )
                {
                  if ( a2 < 128 || a2 > 255 )
                  {
                    panic();
                  }
                  else
                  {
                    putSymbol((int)&models, 10, a1);
                    putSymbol((int)&unk_5374FC, v2 - 127, v3);
                  }
                }
                else
                {
                  putSymbol((int)&models, 9, a1);
                  putSymbol((int)&unk_5370D8, v2 - 63, v3);
                }
              }
              else
              {
                putSymbol((int)&models, 8, a1);
                putSymbol((int)&unk_536CB4, v2 - 31, v3);
              }
            }
            else
            {
              putSymbol((int)&models, 7, a1);
              putSymbol((int)&unk_536890, v2 - 15, v3);
            }
          }
          else
          {
            putSymbol((int)&models, 6, a1);
            putSymbol((int)&unk_53646C, v2 - 7, v3);
          }
        }
        else
        {
          putSymbol((int)&models, 5, a1);
          putSymbol((int)&unk_536048, v2 - 3, v3);
        }
      }
      else
      {
        putSymbol((int)&models, 4, a1);
        putSymbol((int)&unk_535C24, v2 - 1, v3);
      }
      break;
  }
}

//----- (004D3810) --------------------------------------------------------
void __cdecl FreeCompressStructures()
{
  if ( words )
    BaseFree(words, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1121);
  if ( ftab )
    BaseFree(ftab, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1122);
  if ( zptr )
    BaseFree(zptr, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1123);
  words = 0;
  ftab = 0;
  zptr = 0;
}

//----- (004D38B0) --------------------------------------------------------
void __cdecl allocateCompressStructures()
{
  int v0; // [sp+10h] [bp-4h]@1

  v0 = 100000 * blockSize100k;
  FreeCompressStructures();
  words = BaseAlloc(4 * v0 + 65, "F:\\h2xsrc\\Base\\Bzip.cpp", 1141);
  zptr = BaseAlloc(4 * v0 + 1, "F:\\h2xsrc\\Base\\Bzip.cpp", 1142);
  ftab = BaseAlloc(0x40005u, "F:\\h2xsrc\\Base\\Bzip.cpp", 1143);
  if ( !words || !zptr || !ftab )
    compressOutOfMemory(8 * v0 + 262212, v0);
}
// 537934: using guessed type int blockSize100k;

//----- (004D3980) --------------------------------------------------------
void __cdecl FreeDecompressStructures()
{
  if ( block )
    BaseFree(block, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1161);
  if ( ll )
    BaseFree(ll, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1162);
  if ( zptr )
    BaseFree(zptr, (int)"F:\\h2xsrc\\Base\\Bzip.cpp", 1163);
  block = 0;
  ll = 0;
  zptr = 0;
}

//----- (004D3A20) --------------------------------------------------------
void __fastcall setDecompressStructureSizes(int a1)
{
  int v1; // [sp+Ch] [bp-Ch]@1

  v1 = a1;
  if ( a1 != blockSize100k )
  {
    blockSize100k = a1;
    FreeDecompressStructures();
    if ( v1 )
    {
      block = BaseAlloc(100000 * v1 + 1, "F:\\h2xsrc\\Base\\Bzip.cpp", 1185);
      ll = BaseAlloc(100000 * v1 + 1, "F:\\h2xsrc\\Base\\Bzip.cpp", 1186);
      zptr = BaseAlloc(400000 * v1 + 1, "F:\\h2xsrc\\Base\\Bzip.cpp", 1187);
      if ( !block || !ll || !zptr )
        uncompressOutOfMemory(600000 * v1, 100000 * v1);
    }
  }
}
// 537934: using guessed type int blockSize100k;

//----- (004D3B10) --------------------------------------------------------
int __fastcall GETALL(int a1)
{
  return *((_DWORD *)words + a1);
}

//----- (004D3B40) --------------------------------------------------------
int __fastcall SETREST16(int a1, unsigned __int16 a2)
{
  int result; // eax@1

  result = a2 | *((_DWORD *)words + a1) & 0xFFFF0000;
  *((_DWORD *)words + a1) = result;
  return result;
}

//----- (004D3B90) --------------------------------------------------------
int __fastcall SETFIRST(int a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int result; // eax@1

  v2 = *((_DWORD *)words + a1);
  result = (a2 << 24) | v2 & 0xFFFFFF;
  *((_DWORD *)words + a1) = result;
  return result;
}

//----- (004D3BD0) --------------------------------------------------------
int __fastcall SETSECOND(int a1, unsigned __int8 a2)
{
  int result; // eax@1

  result = (a2 << 16) | *((_DWORD *)words + a1) & 0xFF00FFFF;
  *((_DWORD *)words + a1) = result;
  return result;
}

//----- (004D3C10) --------------------------------------------------------
int __fastcall SETTHIRD(int a1, unsigned __int8 a2)
{
  int result; // eax@1

  result = (a2 << 8) | *((_DWORD *)words + a1) & 0xFFFF00FF;
  *((_DWORD *)words + a1) = result;
  return result;
}

//----- (004D3C50) --------------------------------------------------------
int __fastcall SETFOURTH(int a1, unsigned __int8 a2)
{
  int result; // eax@1

  result = a2 | *((_DWORD *)words + a1) & 0xFFFFFF00;
  *((_DWORD *)words + a1) = result;
  return result;
}

//----- (004D3C90) --------------------------------------------------------
int __fastcall NORMALISEHI(int a1)
{
  int result; // eax@2

  if ( lastPP > a1 )
    result = a1;
  else
    result = a1 - lastPP;
  return result;
}
// 5347A0: using guessed type int lastPP;

//----- (004D3CD0) --------------------------------------------------------
int __fastcall NORMALISELO(int a1)
{
  int result; // eax@2

  if ( a1 < 0 )
    result = a1 + lastPP;
  else
    result = a1;
  return result;
}
// 5347A0: using guessed type int lastPP;

//----- (004D3D00) --------------------------------------------------------
void __fastcall sendZeroes(void *a1, signed int a2)
{
  signed int v2; // [sp+Ch] [bp-10h]@1
  signed int v3; // [sp+Ch] [bp-10h]@4
  void *v4; // [sp+10h] [bp-Ch]@1
  unsigned int v5; // [sp+14h] [bp-8h]@2
  int v6; // [sp+18h] [bp-4h]@2

  v2 = a2;
  v4 = a1;
  if ( a2 )
  {
    v5 = 0;
    v6 = 0;
    while ( v2 )
    {
      ++v6;
      v5 *= 2;
      v3 = v2 - 1;
      if ( v3 & 1 )
        v5 |= 1u;
      v2 = v3 >> 1;
    }
    while ( v6 > 0 )
    {
      if ( v5 & 1 )
        sendMTFVal(v4, 257);
      else
        sendMTFVal(v4, 258);
      v5 >>= 1;
      --v6;
    }
  }
}

//----- (004D3DA0) --------------------------------------------------------
void __fastcall moveToFrontCodeAndSend(void *a1, int a2)
{
  char v2; // ST18_1@11
  void *v3; // [sp+10h] [bp-11Ch]@1
  unsigned __int8 v4; // [sp+14h] [bp-118h]@9
  signed int v5; // [sp+1Ch] [bp-110h]@9
  signed int i; // [sp+20h] [bp-10Ch]@4
  int j; // [sp+20h] [bp-10Ch]@7
  char v8[256]; // [sp+24h] [bp-108h]@6
  unsigned __int8 v9; // [sp+124h] [bp-8h]@9
  int v10; // [sp+128h] [bp-4h]@1

  v3 = a1;
  v10 = 0;
  if ( a2 )
    putInt32(a1, -(origPtr + 1));
  else
    putInt32(a1, origPtr + 1);
  initModels();
  for ( i = 0; i <= 255; ++i )
    v8[i] = i;
  for ( j = 0; last >= j; ++j )
  {
    v4 = *((_DWORD *)words + NORMALISELO(*((_DWORD *)zptr + j) - 1)) >> 24;
    v5 = 0;
    v9 = v8[0];
    while ( v9 != v4 )
    {
      ++v5;
      v2 = v9;
      v9 = v8[v5];
      v8[v5] = v2;
    }
    v8[0] = v9;
    if ( v5 )
    {
      sendZeroes(v3, v10);
      v10 = 0;
      sendMTFVal(v3, v5);
    }
    else
    {
      ++v10;
    }
  }
  sendZeroes(v3, v10);
  sendMTFVal(v3, 259);
}
// 5347A4: using guessed type int last;
// 537930: using guessed type int origPtr;
// 4D3DA0: using guessed type char var_108[256];

//----- (004D3F60) --------------------------------------------------------
bool __thiscall getAndMoveToFrontDecode(int this)
{
  int v2; // [sp+Ch] [bp-11Ch]@1
  int v3; // [sp+10h] [bp-118h]@15
  int v4; // [sp+10h] [bp-118h]@16
  int v5; // [sp+14h] [bp-114h]@7
  signed int j; // [sp+18h] [bp-110h]@29
  int v7; // [sp+1Ch] [bp-10Ch]@1
  signed int i; // [sp+20h] [bp-108h]@4
  int v9; // [sp+24h] [bp-104h]@1
  char v10[256]; // [sp+28h] [bp-100h]@6

  v2 = this;
  v7 = 100000 * blockSize100k;
  v9 = getInt32(this);
  if ( v9 >= 0 )
    origPtr = v9 - 1;
  else
    origPtr = -v9 - 1;
  initModels();
  for ( i = 0; i <= 255; ++i )
    v10[i] = i;
  last = -1;
  v5 = getMTFVal(v2);
  while ( v5 != 259 )
  {
    if ( v5 != 257 && v5 != 258 )
    {
      if ( v5 < 1 || v5 > 255 )
      {
        sprintf(gText, "bad MTF value %d\n", v5);
        LogStr(gText);
        panic();
        return 1;
      }
      ++last;
      if ( last >= v7 )
        blockOverrun();
      *((_BYTE *)ll + last) = v10[v5];
      for ( j = v5; j > 3; j -= 4 )
      {
        v10[j] = *((_BYTE *)&v9 + j + 3);
        *((_BYTE *)&v9 + j + 3) = *((_BYTE *)&v9 + j + 2);
        *((_BYTE *)&v9 + j + 2) = *((_BYTE *)&v9 + j + 1);
        *((_BYTE *)&v9 + j + 1) = *((_BYTE *)&v9 + j);
      }
      while ( j > 0 )
      {
        v10[j] = *((_BYTE *)&v9 + j + 3);
        --j;
      }
      v10[0] = *((_BYTE *)ll + last);
      v5 = getMTFVal(v2);
    }
    else
    {
      v3 = 0;
      do
      {
        v4 = 2 * v3;
        if ( v5 == 257 )
          v4 |= 1u;
        v3 = v4 + 1;
        v5 = getMTFVal(v2);
      }
      while ( v5 == 257 || v5 == 258 );
      while ( v3 > 0 )
      {
        ++last;
        if ( last >= v7 )
          blockOverrun();
        *((_BYTE *)ll + last) = v10[0];
        --v3;
      }
    }
  }
  return v9 < 0;
}
// 5347A4: using guessed type int last;
// 537930: using guessed type int origPtr;
// 537934: using guessed type int blockSize100k;
// 4D3F60: using guessed type char var_100[256];

//----- (004D42B0) --------------------------------------------------------
int __cdecl stripe()
{
  int result; // eax@2
  unsigned __int8 v1; // ST0C_1@3
  int v2; // eax@3
  int v3; // eax@3
  int v4; // eax@3
  int i; // [sp+10h] [bp-4h]@1

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( lastPP <= i )
      break;
    v1 = *((_DWORD *)words + i) >> 24;
    v2 = NORMALISELO(i - 1);
    SETSECOND(v2, v1);
    v3 = NORMALISELO(i - 2);
    SETTHIRD(v3, v1);
    v4 = NORMALISELO(i - 3);
    SETFOURTH(v4, v1);
  }
  return result;
}
// 5347A0: using guessed type int lastPP;

//----- (004D4340) --------------------------------------------------------
int __cdecl copyOffsetWords()
{
  int result; // eax@3
  signed int i; // [sp+Ch] [bp-4h]@1

  for ( i = 0; i < 16; ++i )
  {
    result = *((_DWORD *)words + i);
    *((_DWORD *)words + i + lastPP) = result;
  }
  return result;
}
// 5347A0: using guessed type int lastPP;

//----- (004D4390) --------------------------------------------------------
bool __fastcall fullGt(int a1, int a2)
{
  bool result; // eax@2
  int v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+Ch] [bp-14h]@5
  int v5; // [sp+Ch] [bp-14h]@7
  int v6; // [sp+Ch] [bp-14h]@9
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+10h] [bp-10h]@5
  int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+10h] [bp-10h]@9
  int v11; // [sp+14h] [bp-Ch]@3
  int v12; // [sp+14h] [bp-Ch]@5
  int v13; // [sp+14h] [bp-Ch]@7
  int v14; // [sp+14h] [bp-Ch]@9
  int v15; // [sp+18h] [bp-8h]@3
  int v16; // [sp+18h] [bp-8h]@5
  int v17; // [sp+18h] [bp-8h]@7
  int v18; // [sp+18h] [bp-8h]@9
  int v19; // [sp+1Ch] [bp-4h]@1

  v3 = a2;
  v7 = a1;
  v19 = a1;
  if ( a2 == a1 )
  {
    result = 0;
  }
  else
  {
    do
    {
      v15 = GETALL(v7);
      v11 = GETALL(v3);
      if ( v11 != v15 )
        return v11 < (unsigned int)v15;
      v8 = v7 + 4;
      v4 = v3 + 4;
      v16 = GETALL(v8);
      v12 = GETALL(v4);
      if ( v12 != v16 )
        return v12 < (unsigned int)v16;
      v9 = v8 + 4;
      v5 = v4 + 4;
      v17 = GETALL(v9);
      v13 = GETALL(v5);
      if ( v13 != v17 )
        return v13 < (unsigned int)v17;
      v10 = v9 + 4;
      v6 = v5 + 4;
      v18 = GETALL(v10);
      v14 = GETALL(v6);
      if ( v14 != v18 )
        return v14 < (unsigned int)v18;
      v7 = NORMALISEHI(v10 + 4);
      v3 = NORMALISEHI(v6 + 4);
    }
    while ( v7 != v19 );
    result = 0;
  }
  return result;
}

//----- (004D4510) --------------------------------------------------------
int __fastcall qsortFull(int a1, int a2)
{
  int v2; // ST58_4@4
  int v3; // ST54_4@4
  int v4; // ST4C_4@6
  int v5; // ST48_4@6
  int v6; // ST40_4@8
  int v7; // ST3C_4@8
  int v8; // ST34_4@9
  int v9; // ST30_4@9
  int v10; // ST28_4@13
  int v11; // ST24_4@13
  int v12; // ST1C_4@14
  int v13; // ST18_4@14
  int result; // eax@19
  int v15[40]; // [sp+5Ch] [bp-160h]@15
  int v16; // [sp+FCh] [bp-C0h]@9
  int v17; // [sp+100h] [bp-BCh]@9
  int j; // [sp+104h] [bp-B8h]@9
  int v19; // [sp+108h] [bp-B4h]@3
  int i; // [sp+10Ch] [bp-B0h]@1
  int v21; // [sp+110h] [bp-ACh]@20
  int v22[40]; // [sp+114h] [bp-A8h]@15
  int v23; // [sp+1B4h] [bp-8h]@1
  int v24; // [sp+1B8h] [bp-4h]@1

  v23 = 0;
  v24 = a1;
  for ( i = a2; ; i = v15[v23] )
  {
    while ( i - v24 > 10 )
    {
      v19 = (v24 + i) >> 1;
      if ( fullGt(*((_DWORD *)zptr + v24), *((_DWORD *)zptr + ((v24 + i) >> 1))) )
      {
        v2 = v19;
        v3 = *((_DWORD *)zptr + v24);
        *((_DWORD *)zptr + v24) = *((_DWORD *)zptr + v19);
        *((_DWORD *)zptr + v2) = v3;
      }
      if ( fullGt(*((_DWORD *)zptr + v24), *((_DWORD *)zptr + i)) )
      {
        v4 = i;
        v5 = *((_DWORD *)zptr + v24);
        *((_DWORD *)zptr + v24) = *((_DWORD *)zptr + i);
        *((_DWORD *)zptr + v4) = v5;
      }
      if ( fullGt(*((_DWORD *)zptr + v19), *((_DWORD *)zptr + i)) )
      {
        v6 = i;
        v7 = *((_DWORD *)zptr + v19);
        *((_DWORD *)zptr + v19) = *((_DWORD *)zptr + i);
        *((_DWORD *)zptr + v6) = v7;
      }
      v8 = i - 1;
      v9 = *((_DWORD *)zptr + v19);
      *((_DWORD *)zptr + v19) = *((_DWORD *)zptr + i - 1);
      *((_DWORD *)zptr + v8) = v9;
      v16 = *((_DWORD *)zptr + i - 1);
      j = v24;
      v17 = i - 1;
      while ( 1 )
      {
        do
          ++j;
        while ( fullGt(v16, *((_DWORD *)zptr + j)) );
        do
          --v17;
        while ( fullGt(*((_DWORD *)zptr + v17), v16) );
        if ( v17 <= j )
          break;
        v10 = v17;
        v11 = *((_DWORD *)zptr + j);
        *((_DWORD *)zptr + j) = *((_DWORD *)zptr + v17);
        *((_DWORD *)zptr + v10) = v11;
      }
      v12 = i - 1;
      v13 = *((_DWORD *)zptr + j);
      *((_DWORD *)zptr + j) = *((_DWORD *)zptr + i - 1);
      *((_DWORD *)zptr + v12) = v13;
      if ( i - j >= j - v24 )
      {
        v22[v23] = j + 1;
        v15[v23++] = i;
        i = j - 1;
      }
      else
      {
        v22[v23] = v24;
        v15[v23++] = j - 1;
        v24 = j + 1;
      }
    }
    for ( j = v24 + 1; ; ++j )
    {
      result = j;
      if ( i < j )
        break;
      v21 = *((_DWORD *)zptr + j);
      v17 = j;
      do
      {
        if ( !fullGt(*((_DWORD *)zptr + v17 - 1), v21) )
          break;
        *((_DWORD *)zptr + v17) = *((_DWORD *)zptr + v17 - 1);
        --v17;
      }
      while ( v24 < v17 );
      *((_DWORD *)zptr + v17) = v21;
    }
    if ( !v23 )
      break;
    --v23;
    v24 = v22[v23];
  }
  return result;
}
// 4D4510: using guessed type int var_A8[40];
// 4D4510: using guessed type int var_160[40];

//----- (004D4A50) --------------------------------------------------------
bool __fastcall trivialGt(int a1, int a2)
{
  int v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+10h] [bp-10h]@1
  unsigned __int8 v5; // [sp+14h] [bp-Ch]@3
  unsigned __int8 v6; // [sp+18h] [bp-8h]@3
  int i; // [sp+1Ch] [bp-4h]@1

  v3 = a2;
  v4 = a1;
  for ( i = 0; last >= i; ++i )
  {
    v6 = *((_DWORD *)words + v4) >> 24;
    v5 = *((_DWORD *)words + v3) >> 24;
    if ( v5 != v6 )
      return v5 < (signed int)v6;
    v4 = NORMALISEHI(v4 + 1);
    v3 = NORMALISEHI(v3 + 1);
  }
  return 0;
}
// 5347A4: using guessed type int last;

//----- (004D4B10) --------------------------------------------------------
int __cdecl shellTrivial()
{
  int result; // eax@4
  int v1; // [sp+14h] [bp-14h]@5
  int i; // [sp+18h] [bp-10h]@3
  signed int v3; // [sp+1Ch] [bp-Ch]@1
  int v4; // [sp+20h] [bp-8h]@1
  int v5; // [sp+24h] [bp-4h]@5

  v4 = last;
  v3 = 1;
  do
    v3 = 3 * v3 + 1;
  while ( v3 <= last + 1 );
  do
  {
    v3 /= 3;
    for ( i = v3; ; ++i )
    {
      result = i;
      if ( v4 < i )
        break;
      v5 = *((_DWORD *)zptr + i);
      v1 = i;
      do
      {
        if ( !trivialGt(*((_DWORD *)zptr + v1 - v3), v5) )
          break;
        *((_DWORD *)zptr + v1) = *((_DWORD *)zptr + v1 - v3);
        v1 -= v3;
      }
      while ( v3 - 1 < v1 );
      *((_DWORD *)zptr + v1) = v5;
    }
  }
  while ( v3 != 1 );
  return result;
}
// 5347A4: using guessed type int last;

//----- (004D4C20) --------------------------------------------------------
void __cdecl sortIt()
{
  unsigned int v0; // eax@23
  int v1; // [sp+10h] [bp-38h]@45
  unsigned __int16 v2; // [sp+14h] [bp-34h]@43
  int v3; // [sp+18h] [bp-30h]@43
  int v4; // [sp+1Ch] [bp-2Ch]@40
  int v5; // [sp+20h] [bp-28h]@40
  int v6; // [sp+24h] [bp-24h]@38
  signed int v7; // [sp+28h] [bp-20h]@0
  signed int v8; // [sp+2Ch] [bp-1Ch]@0
  int v9; // [sp+30h] [bp-18h]@36
  signed int m; // [sp+38h] [bp-10h]@24
  int v11; // [sp+3Ch] [bp-Ch]@24
  signed int i; // [sp+40h] [bp-8h]@12
  int j; // [sp+40h] [bp-8h]@15
  signed int k; // [sp+40h] [bp-8h]@18
  int l; // [sp+40h] [bp-8h]@21
  signed int n; // [sp+40h] [bp-8h]@36
  int ii; // [sp+44h] [bp-4h]@4

  lastPP = last + 1;
  if ( last + 1 > 1024 )
  {
    stripe();
    if ( veryVerbose )
    {
      sprintf(gText, "bucket sorting ...\n");
      LogStr(gText);
    }
    for ( i = 0; i <= 65536; ++i )
      *((_DWORD *)ftab + i) = 0;
    for ( j = 0; last >= j; ++j )
      ++*((_DWORD *)ftab + (*((_DWORD *)words + j) >> 16));
    for ( k = 1; k <= 65536; ++k )
      *((_DWORD *)ftab + k) += *((_DWORD *)ftab + k - 1);
    for ( l = 0; last >= l; ++l )
    {
      v0 = *((_DWORD *)words + l);
      --*((_DWORD *)ftab + (v0 >> 16));
      *((_DWORD *)zptr + *((_DWORD *)ftab + (v0 >> 16))) = l;
    }
    copyOffsetWords();
    v11 = lastPP;
    for ( m = 1; m <= 5; ++m )
    {
      switch ( m )
      {
        case 1:
          v8 = 2;
          v7 = 15;
          break;
        case 2:
          v8 = 16;
          v7 = 255;
          break;
        case 3:
          v8 = 256;
          v7 = 4095;
          break;
        case 4:
          v8 = 4096;
          v7 = 65535;
          break;
        case 5:
          v8 = 65536;
          v7 = 900000;
          break;
        default:
          panic();
          break;
      }
      if ( v8 <= lastPP )
      {
        v9 = 0;
        for ( n = 0; n <= 65535; ++n )
        {
          v6 = *((_DWORD *)ftab + n + 1) - *((_DWORD *)ftab + n);
          if ( v6 >= v8 && v7 >= v6 )
          {
            v4 = *((_DWORD *)ftab + n);
            v5 = *((_DWORD *)ftab + n + 1) - 1;
            ++v9;
            v11 -= v6;
            if ( veryVerbose )
            {
              sprintf(gText, "   %d -> %d:  cand %5d,   freq = %6d,   notdone = %6d", v8, v7, v9, v6, v11);
              LogStr(gText);
            }
            qsortFull(v4, v5);
            if ( v6 < 65535 )
            {
              v3 = v4;
              v2 = 0;
              while ( v5 >= v3 )
              {
                v1 = *((_DWORD *)zptr + v3);
                SETREST16(v1, v2);
                if ( v1 < 16 )
                  SETREST16(v1 + lastPP, v2);
                ++v3;
                ++v2;
              }
            }
            if ( veryVerbose )
            {
              sprintf(gText, L" ");
              LogStr(gText);
            }
          }
        }
      }
    }
  }
  else
  {
    if ( veryVerbose )
    {
      sprintf(gText, "trivialSort ...\n");
      LogStr(gText);
    }
    for ( ii = 0; ii <= last; ++ii )
      *((_DWORD *)zptr + ii) = ii;
    shellTrivial();
    if ( veryVerbose )
    {
      sprintf(gText, "trivialSort done.\n");
      LogStr(gText);
    }
  }
}
// 5347A0: using guessed type int lastPP;
// 5347A4: using guessed type int last;
// 537920: using guessed type int veryVerbose;

//----- (004D5060) --------------------------------------------------------
void __cdecl doReversibleTransformation()
{
  int i; // [sp+Ch] [bp-4h]@3

  if ( veryVerbose )
  {
    sprintf(gText, L" ");
    LogStr(gText);
  }
  sortIt();
  origPtr = -1;
  for ( i = 0; last >= i; ++i )
  {
    if ( !*((_DWORD *)zptr + i) )
    {
      origPtr = i;
      break;
    }
  }
  if ( origPtr == -1 )
    panic();
}
// 5347A4: using guessed type int last;
// 537920: using guessed type int veryVerbose;
// 537930: using guessed type int origPtr;

//----- (004D5110) --------------------------------------------------------
int __cdecl undoReversibleTransformation()
{
  unsigned __int8 v0; // ST10_1@6
  int result; // eax@10
  unsigned __int8 v2; // ST0C_1@12
  int l; // [sp+14h] [bp-410h]@10
  signed int k; // [sp+18h] [bp-40Ch]@7
  signed int i; // [sp+1Ch] [bp-408h]@1
  int j; // [sp+1Ch] [bp-408h]@4
  int v7; // [sp+1Ch] [bp-408h]@10
  int v8[256]; // [sp+20h] [bp-404h]@3
  int v9; // [sp+420h] [bp-4h]@7

  for ( i = 0; i <= 255; ++i )
    v8[i] = 0;
  for ( j = 0; j <= last; ++j )
  {
    v0 = *((_BYTE *)ll + j);
    *((_DWORD *)zptr + j) = v8[v0]++;
  }
  v9 = 0;
  for ( k = 0; k <= 255; ++k )
  {
    v9 += v8[k];
    v8[k] = v9 - v8[k];
  }
  v7 = origPtr;
  result = last;
  for ( l = last; l >= 0; --l )
  {
    v2 = *((_BYTE *)ll + v7);
    *((_BYTE *)block + l) = v2;
    result = *((_DWORD *)zptr + v7) + v8[v2];
    v7 = *((_DWORD *)zptr + v7) + v8[v2];
  }
  return result;
}
// 5347A4: using guessed type int last;
// 537930: using guessed type int origPtr;
// 4D5110: using guessed type int var_404[256];

//----- (004D52B0) --------------------------------------------------------
int __thiscall spotBlock(void *this)
{
  int result; // eax@2
  void *v2; // [sp+10h] [bp-14h]@1
  int v3; // [sp+14h] [bp-10h]@4
  int v4; // [sp+18h] [bp-Ch]@1
  signed int v5; // [sp+1Ch] [bp-8h]@1
  signed int v6; // [sp+20h] [bp-4h]@17

  v2 = this;
  v4 = 8000;
  v5 = 1;
  while ( 1 )
  {
    result = v4;
    if ( last <= v4 )
      break;
    if ( v2 )
      v3 = (unsigned __int8)(*((_DWORD *)words + v4) >> 24) + 1;
    else
      v3 = *((_BYTE *)block + v4) - 1;
    if ( v3 == 256 )
    {
      v3 = 0;
    }
    else if ( v3 == -1 )
    {
      v3 = 255;
    }
    if ( v3 < 0 || v3 > 255 )
      panic();
    if ( v2 )
      SETFIRST(v4, v3);
    else
      *((_BYTE *)block + v4) = v3;
    switch ( v5 )
    {
      case 3:
        v6 = 1;
        break;
      case 1:
        v6 = 4;
        break;
      case 4:
        v6 = 5;
        break;
      case 5:
        v6 = 9;
        break;
      case 9:
        v6 = 2;
        break;
      case 2:
        v6 = 6;
        break;
      case 6:
        v6 = 7;
        break;
      case 8:
        v6 = 8;
        break;
      case 7:
        v6 = 3;
        break;
      default:
        v6 = 1;
        break;
    }
    v5 = v6;
    v4 += 17 * (v6 - 5) + 8000;
  }
  return result;
}
// 5347A4: using guessed type int last;

//----- (004D5480) --------------------------------------------------------
int __thiscall getRLEpair(FILE *this)
{
  int result; // eax@4
  int v2; // [sp+Ch] [bp-14h]@1
  signed int i; // [sp+10h] [bp-10h]@16
  signed int v4; // [sp+14h] [bp-Ch]@5
  signed int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@6

  v2 = (int)this;
  v5 = getc((int)this);
  if ( v5 == -1 )
  {
    if ( *_errno() )
      ioError();
    result = 65793;
  }
  else
  {
    v4 = 0;
    do
    {
      v6 = getc(v2);
      ++v4;
      ++bytesIn;
    }
    while ( v6 == v5 && v4 < 255 );
    if ( v6 == -1 )
    {
      if ( *_errno() )
        ioError();
    }
    else if ( ungetc(v6, v2) == -1 )
    {
      panic();
    }
    if ( v4 == 1 )
    {
      globalCrc = (globalCrc << 8) ^ crc32Table[((unsigned int)globalCrc >> 24) ^ (unsigned __int8)v5];
      result = v5 | 0x10000;
    }
    else
    {
      for ( i = 1; i <= v4; ++i )
        globalCrc = (globalCrc << 8) ^ crc32Table[((unsigned int)globalCrc >> 24) ^ (unsigned __int8)v5];
      result = v5 | (v4 << 16);
    }
  }
  return result;
}
// 51F9C0: using guessed type int crc32Table[];
// 5347A8: using guessed type int bytesIn;
// 53792C: using guessed type int globalCrc;

//----- (004D55E0) --------------------------------------------------------
bool __thiscall loadAndRLEsource(void *this)
{
  void *v2; // [sp+10h] [bp-14h]@1
  int v3; // [sp+14h] [bp-10h]@4
  unsigned int v4; // [sp+18h] [bp-Ch]@4
  int v5; // [sp+1Ch] [bp-8h]@1
  int v6; // [sp+20h] [bp-4h]@1

  v2 = this;
  last = -1;
  v5 = 0;
  v6 = 100000 * blockSize100k - 20;
  while ( v6 > last && v5 != 257 )
  {
    v3 = getRLEpair((FILE *)v2);
    v5 = (unsigned __int16)v3;
    v4 = (unsigned int)v3 >> 16;
    if ( (unsigned __int16)v3 == 257 )
    {
      ++last;
      SETFIRST(last, 0x2Au);
    }
    else
    {
      switch ( v4 )
      {
        case 1u:
          ++last;
          SETFIRST(last, v3);
          break;
        case 2u:
          ++last;
          SETFIRST(last++, v3);
          SETFIRST(last, v3);
          break;
        case 3u:
          ++last;
          SETFIRST(last++, v3);
          SETFIRST(last++, v3);
          SETFIRST(last, v3);
          break;
        default:
          ++last;
          SETFIRST(last++, v3);
          SETFIRST(last++, v3);
          SETFIRST(last++, v3);
          SETFIRST(last++, v3);
          SETFIRST(last, v4 - 4);
          break;
      }
    }
  }
  return v5 == 257;
}
// 5347A4: using guessed type int last;
// 537934: using guessed type int blockSize100k;

//----- (004D57D0) --------------------------------------------------------
void __fastcall unRLEandDump(FILE *a1, int a2)
{
  int v2; // [sp+Ch] [bp-28h]@1
  int v3; // [sp+10h] [bp-24h]@1
  signed int i; // [sp+14h] [bp-20h]@11
  signed int v5; // [sp+1Ch] [bp-18h]@4
  int v6; // [sp+20h] [bp-14h]@4
  signed int v7; // [sp+24h] [bp-10h]@6
  int v8; // [sp+28h] [bp-Ch]@4
  signed int v9; // [sp+2Ch] [bp-8h]@4
  int v10; // [sp+30h] [bp-4h]@2

  v2 = a2;
  v3 = (int)a1;
  if ( a2 )
    v10 = last - 1;
  else
    v10 = last;
  v9 = 0;
  v6 = 0;
  v5 = 256;
  v8 = getGlobalCRC();
  while ( v6 <= v10 )
  {
    v7 = v5;
    v5 = *((_BYTE *)block + v6++);
    if ( putc(v5, v3) == -1 )
      ioError();
    v8 = (v8 << 8) ^ crc32Table[((unsigned int)v8 >> 24) ^ (unsigned __int8)v5];
    if ( v5 == v7 )
    {
      ++v9;
      if ( v9 >= 4 )
      {
        for ( i = 0; *((_BYTE *)block + v6) > i; ++i )
        {
          if ( putc(v5, v3) == -1 )
            ioError();
          v8 = (v8 << 8) ^ crc32Table[((unsigned int)v8 >> 24) ^ (unsigned __int8)v5];
        }
        ++v6;
        v9 = 0;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  setGlobalCRC((void *)v8);
  if ( v2 && *((_BYTE *)block + last) != 42 )
    unblockError();
}
// 51F9C0: using guessed type int crc32Table[];
// 5347A4: using guessed type int last;

//----- (004D5960) --------------------------------------------------------
void __fastcall compressStream(int a1, void *a2)
{
  int v2; // ST60_4@4
  int v3; // [sp+48h] [bp-18h]@1
  int v4; // [sp+50h] [bp-10h]@1
  signed int v5; // [sp+54h] [bp-Ch]@1
  signed int v6; // [sp+5Ch] [bp-4h]@5

  v3 = a1;
  v5 = 1;
  bytesIn = 0;
  bytesOut = 0;
  v4 = (int)bsOpenWriteStream(a2);
  bsPutUChar(v4, 0x42u);
  bsPutUChar(v4, 0x5Au);
  bsPutUChar(v4, 0x30u);
  bsPutUChar(v4, blockSize100k + 48);
  initialiseCRC();
  initBogusModel();
  arithCodeStartEncoding();
  do
  {
    if ( veryVerbose )
    {
      sprintf(gText, "\nBEGIN block %d\n", v5);
      LogStr(gText);
    }
    ++v5;
    v2 = loadAndRLEsource((void *)v3);
    spotBlock((void *)1);
    doReversibleTransformation();
    moveToFrontCodeAndSend((void *)v4, v2);
  }
  while ( !v2 );
  v6 = getFinalCRC();
  putUInt32((void *)v4, v6);
  if ( veryVerbose )
  {
    sprintf(gText, "\nCRC = 0x%x\n", v6);
    LogStr(gText);
  }
  arithCodeDoneEncoding((void *)v4);
  bsClose((void *)v4);
  if ( *(_BYTE *)(v3 + 12) & 0x20 )
    ioError();
  if ( fclose(v3) == -1 )
    ioError();
  if ( veryVerbose )
  {
    sprintf(gText, L" ");
    LogStr(gText);
    dumpAllModelStats();
    sprintf(gText, L" ");
    LogStr(gText);
  }
  if ( !bytesIn )
    bytesIn = 1;
  if ( !bytesOut )
    bytesOut = 1;
  if ( dword_5357FC )
  {
    sprintf(
      gText,
      "%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %d in, %d out.\n",
      (double)bytesIn / (double)bytesOut,
      (double)bytesOut * 8.0 / (double)bytesIn,
      (1.0 - (double)bytesOut / (double)bytesIn) * 100.0,
      bytesIn,
      bytesOut);
    LogStr(gText);
  }
  if ( veryVerbose )
  {
    sprintf(gText, L"\n");
    LogStr(gText);
  }
}
// 5347A8: using guessed type int bytesIn;
// 534BDC: using guessed type int bytesOut;
// 5357FC: using guessed type int dword_5357FC;
// 537920: using guessed type int veryVerbose;
// 537934: using guessed type int blockSize100k;

//----- (004D5C10) --------------------------------------------------------
signed int __fastcall uncompressStream(void *a1, int a2)
{
  int v2; // ST30_4@1
  signed int result; // eax@8
  int v4; // [sp+Ch] [bp-30h]@1
  signed int v5; // [sp+14h] [bp-28h]@1
  int v6; // [sp+18h] [bp-24h]@1
  int v7; // [sp+24h] [bp-18h]@1
  int v8; // [sp+28h] [bp-14h]@1
  int v9; // [sp+2Ch] [bp-10h]@14
  int v10; // [sp+30h] [bp-Ch]@23
  int v11; // [sp+34h] [bp-8h]@11
  int v12; // [sp+38h] [bp-4h]@23

  v4 = a2;
  v6 = (int)bsOpenReadStream(a1);
  v2 = (unsigned __int8)bsGetUChar((void *)v6);
  v8 = (unsigned __int8)bsGetUChar((void *)v6);
  v7 = (unsigned __int8)bsGetUChar((void *)v6);
  v5 = (unsigned __int8)bsGetUChar((void *)v6);
  if ( v2 == 66 && v8 == 90 && v7 == 48 && v5 >= 49 && v5 <= 57 )
  {
    setDecompressStructureSizes(v5 - 48);
    initialiseCRC();
    initBogusModel();
    arithCodeStartDecoding((void *)v6);
    if ( veryVerbose )
    {
      sprintf(gText, "  ");
      LogStr(gText);
    }
    v11 = 0;
    do
    {
      ++v11;
      if ( veryVerbose )
      {
        sprintf(gText, "[%d: ac+mtf ", v11);
        LogStr(gText);
      }
      v9 = getAndMoveToFrontDecode(v6);
      if ( veryVerbose )
        LogStr("rt ");
      undoReversibleTransformation();
      spotBlock(0);
      if ( veryVerbose )
        LogStr("rld");
      unRLEandDump((FILE *)v4, v9);
      if ( veryVerbose )
        LogStr("] ");
    }
    while ( !v9 );
    if ( veryVerbose )
      LogStr(L" ");
    v10 = getUInt32(v6);
    v12 = getFinalCRC();
    if ( veryVerbose )
    {
      sprintf(gText, "CRCs: stored = 0x%x, computed = 0x%x\n  ", v10, v12);
      LogStr(gText);
    }
    if ( v12 != v10 )
      crcError(v10, v12);
    arithCodeDoneDecoding();
    bsClose((void *)v6);
    if ( *(_BYTE *)(v4 + 12) & 0x20 )
      ioError();
    if ( fclose(v4) == -1 )
      ioError();
    FreeDecompressStructures();
    result = 1;
  }
  else
  {
    bsClose((void *)v6);
    if ( fclose(v4) == -1 )
      ioError();
    FreeDecompressStructures();
    result = 0;
  }
  return result;
}
// 537920: using guessed type int veryVerbose;

//----- (004D5EC0) --------------------------------------------------------
void __fastcall crcError(int a1, int a2)
{
  sprintf(
    gText,
    "\n%s: Data integrity error when decompressing.\n\tStored CRC = 0x%x, computed CRC = 0x%x\n\tThis could be a bug -- please report it to me at:\n\tsewardj@cs.man.ac.uk.\n",
    progName,
    a1,
    a2);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D5F10) --------------------------------------------------------
void __cdecl compressedStreamEOF()
{
  sprintf(
    gText,
    "\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
    progName);
  LogStr(gText);
  perror(progName);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D5F60) --------------------------------------------------------
void __cdecl ioError()
{
  sprintf(gText, "\n%s: I/O or other error, bailing out.  Possible reason follows.\n", progName);
  LogStr(gText);
  perror(progName);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D5FB0) --------------------------------------------------------
void __cdecl blockOverrun()
{
  sprintf(
    gText,
    "\n%s: block overrun during decompression,\n\twhich probably means the compressed file\n\tis corrupted.\n",
    progName);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D5FF0) --------------------------------------------------------
void __cdecl unblockError()
{
  sprintf(gText, "\n%s: compressed file didn't unblock correctly,\n\twhich probably means it is corrupted.\n", progName);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D6030) --------------------------------------------------------
void __cdecl bitStreamEOF()
{
  sprintf(gText, "\n%s: read past the end of compressed data,\n\twhich probably means it is corrupted.\n", progName);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D6070) --------------------------------------------------------
void __fastcall uncompressOutOfMemory(int a1, int a2)
{
  sprintf(
    gText,
    "\n%s: Can't allocate enough memory for decompression.\n\tRequested %d bytes for a block size of %d.\n\tFind a machine with more memory, perhaps?\n",
    progName,
    a1,
    a2);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D60C0) --------------------------------------------------------
void __fastcall compressOutOfMemory(int a1, int a2)
{
  sprintf(
    gText,
    "\n%s: Can't allocate enough memory for compression.\n\tRequested %d bytes for a block size of %d.\n\tReduce the block size, and/or use the -e flag.\n",
    progName,
    a1,
    a2);
  LogStr(gText);
  showFileNames();
  cleanUpAndFail();
}

//----- (004D6110) --------------------------------------------------------
bool __thiscall endsInBz(const char *this)
{
  bool result; // eax@2
  const char *v2; // [sp+Ch] [bp-8h]@1
  unsigned int v3; // [sp+10h] [bp-4h]@1

  v2 = this;
  v3 = strlen(this);
  if ( (signed int)v3 > 3 )
    result = v2[v3 - 3] == 46 && v2[v3 - 2] == 110 && v2[v3 - 1] == 119;
  else
    result = 0;
  return result;
}

//----- (004D61A0) --------------------------------------------------------
int __thiscall compress(const char *this)
{
  int v1; // ST20_4@1
  int v2; // ST24_4@1

  strcpy(inName, this);
  strcpy(outName, this);
  *(_DWORD *)&outName[strlen(outName)] = dword_520628;
  v1 = fopen(inName, (int)"rb");
  v2 = fopen(outName, (int)"wb");
  *_errno() = 0;
  outputHandleJustInCase = v2;
  compressStream(v1, (void *)v2);
  outputHandleJustInCase = 0;
  return remove(inName);
}
// 520628: using guessed type int dword_520628;
// 534BE0: using guessed type int outputHandleJustInCase;

//----- (004D6290) --------------------------------------------------------
void __thiscall uncompress(const char *this)
{
  int v1; // ST24_4@3
  int v2; // ST28_4@3

  strcpy(inName, this);
  strcpy(outName, this);
  if ( endsInBz(inName) )
    *((_BYTE *)&bigR + strlen(outName) + 1) = 0;
  v1 = fopen(inName, (int)"rb");
  v2 = fopen(outName, (int)"wb");
  *_errno() = 0;
  outputHandleJustInCase = v2;
  uncompressStream((void *)v1, v2);
  outputHandleJustInCase = 0;
  if ( remove(inName) )
    ioError();
}
// 534BE0: using guessed type int outputHandleJustInCase;
// 534FF4: using guessed type int bigR;

//----- (004D63A0) --------------------------------------------------------
int __fastcall EncodeData(void *a1, const void *a2, unsigned int a3)
{
  int v3; // ST38_4@3
  int v4; // ST3C_4@3
  const void *v6; // [sp+Ch] [bp-1F0h]@1
  int v7; // [sp+10h] [bp-1ECh]@1
  int v8; // [sp+30h] [bp-1CCh]@1
  char this; // [sp+34h] [bp-1C8h]@1
  char v10; // [sp+35h] [bp-1C7h]@1
  char v11; // [sp+1F5h] [bp-7h]@1
  int v12; // [sp+1F8h] [bp-4h]@3

  v6 = a2;
  v7 = (int)a1;
  memset(&v10, 0, 0x1C0u);
  v11 = 0;
  outputHandleJustInCase = 0;
  bsInUse = 0;
  *_errno() = 0;
  blockSize100k = 3;
  LogStr("Encode 1");
  allocateCompressStructures();
  strcpy(&this, ".\\DATA\\");
  *(_DWORD *)(&this + strlen(&this)) = dword_520650;
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  v8 = open(&this, 33537, 128);
  if ( v8 == -1 )
    FileError(&this);
  _write(v8, v6, a3);
  _close(v8);
  compress(&this);
  *(_DWORD *)(&this + strlen(&this)) = dword_520654;
  v3 = fopen(&this, (int)"rb");
  v12 = fseek(v3, 0, 2);
  v4 = ftell(v3);
  v12 = fseek(v3, 0, 0);
  v12 = fread(v7, v4, 1, (FILE *)v3);
  v12 = fclose(v3);
  v12 = remove(&this);
  FreeCompressStructures();
  return v4;
}
// 520650: using guessed type int dword_520650;
// 520654: using guessed type int dword_520654;
// 534BE0: using guessed type int outputHandleJustInCase;
// 537928: using guessed type int bsInUse;
// 537934: using guessed type int blockSize100k;

//----- (004D6670) --------------------------------------------------------
int __fastcall DecodeData(void *a1, const void *a2, unsigned int a3)
{
  int v3; // ST3C_4@3
  int v4; // ST40_4@3
  const void *v6; // [sp+Ch] [bp-1F4h]@1
  int v7; // [sp+10h] [bp-1F0h]@1
  int v8; // [sp+34h] [bp-1CCh]@1
  char this; // [sp+38h] [bp-1C8h]@1
  char v10; // [sp+39h] [bp-1C7h]@1
  char v11; // [sp+1F9h] [bp-7h]@1
  int v12; // [sp+1FCh] [bp-4h]@3

  v6 = a2;
  v7 = (int)a1;
  memset(&v10, 0, 0x1C0u);
  v11 = 0;
  outputHandleJustInCase = 0;
  bsInUse = 0;
  *_errno() = 0;
  blockSize100k = 0;
  allocateCompressStructures();
  strcpy(&this, ".\\DATA\\");
  *(_DWORD *)(&this + strlen(&this)) = dword_520664;
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  *(&this + strlen(&this)) = Random(65, 90);
  *(_DWORD *)(&this + strlen(&this)) = dword_520668;
  v8 = open(&this, 33537, 128);
  if ( v8 == -1 )
    FileError(&this);
  _write(v8, v6, a3);
  _close(v8);
  uncompress(&this);
  *((_BYTE *)&v8 + strlen(&this) + 1) = 0;
  v3 = fopen(&this, (int)"rb");
  v12 = fseek(v3, 0, 2);
  v4 = ftell(v3);
  v12 = fseek(v3, 0, 0);
  v12 = fread(v7, v4, 1, (FILE *)v3);
  v12 = fclose(v3);
  v12 = remove(&this);
  FreeCompressStructures();
  return v4;
}
// 520664: using guessed type int dword_520664;
// 520668: using guessed type int dword_520668;
// 534BE0: using guessed type int outputHandleJustInCase;
// 537928: using guessed type int bsInUse;
// 537934: using guessed type int blockSize100k;

//----- (004D6960) --------------------------------------------------------
palette *__thiscall palette::palette(palette *this)
{
  palette *thisa; // esi@1

  thisa = this;
  resource::resource((resource *)this, RESOURCE_TYPE_PALETTE, 0, 1, 0);
  thisa->vtable = (resourceVtable *)&palette::_vftable_;
  thisa->contents = (signed __int8 *)BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\PALETTE.CPP", 8);
  return thisa;
}
// 4EAFA8: using guessed type int (__stdcall *palette___vftable_)(int);

//----- (004D6990) --------------------------------------------------------
int __thiscall palette::_scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1
  void *v3; // ecx@1

  *(_DWORD *)this = &palette::_vftable_;
  v2 = this;
  v3 = *(void **)(this + 16);
  if ( v3 )
    BaseFree(v3, (int)"F:\\h2xsrc\\Base\\PALETTE.CPP", 21);
  *(_DWORD *)(v2 + 16) = 0;
  resource::_resource((void *)v2);
  if ( a2 & 1 )
    operator delete((void *)v2);
  return v2;
}
// 4EAFA8: using guessed type int (__stdcall *palette___vftable_)(int);

//----- (004D69E0) --------------------------------------------------------
palette *__thiscall palette::palette(palette *this, int fileID)
{
  palette *thisa; // edi@1

  thisa = this;
  resource::resource((resource *)this, RESOURCE_TYPE_PALETTE, fileID, 1, 0);
  thisa->vtable = (resourceVtable *)&palette::_vftable_;
  thisa->contents = (signed __int8 *)BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\PALETTE.CPP", 13);
  resourceManager::PointToFile(gpResourceManager, fileID);
  resourceManager::ReadBlock(gpResourceManager, thisa->contents, 0x300u);
  return thisa;
}
// 4EAFA8: using guessed type int (__stdcall *palette___vftable_)(int);

//----- (004D6A40) --------------------------------------------------------
#72 *__thiscall palette::Data(palette *this)
{
  return (#72 *)this->contents;
}

//----- (004D6A50) --------------------------------------------------------
void __fastcall FillBitmapArea(bitmap *bmp, int x, int y, unsigned int width, signed int height, char a6)
{
  bitmap *bmpa; // ebp@1
  signed __int8 *row; // ecx@1
  void *offsetRow; // ecx@1
  int v9; // edi@2
  int v10; // eax@2

  bmpa = bmp;
  row = &bmp->contents[y * bmp->width];
  dword_537948 = 0;
  offsetRow = &row[x];
  dword_53794C = (int)offsetRow;
  if ( height > 0 )
  {
    do
    {
      v9 = dword_53794C;
      BYTE1(offsetRow) = a6;
      LOBYTE(offsetRow) = a6;
      v10 = (_DWORD)offsetRow << 16;
      LOWORD(v10) = (_WORD)offsetRow;
      memset32((void *)dword_53794C, v10, width >> 2);
      memset((void *)(v9 + 4 * (width >> 2)), a6, width & 3);
      offsetRow = (void *)(dword_537948 + 1);
      dword_53794C += bmpa->width;
      dword_537948 = (int)offsetRow;
    }
    while ( (signed int)offsetRow < height );
  }
}
// 537948: using guessed type int dword_537948;
// 53794C: using guessed type int dword_53794C;

//----- (004D6AD0) --------------------------------------------------------
void __fastcall BlitBitmap(bitmap *from, int x1, int y1, unsigned int width, int height, bitmap *to, unsigned int x2, int y2)
{
  bitmap *froma; // ebx@1
  int v9; // ecx@1
  signed __int8 *v10; // esi@1

  froma = from;
  blitFromRow = (int)(&from->contents[y1 * from->width] + x1);
  v9 = y2 * to->width;
  v10 = to->contents;
  blitI = 0;
  for ( blitToRow = (int)(&v10[v9] + x2); blitI < height; ++blitI )
  {
    memcpy((void *)blitToRow, (const void *)blitFromRow, width);
    blitFromRow += froma->width;
    blitToRow += to->width;
  }
}
// 53795C: using guessed type int blitI;
// 537964: using guessed type int blitFromRow;
// 537968: using guessed type int blitToRow;

//----- (004D6B80) --------------------------------------------------------
void __fastcall DimBitmapArea(bitmap *bmp, int x, int y, int width, int height, int substitutionIdx)
{
  unsigned __int8 *row; // esi@1
  int wid; // esi@2

  row = (unsigned __int8 *)&bmp->contents[y * bmp->width];
  bitmapColorSubstRectI = 0;
  for ( bitmapColorSubstRectPixel = &row[x]; bitmapColorSubstRectI < height; ++bitmapColorSubstRectI )
  {
    wid = bmp->width;
    bitmapColorSubstRectJ = 0;
    for ( bitmapColorSubstRectNextRow = &bitmapColorSubstRectPixel[wid];
          bitmapColorSubstRectJ < width;
          ++bitmapColorSubstRectJ )
    {
      *bitmapColorSubstRectPixel = uDimPal[substitutionIdx][*bitmapColorSubstRectPixel];
      ++bitmapColorSubstRectPixel;
    }
    bitmapColorSubstRectPixel = bitmapColorSubstRectNextRow;
  }
}
// 537950: using guessed type int bitmapColorSubstRectI;
// 537958: using guessed type int bitmapColorSubstRectJ;

//----- (004D6C30) --------------------------------------------------------
int __fastcall FlipIconToBitmap(icon *icn, bitmap *buf, int x, int y, int spriteIdx, signed int flag, signed int a7, int a8, int width, int height, int a11)
{
  IconEntry *iconContents; // esi@1
  IconEntry *header; // ebx@1
  int spriteWidth; // edi@1
  char *nextBytePtr; // esi@1
  int leftX; // ebp@1
  int secondColX; // ebp@1
  int curPixelX; // ebx@1
  int v18; // ecx@5
  void *v19; // ecx@9
  char *bufBotRow; // ebp@9
  int firstByte; // eax@11
  int result; // eax@13
  int v23; // edx@15
  char v24; // al@18
  int v25; // eax@19
  int v26; // eax@25
  void *v27; // edi@25
  void *v28; // edi@25
  void *v29; // edi@31
  int v30; // ecx@32
  unsigned int v31; // ecx@32
  int v32; // eax@36
  char *v33; // edi@36
  int v34; // eax@39
  int v35; // eax@43
  int v36; // eax@50
  char *pixel; // edx@54
  int nPixels; // edi@55
  char color; // cl@56
  int v40; // edi@60
  char *v41; // edx@63
  int v42; // edi@64
  int v43; // ecx@65
  char v44; // cl@72
  void *imgWidth; // [sp+14h] [bp-4h]@9

  iconContents = icn->headersAndImageData;
  header = &iconContents[spriteIdx];
  spriteWidth = header->width;
  nextBytePtr = (char *)iconContents + header->off;
  leftX = x - header->offsetX - spriteWidth;
  rasterizeRightAlignedHeader = header;
  secondColX = leftX + 1;
  rasterizeRightAlignedSecondColX = secondColX;
  curPixelX = spriteWidth + secondColX - 1;
  rasterizeRightAlignedLastColX = spriteWidth + secondColX - 1;
  rasterizeRightTopY = y + rasterizeRightAlignedHeader->offsetY;
  if ( flag )
  {
    if ( secondColX < a7 || a7 + width < secondColX + spriteWidth || rasterizeRightTopY < a8 )
    {
      v18 = height;
    }
    else
    {
      v18 = height;
      if ( rasterizeRightTopY + rasterizeRightAlignedHeader->height <= height + a8 )
      {
        flag = 0;
        goto LABEL_9;
      }
    }
    flag = 1;
    dword_537990 = a7 + width - 1;
    dword_53799C = a8 + v18 - 1;
  }
LABEL_9:
  v19 = buf->contents;
  bufBotRow = (char *)(buf->width * rasterizeRightTopY);
  imgWidth = (void *)buf->width;
LABEL_10:
  bufBotRow = &bufBotRow[(_DWORD)v19];
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        firstByte = (unsigned __int8)*nextBytePtr++;
        if ( (char)firstByte < 0 )
          break;
        rasterizeRightLastColX = curPixelX;
        rasterizeRightFirstByte = firstByte;
        if ( !firstByte )                       // 0 is end of line
        {
          curPixelX = rasterizeRightAlignedLastColX;
          v19 = imgWidth;
          ++rasterizeRightTopY;
          goto LABEL_10;
        }
        HIWORD(v19) = HIWORD(flag);
        if ( !flag )
        {
          pixel = &bufBotRow[curPixelX];
          dword_5379B0 = 0;
          rasterizeRightCurPixel = (int)&bufBotRow[curPixelX];
          if ( firstByte > 0 )                  // Between 0 and 0x80, just copy next bytes
          {
            nPixels = firstByte;
            dword_5379B0 = firstByte;
            do
            {
              color = *nextBytePtr++;
              *pixel-- = color;
              --nPixels;
              rasterizeRightCurPixel = (int)pixel;
            }
            while ( nPixels );
          }
          goto LABEL_75;
        }
        HIWORD(v19) = HIWORD(rasterizeRightTopY);
        if ( rasterizeRightTopY < a8
          || rasterizeRightTopY > dword_53799C
          || (v19 = (void *)(curPixelX - firstByte), v40 = curPixelX - firstByte + 1, v40 > dword_537990)
          || curPixelX < a7 )
        {
          nextBytePtr += firstByte;
          goto LABEL_75;
        }
        if ( curPixelX > dword_537990 )
        {
          v41 = &bufBotRow[dword_537990];
          nextBytePtr = &nextBytePtr[curPixelX] - dword_537990;
          if ( a7 > (signed int)v19 )
          {
            v42 = width;
            v43 = firstByte + dword_537990 - width - curPixelX;
            goto LABEL_69;
          }
          dword_537994 = 0;
          v42 = firstByte - curPixelX + dword_537990;
        }
        else
        {
          v41 = &bufBotRow[curPixelX];
          if ( a7 > v40 )
          {
            v42 = curPixelX - a7 + 1;
            v43 = firstByte - v42;
LABEL_69:
            dword_537994 = v43;
            goto LABEL_70;
          }
          dword_537994 = 0;
          v42 = firstByte;
        }
LABEL_70:
        rasterizeRightCurPixel = (int)v41;
        dword_537984 = v42;
        dword_5379B0 = 0;
        if ( v42 > 0 )
        {
          dword_5379B0 = v42;
          do
          {
            v44 = *nextBytePtr++;
            *v41-- = v44;
            --v42;
            rasterizeRightCurPixel = (int)v41;
          }
          while ( v42 );
        }
        HIWORD(v19) = HIWORD(dword_537994);
        nextBytePtr += dword_537994;
LABEL_75:
        curPixelX -= firstByte;
        rasterizeRightFirstByte = firstByte;
      }
      if ( !(firstByte & 0x40) )
        break;
      rasterizeRightFirstByte = firstByte;
      v23 = firstByte & 0x3F;
      if ( firstByte & 0x3F )
      {
        if ( firstByte == 193 )
          v23 = (unsigned __int8)*nextBytePtr++;
        v24 = *nextBytePtr++;
        byte_5379A8 = v24;
LABEL_24:
        if ( !flag )
        {
          LOBYTE(v19) = byte_5379A8;
          BYTE1(v19) = byte_5379A8;
          v26 = (_DWORD)v19 << 16;
          LOWORD(v26) = (_WORD)v19;
          v27 = &bufBotRow[curPixelX - v23 + 1];
          memset32(v27, v26, (unsigned int)v23 >> 2);
          v28 = (char *)v27 + 4 * ((unsigned int)v23 >> 2);
          LOBYTE(v19) = v23;
LABEL_33:
          memset(v28, v26, (unsigned __int8)v19 & 3);
          HIWORD(v19) = 0;
          goto LABEL_34;
        }
        HIWORD(v19) = HIWORD(rasterizeRightTopY);
        if ( rasterizeRightTopY >= a8 )
        {
          if ( rasterizeRightTopY <= dword_53799C )
          {
            v19 = (void *)(curPixelX - v23 + 1);
            if ( a7 <= (signed int)v19 )
            {
              if ( curPixelX <= dword_537990 )
              {
                if ( a7 > (signed int)v19 )
                {
                  v30 = curPixelX - a7 + 1;
                  LOBYTE(v30) = byte_5379A8;
                  BYTE1(v30) = byte_5379A8;
                  v26 = v30 << 16;
                  LOWORD(v26) = v30;
                  v31 = (unsigned int)(curPixelX - a7 + 1) >> 2;
                  memset32(&bufBotRow[a7], v26, v31);
                  v28 = &bufBotRow[4 * v31] + a7;
                  v19 = (void *)(curPixelX - a7 + 1);
                }
                else
                {
                  LOBYTE(v19) = byte_5379A8;
                  BYTE1(v19) = byte_5379A8;
                  v26 = (_DWORD)v19 << 16;
                  LOWORD(v26) = (_WORD)v19;
                  v29 = &bufBotRow[curPixelX - v23 + 1];
                  memset32(v29, v26, (unsigned int)v23 >> 2);
                  v28 = (char *)v29 + 4 * ((unsigned int)v23 >> 2);
                  LOBYTE(v19) = v23;
                }
                goto LABEL_33;
              }
            }
          }
        }
LABEL_34:
        curPixelX -= v23;
        rasterizeRightFirstByte = v23;
      }
      else
      {
        v25 = (unsigned __int8)*nextBytePtr++;
        v23 = v25 & 3;
        if ( !(v25 & 3) )
          v23 = (unsigned __int8)*nextBytePtr++;
        HIWORD(v19) = HIWORD(a11);
        dword_537978 = v23;
        if ( a11 )
        {
          rasterizeRightFirstByte = v25;
          if ( v25 & 0x80 )
          {
            dword_537984 = v23;
            byte_5379A8 = a11;
            goto LABEL_24;
          }
        }
        rasterizeRightFirstByte = v25;
        dword_537984 = v23;
        if ( v25 & 0x40 )
        {
          v32 = (v25 & 0x3C) << 6;
          v33 = (char *)uDimPal + v32;
          dword_537988 = (int)((char *)uDimPal + v32);
          if ( flag )
          {
            HIWORD(v19) = HIWORD(rasterizeRightTopY);
            dword_537984 = v23;
            if ( rasterizeRightTopY >= a8 )
            {
              if ( rasterizeRightTopY <= dword_53799C )
              {
                HIWORD(v19) = HIWORD(a7);
                v35 = curPixelX - v23 + 1;
                if ( a7 <= v35 )
                {
                  HIWORD(v19) = HIWORD(dword_537990);
                  if ( curPixelX <= dword_537990 )
                  {
                    if ( a7 > v35 )
                    {
                      v23 = curPixelX - a7 + 1;
                      v19 = &bufBotRow[a7];
                    }
                    else
                    {
                      v19 = &bufBotRow[curPixelX - v23 + 1];
                    }
                    dword_537988 = (int)v33;
                    dword_5379A4 = (int)v19;
                    dword_537984 = v23;
                    dword_5379B0 = 0;
                    if ( v23 > 0 )
                    {
                      dword_5379B0 = v23;
                      do
                      {
                        v19 = (char *)v19 + 1;
                        v36 = *((_BYTE *)v19 - 1);
                        dword_5379A4 = (int)v19;
                        --v23;
                        dword_537988 = (int)v33;
                        *((_BYTE *)v19 - 1) = v33[v36];
                      }
                      while ( v23 );
                    }
                  }
                }
              }
            }
          }
          else
          {
            dword_5379B0 = 0;
            v19 = &bufBotRow[curPixelX - v23 + 1];
            dword_5379A4 = (int)&bufBotRow[curPixelX - v23 + 1];
            if ( v23 > 0 )
            {
              dword_5379B0 = v23;
              do
              {
                v19 = (char *)v19 + 1;
                v34 = *((_BYTE *)v19 - 1);
                dword_5379A4 = (int)v19;
                --v23;
                dword_537988 = (int)v33;
                *((_BYTE *)v19 - 1) = v33[v34];
              }
              while ( v23 );
            }
          }
        }
        curPixelX -= dword_537978;
      }
    }
    rasterizeRightLastColX = curPixelX;
    dword_5379A0 = (int)nextBytePtr;
    dword_53796C = (int)bufBotRow;
    rasterizeRightFirstByte = firstByte;
    result = firstByte & 0x3F;
    if ( !result )
      return result;
    curPixelX -= result;
  }
}
// 53796C: using guessed type int dword_53796C;
// 537974: using guessed type int rasterizeRightAlignedLastColX;
// 537978: using guessed type int dword_537978;
// 53797C: using guessed type int rasterizeRightAlignedSecondColX;
// 537980: using guessed type int rasterizeRightTopY;
// 537984: using guessed type int dword_537984;
// 537988: using guessed type int dword_537988;
// 53798C: using guessed type int rasterizeRightLastColX;
// 537990: using guessed type int dword_537990;
// 537994: using guessed type int dword_537994;
// 537998: using guessed type int rasterizeRightFirstByte;
// 53799C: using guessed type int dword_53799C;
// 5379A0: using guessed type int dword_5379A0;
// 5379A4: using guessed type int dword_5379A4;
// 5379A8: using guessed type char byte_5379A8;
// 5379AC: using guessed type int rasterizeRightCurPixel;
// 5379B0: using guessed type int dword_5379B0;

//----- (004D7124) --------------------------------------------------------
char __cdecl TileToBitmap(tileset *tiles, int idx, bitmap *targ, int x, int y)
{
  int width; // ebx@1
  unsigned __int8 *curDest; // edi@1
  unsigned int v7; // ecx@1
  int v8; // ebx@1
  int v9; // edx@1
  char *curSrc; // esi@1
  int v11; // eax@3
  const void *v12; // esi@4
  void *v13; // edi@4
  const void *v14; // esi@4
  void *v15; // edi@4
  const void *v16; // esi@4
  void *v17; // edi@4
  const void *v18; // esi@4
  void *v19; // edi@4
  const void *v20; // esi@4
  void *v21; // edi@4
  const void *v22; // esi@4
  void *v23; // edi@4
  const void *v24; // esi@4
  void *v25; // edi@4
  const void *v26; // esi@4
  void *v27; // edi@4
  const void *v28; // esi@4
  void *v29; // edi@4
  const void *v30; // esi@4
  void *v31; // edi@4
  const void *v32; // esi@4
  void *v33; // edi@4
  const void *v34; // esi@4
  void *v35; // edi@4
  const void *v36; // esi@4
  void *v37; // edi@4
  const void *v38; // esi@4
  void *v39; // edi@4
  const void *v40; // esi@4
  void *v41; // edi@4
  int v42; // esi@6
  __int16 v43; // dx@6
  int v44; // edi@10
  int v45; // ebx@10
  unsigned int v46; // edx@10
  unsigned int v47; // ecx@11
  int v48; // esi@12
  int v49; // edi@12
  int v50; // esi@15
  unsigned int v51; // edx@15
  unsigned int v52; // ecx@16
  int v53; // esi@17
  _BYTE *v54; // edi@17
  int idxa; // [sp+14h] [bp+Ch]@1

  width = targ->width;
  curDest = (unsigned __int8 *)(&targ->contents[x] + width * y);
  dword_5206C4 = idx;
  idxa = idx & 0xFFF;
  v7 = tiles->field_12;
  v8 = width - v7;
  HIWORD(v9) = (unsigned int)idxa * (unsigned __int64)(tiles->field_14 * (unsigned int)tiles->field_12) >> 48;
  LOWORD(v9) = tiles->field_14;
  curSrc = (char *)tiles->contents + idxa * tiles->field_14 * tiles->field_12;
  if ( dword_5206C4 & 0x8000 )
  {
    if ( dword_5206C4 & 0x4000 )
    {
      v50 = (int)&curSrc[v7 * v7 - 1];
      v51 = v7 >> 3;
      dword_5206C8 = tiles->field_12;
      do
      {
        v52 = v51;
        do
        {
          LOBYTE(v11) = *(_BYTE *)v50;
          v53 = v50 + 1;
          *curDest = v11;
          v54 = curDest + 1;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53++;
          *v54++ = v11;
          LOBYTE(v11) = *(_BYTE *)v53;
          v50 = v53 + 1;
          *v54 = v11;
          curDest = v54 + 1;
          --v52;
        }
        while ( v52 );
        curDest += v8;
        --dword_5206C8;
      }
      while ( dword_5206C8 );
    }
    else
    {
      v44 = (int)&curDest[v7 - 1];
      dword_5206C8 = v9;
      v45 = v7 + v7 + v8;
      v46 = v7 >> 3;
      do
      {
        v47 = v46;
        do
        {
          LOBYTE(v11) = *curSrc;
          v48 = (int)(curSrc + 1);
          *(_BYTE *)v44 = v11;
          v49 = v44 - 1;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48++;
          *(_BYTE *)v49-- = v11;
          LOBYTE(v11) = *(_BYTE *)v48;
          curSrc = (char *)(v48 + 1);
          *(_BYTE *)v49 = v11;
          v44 = v49 - 1;
          --v47;
        }
        while ( v47 );
        v44 += v45;
        --dword_5206C8;
      }
      while ( dword_5206C8 );
    }
  }
  else if ( dword_5206C4 & 0x4000 )
  {
    v42 = (int)&curSrc[v7 * (v7 - 1)];
    v11 = tiles->field_12;
    v43 = tiles->field_12;
    do
    {
      memcpy(curDest, (const void *)v42, 4 * ((unsigned int)v11 >> 2));
      curDest += 4 * ((unsigned int)v11 >> 2) + v8;
      v42 = v42 + 4 * ((unsigned int)v11 >> 2) - v11 - v11;
      --v43;
    }
    while ( v43 );
  }
  else
  {
    v11 = v7 >> 2;
    do
    {
      memcpy(curDest, curSrc, 4 * v11);
      v12 = &curSrc[4 * v11];
      v13 = &curDest[4 * v11] + v8;
      memcpy(v13, v12, 4 * v11);
      v14 = (char *)v12 + 4 * v11;
      v15 = (char *)v13 + 4 * v11 + v8;
      memcpy(v15, v14, 4 * v11);
      v16 = (char *)v14 + 4 * v11;
      v17 = (char *)v15 + 4 * v11 + v8;
      memcpy(v17, v16, 4 * v11);
      v18 = (char *)v16 + 4 * v11;
      v19 = (char *)v17 + 4 * v11 + v8;
      memcpy(v19, v18, 4 * v11);
      v20 = (char *)v18 + 4 * v11;
      v21 = (char *)v19 + 4 * v11 + v8;
      memcpy(v21, v20, 4 * v11);
      v22 = (char *)v20 + 4 * v11;
      v23 = (char *)v21 + 4 * v11 + v8;
      memcpy(v23, v22, 4 * v11);
      v24 = (char *)v22 + 4 * v11;
      v25 = (char *)v23 + 4 * v11 + v8;
      memcpy(v25, v24, 4 * v11);
      v26 = (char *)v24 + 4 * v11;
      v27 = (char *)v25 + 4 * v11 + v8;
      memcpy(v27, v26, 4 * v11);
      v28 = (char *)v26 + 4 * v11;
      v29 = (char *)v27 + 4 * v11 + v8;
      memcpy(v29, v28, 4 * v11);
      v30 = (char *)v28 + 4 * v11;
      v31 = (char *)v29 + 4 * v11 + v8;
      memcpy(v31, v30, 4 * v11);
      v32 = (char *)v30 + 4 * v11;
      v33 = (char *)v31 + 4 * v11 + v8;
      memcpy(v33, v32, 4 * v11);
      v34 = (char *)v32 + 4 * v11;
      v35 = (char *)v33 + 4 * v11 + v8;
      memcpy(v35, v34, 4 * v11);
      v36 = (char *)v34 + 4 * v11;
      v37 = (char *)v35 + 4 * v11 + v8;
      memcpy(v37, v36, 4 * v11);
      v38 = (char *)v36 + 4 * v11;
      v39 = (char *)v37 + 4 * v11 + v8;
      memcpy(v39, v38, 4 * v11);
      v40 = (char *)v38 + 4 * v11;
      v41 = (char *)v39 + 4 * v11 + v8;
      memcpy(v41, v40, 4 * v11);
      curSrc = (char *)v40 + 4 * v11;
      curDest = (unsigned __int8 *)((char *)v41 + 4 * v11 + v8);
      LOWORD(v9) = v9 - 16;
    }
    while ( (_WORD)v9 );
  }
  return v11;
}
// 5206C4: using guessed type int dword_5206C4;
// 5206C8: using guessed type int dword_5206C8;

//----- (004D72C0) --------------------------------------------------------
int __fastcall IconToBitmapColorTable(icon *a1, bitmap *buf, int a3, int a4, int a5, signed int a6, int a7, int a8, unsigned int a9, int a10, int a11, char *paletteSubstitution, int a13)
{
  IconEntry *v13; // esi@1
  int v14; // ecx@1
  int v15; // edi@1
  int v16; // eax@1
  int v17; // esi@1
  int v18; // eax@5
  int v19; // edi@5
  signed __int8 *v20; // ebp@9
  int v21; // edx@9
  int v22; // ecx@10
  int v23; // eax@10
  int result; // eax@12
  int v25; // ebx@14
  int v26; // ecx@17
  int v27; // eax@18
  int v28; // eax@24
  int v29; // edi@24
  int v30; // eax@27
  int v31; // ST10_4@32
  int v32; // ecx@34
  unsigned int v33; // ecx@34
  int v34; // eax@39
  char *v35; // edi@39
  int v36; // eax@48
  int v37; // ebx@66
  int v38; // ecx@69
  unsigned __int8 *v39; // edi@83

  v13 = a1->headersAndImageData;
  v14 = v13[a5].offsetX;
  v15 = (int)&v13[a5];
  v16 = (int)((char *)v13 + v13[a5].off);
  dword_5379D4 = v15;
  dword_5379E4 = v16;
  v17 = v14 + a3;
  dword_5379B4 = v14 + a3;
  dword_5379F4 = buf->width;
  dword_5379D0 = a4 + *(_WORD *)(v15 + 2);
  if ( !a6 )
    goto LABEL_9;
  if ( a7 > v14 + a3 || dword_5379B4 + *(_WORD *)(v15 + 4) > (signed int)(a7 + a9) || a8 > dword_5379D0 )
  {
    v19 = a10;
    goto LABEL_8;
  }
  v18 = dword_5379D0 + *(_WORD *)(v15 + 6);
  v19 = a10;
  if ( v18 > a10 + a8 )
  {
LABEL_8:
    a6 = 1;
    dword_5379B8 = a7 + a9 - 1;
    dword_5379E0 = a8 + v19 - 1;
    goto LABEL_9;
  }
  a6 = 0;
LABEL_9:
  v20 = &buf->contents[dword_5379D0 * dword_5379F4];
  v21 = dword_5379C8;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v22 = dword_5379E4 + 1;
        dword_5379E4 = v22;
        v23 = *(_BYTE *)(v22 - 1);
        if ( (char)v23 < 0 )
          break;
        dword_5379DC = v17;
        dword_5379D8 = v23;
        if ( v23 )
        {
          dword_5379C8 = v21;
          dword_5379F0 = (unsigned __int8 *)dword_5379E4;
          if ( a6 )
          {
            if ( a8 > dword_5379D0
              || dword_5379E0 < dword_5379D0
              || (v38 = v23 + v17, a7 >= v23 + v17)
              || (dword_5379C8 = v21, v17 > dword_5379B8) )
            {
              v37 = 0;
            }
            else if ( v17 < a7 )
            {
              if ( dword_5379B8 < v38 )
              {
                v21 = (int)&v20[a7];
                v37 = a9;
              }
              else
              {
                v21 = (int)&v20[a7];
                v37 = v17 - a7 + v23;
              }
              dword_5379F0 = (unsigned __int8 *)(a7 + dword_5379E4 - v17);
            }
            else
            {
              v21 = (int)&v20[v17];
              if ( dword_5379B8 < v38 )
                v37 = dword_5379B8 - v17 + 1;
              else
                v37 = v23;
            }
          }
          else
          {
            v21 = (int)&v20[v17];
            v37 = v23;
          }
          dword_5379E8 = v37;
          if ( v37 )
          {
            dword_5379EC = 0;
            if ( v37 > 0 )
            {
              dword_5379EC = v37;
              do
              {
                ++v21;
                v39 = dword_5379F0 + 1;
                *(_BYTE *)(v21 - 1) = paletteSubstitution[*dword_5379F0];
                --v37;
                dword_5379F0 = v39;
              }
              while ( v37 );
            }
          }
          v17 += v23;
          dword_5379D8 = v23;
          dword_5379E4 += v23;
        }
        else
        {
          v17 = dword_5379B4;
          v20 += dword_5379F4;
          ++dword_5379D0;
        }
      }
      if ( !(v23 & 0x40) )
        break;
      dword_5379D8 = *(_BYTE *)(v22 - 1);
      v25 = v23 & 0x3F;
      if ( v23 & 0x3F )
      {
        if ( v23 == 193 )
        {
          ++dword_5379E4;
          v25 = *(_BYTE *)(dword_5379E4 - 1);
        }
        v26 = dword_5379E4 + 1;
        dword_5379E4 = v26;
        byte_5379C0 = paletteSubstitution[*(_BYTE *)(v26 - 1)];
LABEL_23:
        if ( !a6 )
        {
          LOBYTE(v26) = byte_5379C0;
          BYTE1(v26) = byte_5379C0;
          v28 = v26 << 16;
          LOWORD(v28) = v26;
          memset32(&v20[v17], v28, (unsigned int)v25 >> 2);
          v29 = (int)(&v20[4 * ((unsigned int)v25 >> 2)] + v17);
          LOBYTE(v26) = v25;
LABEL_36:
          memset((void *)v29, v28, v26 & 3);
          goto LABEL_37;
        }
        if ( a8 <= dword_5379D0 )
        {
          if ( dword_5379E0 >= dword_5379D0 )
          {
            v30 = v25 + v17;
            if ( a7 < v25 + v17 )
            {
              if ( v17 <= dword_5379B8 )
              {
                HIWORD(v26) = HIWORD(dword_5379B8);
                if ( v17 < a7 )
                {
                  if ( dword_5379B8 < v30 )
                  {
                    LOBYTE(v26) = byte_5379C0;
                    BYTE1(v26) = byte_5379C0;
                    v28 = v26 << 16;
                    LOWORD(v28) = v26;
                    memset32(&v20[a7], v28, a9 >> 2);
                    v29 = (int)(&v20[4 * (a9 >> 2)] + a7);
                    LOBYTE(v26) = a9;
                  }
                  else
                  {
                    HIWORD(v32) = HIWORD(a7);
                    LOBYTE(v32) = byte_5379C0;
                    BYTE1(v32) = byte_5379C0;
                    v28 = v32 << 16;
                    LOWORD(v28) = v32;
                    v33 = (unsigned int)(v25 + v17 - a7) >> 2;
                    memset32(&v20[a7], v28, v33);
                    v29 = (int)(&v20[4 * v33] + a7);
                    v26 = v25 + v17 - a7;
                  }
                }
                else if ( dword_5379B8 < v30 )
                {
                  v31 = dword_5379B8 - v17 + 1;
                  LOBYTE(v26) = byte_5379C0;
                  BYTE1(v26) = byte_5379C0;
                  v28 = v26 << 16;
                  LOWORD(v28) = v26;
                  v26 = (unsigned int)(dword_5379B8 - v17 + 1) >> 2;
                  memset32(&v20[v17], v28, v26);
                  v29 = (int)(&v20[4 * v26] + v17);
                  LOBYTE(v26) = v31;
                }
                else
                {
                  LOBYTE(v26) = byte_5379C0;
                  BYTE1(v26) = byte_5379C0;
                  v28 = v26 << 16;
                  LOWORD(v28) = v26;
                  memset32(&v20[v17], v28, (unsigned int)v25 >> 2);
                  v29 = (int)(&v20[4 * ((unsigned int)v25 >> 2)] + v17);
                  LOBYTE(v26) = v25;
                }
                goto LABEL_36;
              }
            }
          }
        }
LABEL_37:
        v17 += v25;
        dword_5379D8 = v25;
      }
      else
      {
        ++dword_5379E4;
        v27 = *(_BYTE *)(dword_5379E4 - 1);
        v25 = *(_BYTE *)(dword_5379E4 - 1) & 3;
        if ( !(*(_BYTE *)(dword_5379E4 - 1) & 3) )
        {
          ++dword_5379E4;
          v25 = *(_BYTE *)(dword_5379E4 - 1);
        }
        HIWORD(v26) = HIWORD(a11);
        dword_5379C4 = v25;
        if ( a11 )
        {
          dword_5379D8 = v27;
          if ( v27 & 0x80 )
          {
            dword_5379E8 = v25;
            byte_5379C0 = a11;
            goto LABEL_23;
          }
        }
        dword_5379E8 = v25;
        dword_5379D8 = v27;
        if ( v27 & 0x40 )
        {
          v34 = (v27 & 0x3C) << 6;
          dword_5379C8 = v21;
          v35 = (char *)uDimPal + v34;
          dword_5379BC = (int)((char *)uDimPal + v34);
          if ( a6 )
          {
            dword_5379E8 = v25;
            if ( a8 <= dword_5379D0 )
            {
              if ( dword_5379E0 >= dword_5379D0 )
              {
                v36 = v25 + v17;
                if ( a7 < v25 + v17 )
                {
                  dword_5379C8 = v21;
                  if ( v17 <= dword_5379B8 )
                  {
                    if ( v17 < a7 )
                    {
                      dword_5379E8 = v25;
                      if ( dword_5379B8 < v36 )
                        v25 = a9;
                      else
                        v25 = v17 + v25 - a7;
                      v21 = (int)&v20[a7];
                    }
                    else
                    {
                      if ( dword_5379B8 < v36 )
                        v25 = dword_5379B8 - v17 + 1;
                      v21 = (int)&v20[v17];
                    }
                    dword_5379BC = (int)v35;
                    dword_5379E8 = v25;
                    dword_5379EC = 0;
                    if ( v25 > 0 )
                    {
                      dword_5379EC = v25;
                      do
                      {
                        if ( a13 )
                          *(_BYTE *)v21 = v35[*(_BYTE *)v21];
                        ++v21;
                        dword_5379BC = (int)v35;
                        --v25;
                      }
                      while ( v25 );
                    }
                  }
                }
              }
            }
          }
          else
          {
            v21 = (int)&v20[v17];
            dword_5379EC = 0;
            if ( v25 > 0 )
            {
              dword_5379EC = v25;
              do
              {
                if ( a13 )
                  *(_BYTE *)v21 = v35[*(_BYTE *)v21];
                ++v21;
                dword_5379BC = (int)((char *)uDimPal + v34);
                --v25;
              }
              while ( v25 );
            }
          }
        }
        v17 += dword_5379C4;
      }
    }
    dword_5379DC = v17;
    dword_5379CC = (int)v20;
    dword_5379C8 = v21;
    dword_5379D8 = v23;
    result = v23 & 0x3F;
    if ( !result )
      return result;
    v17 += result;
  }
}
// 5379B4: using guessed type int dword_5379B4;
// 5379B8: using guessed type int dword_5379B8;
// 5379BC: using guessed type int dword_5379BC;
// 5379C0: using guessed type char byte_5379C0;
// 5379C4: using guessed type int dword_5379C4;
// 5379C8: using guessed type int dword_5379C8;
// 5379CC: using guessed type int dword_5379CC;
// 5379D0: using guessed type int dword_5379D0;
// 5379D4: using guessed type int dword_5379D4;
// 5379D8: using guessed type int dword_5379D8;
// 5379DC: using guessed type int dword_5379DC;
// 5379E0: using guessed type int dword_5379E0;
// 5379E4: using guessed type int dword_5379E4;
// 5379E8: using guessed type int dword_5379E8;
// 5379EC: using guessed type int dword_5379EC;
// 5379F4: using guessed type int dword_5379F4;

//----- (004D7880) --------------------------------------------------------
int __fastcall IconToBitmapScale(icon *ikon, bitmap *a2, int a3, int a4, int spriteIdx, signed int a6, int a7, int a8, unsigned int a9, int a10, signed int a11)
{
  bitmap *v11; // esi@1
  int result; // eax@2
  bitmap *v13; // eax@3
  signed int v14; // edx@6
  int v15; // edx@8
  int v16; // edi@10
  int v17; // esi@10
  signed int v18; // eax@11
  char v19; // zf@15
  bitmap *bmp; // [sp+10h] [bp-18h]@4
  signed int icna; // [sp+14h] [bp-14h]@9
  signed __int8 *v23; // [sp+18h] [bp-10h]@6
  int v24; // [sp+18h] [bp-10h]@8
  int v25; // [sp+1Ch] [bp-Ch]@8

  v11 = a2;
  if ( a11 == 32 )
  {
    result = IconToBitmap(ikon, a2, a3, a4, spriteIdx, a6, a7, a8, a9, a10, 0);
  }
  else
  {
    v13 = (bitmap *)operator new(26);
    if ( v13 )
      bmp = bitmap::bitmap(v13, 0, 64, 64);
    else
      bmp = 0;
    v14 = 0;
    v23 = bmp->contents;
    do
    {
      memset(&v23[v14], 0, 0x20u);
      v14 += 32;
    }
    while ( v14 < 2048 );
    IconToBitmap(ikon, bmp, 0, 0, spriteIdx, 1, 0, 0, 0x20u, 32, 0);
    v24 = v11->width;
    v25 = (int)(&v11->contents[v11->width * a4] + a3);
    v15 = (int)&bmp->contents[65 * ((32 / a11 * (1 - a11) + 32) >> 1)];
    if ( a11 > 0 )
    {
      icna = a11;
      do
      {
        v16 = v15;
        v17 = v25;
        if ( a11 > 0 )
        {
          v18 = a11;
          do
          {
            if ( *(_BYTE *)v16 )
              *(_BYTE *)v17 = *(_BYTE *)v16;
            ++v17;
            v16 += 32 / a11;
            --v18;
          }
          while ( v18 );
        }
        v15 += 32 / a11 << 6;
        v19 = icna == 1;
        v25 += v24;
        --icna;
      }
      while ( !v19 );
    }
    result = (int)bmp;
    if ( bmp )
      result = ((int (__fastcall *)(bitmap *, int, signed int))bmp->vtable->scalarDeletingDestructor)(bmp, v15, 1);
  }
  return result;
}

//----- (004D7A00) --------------------------------------------------------
void __fastcall DoRipple(bitmap *bmp1, bitmap *bmp2, int height, int rippleStrengt)
{
  signed int xOffset; // ecx@2
  int x; // edi@3
  unsigned __int8 *targContents; // ebx@6
  int y; // eax@6
  unsigned __int8 *ptr; // ebp@6
  unsigned int width; // eax@11
  int xOff; // edx@11
  signed int leftX; // [sp+10h] [bp-2C4h]@1
  char yDistortionForOffset[51]; // [sp+14h] [bp-2C0h]@1
  int nextFrameTime; // [sp+48h] [bp-28Ch]@2
  bitmap *toBmp; // [sp+4Ch] [bp-288h]@1
  bitmap *fromBmp; // [sp+50h] [bp-284h]@1
  char firstRowWrittenFor[640]; // [sp+54h] [bp-280h]@1

  toBmp = bmp2;
  fromBmp = bmp1;
  mouseManager::HideColorPointer(gpMouseManager);
  yDistortionForOffset[0] = 0;
  yDistortionForOffset[1] = 0;
  yDistortionForOffset[2] = 0;
  yDistortionForOffset[3] = 0;
  yDistortionForOffset[4] = 0;
  yDistortionForOffset[5] = 0;
  yDistortionForOffset[6] = 0;
  yDistortionForOffset[7] = 1;
  yDistortionForOffset[8] = 1;
  yDistortionForOffset[9] = 1;
  yDistortionForOffset[10] = 1;
  yDistortionForOffset[11] = 1;
  yDistortionForOffset[12] = 2;
  yDistortionForOffset[13] = 2;
  yDistortionForOffset[14] = 2;
  yDistortionForOffset[15] = 2;
  yDistortionForOffset[16] = 3;
  yDistortionForOffset[17] = 3;
  yDistortionForOffset[18] = 4;
  yDistortionForOffset[19] = 5;
  yDistortionForOffset[23] = 7;
  yDistortionForOffset[24] = 7;
  yDistortionForOffset[25] = 7;
  yDistortionForOffset[26] = 7;
  yDistortionForOffset[27] = 7;
  yDistortionForOffset[20] = 6;
  yDistortionForOffset[21] = 6;
  yDistortionForOffset[22] = 6;
  yDistortionForOffset[28] = 6;
  yDistortionForOffset[29] = 6;
  yDistortionForOffset[30] = 6;
  yDistortionForOffset[31] = 5;
  yDistortionForOffset[35] = 2;
  yDistortionForOffset[36] = 2;
  yDistortionForOffset[37] = 2;
  yDistortionForOffset[38] = 2;
  yDistortionForOffset[39] = 1;
  yDistortionForOffset[40] = 1;
  yDistortionForOffset[41] = 1;
  yDistortionForOffset[42] = 1;
  yDistortionForOffset[43] = 1;
  yDistortionForOffset[44] = 0;
  yDistortionForOffset[45] = 0;
  yDistortionForOffset[46] = 0;
  yDistortionForOffset[32] = 4;
  yDistortionForOffset[33] = 3;
  yDistortionForOffset[34] = 3;
  yDistortionForOffset[47] = 0;
  yDistortionForOffset[48] = 0;
  yDistortionForOffset[49] = 0;
  yDistortionForOffset[50] = 0;
  memset(firstRowWrittenFor, 0, sizeof(firstRowWrittenFor));
  leftX = -25;
  do
  {
    PollSound();
    nextFrameTime = KBTickCount();
    xOffset = 0;
    nextFrameTime = (signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 9.0 + (double)nextFrameTime);
    do
    {
      x = leftX + xOffset - 25;
      if ( x >= 0 && x < 640 && firstRowWrittenFor[x] != yDistortionForOffset[xOffset] )
      {
        targContents = (unsigned __int8 *)&toBmp->contents[x];
        y = rippleStrengt * (unsigned __int8)yDistortionForOffset[xOffset];
        for ( ptr = (unsigned __int8 *)(&fromBmp->contents[640 * y] + x); y < height; ++y )
        {
          *targContents = *ptr;
          if ( y - height == -1 )
            break;
          targContents += 640;
          ptr += 640;
        }
        firstRowWrittenFor[x] = yDistortionForOffset[xOffset];
      }
      ++xOffset;
    }
    while ( xOffset <= 50 );
    width = 41;
    xOff = leftX - 22;
    if ( leftX - 22 < 0 )
    {
      width = xOff + 41;
      xOff = 0;
    }
    if ( (signed int)(xOff + width) > 640 )
      width = 640 - xOff;
    if ( (signed int)width >= 1 )
    {
      BlitBitmapToScreen(gpWindowManager->screenBuffer, xOff, 0, width, height, xOff, 0);
      DelayTil(&nextFrameTime);
    }
    leftX += 4;
  }
  while ( leftX < 665 );
  mouseManager::ShowColorPointer(gpMouseManager);
}
// 4D7A00: using guessed type char firstRowWrittenFor[640];

//----- (004D7C40) --------------------------------------------------------
void __fastcall DoBlur(bitmap *fromBmp, bitmap *toBmp, int height, char a4, char a5, char a6)
{
  bitmap *v6; // ecx@1
  char (*v7)[3]; // ecx@4
  signed int v8; // eax@4
  resourceManager *v9; // esi@6
  int v10; // eax@6
  unsigned __int8 *v11; // ecx@10
  int v12; // eax@11
  int v13; // ST40_4@11
  int v14; // ST44_4@11
  int v15; // ST48_4@11
  int v16; // ST4C_4@11
  int v17; // ST50_4@11
  int v18; // ST54_4@11
  int v19; // ST58_4@11
  int v20; // ST5C_4@11
  int v21; // ST60_4@11
  int v22; // ST64_4@11
  int v23; // ST68_4@11
  int v24; // ST6C_4@11
  unsigned int v25; // edi@11
  LPVOID v26; // eax@13
  void *v27; // edi@13
  int v28; // ebx@13
  const void *v29; // ebp@13
  int v30; // eax@13
  const void *v31; // esi@13
  signed int v32; // ecx@13
  int v33; // ebx@27
  bitmap *newBMP; // [sp+10h] [bp-C5Ch]@2
  signed int v35; // [sp+14h] [bp-C58h]@7
  int v36; // [sp+18h] [bp-C54h]@6
  bitmap *toBmpa; // [sp+1Ch] [bp-C50h]@1
  unsigned __int8 *v38; // [sp+54h] [bp-C18h]@10
  unsigned int npixels; // [sp+58h] [bp-C14h]@4
  unsigned __int8 (*a1a)[32]; // [sp+5Ch] [bp-C10h]@4
  bitmap *fromBmpa; // [sp+60h] [bp-C0Ch]@1
  signed int v42; // [sp+64h] [bp-C08h]@10
  int a7[3][256]; // [sp+68h] [bp-C04h]@5

  toBmpa = toBmp;
  fromBmpa = fromBmp;
  PollSound();
  mouseManager::HideColorPointer(gpMouseManager);
  heroWindowManager::SaveFizzleSource(gpWindowManager, 0, 0, 640, height);
  v6 = (bitmap *)operator new(26);
  if ( v6 )
    newBMP = bitmap::bitmap(v6, 0, 640, height);
  else
    newBMP = 0;
  npixels = 640 * height;
  memcpy(newBMP->contents, toBmpa->contents, 640 * height);
  a1a = (unsigned __int8 (*)[32])BaseAlloc(0x8000u, "F:\\h2xsrc\\Base\\Blur.cpp", 25);
  v7 = (char (*)[3])gpBufferPalette->contents;
  v8 = 0;
  do
  {
    ++v7;
    ++v8;
    a7[2][v8] = (*v7)[-3];
    a7[0][v8] = (*v7)[-2];
    a7[1][v8] = (*v7)[-1];
  }
  while ( v8 < 256 );
  v9 = gpResourceManager;
  v10 = resourceManager::MakeId(gpResourceManager, "RGBLOOKP.BIN", 1);
  resourceManager::PointToFile(v9, v10);
  resourceManager::ReadBlock(gpResourceManager, a1a, 0x8000u);
  memcpy(fromBmpa->contents, toBmpa->contents, npixels);
  PollSound();
  v36 = 4;
  a7[0][0] = height - 4;
  if ( height - 4 > 4 )
  {
    v35 = 2560;
    do
    {
      if ( (v36 & 0x3F) == 63 )
        PollSound();
      v42 = 632;
      v11 = (unsigned __int8 *)&fromBmpa->contents[v35 + 4];
      v38 = (unsigned __int8 *)&toBmpa->contents[v35 + 4];
      do
      {
        v12 = (v11++)[2];
        v13 = v11[1919];
        v14 = v11[2];
        v15 = *(v11 - 3);
        v16 = *(v11 - 1921);
        v17 = v11[3];
        v18 = *(v11 - 4);
        v19 = *(v11 - 5);
        v20 = v11[639];
        v21 = v11[2559];
        v22 = *(v11 - 641);
        v23 = *(v11 - 2561);
        v24 = *(v11 - 2);
        v25 = ((unsigned int)(a7[1][*v11 + 1]
                            + a7[1][*(v11 - 1281) + 1]
                            + a7[1][v11[1279] + 1]
                            + a7[1][v24 + 1]
                            + a7[1][v23 + 1]
                            + a7[1][v22 + 1]
                            + a7[1][v21 + 1]
                            + a7[1][v20 + 1]
                            + a7[1][v19 + 1]
                            + a7[1][v18 + 1]
                            + a7[1][v17 + 1]
                            + a7[1][v14 + 1]
                            + a7[1][v16 + 1]
                            + a7[1][v15 + 1]
                            + a7[1][v13 + 1]
                            + a7[1][v12 + 1]) >> 5)
            + ((a7[0][*v11 + 1]
              + a7[0][*(v11 - 1281) + 1]
              + a7[0][v11[1279] + 1]
              + a7[0][v24 + 1]
              + a7[0][v23 + 1]
              + a7[0][v22 + 1]
              + a7[0][v21 + 1]
              + a7[0][v20 + 1]
              + a7[0][v19 + 1]
              + a7[0][v18 + 1]
              + a7[0][v17 + 1]
              + a7[0][v16 + 1]
              + a7[0][v15 + 1]
              + a7[0][v14 + 1]
              + a7[0][v13 + 1]
              + a7[0][v12 + 1]) & 0xFFFFFFE0);
        *v38++ = a1a[(a7[2][*(v11 - 1281) + 1]
                    + a7[2][*v11 + 1]
                    + a7[2][v11[1279] + 1]
                    + a7[2][v24 + 1]
                    + a7[2][v23 + 1]
                    + a7[2][v22 + 1]
                    + a7[2][v21 + 1]
                    + a7[2][v20 + 1]
                    + a7[2][v19 + 1]
                    + a7[2][v18 + 1]
                    + a7[2][v17 + 1]
                    + a7[2][v16 + 1]
                    + a7[2][v15 + 1]
                    + a7[2][v14 + 1]
                    + a7[2][v13 + 1]
                    + a7[2][v12 + 1]) & 0xFFFFFFE0][v25];
        --v42;
      }
      while ( v42 );
      v35 += 640;
      ++v36;
    }
    while ( v36 < a7[0][0] );
  }
  PollSound();
  v26 = BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\Blur.cpp", 139);
  v27 = v26;
  v28 = (int)v26;
  v29 = BaseAlloc(0x300u, "F:\\h2xsrc\\Base\\Blur.cpp", 140);
  memcpy(v27, gPalette->contents, 0x300u);
  v30 = v28;
  v31 = v29;
  v32 = 256;
  a7[0][1] = v28;
  do
  {
    *(_BYTE *)v31 = a4 + *(_BYTE *)v30;
    *((_BYTE *)v31 + 1) = a5 + *(_BYTE *)(v30 + 1);
    *((_BYTE *)v31 + 2) = a6 + *(_BYTE *)(v30 + 2);
    if ( *(_BYTE *)v31 > 63 )
      *(_BYTE *)v31 = 63;
    if ( *(_BYTE *)v31 < 0 )
      *(_BYTE *)v31 = 0;
    if ( *((_BYTE *)v31 + 1) > 63 )
      *((_BYTE *)v31 + 1) = 63;
    if ( *((_BYTE *)v31 + 1) < 0 )
      *((_BYTE *)v31 + 1) = 0;
    if ( *((_BYTE *)v31 + 2) > 63 )
      *((_BYTE *)v31 + 2) = 63;
    if ( *((_BYTE *)v31 + 2) < 0 )
      *((_BYTE *)v31 + 2) = 0;
    v30 += 3;
    v31 = (char *)v31 + 3;
    --v32;
  }
  while ( v32 );
  v33 = a7[0][1];
  heroWindowManager::FizzleForward(gpWindowManager, 0, 0, 640, height, 150, (const void *)a7[0][1], (int)v29);
  DelayMilli((signed __int64)(gfCombatSpeedMod[giCombatSpeed] * 350.0));
  heroWindowManager::SaveFizzleSource(gpWindowManager, 0, 0, 640, height);
  memcpy(toBmpa->contents, newBMP->contents, npixels);
  heroWindowManager::FizzleForward(gpWindowManager, 0, 0, 640, height, 150, v29, v33);
  BaseFree(a1a, (int)"F:\\h2xsrc\\Base\\Blur.cpp", 168);
  if ( newBMP )
    ((void (__stdcall *)(signed int))newBMP->vtable->scalarDeletingDestructor)(1);
  mouseManager::ShowColorPointer(gpMouseManager);
  BaseFree((void *)v33, (int)"F:\\h2xsrc\\Base\\Blur.cpp", 173);
  BaseFree((void *)v29, (int)"F:\\h2xsrc\\Base\\Blur.cpp", 174);
}

//----- (004D82D0) --------------------------------------------------------
int __fastcall MonoIconToBitmap(icon *a1, bitmap *a2, int x, int y, int idx, char color, signed int a7, int a8, int a9, unsigned int a10, int a11)
{
  IconEntry *v11; // esi@1
  int v12; // ecx@1
  int v13; // eax@1
  int v14; // esi@1
  int v15; // edi@1
  int v16; // esi@1
  int v17; // eax@5
  int v18; // ecx@5
  unsigned int v19; // ecx@9
  int v20; // ebp@9
  int result; // eax@10
  unsigned int v22; // edx@10
  int v23; // edx@11
  int v24; // eax@15
  int v25; // edi@15
  int v26; // eax@18
  int v27; // ST10_4@23
  int v28; // ecx@25
  unsigned int v29; // ecx@25
  int v30; // [sp+14h] [bp-4h]@9

  v11 = a1->headersAndImageData;
  v12 = (int)&v11[idx];
  dword_537A18 = v12;
  v13 = (int)((char *)v11 + *(_DWORD *)(v12 + 9));
  v14 = *(_WORD *)v12;
  v15 = *(_WORD *)(v12 + 2);
  dword_537A08 = v13;
  v16 = v14 + x;
  dword_537A04 = v16;
  dword_537A00 = v15 + y;
  if ( !a7 )
    goto LABEL_9;
  if ( a8 > dword_537A04 || dword_537A04 + *(_WORD *)(v12 + 4) > (signed int)(a8 + a10) || dword_537A00 < a9 )
  {
    v18 = a11;
    goto LABEL_8;
  }
  v17 = dword_537A00 + *(_WORD *)(v12 + 6);
  v18 = a11;
  if ( v17 > a11 + a9 )
  {
LABEL_8:
    a7 = 1;
    dword_537A10 = a8 + a10 - 1;
    dword_537A14 = a9 + v18 - 1;
    goto LABEL_9;
  }
  a7 = 0;
LABEL_9:
  v19 = (unsigned int)a2->contents;
  v20 = v19 + a2->width * dword_537A00;
  v30 = a2->width;
  while ( 1 )
  {
    while ( 1 )
    {
      result = dword_537A08 + 1;
      dword_5379F8 = v16;
      dword_537A08 = result;
      v22 = *(_BYTE *)(result - 1);
      if ( (char)v22 < 0 )
        break;
      dword_5379FC = *(_BYTE *)(result - 1);
      if ( v22 )
      {
        if ( !a7 )
        {
          BYTE1(v19) = color;
          LOBYTE(v19) = color;
          v24 = v19 << 16;
          LOWORD(v24) = v19;
          memset32((void *)(v20 + v16), v24, v22 >> 2);
          v25 = v20 + v16 + 4 * (v22 >> 2);
          LOBYTE(v19) = v22;
LABEL_27:
          memset((void *)v25, v24, v19 & 3);
          HIWORD(v19) = 0;
          goto LABEL_28;
        }
        HIWORD(v19) = HIWORD(a9);
        if ( dword_537A00 >= a9 )
        {
          HIWORD(v19) = HIWORD(dword_537A14);
          if ( dword_537A00 <= dword_537A14 )
          {
            v26 = v22 + v16;
            HIWORD(v19) = HIWORD(a8);
            if ( a8 < (signed int)(v22 + v16) )
            {
              HIWORD(v19) = HIWORD(dword_537A10);
              if ( v16 <= dword_537A10 )
              {
                HIWORD(v19) = HIWORD(dword_537A10);
                if ( v16 < a8 )
                {
                  if ( v26 > dword_537A10 )
                  {
                    BYTE1(v19) = color;
                    LOBYTE(v19) = color;
                    v24 = v19 << 16;
                    LOWORD(v24) = v19;
                    memset32((void *)(v20 + a8), v24, a10 >> 2);
                    v25 = v20 + a8 + 4 * (a10 >> 2);
                    LOBYTE(v19) = a10;
                  }
                  else
                  {
                    v28 = v22 + v16 - a8;
                    BYTE1(v28) = color;
                    LOBYTE(v28) = color;
                    v24 = v28 << 16;
                    LOWORD(v24) = v28;
                    v29 = (v22 + v16 - a8) >> 2;
                    memset32((void *)(v20 + a8), v24, v29);
                    v25 = v20 + a8 + 4 * v29;
                    v19 = v22 + v16 - a8;
                  }
                }
                else if ( v26 > dword_537A10 )
                {
                  BYTE1(v19) = color;
                  LOBYTE(v19) = color;
                  v27 = dword_537A10 - v16 + 1;
                  v24 = v19 << 16;
                  LOWORD(v24) = v19;
                  v19 = (unsigned int)(dword_537A10 - v16 + 1) >> 2;
                  memset32((void *)(v20 + v16), v24, v19);
                  v25 = v20 + v16 + 4 * v19;
                  LOBYTE(v19) = v27;
                }
                else
                {
                  BYTE1(v19) = color;
                  LOBYTE(v19) = color;
                  v24 = v19 << 16;
                  LOWORD(v24) = v19;
                  memset32((void *)(v20 + v16), v24, v22 >> 2);
                  v25 = v20 + v16 + 4 * (v22 >> 2);
                  LOBYTE(v19) = v22;
                }
                goto LABEL_27;
              }
            }
          }
        }
LABEL_28:
        v16 += v22;
        dword_5379FC = v22;
      }
      else
      {
        v16 = dword_537A04;
        v20 += v30;
        v19 = dword_537A00++ + 1;
      }
    }
    dword_537A0C = v20;
    dword_5379FC = v22;
    v23 = v22 & 0x7F;
    if ( !v23 )
      return result;
    v16 += v23;
  }
}
// 5379F8: using guessed type int dword_5379F8;
// 5379FC: using guessed type int dword_5379FC;
// 537A00: using guessed type int dword_537A00;
// 537A04: using guessed type int dword_537A04;
// 537A08: using guessed type int dword_537A08;
// 537A0C: using guessed type int dword_537A0C;
// 537A10: using guessed type int dword_537A10;
// 537A14: using guessed type int dword_537A14;
// 537A18: using guessed type int dword_537A18;

//----- (004D8580) --------------------------------------------------------
int __fastcall DimIconToBitmap(icon *a1, int a2, int a3, int a4, int a5, int a6, signed int a7, int a8, int a9, int a10, int a11)
{
  IconEntry *v11; // edi@1
  int v12; // ecx@1
  int v13; // esi@1
  int v14; // eax@1
  int v15; // edi@1
  int v16; // ecx@1
  int v17; // eax@5
  int v18; // esi@5
  int v19; // ebp@9
  int result; // eax@10
  int v21; // edx@10
  int v22; // edx@11
  int v23; // esi@15
  int v24; // edi@16
  int v25; // ebx@17
  int v26; // eax@21
  int v27; // eax@25
  int v28; // edi@25
  int v29; // ebx@33
  int v30; // [sp+10h] [bp-4h]@9

  v11 = a1->headersAndImageData;
  v12 = v11[a5].offsetX;
  v13 = (int)&v11[a5];
  v14 = (int)((char *)v11 + v11[a5].off);
  dword_537A24 = v13;
  v15 = *(_WORD *)(v13 + 2);
  dword_537A30 = v14;
  v16 = v12 + a3;
  dword_537A28 = v16;
  dword_537A20 = v15 + a4;
  if ( !a7 )
    goto LABEL_9;
  if ( a8 > dword_537A28 || dword_537A28 + *(_WORD *)(v13 + 4) > a8 + a10 || dword_537A20 < a9 )
  {
    v18 = a11;
    goto LABEL_8;
  }
  v17 = dword_537A20 + *(_WORD *)(v13 + 6);
  v18 = a11;
  if ( v17 > a11 + a9 )
  {
LABEL_8:
    a7 = 1;
    dword_537A3C = a8 + a10 - 1;
    dword_537A40 = a9 + v18 - 1;
    goto LABEL_9;
  }
  a7 = 0;
LABEL_9:
  v19 = *(_DWORD *)(a2 + 22) + *(_WORD *)(a2 + 18) * dword_537A20;
  v30 = *(_WORD *)(a2 + 18);
  while ( 1 )
  {
    while ( 1 )
    {
      result = dword_537A30 + 1;
      dword_537A2C = v16;
      dword_537A30 = result;
      v21 = *(_BYTE *)(result - 1);
      if ( (char)v21 < 0 )
        break;
      dword_537A48 = *(_BYTE *)(result - 1);
      if ( v21 )
      {
        if ( a7 )
        {
          if ( dword_537A20 >= a9 )
          {
            if ( dword_537A20 <= dword_537A40 )
            {
              v26 = v21 + v16;
              if ( a8 < v21 + v16 )
              {
                if ( v16 <= dword_537A3C )
                {
                  if ( v16 < a8 )
                  {
                    if ( v26 > dword_537A3C )
                      v27 = a10;
                    else
                      v27 = v21 + v16 - a8;
                    v28 = v19 + a8;
                  }
                  else if ( v26 > dword_537A3C )
                  {
                    v28 = v19 + v16;
                    v27 = dword_537A3C - v16 + 1;
                  }
                  else
                  {
                    v27 = v21;
                    v28 = v19 + v16;
                  }
                  dword_537A34 = v28;
                  dword_537A44 = v27;
                  dword_537A1C = 0;
                  if ( v27 > 0 )
                  {
                    dword_537A1C = v27;
                    do
                    {
                      ++v28;
                      v29 = *(_BYTE *)(v28 - 1);
                      --v27;
                      dword_537A34 = v28;
                      *(_BYTE *)(v28 - 1) = uDimPal[a6][v29];
                    }
                    while ( v27 );
                  }
                }
              }
            }
          }
        }
        else
        {
          v23 = v19 + v16;
          dword_537A1C = 0;
          dword_537A34 = v19 + v16;
          if ( v21 > 0 )
          {
            v24 = v21;
            dword_537A1C = v21;
            do
            {
              ++v23;
              v25 = *(_BYTE *)(v23 - 1);
              --v24;
              dword_537A34 = v23;
              *(_BYTE *)(v23 - 1) = uDimPal[a6][v25];
            }
            while ( v24 );
          }
        }
        v16 += v21;
        dword_537A48 = v21;
      }
      else
      {
        v16 = dword_537A28;
        v19 += v30;
        ++dword_537A20;
      }
    }
    dword_537A38 = v19;
    dword_537A48 = v21;
    v22 = v21 & 0x7F;
    if ( !v22 )
      break;
    v16 += v22;
  }
  return result;
}
// 537A1C: using guessed type int dword_537A1C;
// 537A20: using guessed type int dword_537A20;
// 537A24: using guessed type int dword_537A24;
// 537A28: using guessed type int dword_537A28;
// 537A2C: using guessed type int dword_537A2C;
// 537A30: using guessed type int dword_537A30;
// 537A34: using guessed type int dword_537A34;
// 537A38: using guessed type int dword_537A38;
// 537A3C: using guessed type int dword_537A3C;
// 537A40: using guessed type int dword_537A40;
// 537A44: using guessed type int dword_537A44;
// 537A48: using guessed type int dword_537A48;

//----- (004D87F0) --------------------------------------------------------
resource *__thiscall resource::resource(resource *this, RESOURCE_TYPE type, int fileID, __int16 referenceCount, resource *next)
{
  this->resourceType = type;
  this->vtable = (resourceVtable *)resource::_vftable_;
  this->referenceCount = referenceCount;
  this->fileID = fileID;
  this->next = next;
  return this;
}
// 4EAFB4: using guessed type int (*resource___vftable_[2])();

//----- (004D8820) --------------------------------------------------------
void __thiscall resource::_resource(void *this)
{
  *(_DWORD *)this = resource::_vftable_;
}
// 4EAFB4: using guessed type int (*resource___vftable_[2])();

//----- (004D8830) --------------------------------------------------------
void __fastcall BlitBitmapToScreenVesa(bitmap *bmp, int x, int y, unsigned int width, int height, int screenX, signed int screenY)
{
  int v7; // ebp@2
  signed int v8; // ebx@3
  int v9; // eax@3
  int v10; // esi@4
  int v11; // eax@14
  RECT Rect; // [sp+14h] [bp-10h]@28

  if ( gpWindowManager->screenBuffer == bmp || (v7 = 0, height <= 0) )
  {
    v8 = width;
  }
  else
  {
    v8 = width;
    v9 = 640 * screenY;
    do
    {
      v10 = v7++ + y;
      memcpy(&gpWindowManager->screenBuffer->contents[screenX] + v9, &bmp->contents[bmp->width * v10] + x, width);
      v9 += 640;
    }
    while ( v7 < height );
  }
  if ( gbEnlargeScreenBlit && !*(&bMenu + 7 * giCurExe + 5) )
  {
    if ( iMainWinScreenWidth != 640 || iMainWinScreenHeight != 480 )
    {
      if ( screenX > 0 )
        --screenX;
      if ( screenY > 0 )
        --screenY;
      if ( v8 < 637 )
        v8 += 4;
      if ( height < 637 )
      {
        v11 = height + 4;
        goto LABEL_23;
      }
    }
    else
    {
      if ( v8 < 640 )
        ++v8;
      if ( height < 640 )
      {
        v11 = height + 1;
LABEL_23:
        height = v11;
        goto LABEL_24;
      }
    }
  }
LABEL_24:
  if ( dword_4F1CC0 )
  {
    if ( screenY >= 411 )
      return;
    if ( height + screenY >= 411 )
      height = 411 - screenY;
  }
  Rect.left = screenX * iMainWinScreenWidth / 640;
  Rect.top = iMainWinScreenHeight * screenY / 480;
  Rect.right = iMainWinScreenWidth * (v8 + screenX) / 640 - 1;
  Rect.bottom = iMainWinScreenHeight * (height + screenY) / 480 - 1;
  if ( !InvalidateRect(hwndApp, &Rect, 0) )
    LogStr("InvalidateRect Failed");
  if ( !UpdateWindow(hwndApp) )
    LogStr("UpdateWindow Failed");
}
// 4F1CC0: using guessed type int dword_4F1CC0;
// 4F2E84: using guessed type int gbEnlargeScreenBlit;
// 4F2E88: using guessed type int giCurExe;

//----- (004D8A20) --------------------------------------------------------
textEntryWidget *__thiscall textEntryWidget::textEntryWidget(int this)
{
  textEntryWidget *v1; // esi@1

  v1 = (textEntryWidget *)this;
  textWidget::textWidget((textWidget *)this);
  v1->vtable = (int)&textEntryWidget::_vftable_;
  v1->field_31 = 0;
  v1->icon = 0;
  v1->field_14 = 16384;
  v1->fifthShort = 0;
  v1->field_2F = 0;
  v1->field_4B = 0;
  return v1;
}
// 4EAFB8: using guessed type widgetVtable textEntryWidget___vftable_;

//----- (004D8A50) --------------------------------------------------------
textEntryWidget *__thiscall textEntryWidget::_scalar_deleting_destructor_(textEntryWidget *this, char a2)
{
  int icn; // eax@1
  textEntryWidget *thisa; // esi@1

  icn = this->icon;
  this->vtable = (int)&textEntryWidget::_vftable_;
  thisa = this;
  resourceManager::Dispose(gpResourceManager, (resource *)icn);
  textWidget::_textWidget((textWidget *)thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}
// 4EAFB8: using guessed type widgetVtable textEntryWidget___vftable_;

//----- (004D8A90) --------------------------------------------------------
int __thiscall textEntryWidget::textEntryWidget(int this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, unsigned __int16 a6, int a7, const char *a8, __int16 a9, const char *filename, __int16 a11, __int16 a12, __int16 a13, __int16 a14, __int16 a15, __int16 a16)
{
  int v16; // ebx@1
  icon *v17; // eax@1
  __int16 v18; // cx@1
  __int16 v19; // dx@1
  __int16 v20; // cx@1
  __int16 v21; // cx@2
  __int16 v22; // ax@2
  __int16 v23; // cx@2

  v16 = this;
  textWidget::textWidget((textWidget *)this, a2, a3, a4, a5, (char *)a7, a8, a9, a12, a13, 1);
  *(_WORD *)(v16 + 51) = a6;
  *(_WORD *)(v16 + 49) = 0;
  *(_DWORD *)v16 = &textEntryWidget::_vftable_;
  v17 = resourceManager::GetIcon(gpResourceManager, filename);
  v18 = *(_WORD *)(v16 + 24);
  *(_DWORD *)(v16 + 43) = v17;
  *(_WORD *)(v16 + 75) = 0;
  *(_WORD *)(v16 + 20) = 16384;
  v19 = *(_WORD *)(v16 + 26);
  *(_WORD *)(v16 + 47) = a11;
  *(_WORD *)(v16 + 69) = 1;
  *(_WORD *)(v16 + 71) = 0;
  *(_WORD *)(v16 + 40) = 1;
  LOWORD(v17) = *(_WORD *)(v16 + 28);
  *(_WORD *)(v16 + 53) = v18;
  v20 = *(_WORD *)(v16 + 30);
  *(_WORD *)(v16 + 55) = v19;
  *(_WORD *)(v16 + 57) = (_WORD)v17;
  *(_WORD *)(v16 + 51) = a6;
  *(_WORD *)(v16 + 59) = v20;
  *(_DWORD *)(v16 + 32) = BaseAlloc(a6 + 5, "F:\\h2xsrc\\Base\\Textntry.cpp", 62);
  strcpy(*(char **)(v16 + 32), (const char *)a7);
  if ( a14 == 4 )
  {
    *(_WORD *)(v16 + 71) = 1;
    v21 = a16 + *(_WORD *)(v16 + 26);
    *(_WORD *)(v16 + 65) = a15 + *(_WORD *)(v16 + 24);
    v22 = *(_WORD *)(v16 + 28) - 2 * a15;
    *(_WORD *)(v16 + 67) = v21;
    v23 = *(_WORD *)(v16 + 30);
    *(_WORD *)(v16 + 61) = v22;
    *(_WORD *)(v16 + 63) = v23;
  }
  return v16;
}
// 4EAFB8: using guessed type widgetVtable textEntryWidget___vftable_;

//----- (004D8BD0) --------------------------------------------------------
__int16 __thiscall textEntryWidget::Read(textEntryWidget *this, int type)
{
  textEntryWidget *thisa; // esi@1
  __int16 v3; // ax@1
  __int16 v4; // cx@3
  __int16 v5; // dx@3
  __int16 v6; // ax@3
  __int16 v7; // cx@6
  __int16 v8; // ax@7
  __int16 v9; // cx@8
  __int16 v10; // cx@9
  __int16 v11; // dx@9
  __int16 v12; // ax@9
  __int16 result; // ax@10
  char buf; // [sp+8h] [bp-10h]@1

  thisa = this;
  this->offsetX = resourceManager::ReadWord(gpResourceManager);
  thisa->offsetY = resourceManager::ReadWord(gpResourceManager);
  thisa->width = resourceManager::ReadWord(gpResourceManager);
  thisa->height = resourceManager::ReadWord(gpResourceManager);
  v3 = resourceManager::ReadWord(gpResourceManager);
  thisa->fifthShort = v3;
  thisa->ptrToFifthShortPlusFiveManyBytes = BaseAlloc((unsigned __int16)v3 + 5, "F:\\h2xsrc\\Base\\Textntry.cpp", 99);
  resourceManager::ReadBlock(gpResourceManager, thisa->ptrToFifthShortPlusFiveManyBytes, thisa->fifthShort);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  thisa->font = (int)resourceManager::GetFont(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  thisa->field_28 = (unsigned __int8)resourceManager::ReadWord(gpResourceManager);
  thisa->field_2A = resourceManager::ReadWord(gpResourceManager);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  thisa->icon = (int)resourceManager::GetIcon(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  thisa->type = type;
  if ( type == 2 )
  {
    thisa->field_35 = resourceManager::ReadWord(gpResourceManager);
    thisa->field_37 = resourceManager::ReadWord(gpResourceManager);
    thisa->field_39 = resourceManager::ReadWord(gpResourceManager);
    thisa->field_3B = resourceManager::ReadWord(gpResourceManager);
    thisa->field_45 = resourceManager::ReadWord(gpResourceManager);
    thisa->field_47 = resourceManager::ReadWord(gpResourceManager);
  }
  else
  {
    v4 = thisa->offsetY;
    v5 = thisa->width;
    thisa->field_35 = thisa->offsetX;
    v6 = thisa->height;
    thisa->field_37 = v4;
    thisa->field_39 = v5;
    thisa->field_3B = v6;
    thisa->field_45 = 1;
    thisa->field_47 = 1;
    if ( type != 3 )
      thisa->field_47 = 0;
  }
  if ( type == 4 )
  {
    thisa->field_41 = thisa->offsetX + 7;
    v7 = thisa->height;
    thisa->field_43 = thisa->offsetY + 5;
    thisa->field_3D = thisa->width - 14;
    thisa->field_3F = v7;
  }
  else
  {
    v8 = thisa->offsetX;
    if ( type == 5 )
    {
      thisa->field_41 = v8 + 7;
      v9 = thisa->height;
      thisa->field_43 = thisa->offsetY + 4;
      thisa->field_3D = thisa->width - 14;
      thisa->field_3F = v9;
    }
    else
    {
      v10 = thisa->offsetY;
      v11 = thisa->width;
      thisa->field_41 = v8;
      v12 = thisa->height;
      thisa->field_43 = v10;
      thisa->field_3D = v11;
      thisa->field_3F = v12;
    }
  }
  thisa->field_2F = resourceManager::ReadWord(gpResourceManager);
  thisa->fieldID = resourceManager::ReadWord(gpResourceManager);
  result = resourceManager::ReadWord(gpResourceManager);
  thisa->field_14 = 16384;
  return result;
}

//----- (004D8E40) --------------------------------------------------------
#error "4D920B: switch analysis failed (funcsize=612)"

//----- (004D96C0) --------------------------------------------------------
// Actually a TextEntry, but IDA crashes when I set it to TextEntry
void __thiscall textEntryWidget::Draw(int this)
{
  int v1; // ebp@1
  unsigned int i; // esi@2
  int v3; // eax@5
  char v4; // [sp+Fh] [bp-259h]@3
  char str; // [sp+10h] [bp-258h]@2

  v1 = this;
  if ( *(_WORD *)(this + 73) == 3 )
  {
    strcpy(&str, (const char *)(*(_DWORD *)(this + 32) + *(_WORD *)(this + 75)));
    for ( i = strlen(&str); font::LineWidth(*(font **)(v1 + 36), &str) > *(_WORD *)(v1 + 61); --i )
      *(&v4 + i) = 0;
    icon::DrawToBuffer(
      *(icon **)(v1 + 43),
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 53),
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 55),
      *(_WORD *)(v1 + 47),
      0);
    font::DrawBoundedString(
      *(font **)(v1 + 36),
      &str,
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 65),
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 67),
      *(_WORD *)(v1 + 61),
      *(_WORD *)(v1 + 63),
      *(_WORD *)(v1 + 40),
      *(_BYTE *)(v1 + 42));
  }
  else
  {
    icon::DrawToBuffer(
      *(icon **)(this + 43),
      *(_DWORD *)(*(_DWORD *)(this + 4) + 40) + *(_WORD *)(this + 53),
      *(_DWORD *)(*(_DWORD *)(this + 4) + 44) + *(_WORD *)(this + 55),
      *(_WORD *)(this + 47),
      0);
    v3 = 3;
    if ( !(*(_BYTE *)(v1 + 22) & 8) )
      v3 = *(_WORD *)(v1 + 40);
    font::DrawBoundedString(
      *(font **)(v1 + 36),
      *(char **)(v1 + 32),
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 65),
      *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 67),
      *(_WORD *)(v1 + 61),
      *(_WORD *)(v1 + 63),
      v3,
      *(_BYTE *)(v1 + 42));
  }
}

//----- (004D9820) --------------------------------------------------------
void *__thiscall textEntryWidget::SetupDisplayString(textEntryWidget *this, const char *a2, unsigned __int16 a3)
{
  textEntryWidget *thisa; // ebp@1
  const char *v4; // esi@4
  unsigned int v5; // ebx@7
  void *result; // eax@10
  int v7; // ecx@14
  int v8; // ebx@18
  signed int v9; // [sp+10h] [bp-130h]@13
  char str; // [sp+14h] [bp-12Ch]@13
  char v11[299]; // [sp+15h] [bp-12Bh]@14

  thisa = this;
  if ( KBTickCount() > glTimers )
  {
    thisa->_2 = 1 - thisa->_2;
    glTimers = KBTickCount() + 360;
  }
  if ( a3 )
  {
    v4 = a2;
    strncpy((char *)thisa->ptrToFifthShortPlusFiveManyBytes, a2, a3);
  }
  else
  {
    v4 = a2;
  }
  if ( thisa->_2 )
  {
    v5 = a3;
    *((_BYTE *)thisa->ptrToFifthShortPlusFiveManyBytes + a3) = 31;
  }
  else
  {
    v5 = a3;
    *((_BYTE *)thisa->ptrToFifthShortPlusFiveManyBytes + a3) = 95;
  }
  if ( strlen(v4) <= v5 )
  {
    result = thisa->ptrToFifthShortPlusFiveManyBytes;
    *((_BYTE *)result + v5 + 1) = 0;
  }
  else
  {
    result = thisa->ptrToFifthShortPlusFiveManyBytes;
    strcpy((char *)result + v5 + 1, &v4[v5]);
  }
  if ( thisa->type == 3 )
  {
    do
    {
      v9 = 0;
      strcpy(&str, (const char *)thisa->ptrToFifthShortPlusFiveManyBytes + thisa->field_4B);
      if ( font::LineWidth((font *)thisa->font, &str) > thisa->field_3D )
      {
        v7 = thisa->font;
        v11[v5 - thisa->field_4B] = 0;
        if ( font::LineWidth((font *)v7, &str) > thisa->field_3D )
        {
          v9 = 1;
          ++thisa->field_4B;
        }
      }
      result = (void *)v9;
    }
    while ( v9 );
    if ( thisa->field_4B > 0 )
    {
      do
      {
        v8 = 0;
        strcpy(&str, (const char *)thisa->ptrToFifthShortPlusFiveManyBytes + thisa->field_4B - 1);
        result = (void *)font::LineWidth((font *)thisa->font, &str);
        if ( (signed int)result > thisa->field_3D )
          v8 = 0;
        else
          --thisa->field_4B;
        if ( !thisa->field_4B )
          v8 = 0;
      }
      while ( v8 );
    }
  }
  return result;
}
// 4D9820: using guessed type char var_12B[299];

//----- (004D99E0) --------------------------------------------------------
listBox *__thiscall listBoxWidget::listBoxWidget(listBox *this)
{
  listBox *v1; // esi@1

  v1 = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  v1->vtable = (int)&listBoxWidget::_vftable_;
  *(_DWORD *)&v1->field_3C = 0;
  *(_DWORD *)&v1->field_72[14] = 0;
  v1->field_32 = 0;
  v1->field_34 = -1;
  v1->field_36 = -1;
  return v1;
}
// 4EAFC8: using guessed type widgetVtable listBoxWidget___vftable_;

//----- (004D9A30) --------------------------------------------------------
int __thiscall listBoxWidget::_scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  listBoxWidget::_listBoxWidget(this);
  if ( a2 & 1 )
    operator delete((void *)v2);
  return v2;
}

//----- (004D9A50) --------------------------------------------------------
void __thiscall listBoxWidget::_listBoxWidget(int this)
{
  resource *v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ebx@3
  signed int v5; // edi@3

  v1 = *(resource **)(this + 32);
  *(_DWORD *)this = &listBoxWidget::_vftable_;
  v2 = this;
  resourceManager::Dispose(gpResourceManager, v1);
  resourceManager::Dispose(gpResourceManager, *(resource **)(v2 + 36));
  v3 = *(_DWORD *)(v2 + 142);
  if ( v3 )
    (**(void (__stdcall ***)(_DWORD))v3)(1);
  v4 = 0;
  v5 = 0;
  while ( *(_WORD *)(v2 + 50) > v5 )
  {
    v4 += 4;
    ++v5;
    BaseFree(*(void **)(*(_DWORD *)(v2 + 60) + v4 - 4), (int)"F:\\h2xsrc\\Base\\listbox.cpp", 25);
  }
  BaseFree(*(void **)(v2 + 60), (int)"F:\\h2xsrc\\Base\\listbox.cpp", 27);
  gbSendMouseMoveMessages = 0;
  widget::_widget((void *)v2);
}
// 4EAFC8: using guessed type widgetVtable listBoxWidget___vftable_;
// 4F19AC: using guessed type int gbSendMouseMoveMessages;

//----- (004D9AE0) --------------------------------------------------------
__int16 __thiscall listBoxWidget::Read(listBox *this)
{
  listBox *v1; // esi@1
  __int16 v2; // ax@1
  int v3; // ecx@1
  int v4; // eax@1
  __int16 v5; // ST14_2@1
  __int16 v6; // di@1
  __int16 v7; // bx@1
  __int16 v8; // bp@1
  __int16 v9; // dx@1
  __int16 v10; // bx@1
  int v11; // eax@1
  __int16 v12; // di@1
  __int16 v13; // dx@1
  int v14; // eax@1
  __int16 v15; // bp@1
  __int16 result; // ax@1
  char buf; // [sp+14h] [bp-10h]@1

  v1 = this;
  this->offsetX = resourceManager::ReadWord(gpResourceManager);
  v1->offsetY = resourceManager::ReadWord(gpResourceManager);
  v1->width = resourceManager::ReadWord(gpResourceManager);
  v1->height = resourceManager::ReadWord(gpResourceManager);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  v1->fontID = (int)resourceManager::GetFont(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  v1->icon = resourceManager::GetIcon(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  v1->field_28 = resourceManager::ReadWord(gpResourceManager);
  v1->field_2C = resourceManager::ReadWord(gpResourceManager);
  v1->field_2E = resourceManager::ReadWord(gpResourceManager);
  v1->field_30 = resourceManager::ReadWord(gpResourceManager);
  v2 = resourceManager::ReadWord(gpResourceManager);
  v1->field_44[0] = 0;
  v1->fieldID = v2;
  v1->field_44[1] = 1;
  v1->field_44[2] = 2;
  v1->field_44[3] = 3;
  v1->field_44[4] = 4;
  v1->field_44[5] = 5;
  v1->field_44[6] = 6;
  v1->field_44[7] = 7;
  v1->field_44[8] = 8;
  v1->field_44[9] = 9;
  v1->field_44[10] = 10;
  v3 = (int)v1->icon;
  v4 = *(_DWORD *)(v3 + 18);
  v3 += 18;
  v4 += 130;
  v1->field_72[9] = *(_WORD *)(v4 + 4);
  LOWORD(v4) = *(_WORD *)(v4 + 6);
  v5 = v4;
  v1->field_72[10] = v4;
  v6 = *(_WORD *)(*(_DWORD *)v3 + 6);
  v1->field_44[11] = v6;
  v7 = v1->offsetX;
  LOWORD(v4) = *(_WORD *)(*(_DWORD *)v3 + 19);
  v8 = v1->offsetY;
  v1->field_44[12] = v4;
  v9 = *(_WORD *)(*(_DWORD *)v3 + 32);
  v1->field_44[13] = v9;
  v1->field_44[14] = v7;
  v1->field_44[15] = v8;
  v1->field_44[16] = *(_WORD *)(*(_DWORD *)v3 + 4);
  v1->field_44[17] = v9 + v6 + (_WORD)v4 * (v1->field_28 - 2);
  v10 = *(_WORD *)(*(_DWORD *)v3 + 43);
  v11 = *(_DWORD *)v3 + 39;
  v1->field_44[20] = v10;
  v12 = *(_WORD *)(v11 + 6);
  v1->field_44[21] = v12;
  v13 = *(_WORD *)(*(_DWORD *)v3 + 69);
  v14 = *(_DWORD *)v3 + 65;
  LOWORD(v3) = v1->width - v10;
  v1->field_72[5] = v13;
  LOWORD(v3) = v1->offsetX + v3;
  LOWORD(v14) = *(_WORD *)(v14 + 6);
  v1->field_72[6] = v14;
  v1->field_44[18] = v3;
  v1->field_44[19] = v8;
  v15 = v1->height - v14;
  v1->field_72[3] = v3;
  LOWORD(v14) = v15 + v1->offsetY;
  v1->field_72[4] = v14;
  v1->field_44[22] = v3;
  LOWORD(v3) = v12 + v1->offsetY;
  LOWORD(v14) = v14 - v3;
  LOBYTE(v1->field_72[12]) = 0;
  HIBYTE(v1->field_72[12]) = 0;
  HIBYTE(v1->field_72[13]) = 0;
  LOBYTE(v1->field_72[13]) = 0;
  v1->field_40 = 0;
  v1->field_42 = 0;
  v1->field_2A = 0;
  v1->field_72[0] = v3;
  v1->field_72[1] = v13;
  v1->field_72[2] = v14;
  result = v14 - v5 - 7;
  v1->field_72[11] = result;
  return result;
}

//----- (004D9D50) --------------------------------------------------------
void __thiscall listBoxWidget::DeleteItem(int this, int a2)
{
  __int16 v2; // dx@1
  int v3; // ebx@1
  int v4; // ecx@1
  __int16 v5; // ax@4
  unsigned __int8 v6; // sf@7
  __int16 v7; // ax@11
  void *v8; // ecx@17
  __int16 v9; // ax@20
  unsigned __int8 v10; // zf@20
  void *v11; // [sp+10h] [bp-4h]@15

  v2 = *(_WORD *)(this + 50);
  v3 = this;
  v4 = *(_WORD *)(this + 50);
  if ( v4 > a2 )
  {
    if ( *(_WORD *)(v3 + 52) == a2 )
      *(_WORD *)(v3 + 52) = -1;
    v5 = *(_WORD *)(v3 + 64);
    if ( *(_WORD *)(v3 + 64) == a2 && *(_WORD *)(v3 + 66) <= v5 )
      *(_WORD *)(v3 + 64) = v5 - 1;
    v6 = (signed __int16)((*(_WORD *)(v3 + 66))-- - 1) < 0;
    if ( v6 )
      *(_WORD *)(v3 + 66) = 0;
    if ( *(_WORD *)(v3 + 64) < 0 )
      *(_WORD *)(v3 + 64) = 0;
    v7 = *(_WORD *)(v3 + 66);
    if ( *(_WORD *)(v3 + 64) > v7 )
      *(_WORD *)(v3 + 64) = v7;
    if ( v2 == 1 )
    {
      BaseFree(**(void ***)(v3 + 60), (int)"F:\\h2xsrc\\Base\\listbox.cpp", 156);
      BaseFree(*(void **)(v3 + 60), (int)"F:\\h2xsrc\\Base\\listbox.cpp", 157);
      *(_DWORD *)(v3 + 60) = 0;
    }
    else
    {
      v11 = BaseAlloc(4 * v4 - 4, "F:\\h2xsrc\\Base\\listbox.cpp", 162);
      memcpy(v11, *(const void **)(v3 + 60), 4 * ((unsigned int)(4 * *(_WORD *)(v3 + 50) - 4) >> 2));
      if ( *(_WORD *)(v3 + 50) - a2 - 1 > 0 )
        memcpy(
          (char *)v11 + 4 * a2,
          (const void *)(*(_DWORD *)(v3 + 60) + 4 * a2 + 4),
          4 * ((unsigned int)(4 * (*(_WORD *)(v3 + 50) - a2 - 1)) >> 2));
      v8 = *(void **)(v3 + 60);
      if ( v8 )
        BaseFree(v8, (int)"F:\\h2xsrc\\Base\\listbox.cpp", 169);
      *(_DWORD *)(v3 + 60) = v11;
    }
    v9 = *(_WORD *)(v3 + 50) - 1;
    v10 = *(_WORD *)(v3 + 66) == 0;
    v6 = *(_WORD *)(v3 + 66) < 0;
    *(_WORD *)(v3 + 50) = v9;
    if ( v6 | v10 )
      *(_WORD *)(v3 + 42) = v9;
    else
      *(_WORD *)(v3 + 42) = *(_WORD *)(v3 + 40);
  }
}

//----- (004D9EA0) --------------------------------------------------------
#error "4D9FC7: switch analysis failed (funcsize=280)"

//----- (004DA210) --------------------------------------------------------
void __thiscall listBoxWidget::Draw(listBox *this)
{
  listBoxWidget::DrawLBStuff(this, 0);
}

//----- (004DA220) --------------------------------------------------------
void __thiscall listBoxWidget::DrawLBStuff(listBox *this, int a2)
{
  heroWindow *window; // eax@1
  listBox *thisa; // esi@1
  int v4; // edi@1
  int v5; // ebx@1
  signed int i; // ebp@1
  int v7; // eax@5
  int v8; // eax@8
  int v9; // eax@12
  int v10; // eax@17
  int v11; // eax@24
  int v12; // edi@26
  int v13; // ebx@27
  int v14; // eax@29
  int v15; // eax@31
  heroWindow *v16; // ebx@31
  int v17; // edi@31
  __int16 v18; // cx@31
  int v19; // eax@32
  int v20; // ecx@34
  int v21; // ST14_4@34
  int v22; // eax@34
  int v23; // [sp+10h] [bp-8h]@11
  int v24; // [sp+10h] [bp-8h]@16

  window = this->parentWindow;
  thisa = this;
  v4 = window->xOffset + this->field_44[14];
  v5 = window->yOffset + this->field_44[15];
  for ( i = 0; thisa->field_28 > i; ++i )
  {
    if ( i )
    {
      if ( thisa->field_28 - i == 1 )
      {
        icon::DrawToBuffer(thisa->icon, v4, v5, thisa->field_44[2], 0);
        if ( thisa->field_2A > i )
        {
          v23 = i + thisa->field_40;
          if ( thisa->field_34 == v23 )
            v9 = thisa->field_2E;
          else
            v9 = thisa->field_2C;
          font::DrawBoundedString(
            (font *)thisa->fontID,
            *(char **)(*(_DWORD *)&thisa->field_3C + 4 * v23),
            v4 + 5,
            v5 + 2,
            thisa->field_44[16] - 10,
            *(_DWORD *)(thisa->fontID + 16) + 1,
            v9,
            thisa->field_30);
        }
        continue;
      }
      icon::DrawToBuffer(thisa->icon, v4, v5, thisa->field_44[1], 0);
      if ( thisa->field_2A > i )
      {
        v24 = i + thisa->field_40;
        if ( thisa->field_34 == v24 )
          v10 = thisa->field_2E;
        else
          v10 = thisa->field_2C;
        font::DrawBoundedString(
          (font *)thisa->fontID,
          *(char **)(*(_DWORD *)&thisa->field_3C + 4 * v24),
          v4 + 5,
          v5 + 2,
          thisa->field_44[16] - 10,
          *(_DWORD *)(thisa->fontID + 16) + 1,
          v10,
          thisa->field_30);
      }
      v8 = thisa->field_44[12];
    }
    else
    {
      icon::DrawToBuffer(thisa->icon, v4, v5, thisa->field_44[0], 0);
      if ( thisa->field_2A > 0 )
      {
        if ( thisa->field_34 == thisa->field_40 )
          v7 = thisa->field_2E;
        else
          v7 = thisa->field_2C;
        font::DrawBoundedString(
          (font *)thisa->fontID,
          *(char **)(*(_DWORD *)&thisa->field_3C + 4 * thisa->field_40),
          v4 + 5,
          v5 + 4,
          thisa->field_44[16] - 10,
          *(_DWORD *)(thisa->fontID + 16) + 1,
          v7,
          thisa->field_30);
      }
      v8 = thisa->field_44[11];
    }
    v5 += v8;
  }
  if ( LOBYTE(thisa->field_72[12]) )
    v11 = thisa->field_44[4];
  else
    v11 = thisa->field_44[3];
  icon::DrawToBuffer(
    thisa->icon,
    thisa->parentWindow->xOffset + thisa->field_44[18],
    thisa->parentWindow->yOffset + thisa->field_44[19],
    v11,
    0);
  v12 = 2;
  icon::DrawToBuffer(
    thisa->icon,
    thisa->field_44[22] + thisa->parentWindow->xOffset,
    thisa->field_72[0] + thisa->parentWindow->yOffset,
    thisa->field_44[7],
    0);
  if ( thisa->field_28 - 2 > 2 )
  {
    do
    {
      v13 = v12++ - 1;
      icon::DrawToBuffer(
        thisa->icon,
        thisa->field_44[22] + thisa->parentWindow->xOffset,
        thisa->field_72[0] + thisa->parentWindow->yOffset + v13 * thisa->field_44[12],
        thisa->field_44[8],
        0);
    }
    while ( thisa->field_28 - 2 > v12 );
  }
  icon::DrawToBuffer(
    thisa->icon,
    thisa->field_44[22] + thisa->parentWindow->xOffset,
    thisa->field_72[0] + thisa->parentWindow->yOffset + (v12 - 1) * thisa->field_44[12],
    thisa->field_44[9],
    0);
  if ( HIBYTE(thisa->field_72[12]) )
    v14 = thisa->field_44[6];
  else
    v14 = thisa->field_44[5];
  v15 = icon::DrawToBuffer(
          thisa->icon,
          thisa->parentWindow->xOffset + thisa->field_72[3],
          thisa->parentWindow->yOffset + thisa->field_72[4],
          v14,
          0);
  LOWORD(v15) = thisa->field_44[22];
  v16 = thisa->parentWindow;
  v17 = v16->xOffset + v15 + 5;
  v18 = thisa->field_42;
  thisa->field_72[7] = v17;
  if ( v18 <= 0 )
    v19 = thisa->field_72[11] / 2;
  else
    v19 = thisa->field_72[11] * thisa->field_40 / v18;
  v20 = v16->yOffset;
  LOWORD(v20) = thisa->field_72[0] + v20;
  v21 = thisa->field_44[10];
  v22 = v20 + v19 + 3;
  thisa->field_72[8] = v22;
  icon::DrawToBuffer(thisa->icon, (signed __int16)v17, (signed __int16)v22, v21, 0);
  if ( a2 )
    heroWindowManager::UpdateScreenRegion(
      gpWindowManager,
      thisa->parentWindow->xOffset + thisa->offsetX,
      thisa->parentWindow->yOffset + thisa->offsetY,
      thisa->width,
      thisa->height);
}

//----- (004DA560) --------------------------------------------------------
signed int __thiscall listBoxWidget::ProcessMouseMessage(listBox *this, int a2)
{
  heroWindow *v2; // eax@1
  listBox *thisa; // esi@1
  int v4; // ebp@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // ecx@6
  int v10; // eax@7
  int v11; // ecx@11
  int v12; // edi@16
  int v13; // eax@16
  signed int result; // eax@22
  int v15; // edi@24
  int v16; // ecx@28
  int v17; // ecx@29
  __int16 v18; // ax@35
  __int16 v19; // ax@39
  int v20; // eax@42
  __int16 v21; // di@45
  int v22; // eax@45
  int v23; // ecx@53

  v2 = this->parentWindow;
  thisa = this;
  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 16) - v2->xOffset;
  v6 = *(_DWORD *)(a2 + 20) - v2->yOffset;
  v7 = thisa->field_44[15];
  v8 = *(_DWORD *)(a2 + 20) - v2->yOffset - v7;
  if ( *(_DWORD *)a2 == 4 )
  {
    if ( HIBYTE(thisa->field_72[13]) )
    {
      v9 = thisa->field_44[11];
      if ( v8 <= v9 )
        v10 = 0;
      else
        v10 = (v8 - v9) / thisa->field_44[12] + 1;
      if ( v10 < 0 )
        v10 = 0;
      v11 = thisa->field_2A;
      if ( v10 >= v11 )
        v10 = v11 - 1;
      if ( v10 + thisa->field_40 == thisa->field_34 )
        return 1;
      thisa->field_34 = thisa->field_40 + v10;
    }
    else
    {
      if ( !LOBYTE(thisa->field_72[13]) )
        return 0;
      v12 = thisa->field_42;
      v13 = (v12 + 1) * (v6 - thisa->field_72[10] / 2 - thisa->field_72[0] - 4) / thisa->field_72[11];
      if ( v13 < 0 )
        v13 = 0;
      if ( v13 > v12 )
        v13 = thisa->field_42;
      if ( thisa->field_40 == v13 )
        return 1;
      thisa->field_40 = v13;
    }
    goto LABEL_59;
  }
  if ( v4 == 8 )
  {
    if ( !thisa->field_32 )
      return 1;
    v15 = thisa->field_44[14];
    if ( v5 < v15 || v6 < v7 || v15 + thisa->field_44[16] <= v5 || v7 + thisa->field_44[17] <= v6 )
    {
      if ( thisa->field_44[21] + thisa->field_44[19] <= v6 )
      {
        if ( thisa->field_72[4] > v6 )
        {
          v20 = thisa->field_72[8];
          if ( v6 >= v20 && v20 + thisa->field_72[10] > v6 )
          {
            LOBYTE(thisa->field_72[13]) = 1;
            gbSendMouseMoveMessages = 1;
          }
          v21 = thisa->field_42;
          v22 = (thisa->field_42 + 1) * (v6 - thisa->field_72[10] / 2 - thisa->field_72[0] - 4) / thisa->field_72[11];
          thisa->field_40 = v22;
          if ( (signed __int16)v22 < 0 )
            thisa->field_40 = 0;
          if ( thisa->field_40 > v21 )
            thisa->field_40 = v21;
        }
        else
        {
          v19 = thisa->field_40;
          if ( thisa->field_42 > v19 )
            thisa->field_40 = v19 + 1;
          HIBYTE(thisa->field_72[12]) = 1;
        }
      }
      else
      {
        v18 = thisa->field_40;
        if ( v18 > 0 )
          thisa->field_40 = v18 - 1;
        LOBYTE(thisa->field_72[12]) = 1;
      }
    }
    else
    {
      v16 = thisa->field_44[11];
      if ( v8 <= v16 )
        v17 = thisa->field_40;
      else
        v17 = thisa->field_40 + (v8 - v16) / thisa->field_44[12] + 1;
      if ( thisa->field_32 <= v17 )
        return 1;
      HIBYTE(thisa->field_72[13]) = 1;
      gbSendMouseMoveMessages = 1;
      if ( thisa->field_34 == v17 )
        return 1;
      thisa->field_34 = v17;
    }
LABEL_59:
    listBoxWidget::DrawLBStuff(thisa, 1);
    return 1;
  }
  if ( v4 != 16 )
    return 1;
  gbSendMouseMoveMessages = 0;
  if ( LOBYTE(thisa->field_72[12]) || HIBYTE(thisa->field_72[12]) || LOBYTE(thisa->field_72[13]) )
  {
    LOBYTE(thisa->field_72[13]) = 0;
    HIBYTE(thisa->field_72[12]) = 0;
    LOBYTE(thisa->field_72[12]) = 0;
    goto LABEL_59;
  }
  if ( HIBYTE(thisa->field_72[13]) )
  {
    HIBYTE(thisa->field_72[13]) = 0;
    *(_DWORD *)(a2 + 4) = 12;
    *(_DWORD *)a2 = 512;
    *(_DWORD *)(a2 + 8) = thisa->fieldID;
    v23 = thisa->field_34;
    *(_DWORD *)(a2 + 12) = 1;
    *(_DWORD *)(a2 + 24) = v23;
    if ( thisa->field_36 == thisa->field_34 )
    {
      if ( KBTickCount() < *(_DWORD *)&thisa->field_38 + 400 )
        *(_DWORD *)(a2 + 12) = 2;
    }
    thisa->field_36 = thisa->field_34;
    *(_DWORD *)&thisa->field_38 = KBTickCount();
    result = 2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4F19AC: using guessed type int gbSendMouseMoveMessages;

//----- (004DA880) --------------------------------------------------------
int __thiscall dropListWidget::dropListWidget(int this)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(v1 + 64) = 0;
  result = v1;
  *(_DWORD *)v1 = &dropListWidget::_vftable_;
  *(_DWORD *)(v1 + 176) = 0;
  *(_WORD *)(v1 + 60) = 0;
  *(_WORD *)(v1 + 62) = -1;
  return result;
}
// 4EAFD8: using guessed type widgetVtable dropListWidget___vftable_;

//----- (004DA8C0) --------------------------------------------------------
int __thiscall dropListWidget::_scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  dropListWidget::_dropListWidget(this);
  if ( a2 & 1 )
    operator delete((void *)v2);
  return v2;
}

//----- (004DA8E0) --------------------------------------------------------
void __thiscall dropListWidget::_dropListWidget(int this)
{
  resource *v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ebx@3
  signed int v5; // edi@3

  v1 = *(resource **)(this + 32);
  *(_DWORD *)this = &dropListWidget::_vftable_;
  v2 = this;
  resourceManager::Dispose(gpResourceManager, v1);
  resourceManager::Dispose(gpResourceManager, *(resource **)(v2 + 36));
  v3 = *(_DWORD *)(v2 + 176);
  if ( v3 )
    (**(void (__stdcall ***)(_DWORD))v3)(1);
  v4 = 0;
  v5 = 0;
  while ( *(_WORD *)(v2 + 60) > v5 )
  {
    v4 += 4;
    ++v5;
    BaseFree(*(void **)(*(_DWORD *)(v2 + 64) + v4 - 4), (int)"F:\\h2xsrc\\Base\\droplist.cpp", 25);
  }
  BaseFree(*(void **)(v2 + 64), (int)"F:\\h2xsrc\\Base\\droplist.cpp", 27);
  widget::_widget((void *)v2);
}
// 4EAFD8: using guessed type widgetVtable dropListWidget___vftable_;

//----- (004DA960) --------------------------------------------------------
__int16 __thiscall dropListWidget::Read(int this)
{
  int v1; // esi@1
  __int16 v2; // ax@1
  __int16 v3; // bp@1
  int v4; // edx@1
  __int16 v5; // bx@1
  int v6; // eax@1
  __int16 v7; // cx@1
  int v8; // edi@1
  int v9; // eax@1
  __int16 result; // ax@1
  char buf; // [sp+10h] [bp-10h]@1

  v1 = this;
  *(_WORD *)(this + 24) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 26) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 28) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 30) = resourceManager::ReadWord(gpResourceManager);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  *(_DWORD *)(v1 + 32) = resourceManager::GetFont(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  resourceManager::Read13(gpResourceManager, &buf);
  resourceManager::SavePosition(gpResourceManager);
  *(_DWORD *)(v1 + 36) = resourceManager::GetIcon(gpResourceManager, &buf);
  resourceManager::RestorePosition(gpResourceManager);
  *(_WORD *)(v1 + 40) = resourceManager::ReadWord(gpResourceManager) + *(_WORD *)(v1 + 24);
  *(_WORD *)(v1 + 42) = resourceManager::ReadWord(gpResourceManager) + *(_WORD *)(v1 + 26);
  *(_WORD *)(v1 + 44) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 46) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 48) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 52) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 54) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 56) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 58) = resourceManager::ReadWord(gpResourceManager);
  v2 = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 72) = 0;
  *(_WORD *)(v1 + 74) = 1;
  *(_WORD *)(v1 + 76) = 2;
  *(_WORD *)(v1 + 78) = 3;
  *(_WORD *)(v1 + 80) = 4;
  *(_WORD *)(v1 + 82) = 5;
  *(_WORD *)(v1 + 84) = 6;
  *(_WORD *)(v1 + 86) = 7;
  *(_WORD *)(v1 + 88) = 8;
  *(_WORD *)(v1 + 90) = 9;
  *(_WORD *)(v1 + 92) = 10;
  *(_WORD *)(v1 + 16) = v2;
  v3 = *(_WORD *)(v1 + 24);
  v4 = *(_DWORD *)(v1 + 36) + 18;
  *(_WORD *)(v1 + 94) = 11;
  *(_WORD *)(v1 + 96) = 12;
  *(_WORD *)(v1 + 98) = 13;
  v5 = *(_WORD *)(v1 + 26);
  v6 = *(_DWORD *)v4;
  *(_WORD *)(v1 + 108) = v3;
  *(_WORD *)(v1 + 110) = v5;
  v7 = *(_WORD *)(v6 + 4);
  *(_WORD *)(v1 + 112) = v7;
  *(_WORD *)(v1 + 114) = *(_WORD *)(v6 + 6);
  v8 = *(_DWORD *)v4;
  *(_WORD *)(v1 + 100) = v3 + v7;
  v8 += 13;
  *(_WORD *)(v1 + 102) = v5;
  *(_WORD *)(v1 + 104) = *(_WORD *)(v8 + 4);
  *(_WORD *)(v1 + 106) = *(_WORD *)(v8 + 6);
  v9 = *(_DWORD *)v4 + 169;
  *(_WORD *)(v1 + 166) = *(_WORD *)(*(_DWORD *)v4 + 173);
  result = *(_WORD *)(v9 + 6);
  *(_WORD *)(v1 + 168) = result;
  return result;
}

//----- (004DAB80) --------------------------------------------------------
void __thiscall dropListWidget::DeleteItem(int this, int a2)
{
  int v2; // ebp@1
  __int16 v3; // ax@1
  int v4; // esi@1
  void *v5; // ecx@8
  void *v6; // [sp+10h] [bp-4h]@6

  v2 = this;
  v3 = *(_WORD *)(this + 60);
  v4 = *(_WORD *)(this + 60);
  if ( a2 < v4 )
  {
    if ( *(_WORD *)(this + 62) == a2 )
      *(_WORD *)(this + 62) = -1;
    if ( v3 == 1 )
    {
      BaseFree(**(void ***)(this + 64), (int)"F:\\h2xsrc\\Base\\droplist.cpp", 111);
      BaseFree(*(void **)(v2 + 64), (int)"F:\\h2xsrc\\Base\\droplist.cpp", 112);
      *(_DWORD *)(v2 + 64) = 0;
    }
    else
    {
      v6 = BaseAlloc(4 * v4 - 4, "F:\\h2xsrc\\Base\\droplist.cpp", 117);
      memcpy(v6, *(const void **)(v2 + 64), 4 * ((unsigned int)(4 * *(_WORD *)(v2 + 60) - 4) >> 2));
      if ( *(_WORD *)(v2 + 60) - a2 - 1 > 0 )
        memcpy(
          (char *)v6 + 4 * a2,
          (const void *)(*(_DWORD *)(v2 + 64) + 4 * a2 + 4),
          4 * ((unsigned int)(4 * (*(_WORD *)(v2 + 60) - a2 - 1)) >> 2));
      v5 = *(void **)(v2 + 64);
      if ( v5 )
        BaseFree(v5, (int)"F:\\h2xsrc\\Base\\droplist.cpp", 123);
      *(_DWORD *)(v2 + 64) = v6;
    }
    --*(_WORD *)(v2 + 60);
  }
}

//----- (004DAC60) --------------------------------------------------------
#error "4DADB8: switch analysis failed (funcsize=273)"

//----- (004DAFB0) --------------------------------------------------------
void __thiscall dropListWidget::Draw(int this)
{
  int v1; // esi@1
  __int16 v2; // dx@2
  int v3; // eax@3

  v1 = this;
  icon::DrawToBuffer(
    *(icon **)(v1 + 36),
    *(_DWORD *)(*(_DWORD *)(this + 4) + 40) + *(_WORD *)(v1 + 108),
    *(_DWORD *)(*(_DWORD *)(this + 4) + 44) + *(_WORD *)(v1 + 110),
    *(_WORD *)(this + 72),
    0);
  icon::DrawToBuffer(
    *(icon **)(v1 + 36),
    *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 100),
    *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 102),
    *(_WORD *)(v1 + 74),
    0);
  if ( *(_WORD *)(v1 + 60) > 0 )
  {
    v2 = *(_WORD *)(v1 + 62);
    if ( v2 >= 0 )
    {
      v3 = 3;
      if ( !(*(_BYTE *)(v1 + 22) & 8) )
        v3 = *(_WORD *)(v1 + 52);
      font::DrawBoundedString(
        *(font **)(v1 + 32),
        *(char **)(*(_DWORD *)(v1 + 64) + 4 * v2),
        *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 40),
        *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 42),
        *(_WORD *)(v1 + 44),
        *(_WORD *)(v1 + 46),
        v3,
        *(_WORD *)(v1 + 58));
    }
  }
}

//----- (004DB060) --------------------------------------------------------
void __thiscall dropListWidget::DrawDropStuff(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // edi@1
  __int16 v4; // dx@1
  int v5; // eax@2
  int v6; // ebx@4
  int v7; // edi@4
  int v8; // edx@6
  int v9; // eax@7
  int v10; // edx@10
  int v11; // eax@12
  int v12; // eax@17
  int v13; // edi@19
  int v14; // ebx@20
  int v15; // eax@22
  int v16; // ecx@24
  int v17; // edi@24
  signed int v18; // ebx@24
  int v19; // ecx@24
  signed int v20; // eax@24
  int v21; // eax@24
  int v22; // edx@24
  int v23; // eax@24
  int v24; // edx@24

  v1 = *(_DWORD *)(this + 4);
  v2 = this;
  v3 = *(_DWORD *)(v1 + 44) + *(_WORD *)(this + 132);
  icon::DrawToBuffer(
    *(icon **)(this + 36),
    *(_WORD *)(this + 130) + *(_DWORD *)(v1 + 40),
    *(_DWORD *)(v1 + 44) + *(_WORD *)(this + 132),
    *(_WORD *)(this + 78),
    0);
  v4 = *(_WORD *)(v2 + 68);
  if ( *(_WORD *)(v2 + 62) == v4 )
    v5 = *(_WORD *)(v2 + 54);
  else
    v5 = *(_WORD *)(v2 + 52);
  v6 = 1;
  font::DrawBoundedString(
    *(font **)(v2 + 32),
    *(char **)(*(_DWORD *)(v2 + 64) + 4 * v4),
    *(_WORD *)(v2 + 130) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40) + 5,
    v3 + 4,
    *(_WORD *)(v2 + 134) - 10,
    *(_DWORD *)(*(_DWORD *)(v2 + 32) + 16) + 1,
    v5,
    *(_WORD *)(v2 + 58));
  v7 = *(_WORD *)(v2 + 116) + v3;
  if ( *(_WORD *)(v2 + 50) - 1 > 1 )
  {
    do
    {
      if ( v6 + *(_WORD *)(v2 + 68) >= *(_WORD *)(v2 + 60) )
        break;
      icon::DrawToBuffer(
        *(icon **)(v2 + 36),
        *(_WORD *)(v2 + 130) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40),
        v7,
        *(_WORD *)(v2 + 80),
        0);
      v8 = *(_WORD *)(v2 + 68) + v6;
      v9 = *(_WORD *)(v2 + 62) == v8 ? *(_WORD *)(v2 + 54) : (signed int)*(_WORD *)(v2 + 52);
      ++v6;
      font::DrawBoundedString(
        *(font **)(v2 + 32),
        *(char **)(*(_DWORD *)(v2 + 64) + 4 * v8),
        *(_WORD *)(v2 + 130) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40) + 5,
        v7 + 2,
        *(_WORD *)(v2 + 134) - 10,
        *(_DWORD *)(*(_DWORD *)(v2 + 32) + 16) + 1,
        v9,
        *(_WORD *)(v2 + 58));
      v7 += *(_WORD *)(v2 + 118);
    }
    while ( *(_WORD *)(v2 + 50) - 1 > v6 );
  }
  icon::DrawToBuffer(
    *(icon **)(v2 + 36),
    *(_WORD *)(v2 + 130) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40),
    v7,
    *(_WORD *)(v2 + 82),
    0);
  v10 = *(_WORD *)(v2 + 68) + v6;
  if ( *(_WORD *)(v2 + 60) > v10 )
  {
    if ( *(_WORD *)(v2 + 62) == v10 )
      v11 = *(_WORD *)(v2 + 54);
    else
      v11 = *(_WORD *)(v2 + 52);
    font::DrawBoundedString(
      *(font **)(v2 + 32),
      *(char **)(*(_DWORD *)(v2 + 64) + 4 * v10),
      *(_WORD *)(v2 + 130) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40) + 5,
      v7 + 2,
      *(_WORD *)(v2 + 134) - 10,
      *(_DWORD *)(*(_DWORD *)(v2 + 32) + 16) + 1,
      v11,
      *(_WORD *)(v2 + 58));
  }
  if ( *(_WORD *)(v2 + 70) > 0 )
  {
    if ( *(_BYTE *)(v2 + 172) )
      v12 = *(_WORD *)(v2 + 86);
    else
      v12 = *(_WORD *)(v2 + 84);
    icon::DrawToBuffer(
      *(icon **)(v2 + 36),
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40) + *(_WORD *)(v2 + 138),
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) + *(_WORD *)(v2 + 140),
      v12,
      0);
    v13 = 2;
    icon::DrawToBuffer(
      *(icon **)(v2 + 36),
      *(_WORD *)(v2 + 146) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40),
      *(_WORD *)(v2 + 148) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44),
      *(_WORD *)(v2 + 92),
      0);
    if ( *(_WORD *)(v2 + 50) - 2 > 2 )
    {
      do
      {
        v14 = v13++ - 1;
        icon::DrawToBuffer(
          *(icon **)(v2 + 36),
          *(_WORD *)(v2 + 146) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40),
          *(_WORD *)(v2 + 148) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) + v14 * *(_WORD *)(v2 + 118),
          *(_WORD *)(v2 + 94),
          0);
      }
      while ( *(_WORD *)(v2 + 50) - 2 > v13 );
    }
    icon::DrawToBuffer(
      *(icon **)(v2 + 36),
      *(_WORD *)(v2 + 146) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40),
      *(_WORD *)(v2 + 148) + *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) + (v13 - 1) * *(_WORD *)(v2 + 118),
      *(_WORD *)(v2 + 96),
      0);
    if ( *(_BYTE *)(v2 + 173) )
      v15 = *(_WORD *)(v2 + 90);
    else
      v15 = *(_WORD *)(v2 + 88);
    icon::DrawToBuffer(
      *(icon **)(v2 + 36),
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 40) + *(_WORD *)(v2 + 154),
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) + *(_WORD *)(v2 + 156),
      v15,
      0);
    LOWORD(v16) = *(_WORD *)(v2 + 146);
    v17 = *(_DWORD *)(v2 + 4);
    v18 = *(_WORD *)(v2 + 70);
    v19 = *(_DWORD *)(v17 + 40) + v16 + 5;
    v20 = *(_WORD *)(v2 + 68) * *(_WORD *)(v2 + 170);
    *(_WORD *)(v2 + 162) = v19;
    v21 = v20 / v18;
    v22 = *(_DWORD *)(v17 + 44);
    LOWORD(v22) = v21 + v22;
    LOWORD(v21) = *(_WORD *)(v2 + 148);
    v23 = v22 + v21 + 3;
    v24 = *(_WORD *)(v2 + 98);
    *(_WORD *)(v2 + 164) = v23;
    icon::DrawToBuffer(*(icon **)(v2 + 36), (signed __int16)v19, (signed __int16)v23, v24, 0);
  }
  heroWindowManager::UpdateScreenRegion(
    gpWindowManager,
    *(_WORD *)(v2 + 24),
    *(_WORD *)(v2 + 26),
    *(_WORD *)(v2 + 28),
    *(_WORD *)(v2 + 30) + *(_WORD *)(v2 + 128));
}

//----- (004DB3E0) --------------------------------------------------------
void __thiscall dropListWidget::ProcessSelectDialog(int this)
{
  int v1; // ebx@1
  signed __int16 v2; // si@1
  __int16 v3; // dx@1
  __int16 v4; // ax@2
  __int16 v5; // cx@2
  int v6; // ecx@11
  int v7; // esi@11
  int v8; // edx@11
  int v9; // edi@11
  __int16 v10; // bp@11
  __int16 v11; // ax@11
  __int16 v12; // di@11
  __int16 v13; // dx@11
  __int16 v14; // bp@11
  __int16 v15; // si@11
  int v16; // ebp@11
  int v17; // ebp@11
  int v18; // eax@11
  int v19; // eax@11
  unsigned __int8 v20; // zf@11
  unsigned __int8 v21; // sf@11
  __int16 v22; // bp@15
  __int16 v23; // dx@15
  bitmap *v24; // ecx@16
  int v25; // eax@21
  int v26; // edx@21
  int v27; // edi@21
  int v28; // esi@21
  int v29; // ecx@21
  int v30; // eax@22
  __int16 v31; // ax@24
  __int16 v32; // ax@25
  __int16 v33; // cx@28
  __int16 v34; // ax@28
  __int16 v35; // ax@30
  int v36; // ecx@37
  signed __int16 v37; // ax@37
  __int16 v38; // cx@39
  int v39; // eax@39
  int v40; // edx@39
  int v41; // ecx@42
  int v42; // eax@42
  int v43; // eax@43
  int v44; // ecx@47
  int v45; // edx@49
  int v46; // esi@53
  int v47; // eax@53
  int v48; // eax@59
  int v49; // edi@60
  int v50; // eax@63
  int v51; // edx@64
  int v52; // eax@67
  int v53; // ecx@67
  int v54; // eax@67
  int v55; // ecx@68
  __int16 v56; // ax@74
  __int16 v57; // ax@78
  int v58; // eax@81
  __int16 v59; // si@84
  int v60; // eax@84
  int v61; // ecx@95
  __int16 v62; // [sp+10h] [bp-4Ch]@11
  __int16 v63; // [sp+14h] [bp-48h]@11
  __int16 v64; // [sp+18h] [bp-44h]@11
  __int16 v65; // [sp+1Ch] [bp-40h]@11
  signed int v66; // [sp+20h] [bp-3Ch]@1
  tag_message a2; // [sp+24h] [bp-38h]@11
  int v68; // [sp+40h] [bp-1Ch]@21
  int v69; // [sp+44h] [bp-18h]@22
  int v70; // [sp+50h] [bp-Ch]@21
  int v71; // [sp+54h] [bp-8h]@21

  v66 = 1;
  v1 = this;
  *(_BYTE *)(this + 172) = 0;
  *(_BYTE *)(this + 173) = 0;
  *(_BYTE *)(this + 175) = 0;
  *(_BYTE *)(this + 174) = 0;
  *(_WORD *)(this + 68) = 0;
  *(_WORD *)(this + 70) = 0;
  v2 = *(_WORD *)(this + 60);
  v3 = *(_WORD *)(this + 48);
  if ( v2 > v3 )
  {
    v4 = v2 - v3;
    v5 = *(_WORD *)(this + 62);
    *(_WORD *)(v1 + 70) = v2 - v3;
    *(_WORD *)(v1 + 68) = v5;
    if ( v5 < 0 )
      *(_WORD *)(v1 + 68) = 0;
    if ( *(_WORD *)(v1 + 68) > v4 )
      *(_WORD *)(v1 + 68) = v4;
  }
  if ( *(_WORD *)(v1 + 70) <= 0 )
  {
    if ( v2 <= 3 )
      v2 = 3;
    *(_WORD *)(v1 + 50) = v2;
  }
  else
  {
    *(_WORD *)(v1 + 50) = v3;
  }
  v6 = *(_DWORD *)(v1 + 36);
  v7 = *(_WORD *)(v1 + 80);
  v8 = 13 * *(_WORD *)(v1 + 78);
  LOWORD(a2.eventCode) = *(_WORD *)(*(_DWORD *)(v6 + 18) + v8 + 6);
  *(_WORD *)(v1 + 116) = a2.eventCode;
  v9 = *(_WORD *)(v1 + 82);
  LOWORD(v7) = *(_WORD *)(13 * v7 + *(_DWORD *)(v6 + 18) + 6);
  *(_WORD *)(v1 + 118) = v7;
  v10 = *(_WORD *)(v1 + 108);
  v11 = *(_WORD *)(13 * v9 + *(_DWORD *)(v6 + 18) + 6);
  LOWORD(v9) = *(_WORD *)(v1 + 110);
  *(_WORD *)(v1 + 120) = v11;
  v12 = *(_WORD *)(v1 + 114) + v9;
  *(_WORD *)(v1 + 130) = v10;
  *(_WORD *)(v1 + 132) = v12;
  v13 = *(_WORD *)(*(_DWORD *)(v6 + 18) + v8 + 4);
  v14 = a2.eventCode + (_WORD)v7 * (*(_WORD *)(v1 + 50) - 2);
  *(_WORD *)(v1 + 134) = v13;
  v15 = v14 + v11;
  v16 = *(_WORD *)(v1 + 84);
  *(_WORD *)(v1 + 136) = v15;
  v17 = *(_DWORD *)(v6 + 18) + 13 * v16;
  v62 = *(_WORD *)(v17 + 4);
  *(_WORD *)(v1 + 142) = v62;
  v18 = *(_WORD *)(v1 + 88);
  LOWORD(v17) = *(_WORD *)(v17 + 6);
  a2.eventCode = *(_WORD *)(v1 + 88);
  v64 = v17;
  *(_WORD *)(v1 + 144) = v17;
  v19 = *(_DWORD *)(v6 + 18) + a2.eventCode + 12 * v18;
  v65 = *(_WORD *)(v19 + 4);
  *(_WORD *)(v1 + 158) = v65;
  v63 = *(_WORD *)(v19 + 6);
  *(_WORD *)(v1 + 160) = v63;
  *(_WORD *)(v1 + 122) = *(_WORD *)(v1 + 108);
  v20 = *(_WORD *)(v1 + 70) == 0;
  v21 = *(_WORD *)(v1 + 70) < 0;
  *(_WORD *)(v1 + 124) = v12;
  if ( v21 | v20 )
    *(_WORD *)(v1 + 126) = v13;
  else
    *(_WORD *)(v1 + 126) = v13 + v62;
  v20 = *(_WORD *)(v1 + 70) == 0;
  v21 = *(_WORD *)(v1 + 70) < 0;
  *(_WORD *)(v1 + 128) = v15;
  if ( !(v21 | v20) )
  {
    v22 = *(_WORD *)(v1 + 28) + *(_WORD *)(v1 + 24) - v62;
    *(_WORD *)(v1 + 138) = v22;
    *(_WORD *)(v1 + 140) = v12;
    *(_WORD *)(v1 + 154) = v22;
    *(_WORD *)(v1 + 156) = v12 - v63 + v15;
    v23 = v12 - v63 + v15 - (v12 + v64);
    *(_WORD *)(v1 + 146) = v22;
    *(_WORD *)(v1 + 148) = v12 + v64;
    *(_WORD *)(v1 + 150) = v65;
    *(_WORD *)(v1 + 152) = v23;
    *(_WORD *)(v1 + 170) = v23 - *(_WORD *)(v1 + 168) - 7;
  }
  icon::DrawToBuffer(
    (icon *)v6,
    *(_WORD *)(v1 + 100) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40),
    *(_WORD *)(v1 + 102) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44),
    *(_WORD *)(v1 + 76),
    0);
  heroWindowManager::UpdateScreenRegion(
    gpWindowManager,
    *(_WORD *)(v1 + 100) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40),
    *(_WORD *)(v1 + 102) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44),
    *(_WORD *)(v1 + 104),
    *(_WORD *)(v1 + 106));
  v24 = (bitmap *)operator new(26);
  if ( v24 )
    *(_DWORD *)(v1 + 176) = bitmap::bitmap(v24, 0, *(_WORD *)(v1 + 126), *(_WORD *)(v1 + 128));
  else
    *(_DWORD *)(v1 + 176) = 0;
  bitmap::GrabScreen(*(bitmap **)(v1 + 176), *(_WORD *)(v1 + 122), *(_WORD *)(v1 + 124));
LABEL_20:
  dropListWidget::DrawDropStuff(v1);
  while ( 2 )
  {
    PollSound();
    Process1WindowsMessage();
    memcpy(&v68, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
    (*(void (__stdcall **)(int *))(LODWORD(gpMouseManager->vtable) + 8))(&v68);
    v25 = *(_DWORD *)(v1 + 4);
    v26 = *(_DWORD *)(v25 + 40);
    v27 = *(_DWORD *)(v25 + 44);
    v28 = v70 - v26;
    v29 = v71 - v27;
    switch ( v68 )
    {
      default:
        continue;
      case 1:
        v30 = v69 - 71;
        switch ( v69 )
        {
          default:
            continue;
          case 71:
            *(_WORD *)(v1 + 68) = 0;
            *(_WORD *)(v1 + 62) = 0;
            goto LABEL_20;
          case 72:
            v31 = *(_WORD *)(v1 + 62);
            if ( v31 > 0 )
            {
              *(_WORD *)(v1 + 62) = v31 - 1;
              v32 = *(_WORD *)(v1 + 62);
              if ( v32 > 0 )
              {
                if ( *(_WORD *)(v1 + 68) > v32 )
                  *(_WORD *)(v1 + 68) = v32;
              }
            }
            break;
          case 73:
            v33 = *(_WORD *)(v1 + 48);
            v34 = *(_WORD *)(v1 + 68) - v33 + 1;
            *(_WORD *)(v1 + 68) = v34;
            if ( v34 < 0 )
              *(_WORD *)(v1 + 68) = 0;
            v35 = *(_WORD *)(v1 + 62) - v33 + 1;
            *(_WORD *)(v1 + 62) = v35;
            if ( v35 < 0 )
              *(_WORD *)(v1 + 62) = 0;
            break;
          case 79:
            *(_WORD *)(v1 + 68) = *(_WORD *)(v1 + 70);
            *(_WORD *)(v1 + 62) = *(_WORD *)(v1 + 60) - 1;
            break;
          case 80:
            if ( *(_WORD *)(v1 + 60) - 1 > *(_WORD *)(v1 + 62) )
              ++*(_WORD *)(v1 + 62);
            if ( *(_WORD *)(v1 + 48) + (signed int)*(_WORD *)(v1 + 68) - 1 < *(_WORD *)(v1 + 62) )
              *(_WORD *)(v1 + 68) = *(_WORD *)(v1 + 62) - *(_WORD *)(v1 + 48) + 1;
            break;
          case 81:
            LOWORD(v30) = *(_WORD *)(v1 + 68);
            LOWORD(v26) = *(_WORD *)(v1 + 48);
            v36 = v30 + v26 - 1;
            v37 = *(_WORD *)(v1 + 70);
            *(_WORD *)(v1 + 68) = v36;
            if ( v37 < (signed __int16)v36 )
              *(_WORD *)(v1 + 68) = v37;
            LOWORD(v30) = *(_WORD *)(v1 + 62);
            v38 = *(_WORD *)(v1 + 60);
            v39 = v30 + v26 - 1;
            v40 = *(_WORD *)(v1 + 60);
            *(_WORD *)(v1 + 62) = v39;
            if ( v40 - 1 < (signed __int16)v39 )
              *(_WORD *)(v1 + 62) = v38 - 1;
            break;
        }
        goto LABEL_20;
      case 4:
        if ( *(_BYTE *)(v1 + 175) )
        {
          v41 = v29 - *(_WORD *)(v1 + 132);
          v42 = *(_WORD *)(v1 + 116);
          if ( v41 <= v42 )
            v43 = 0;
          else
            v43 = (v41 - v42) / *(_WORD *)(v1 + 118) + 1;
          if ( v43 < 0 )
            v43 = 0;
          v44 = *(_WORD *)(v1 + 50);
          if ( v43 >= v44 )
            v43 = v44 - 1;
          v45 = *(_WORD *)(v1 + 68) + v43;
          if ( *(_WORD *)(v1 + 60) > v45 && *(_WORD *)(v1 + 62) != v45 )
          {
            *(_WORD *)(v1 + 62) = *(_WORD *)(v1 + 68) + v43;
            goto LABEL_20;
          }
        }
        else if ( *(_BYTE *)(v1 + 174) )
        {
          v46 = *(_WORD *)(v1 + 70);
          v47 = (v46 + 1) * (v29 - *(_WORD *)(v1 + 168) / 2 - *(_WORD *)(v1 + 148) - 4) / *(_WORD *)(v1 + 170);
          if ( v47 < 0 )
            v47 = 0;
          if ( v47 > v46 )
            v47 = *(_WORD *)(v1 + 70);
          if ( *(_WORD *)(v1 + 68) != v47 )
          {
            *(_WORD *)(v1 + 68) = v47;
            goto LABEL_20;
          }
        }
        continue;
      case 8:
        v48 = *(_WORD *)(v1 + 122);
        if ( v28 < v48 )
          goto LABEL_95;
        v49 = *(_WORD *)(v1 + 124);
        if ( v29 < v49 || v48 + *(_WORD *)(v1 + 126) <= v28 || v49 + *(_WORD *)(v1 + 128) <= v29 )
          goto LABEL_95;
        v50 = *(_WORD *)(v1 + 130);
        if ( v28 < v50
          || (v51 = *(_WORD *)(v1 + 132), v29 < v51)
          || v50 + *(_WORD *)(v1 + 134) <= v28
          || v51 + *(_WORD *)(v1 + 136) <= v29 )
        {
          if ( *(_WORD *)(v1 + 144) + (signed int)*(_WORD *)(v1 + 140) <= v29 )
          {
            if ( *(_WORD *)(v1 + 156) > v29 )
            {
              v58 = *(_WORD *)(v1 + 164);
              if ( v29 >= v58 && v58 + *(_WORD *)(v1 + 168) > v29 )
                *(_BYTE *)(v1 + 174) = 1;
              v59 = *(_WORD *)(v1 + 70);
              v60 = (*(_WORD *)(v1 + 70) + 1)
                  * (v29 - *(_WORD *)(v1 + 168) / 2 - *(_WORD *)(v1 + 148) - 4)
                  / *(_WORD *)(v1 + 170);
              *(_WORD *)(v1 + 68) = v60;
              if ( (signed __int16)v60 < 0 )
                *(_WORD *)(v1 + 68) = 0;
              if ( *(_WORD *)(v1 + 68) > v59 )
                *(_WORD *)(v1 + 68) = v59;
            }
            else
            {
              v57 = *(_WORD *)(v1 + 68);
              if ( *(_WORD *)(v1 + 70) > v57 )
                *(_WORD *)(v1 + 68) = v57 + 1;
              *(_BYTE *)(v1 + 173) = 1;
            }
          }
          else
          {
            v56 = *(_WORD *)(v1 + 68);
            if ( v56 > 0 )
              *(_WORD *)(v1 + 68) = v56 - 1;
            *(_BYTE *)(v1 + 172) = 1;
          }
          goto LABEL_20;
        }
        v52 = v29;
        v53 = *(_WORD *)(v1 + 116);
        v54 = v52 - v51;
        if ( v54 <= v53 )
          v55 = *(_WORD *)(v1 + 68);
        else
          v55 = *(_WORD *)(v1 + 68) + (v54 - v53) / *(_WORD *)(v1 + 118) + 1;
        *(_BYTE *)(v1 + 175) = 1;
        if ( *(_WORD *)(v1 + 60) > v55 && *(_WORD *)(v1 + 62) != v55 )
        {
          *(_WORD *)(v1 + 62) = v55;
          goto LABEL_20;
        }
        continue;
      case 16:
        if ( v66 )
        {
          v66 = 0;
          icon::DrawToBuffer(
            *(icon **)(v1 + 36),
            v26 + *(_WORD *)(v1 + 100),
            v27 + *(_WORD *)(v1 + 102),
            *(_WORD *)(v1 + 74),
            0);
          heroWindowManager::UpdateScreenRegion(
            gpWindowManager,
            *(_WORD *)(v1 + 100) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40),
            *(_WORD *)(v1 + 102) + *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44),
            *(_WORD *)(v1 + 104),
            *(_WORD *)(v1 + 106));
          continue;
        }
        if ( !*(_BYTE *)(v1 + 175) )
        {
          if ( *(_BYTE *)(v1 + 172) || *(_BYTE *)(v1 + 173) || *(_BYTE *)(v1 + 174) )
          {
            *(_BYTE *)(v1 + 174) = 0;
            *(_BYTE *)(v1 + 173) = 0;
            *(_BYTE *)(v1 + 172) = 0;
            goto LABEL_20;
          }
          continue;
        }
LABEL_95:
        bitmap::DrawToBuffer(*(bitmap **)(v1 + 176), *(_WORD *)(v1 + 122), *(_WORD *)(v1 + 124));
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          *(_WORD *)(v1 + 122),
          *(_WORD *)(v1 + 124),
          *(_WORD *)(v1 + 126),
          *(_WORD *)(v1 + 128));
        v61 = *(_DWORD *)(v1 + 176);
        if ( v61 )
          (**(void (__stdcall ***)(_DWORD))v61)(1);
        *(_DWORD *)(v1 + 176) = 0;
        (**(void (__thiscall ***)(_DWORD))v1)(v1);
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          *(_DWORD *)(*(_DWORD *)(v1 + 4) + 40) + *(_WORD *)(v1 + 24),
          *(_DWORD *)(*(_DWORD *)(v1 + 4) + 44) + *(_WORD *)(v1 + 26),
          *(_WORD *)(v1 + 28),
          *(_WORD *)(v1 + 30));
        return;
    }
  }
}

//----- (004DBC10) --------------------------------------------------------
int __thiscall dimmerWidget::dimmerWidget(int this)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = this;
  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  result = v1;
  *(_DWORD *)v1 = &dimmerWidget::_vftable_;
  return result;
}
// 4EAFE8: using guessed type int (*dimmerWidget___vftable_)();

//----- (004DBC30) --------------------------------------------------------
__int16 __thiscall dimmerWidget::Read(int this)
{
  int v1; // esi@1
  __int16 result; // ax@1

  v1 = this;
  *(_WORD *)(this + 24) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 26) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 28) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 30) = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 16) = resourceManager::ReadWord(gpResourceManager);
  result = resourceManager::ReadWord(gpResourceManager);
  *(_WORD *)(v1 + 20) = result;
  return result;
}

//----- (004DBC90) --------------------------------------------------------
signed int __thiscall dimmerWidget::Main(int this, int a2)
{
  return widget::Main((widget *)this, (Event *)a2);
}

//----- (004DBCB0) --------------------------------------------------------
void *__thiscall dimmerWidget::_scalar_deleting_destructor_(void *this, char a2)
{
  void *v2; // esi@1

  *(_DWORD *)this = &dimmerWidget::_vftable_;
  v2 = this;
  widget::_widget(this);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 4EAFE8: using guessed type int (*dimmerWidget___vftable_)();

//----- (004DBCE0) --------------------------------------------------------
button *__thiscall button::button(button *this)
{
  button *result; // eax@1

  widget::widget((widget *)this, 0, 0, 0, 0, 0, 0);
  this->normalImageIdx = 0;
  this->vtable = &button::_vftable_;
  this->armedImageIdx = 0;
  this->icnFileID = 0;
  this->field_28 = 0;
  result = this;
  this->field_2A = -1;
  this->icon = 0;
  return result;
}

//----- (004DBD20) --------------------------------------------------------
void __thiscall button::_scalar_deleting_destructor_(button *this, char a2)
{
  resource *icn; // eax@1

  icn = (resource *)this->icon;
  this->vtable = &button::_vftable_;
  resourceManager::Dispose(gpResourceManager, icn);
  widget::_widget(this);
  if ( a2 & 1 )
    operator delete(this);
}

//----- (004DBD60) --------------------------------------------------------
__int16 __thiscall button::Read(button *this)
{
  int icnFileID; // eax@1
  __int16 result; // ax@1
  char buf[13]; // [sp+4h] [bp-10h]@1

  HIWORD(this->flags) = resourceManager::ReadWord(gpResourceManager);
  this->offsetY = resourceManager::ReadWord(gpResourceManager);
  this->width = resourceManager::ReadWord(gpResourceManager);
  this->height = resourceManager::ReadWord(gpResourceManager);
  resourceManager::Read13(gpResourceManager, buf);
  resourceManager::SavePosition(gpResourceManager);
  icnFileID = resourceManager::MakeId(gpResourceManager, buf, 1);
  this->icnFileID = icnFileID;
  this->icon = resourceManager::GetIcon(gpResourceManager, icnFileID);
  resourceManager::RestorePosition(gpResourceManager);
  this->normalImageIdx = resourceManager::ReadWord(gpResourceManager);
  this->armedImageIdx = resourceManager::ReadWord(gpResourceManager);
  this->field_28 = resourceManager::ReadWord(gpResourceManager);
  this->field_2A = resourceManager::ReadWord(gpResourceManager);
  this->fieldID = resourceManager::ReadWord(gpResourceManager);
  result = resourceManager::ReadWord(gpResourceManager);
  this->field_14 = result;
  return result;
}

//----- (004DBE50) --------------------------------------------------------
signed __int16 __thiscall button::Main(button *this, tag_message *e)
{
  button *thisa; // ebx@1
  __int16 v3; // ax@4
  signed __int16 result; // ax@5
  __int16 v5; // cx@7
  __int16 v6; // ax@7
  INPUT_EVENT_CODE code; // edi@11
  __int16 v8; // ax@23
  __int16 v9; // ax@30
  heroWindow *v10; // eax@37
  __int16 v11; // si@37
  __int16 v12; // dx@37
  __int16 v13; // cx@38
  __int16 v14; // ax@39
  int v15; // eax@42
  __int16 v16; // cx@45
  __int16 v17; // ax@46
  __int16 v18; // di@52
  heroWindow *v19; // ecx@52
  __int16 v20; // ax@52
  int v21; // edx@52
  __int16 v22; // cx@53
  __int16 v23; // cx@58
  __int16 v24; // cx@61
  icon *buttonIcon; // ST10_4@70
  tag_message a2; // [sp+Ch] [bp-20h]@60

  thisa = this;
  if ( this->field_14 == 4096 && this->flags & 1 && KBTickCount() > dword_524BF0 )
  {
    v3 = LOWORD(thisa->flags);
    if ( v3 & 1 )
    {
      LOBYTE(v3) = v3 & 0xFE;
      LOWORD(thisa->flags) = v3;
      thisa->vtable->paint((widget *)thisa);
      heroWindowManager::UpdateScreenRegion(
        gpWindowManager,
        HIWORD(thisa->flags) + thisa->parentWindow->xOffset,
        thisa->offsetY + thisa->parentWindow->yOffset,
        thisa->width,
        thisa->height);
      e->xCoordOrKeycode = 13;
      e->eventCode = 512;
      e->yCoordOrFieldID = thisa->fieldID;
      e->inputTypeBitmask = iLeftRightSave;
      result = 2;
      iLeftRightSave = 0;
    }
    else
    {
      result = 0;
    }
    return result;
  }
  v5 = LOWORD(thisa->flags);
  v6 = thisa->flags & 2;
  if ( !(thisa->flags & 2) )
  {
    if ( e->eventCode == 512 )
      result = widget::Main((widget *)thisa, (Event *)e);
    else
      result = 0;
    return result;
  }
  code = e->eventCode;
  if ( e->eventCode > INPUT_LEFT_CLICK_EVENT_CODE )
  {
    if ( code == INPUT_LEFT_UP_EVENT_CODE )
    {
      if ( v5 & 4 && v5 & 1 )
      {
        LOBYTE(v5) = v5 & 0xFE;
        LOWORD(thisa->flags) = v5;
        thisa->vtable->paint((widget *)thisa);
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          thisa->parentWindow->xOffset + HIWORD(thisa->flags),
          thisa->parentWindow->yOffset + thisa->offsetY,
          thisa->width,
          thisa->height);
        e->xCoordOrKeycode = 13;
        e->eventCode = 512;
        e->yCoordOrFieldID = thisa->fieldID;
        e->inputTypeBitmask = iLeftRightSave;
        result = 2;
        iLeftRightSave = 0;
        return result;
      }
      return widget::Main((widget *)thisa, (Event *)e);
    }
    if ( code != 32 )
    {
      if ( code != 512 || e->xCoordOrKeycode != 60 )
        return widget::Main((widget *)thisa, (Event *)e);
      if ( e->yCoordOrFieldID == thisa->icnFileID )
      {
        buttonIcon = thisa->icon;
        thisa->icnFileID = (int)e->payload;
        resourceManager::Dispose(gpResourceManager, (resource *)buttonIcon);
        thisa->icon = resourceManager::GetIcon(gpResourceManager, (int)e->payload);
      }
      return 0;
    }
    goto LABEL_36;
  }
  if ( e->eventCode == INPUT_LEFT_CLICK_EVENT_CODE )
  {
LABEL_36:
    if ( !(v5 & 4) )
      return widget::Main((widget *)thisa, (Event *)e);
    v10 = thisa->parentWindow;
    v11 = e->xCoordOrKeycode - LOWORD(v10->xOffset);
    v12 = e->yCoordOrFieldID - LOWORD(v10->yOffset);
    if ( code == INPUT_RIGHT_CLICK )
    {
      v13 = HIWORD(thisa->flags);
      if ( v11 < v13 || (v14 = thisa->offsetY, v12 < v14) || v13 + thisa->width <= v11 || v14 + thisa->height <= v12 )
      {
        result = 0;
      }
      else
      {
        e->xCoordOrKeycode = 14;
        e->eventCode = 512;
        v15 = thisa->fieldID;
        e->inputTypeBitmask = 512;
        e->yCoordOrFieldID = v15;
        result = 2;
      }
    }
    else if ( v5 & 8
  || (v16 = HIWORD(thisa->flags), v11 < v16)
  || (v17 = thisa->offsetY, v12 < v17)
  || v16 + thisa->width <= v11
  || v17 + thisa->height <= v12 )
    {
      result = 0;
    }
    else
    {
      button::Select(thisa, e);
      while ( e->eventCode != 16 )
      {
        if ( e->eventCode == 64 )
          break;
        PollSound();
        (*(void (__thiscall **)(mouseManager *))(LODWORD(gpMouseManager->vtable) + 8))(gpMouseManager);
        if ( e->eventCode == 4 )
        {
          v18 = HIWORD(thisa->flags);
          v19 = thisa->parentWindow;
          v21 = e->yCoordOrFieldID;
          v20 = e->xCoordOrKeycode - LOWORD(v19->xOffset);
          LOWORD(v21) = v21 - LOWORD(v19->yOffset);
          if ( v20 < v18
            || (v22 = thisa->offsetY, (signed __int16)v21 < v22)
            || v18 + thisa->width <= v20
            || v22 + thisa->height <= (signed __int16)v21 )
          {
            v23 = LOWORD(thisa->flags);
            if ( thisa->flags & 1 )
            {
              LOBYTE(v23) = v23 & 0xFE;
              LOWORD(thisa->flags) = v23;
              ((void (__fastcall *)(button *, int))thisa->vtable->paint)(thisa, v21);
              heroWindowManager::UpdateScreenRegion(
                gpWindowManager,
                HIWORD(thisa->flags) + thisa->parentWindow->xOffset,
                thisa->offsetY + thisa->parentWindow->yOffset,
                thisa->width,
                thisa->height);
              e->xCoordOrKeycode = 13;
              e->eventCode = 512;
              e->yCoordOrFieldID = thisa->fieldID;
              e->inputTypeBitmask = iLeftRightSave;
              iLeftRightSave = 0;
            }
          }
          else if ( !(thisa->flags & 1) )
          {
            button::Select(thisa, e);
          }
        }
        Process1WindowsMessage();
        memcpy(e, inputManager::GetEvent((tag_message *)gpInputManager, (inputManager *)&a2), 0x1Cu);
      }
      v24 = LOWORD(thisa->flags);
      if ( thisa->flags & BUTTON_IS_ARMED )
      {
        LOBYTE(v24) = v24 & 0xFE;
        LOWORD(thisa->flags) = v24;
        thisa->vtable->paint((widget *)thisa);
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          HIWORD(thisa->flags) + thisa->parentWindow->xOffset,
          thisa->offsetY + thisa->parentWindow->yOffset,
          thisa->width,
          thisa->height);
        e->xCoordOrKeycode = 13;
        result = 2;
        e->eventCode = 512;
        e->yCoordOrFieldID = thisa->fieldID;
        e->inputTypeBitmask = iLeftRightSave;
        iLeftRightSave = 0;
      }
      else
      {
        result = 1;
      }
    }
    return result;
  }
  if ( code != 1 )
  {
    if ( code == INPUT_KEYUP_EVENT_CODE && v6 && v5 & 4 && !(v5 & 8) )
    {
      v9 = thisa->field_2A;
      if ( v9 == -1 || v9 != e->xCoordOrKeycode )
      {
        result = 0;
      }
      else if ( v5 & 1 )
      {
        LOBYTE(v5) = v5 & 0xFE;
        LOWORD(thisa->flags) = v5;
        thisa->vtable->paint((widget *)thisa);
        heroWindowManager::UpdateScreenRegion(
          gpWindowManager,
          HIWORD(thisa->flags) + thisa->parentWindow->xOffset,
          thisa->offsetY + thisa->parentWindow->yOffset,
          thisa->width,
          thisa->height);
        e->xCoordOrKeycode = 13;
        result = 2;
        e->eventCode = 512;
        e->yCoordOrFieldID = thisa->fieldID;
        e->inputTypeBitmask = iLeftRightSave;
        iLeftRightSave = 0;
      }
      else
      {
        result = 0;
      }
      return result;
    }
    return widget::Main((widget *)thisa, (Event *)e);
  }
  if ( !v6 || !(v5 & 4) || v5 & 8 )
    return widget::Main((widget *)thisa, (Event *)e);
  v8 = thisa->field_2A;
  if ( v8 == -1 || v8 != e->xCoordOrKeycode )
    result = 0;
  else
    result = button::Select(thisa, e);
  return result;
}
// 520A70: using guessed type int iLeftRightSave;
// 524BF0: using guessed type int dword_524BF0;

//----- (004DC3F0) --------------------------------------------------------
signed __int16 __thiscall button::Select(button *this, tag_message *evt)
{
  heroWindow *window; // eax@1
  button *thisa; // esi@1
  int xPos; // edi@1
  int yPos; // ebx@1
  char v6; // zf@1
  int v7; // ecx@3
  signed __int16 result; // ax@3

  window = this->parentWindow;
  thisa = this;
  xPos = (signed __int16)(LOWORD(window->xOffset) + HIWORD(this->flags));
  yPos = (signed __int16)(LOWORD(window->yOffset) + this->offsetY);
  icon::DrawToBuffer(this->icon, xPos, yPos, this->armedImageIdx, 0);
  heroWindowManager::UpdateScreenRegion(gpWindowManager, xPos, yPos, thisa->width, thisa->height);
  LOBYTE(thisa->flags) |= 1u;
  evt->eventCode = 512;
  evt->yCoordOrFieldID = thisa->fieldID;
  v6 = thisa->field_28 == 1;
  evt->xCoordOrKeycode = 10;
  if ( !v6 )
    evt->xCoordOrKeycode = 12;
  v7 = KBTickCount() + 60;
  result = 2;
  dword_524BF0 = v7;
  iLeftRightSave = evt->inputTypeBitmask & 0x300;
  return result;
}
// 520A70: using guessed type int iLeftRightSave;
// 524BF0: using guessed type int dword_524BF0;

//----- (004DC490) --------------------------------------------------------
int __thiscall button::Draw(button *this)
{
  heroWindow *window; // edx@1
  int result; // eax@2

  window = this->parentWindow;
  if ( this->flags & BUTTON_IS_ARMED )
    result = icon::DrawToBuffer(
               this->icon,
               window->xOffset + HIWORD(this->flags),
               window->yOffset + this->offsetY,
               this->armedImageIdx,
               0);
  else
    result = icon::DrawToBuffer(
               this->icon,
               window->xOffset + HIWORD(this->flags),
               window->yOffset + this->offsetY,
               this->normalImageIdx,
               0);
  return result;
}

//----- (004DC4F0) --------------------------------------------------------
widget *__thiscall widget::widget(widget *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 fieldID, __int16 a7)
{
  this->offsetX = a2;
  this->vtable = &widget::_vftable_;
  this->parentWindow = 0;
  this->offsetY = a3;
  this->nextInLinkedList = 0;
  this->prevInLinkedList = 0;
  this->flags = 6;
  this->componentIndex = -1;
  this->width = a4;
  this->height = a5;
  this->fieldID = fieldID;
  this->field_14 = a7;
  return this;
}

//----- (004DC550) --------------------------------------------------------
void __thiscall widget::_widget(void *this)
{
  *(_DWORD *)this = &widget::_vftable_;
}

//----- (004DC560) --------------------------------------------------------
int __thiscall widget::Open(widget *this, __int16 idx, heroWindow *parent)
{
  this->componentIndex = idx;
  this->parentWindow = parent;
  return 0;
}

//----- (004DC590) --------------------------------------------------------
signed int __thiscall widget::Main(widget *this, Event *evt)
{
  widget *thisa; // esi@1
  signed int result; // eax@3
  __int16 offX; // bp@4
  heroWindow *window; // eax@4
  __int16 x; // dx@4
  __int16 y; // di@4
  __int16 offY; // ax@5
  __int16 v9; // ax@13
  void *v10; // eax@17
  __int16 v11; // cx@19
  __int16 v12; // ax@20
  void *v13; // edi@27

  thisa = this;
  if ( evt->inputEvt.eventCode == INPUT_MOUSEMOVE_EVENT_CODE )
  {
    offX = this->offsetX;
    window = this->parentWindow;
    x = evt->inputEvt.xCoordOrKeycode - LOWORD(window->xOffset);
    y = evt->inputEvt.yCoordOrFieldID - LOWORD(window->yOffset);
    if ( x < offX )
      return 0;
    offY = this->offsetY;
    if ( y < offY || offX + this->width <= x || offY + this->height <= y )
      return 0;
    evt->inputEvt.yCoordOrFieldID = this->fieldID;
    result = 2;
  }
  else
  {
    if ( evt->inputEvt.eventCode != INPUT_GUI_MESSAGE_CODE )
      return 0;
    switch ( evt->inputEvt.xCoordOrKeycode )
    {
      default:
        return 0;
      case GUI_MESSAGE_REPAINT:
        if ( this->flags & 4 )
          this->vtable->paint(this);
        if ( !(thisa->flags & 8) )
          return 0;
        v9 = thisa->field_14;
        if ( v9 == 8 || v9 == 512 )
          return 0;
        DimBitmapArea(
          gpWindowManager->screenBuffer,
          (signed __int16)(LOWORD(thisa->parentWindow->xOffset) + thisa->offsetX),
          (signed __int16)(LOWORD(thisa->parentWindow->yOffset) + thisa->offsetY),
          thisa->width,
          thisa->height,
          0);
        return 0;
      case 5:
        if ( this->fieldID != evt->inputEvt.yCoordOrFieldID )
          return 0;
        v10 = evt->inputEvt.payload;
        if ( v10 == (void *)4096 )
        {
          result = 1;
          LOBYTE(this->flags) |= 8u;
        }
        else
        {
          v11 = (unsigned __int16)v10 | this->flags;
          thisa->flags = v11;
          if ( v11 & 8 )
          {
            thisa->vtable->paint(thisa);
            v12 = thisa->field_14;
            if ( v12 != 8 )
            {
              if ( v12 != 512 )
                DimBitmapArea(
                  gpWindowManager->screenBuffer,
                  (signed __int16)(LOWORD(thisa->parentWindow->xOffset) + thisa->offsetX),
                  (signed __int16)(LOWORD(thisa->parentWindow->yOffset) + thisa->offsetY),
                  thisa->width,
                  thisa->height,
                  0);
            }
          }
          if ( HIBYTE(thisa->flags) & 0x40 )
          {
            heroWindowManager::UpdateScreenRegion(
              gpWindowManager,
              thisa->parentWindow->xOffset + thisa->offsetX,
              thisa->parentWindow->yOffset + thisa->offsetY,
              thisa->width,
              thisa->height);
            HIBYTE(thisa->flags) &= 0xBFu;
          }
          result = 1;
        }
        return result;
      case GUI_MESSAGE_REMOVE_FLAGS:
        if ( this->fieldID != evt->inputEvt.yCoordOrFieldID )
          return 0;
        v13 = evt->inputEvt.payload;
        if ( v13 == (void *)4096 )
        {
          result = 1;
          LOBYTE(this->flags) &= 0xF7u;
        }
        else
        {
          this->flags &= ~(_WORD)v13;
          if ( (unsigned __int8)v13 & 8 )
            this->vtable->paint(this);
          if ( (unsigned __int16)v13 & 0x4000 )
            heroWindowManager::UpdateScreenRegion(
              gpWindowManager,
              thisa->parentWindow->xOffset + thisa->offsetX,
              thisa->parentWindow->yOffset + thisa->offsetY,
              thisa->width,
              thisa->height);
          result = 1;
        }
        return result;
      case GUI_MESSAGE_SET_OFFSETX:
        if ( this->fieldID != evt->inputEvt.yCoordOrFieldID )
          return 0;
        this->offsetX = (__int16)evt->inputEvt.payload;
        return 1;
      case GUI_MESSAGE_SET_OFFSETY:
        if ( this->fieldID != evt->inputEvt.yCoordOrFieldID )
          return 0;
        this->offsetY = (__int16)evt->inputEvt.payload;
        return 1;
      case GUI_MESSAGE_SET_WIDTH:
        if ( this->fieldID != evt->inputEvt.yCoordOrFieldID )
          return 0;
        this->width = (__int16)evt->inputEvt.payload;
        result = 1;
        break;
    }
  }
  return result;
}

//----- (004DC890) --------------------------------------------------------
void __thiscall dimmerWidget::Draw(int this)
{
  __int16 v1; // ax@1

  v1 = *(_WORD *)(this + 20);
  if ( v1 != 8 )
  {
    if ( v1 != 512 )
      DimBitmapArea(
        gpWindowManager->screenBuffer,
        (signed __int16)(*(_WORD *)(*(_DWORD *)(this + 4) + 40) + *(_WORD *)(this + 24)),
        (signed __int16)(*(_WORD *)(*(_DWORD *)(this + 4) + 44) + *(_WORD *)(this + 26)),
        *(_WORD *)(this + 28),
        *(_WORD *)(this + 30),
        0);
  }
}

//----- (004DC8E0) --------------------------------------------------------
tileset *__thiscall tileset::tileset(tileset *this, int fileID)
{
  tileset *thisa; // esi@1
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@1
  void *v6; // eax@1

  thisa = this;
  resource::resource((resource *)this, RESOURCE_TYPE_TILESET, fileID, 1, 0);
  thisa->vtable = (resourceVtable *)tileset::_vftable_;
  resourceManager::PointToFile(gpResourceManager, fileID);
  thisa->numTiles = resourceManager::ReadWord(gpResourceManager);
  HIWORD(v3) = 0;
  thisa->field_12 = resourceManager::ReadWord(gpResourceManager);
  LOWORD(v4) = resourceManager::ReadWord(gpResourceManager);
  LOWORD(v3) = v4;
  thisa->field_14 = v4;
  v4 = (unsigned __int16)v4;
  LOWORD(v4) = thisa->numTiles;
  v5 = thisa->field_12 * v4 * v3;
  v6 = BaseAlloc(v5, "F:\\h2xsrc\\Base\\TILESET.CPP", 18);
  thisa->contents = v6;
  resourceManager::ReadBlock(gpResourceManager, v6, v5);
  return thisa;
}
// 4EB014: using guessed type int (__thiscall *tileset___vftable_[3])(void *, int);

//----- (004DC970) --------------------------------------------------------
tileset *__thiscall tileset::_scalar_deleting_destructor_(tileset *this, char a2)
{
  tileset *thisa; // esi@1

  this->vtable = (resourceVtable *)tileset::_vftable_;
  thisa = this;
  BaseFree(this->contents, (int)"F:\\h2xsrc\\Base\\TILESET.CPP", 28);
  resource::_resource(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}
// 4EB014: using guessed type int (__thiscall *tileset___vftable_[3])(void *, int);

//----- (004DC9B0) --------------------------------------------------------
sample *__thiscall sample::sample(sample *this, const char *filename, int a3, int a4, int a5)
{
  sample *thisa; // ebx@1
  int fileID; // eax@1
  signed int v7; // ebp@1
  signed int v8; // eax@1
  int fileIDa; // ST0C_4@10
  unsigned __int32 v10; // eax@10
  DWORD size; // esi@10
  void *v12; // eax@10
  int fileIDb; // ecx@10
  char v15[32]; // [sp+10h] [bp-20h]@1

  thisa = this;
  fileID = resourceManager::MakeId(gpResourceManager, filename, 1);
  resource::resource((resource *)thisa, RESOURCE_TYPE_SAMPLE, fileID, 1, NULL);
  v7 = 2;
  thisa->vtable = &sample::_vftable_;
  thisa->codeThing = a3;
  thisa->field_28 = a4;
  thisa->loopCount = a5;
  strcpy(v15, filename);
  _strrev((unsigned int)v15);
  v8 = 0;
  do
  {
    switch ( v15[v8] )
    {
      case '1':
        thisa->playbackRate = 11025;
        break;
      case '2':
        thisa->playbackRate = 22050;
        break;
      case '4':
        thisa->playbackRate = 44100;
        break;
      case '6':
        thisa->sampleType = 1;
        break;
      case '8':
        thisa->sampleType = 0;
        break;
      case 'M':
      case 'm':
        v7 = 0;
        break;
      default:
        break;
    }
    ++v8;
  }
  while ( v8 < 3 );
  fileIDa = thisa->fileID;
  thisa->sampleType += v7;
  v10 = resourceManager::GetFileSize(gpResourceManager, fileIDa);
  size = v10;
  v12 = BaseAlloc(v10, "F:\\h2xsrc\\Base\\SAMPLE.CPP", 57);
  fileIDb = thisa->fileID;
  thisa->contents = v12;
  thisa->nbytes = size;
  resourceManager::PointToFile(gpResourceManager, fileIDb);
  resourceManager::ReadBlock(gpResourceManager, thisa->contents, size);
  return thisa;
}
// 4DC9B0: using guessed type char var_20[32];

//----- (004DCB40) --------------------------------------------------------
sample *__thiscall sample::_scalar_deleting_destructor_(sample *this, char a2)
{
  sample *thisa; // esi@1

  this->vtable = &sample::_vftable_;
  thisa = this;
  BaseFree(this->contents, (int)"F:\\h2xsrc\\Base\\SAMPLE.CPP", 97);
  thisa->contents = 0;
  thisa->nbytes = 0;
  thisa->field_28 = 0;
  resource::_resource(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}

//----- (004DCB90) --------------------------------------------------------
MIDIWrap *__thiscall MIDIWrap::MIDIWrap(MIDIWrap *this, const char *filename)
{
  MIDIWrap *thisa; // esi@1
  int v3; // eax@1
  int v4; // eax@1
  unsigned __int32 size; // edi@1

  thisa = this;
  v3 = resourceManager::MakeId(gpResourceManager, filename, 1);
  resource::resource((resource *)thisa, RESOURCE_TYPE_SAMPLE, v3, 1, 0);
  v4 = thisa->fileID;
  thisa->vtable = &MIDIWrap::_vftable_;
  size = resourceManager::GetFileSize(gpResourceManager, v4);
  thisa->contents = BaseAlloc(size, "F:\\h2xsrc\\Base\\SAMPLE.CPP", 110);
  resourceManager::PointToFile(gpResourceManager, thisa->fileID);
  resourceManager::ReadBlock(gpResourceManager, thisa->contents, size);
  return thisa;
}

//----- (004DCC10) --------------------------------------------------------
MIDIWrap *__thiscall MIDIWrap::_scalar_deleting_destructor_(MIDIWrap *this, char a2)
{
  MIDIWrap *thisa; // esi@1

  this->vtable = &MIDIWrap::_vftable_;
  thisa = this;
  BaseFree(this->contents, (int)"F:\\h2xsrc\\Base\\SAMPLE.CPP", 118);
  thisa->contents = 0;
  resource::_resource(thisa);
  if ( a2 & 1 )
    operator delete(thisa);
  return thisa;
}

//----- (004DCC50) --------------------------------------------------------
char __fastcall FlipIconToBitmapColorTable(icon *icn, bitmap *bmp, int offX, int offY, int idx, signed int a6, int a7, int a8, int a9, int a10, int a11, char *paletteSubstitution)
{
  IconEntry *data; // esi@1
  IconEntry *header; // ebx@1
  int width; // edi@1
  unsigned __int8 *contents; // esi@1
  int leftX; // ecx@1
  int v17; // ebx@1
  int v18; // eax@1
  int v19; // ecx@1
  int v20; // ebp@1
  int v21; // ecx@5
  int v22; // eax@9
  int v23; // eax@9
  int byte; // ecx@10
  int v25; // ecx@12
  int v26; // edx@14
  int v27; // eax@17
  int v28; // eax@18
  void *v29; // edi@24
  int v30; // edi@24
  void *v31; // edi@30
  int v32; // ecx@31
  int v33; // edi@31
  unsigned int v34; // ecx@31
  int v35; // eax@35
  char *v36; // ecx@35
  int v37; // edi@36
  int v38; // eax@38
  int v39; // eax@42
  int v40; // edi@45
  int v41; // eax@49
  int v42; // ebx@53
  int v43; // edx@54
  int v44; // ebx@62
  int v45; // eax@63
  int v46; // edx@64
  int v47; // edx@71
  int v49; // [sp+14h] [bp-4h]@9

  data = icn->headersAndImageData;
  header = &data[idx];
  width = header->width;
  contents = (unsigned __int8 *)((char *)data + header->off);
  leftX = offX - header->offsetX - width;
  dword_537A98 = header;
  v17 = header->offsetY;
  v18 = width + leftX;
  v19 = leftX + 1;
  v20 = v18;
  dword_537AC8 = v19;
  dword_537AA0 = v18;
  dword_537AA4 = v17 + offY;
  if ( !a6 )
    goto LABEL_9;
  if ( v19 < a7 || a7 + a9 < v19 + width || a8 > dword_537AA4 )
  {
    v21 = a10;
    goto LABEL_8;
  }
  v21 = a10;
  if ( dword_537AA4 + dword_537A98->height > a10 + a8 )
  {
LABEL_8:
    a6 = 1;
    dword_537A94 = a7 + a9 - 1;
    dword_537AB4 = a8 + v21 - 1;
    goto LABEL_9;
  }
  a6 = 0;
LABEL_9:
  v22 = bmp->width;
  v49 = v22;
  v23 = (int)&bmp->contents[dword_537AA4 * v22];
  dword_537AB8 = v23;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        byte = *contents++;
        if ( (char)byte < 0 )
          break;
        dword_537AC0 = v20;
        dword_537ACC = byte;
        if ( byte )
        {
          LOBYTE(v23) = a6;
          if ( !a6 )
          {
            dword_537A90 = 0;
            v42 = v20 + dword_537AB8;
            dword_537ABC = v20 + dword_537AB8;
            if ( byte > 0 )
            {
              v43 = byte;
              dword_537A90 = byte;
              do
              {
                v23 = *contents++;
                --v42;
                --v43;
                LOBYTE(v23) = paletteSubstitution[v23];
                dword_537ABC = v42;
                *(_BYTE *)(v42 + 1) = v23;
              }
              while ( v43 );
            }
            goto LABEL_74;
          }
          LOBYTE(v23) = dword_537AA4;
          if ( a8 > dword_537AA4
            || dword_537AB4 < dword_537AA4
            || (v23 = v20 - byte + 1, dword_537A94 < v23)
            || v20 < a7 )
          {
            contents += byte;
            goto LABEL_74;
          }
          if ( v20 > dword_537A94 )
          {
            v44 = dword_537A94 + dword_537AB8;
            contents = &contents[v20] - dword_537A94;
            if ( a7 > v20 - byte )
            {
              v45 = a9;
              v46 = byte + dword_537A94 - a9 - v20;
              goto LABEL_68;
            }
            dword_537AA8 = 0;
            v45 = byte - v20 + dword_537A94;
          }
          else
          {
            v44 = v20 + dword_537AB8;
            if ( a7 > v23 )
            {
              v45 = v20 - a7 + 1;
              v46 = byte - v45;
LABEL_68:
              dword_537AA8 = v46;
              goto LABEL_69;
            }
            dword_537AA8 = 0;
            v45 = byte;
          }
LABEL_69:
          dword_537AD0 = v45;
          dword_537ABC = v44;
          dword_537A90 = 0;
          if ( v45 > 0 )
          {
            dword_537A90 = v45;
            do
            {
              v47 = *contents++;
              --v44;
              --v45;
              LOBYTE(v47) = paletteSubstitution[v47];
              dword_537ABC = v44;
              *(_BYTE *)(v44 + 1) = v47;
            }
            while ( v45 );
          }
          LOBYTE(v23) = dword_537AA8;
          contents += dword_537AA8;
LABEL_74:
          v20 -= byte;
          dword_537ACC = byte;
        }
        else
        {
          v20 = dword_537AA0;
          LOBYTE(v23) = dword_537AA4++ + 1;
          dword_537AB8 += v49;
        }
      }
      if ( !(byte & 0x40) )
        break;
      dword_537ACC = byte;
      v26 = byte & 0x3F;
      if ( byte & 0x3F )
      {
        if ( byte == 193 )
          v26 = *contents++;
        v27 = *contents++;
        byte_537AD4 = paletteSubstitution[v27];
LABEL_23:
        if ( !a6 )
        {
          LOBYTE(byte) = byte_537AD4;
          BYTE1(byte) = byte_537AD4;
          v23 = byte << 16;
          LOWORD(v23) = byte;
          v29 = (void *)(v20 - v26 + dword_537AB8 + 1);
          memset32(v29, v23, (unsigned int)v26 >> 2);
          v30 = (int)((char *)v29 + 4 * ((unsigned int)v26 >> 2));
          LOBYTE(byte) = v26;
LABEL_32:
          memset((void *)v30, v23, byte & 3);
          goto LABEL_33;
        }
        LOBYTE(v23) = dword_537AA4;
        if ( a8 <= dword_537AA4 )
        {
          if ( dword_537AB4 >= dword_537AA4 )
          {
            v23 = v20 - v26 + 1;
            if ( a7 <= v23 )
            {
              if ( v20 <= dword_537A94 )
              {
                HIWORD(byte) = HIWORD(a7);
                if ( a7 > v23 )
                {
                  v32 = v20 - a7 + 1;
                  LOBYTE(v32) = byte_537AD4;
                  BYTE1(v32) = byte_537AD4;
                  v33 = dword_537AB8 + a7;
                  v23 = v32 << 16;
                  LOWORD(v23) = v32;
                  v34 = (unsigned int)(v20 - a7 + 1) >> 2;
                  memset32((void *)(dword_537AB8 + a7), v23, v34);
                  v30 = v33 + 4 * v34;
                  byte = v20 - a7 + 1;
                }
                else
                {
                  LOBYTE(byte) = byte_537AD4;
                  BYTE1(byte) = byte_537AD4;
                  v23 = byte << 16;
                  LOWORD(v23) = byte;
                  v31 = (void *)(v20 - v26 + dword_537AB8 + 1);
                  memset32(v31, v23, (unsigned int)v26 >> 2);
                  v30 = (int)((char *)v31 + 4 * ((unsigned int)v26 >> 2));
                  LOBYTE(byte) = v26;
                }
                goto LABEL_32;
              }
            }
          }
        }
LABEL_33:
        v20 -= v26;
        dword_537ACC = v26;
      }
      else
      {
        v28 = *contents++;
        v26 = v28 & 3;
        if ( !(v28 & 3) )
          v26 = *contents++;
        HIWORD(byte) = HIWORD(a11);
        dword_537AB0 = v26;
        if ( a11 )
        {
          dword_537ACC = v28;
          if ( v28 & 0x80 )
          {
            dword_537AD0 = v26;
            byte_537AD4 = a11;
            goto LABEL_23;
          }
        }
        dword_537AD0 = v26;
        dword_537ACC = v28;
        if ( v28 & 0x40 )
        {
          v35 = (v28 & 0x3C) << 6;
          v36 = (char *)uDimPal + v35;
          if ( a6 )
          {
            dword_537AD0 = v26;
            dword_537A9C = (int)((char *)uDimPal + v35);
            if ( a8 <= dword_537AA4 )
            {
              if ( dword_537AB4 >= dword_537AA4 )
              {
                v39 = v20 - v26 + 1;
                if ( a7 <= v39 )
                {
                  if ( v20 <= dword_537A94 )
                  {
                    if ( a7 > v39 )
                    {
                      v26 = v20 - a7 + 1;
                      v40 = a7 + dword_537AB8;
                    }
                    else
                    {
                      v40 = v20 - v26 + dword_537AB8 + 1;
                    }
                    dword_537AD0 = v26;
                    dword_537A9C = (int)v36;
                    dword_537AAC = v40;
                    dword_537A90 = 0;
                    if ( v26 > 0 )
                    {
                      dword_537A90 = v26;
                      do
                      {
                        ++v40;
                        v41 = *(_BYTE *)(v40 - 1);
                        dword_537AAC = v40;
                        --v26;
                        dword_537A9C = (int)v36;
                        *(_BYTE *)(v40 - 1) = v36[v41];
                      }
                      while ( v26 );
                    }
                  }
                }
              }
            }
          }
          else
          {
            dword_537A9C = (int)((char *)uDimPal + v35);
            dword_537A90 = 0;
            v37 = v20 - v26 + dword_537AB8 + 1;
            dword_537AAC = v20 - v26 + dword_537AB8 + 1;
            if ( v26 > 0 )
            {
              dword_537A90 = v26;
              do
              {
                ++v37;
                v38 = *(_BYTE *)(v37 - 1);
                dword_537AAC = v37;
                --v26;
                dword_537A9C = (int)v36;
                *(_BYTE *)(v37 - 1) = v36[v38];
              }
              while ( v26 );
            }
          }
        }
        LOBYTE(v23) = dword_537AB0;
        v20 -= dword_537AB0;
      }
    }
    dword_537AC0 = v20;
    dword_537AC4 = (int)contents;
    dword_537ACC = byte;
    v25 = byte & 0x3F;
    if ( !v25 )
      return v23;
    v20 -= v25;
  }
}
// 537A90: using guessed type int dword_537A90;
// 537A94: using guessed type int dword_537A94;
// 537A9C: using guessed type int dword_537A9C;
// 537AA0: using guessed type int dword_537AA0;
// 537AA4: using guessed type int dword_537AA4;
// 537AA8: using guessed type int dword_537AA8;
// 537AAC: using guessed type int dword_537AAC;
// 537AB0: using guessed type int dword_537AB0;
// 537AB4: using guessed type int dword_537AB4;
// 537AB8: using guessed type int dword_537AB8;
// 537ABC: using guessed type int dword_537ABC;
// 537AC0: using guessed type int dword_537AC0;
// 537AC4: using guessed type int dword_537AC4;
// 537AC8: using guessed type int dword_537AC8;
// 537ACC: using guessed type int dword_537ACC;
// 537AD0: using guessed type int dword_537AD0;
// 537AD4: using guessed type char byte_537AD4;

//----- (004DD1B0) --------------------------------------------------------
int __fastcall FlipIconToBitmapYModify(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int v12; // eax@2
  int result; // eax@4
  int v14; // eax@11
  int v15; // eax@11
  char v16; // si@20
  int v17; // ecx@20
  int v18; // eax@23
  void *v19; // edi@23
  unsigned int v20; // ecx@23
  int v21; // edi@23
  char v22; // cl@23
  int v23; // esi@24
  int v24; // edi@24
  unsigned int v25; // ecx@24
  int v26; // ecx@31
  int v27; // eax@34
  int v28; // esi@43
  int v29; // eax@48
  int v30; // eax@55
  int v31; // ecx@58

  dword_537AD8 = *(_DWORD *)(a1 + 18) + 13 * a5;
  dword_537AE0 = *(_DWORD *)(a1 + 18) + *(_DWORD *)(dword_537AD8 + 9);
  dword_537B14 = a3 - *(_WORD *)(dword_537AD8 + 4) - *(_WORD *)dword_537AD8 + 1;
  dword_537AE4 = dword_537B14 + *(_WORD *)(dword_537AD8 + 4) - 1;
  dword_537B00 = a4 + *(_WORD *)(dword_537AD8 + 2);
  dword_537AE8 = dword_537AE4 - *(_BYTE *)(dword_537B00 + a12);
  dword_537AEC = a7 + a9 - 1;
  dword_537B1C = a10 + a8 - 1;
  dword_537B04 = *(_DWORD *)(a2 + 22) + dword_537B00 * *(_WORD *)(a2 + 18);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *(_BYTE *)dword_537AE0;
        dword_537AFC = v12;
        ++dword_537AE0;
        if ( (char)v12 < 0 )
          break;
        if ( dword_537AFC )
        {
          if ( *(_BYTE *)(dword_537B00 + a12) == 127
            || a8 > dword_537B00
            || dword_537B1C < dword_537B00
            || (v28 = dword_537AE8 - dword_537AFC + 1, dword_537AEC < v28)
            || dword_537AE8 < a7 )
          {
            v30 = dword_537AFC;
            goto LABEL_57;
          }
          if ( dword_537AE8 > dword_537AEC )
          {
            dword_537AE0 += dword_537AE8 - dword_537AEC;
            dword_537B0C = dword_537B04 + dword_537AEC;
            if ( a7 > dword_537AE8 - dword_537AFC )
            {
              dword_537B10 = a9;
              v29 = dword_537AFC + dword_537AEC - a9 - dword_537AE8;
              goto LABEL_52;
            }
            dword_537AF8 = 0;
            dword_537B10 = dword_537AEC + dword_537AFC - dword_537AE8;
          }
          else
          {
            dword_537B0C = dword_537AE8 + dword_537B04;
            if ( a7 > v28 )
            {
              dword_537B10 = dword_537AE8 - a7 + 1;
              v29 = dword_537AFC - dword_537B10;
LABEL_52:
              dword_537AF8 = v29;
              goto LABEL_53;
            }
            dword_537AF8 = 0;
            dword_537B10 = dword_537AFC;
          }
LABEL_53:
          for ( dword_537ADC = 0; dword_537B10 > dword_537ADC; ++dword_537ADC )
            *(_BYTE *)dword_537B0C-- = *(_BYTE *)dword_537AE0++;
          v30 = dword_537AF8;
LABEL_57:
          dword_537AE0 += v30;
          dword_537AE8 -= dword_537AFC;
        }
        else
        {
          v31 = dword_537AE4 - *(_BYTE *)(dword_537B00++ + 1 + a12 - 1);
          dword_537AE8 = v31;
          dword_537B04 += *(_WORD *)(a2 + 18);
        }
      }
      if ( !(v12 & 0x40) )
        break;
      if ( dword_537AFC & 0x3F )
      {
        if ( dword_537AFC == 193 )
          dword_537AFC = *(_BYTE *)dword_537AE0++;
        else
          dword_537AFC &= 0x3Fu;
        byte_537B18 = *(_BYTE *)dword_537AE0++;
LABEL_17:
        if ( *(_BYTE *)(dword_537B00 + a12) != 127 )
        {
          if ( a8 <= dword_537B00 )
          {
            if ( dword_537B1C >= dword_537B00 )
            {
              v16 = dword_537AFC;
              v17 = dword_537AE8 - dword_537AFC + 1;
              if ( a7 <= v17 )
              {
                if ( dword_537AE8 <= dword_537AEC )
                {
                  if ( a7 > v17 )
                  {
                    v23 = dword_537AE8 - a7 + 1;
                    LOBYTE(v17) = byte_537B18;
                    BYTE1(v17) = byte_537B18;
                    v24 = a7 + dword_537B04;
                    v18 = v17 << 16;
                    LOWORD(v18) = v17;
                    v25 = (unsigned int)(dword_537AE8 - a7 + 1) >> 2;
                    memset32((void *)(a7 + dword_537B04), v18, v25);
                    v21 = v24 + 4 * v25;
                    v22 = v23;
                  }
                  else
                  {
                    LOBYTE(v17) = byte_537B18;
                    BYTE1(v17) = byte_537B18;
                    v18 = v17 << 16;
                    LOWORD(v18) = v17;
                    v19 = (void *)(dword_537AE8 - dword_537AFC + dword_537B04 + 1);
                    v20 = (unsigned int)dword_537AFC >> 2;
                    memset32(v19, v18, (unsigned int)dword_537AFC >> 2);
                    v21 = (int)((char *)v19 + 4 * v20);
                    v22 = v16;
                  }
                  memset((void *)v21, v18, v22 & 3);
                }
              }
            }
          }
        }
        dword_537AE8 -= dword_537AFC;
      }
      else
      {
        v14 = *(_BYTE *)dword_537AE0;
        dword_537AFC = v14;
        v15 = v14 & 3;
        ++dword_537AE0;
        if ( v15 )
          dword_537B10 = v15;
        else
          dword_537B10 = *(_BYTE *)dword_537AE0++;
        dword_537AF4 = dword_537B10;
        if ( a11 && dword_537AFC & 0x80 )
        {
          byte_537B18 = a11;
          dword_537AFC = dword_537B10;
          goto LABEL_17;
        }
        if ( dword_537AFC & 0x40 )
        {
          dword_537B08 = (int)((char *)uDimPal + 64 * (dword_537AFC & 0x3C));
          if ( *(_BYTE *)(dword_537B00 + a12) != 127 )
          {
            if ( a8 <= dword_537B00 )
            {
              if ( dword_537B1C >= dword_537B00 )
              {
                v26 = dword_537AE8 - dword_537B10 + 1;
                if ( a7 <= v26 )
                {
                  if ( dword_537AE8 <= dword_537AEC )
                  {
                    if ( a7 > v26 )
                    {
                      dword_537B10 = dword_537AE8 - a7 + 1;
                      v27 = a7 + dword_537B04;
                    }
                    else
                    {
                      v27 = dword_537B04 + dword_537AE8 - dword_537B10 + 1;
                    }
                    dword_537ADC = 0;
                    for ( dword_537AF0 = v27; dword_537B10 > dword_537ADC; ++dword_537ADC )
                    {
                      *(_BYTE *)dword_537AF0 = *(_BYTE *)(*(_BYTE *)dword_537AF0 + dword_537B08);
                      ++dword_537AF0;
                    }
                  }
                }
              }
            }
          }
        }
        dword_537AE8 -= dword_537AF4;
      }
    }
    result = v12 & 0x3F;
    if ( !result )
      return result;
    dword_537AE8 -= result;
  }
}
// 537AD8: using guessed type int dword_537AD8;
// 537ADC: using guessed type int dword_537ADC;
// 537AE0: using guessed type int dword_537AE0;
// 537AE4: using guessed type int dword_537AE4;
// 537AE8: using guessed type int dword_537AE8;
// 537AEC: using guessed type int dword_537AEC;
// 537AF0: using guessed type int dword_537AF0;
// 537AF4: using guessed type int dword_537AF4;
// 537AF8: using guessed type int dword_537AF8;
// 537AFC: using guessed type int dword_537AFC;
// 537B00: using guessed type int dword_537B00;
// 537B04: using guessed type int dword_537B04;
// 537B08: using guessed type int dword_537B08;
// 537B0C: using guessed type int dword_537B0C;
// 537B10: using guessed type int dword_537B10;
// 537B14: using guessed type int dword_537B14;
// 537B18: using guessed type char byte_537B18;
// 537B1C: using guessed type int dword_537B1C;

//----- (004DD740) --------------------------------------------------------
int __fastcall IconToBitmapYModify(icon *a1, bitmap *a2, int offX, int offY, int idx, int one, int zero1, int zero2, unsigned int width, int height, int a11, int a12)
{
  int v12; // ecx@2
  int result; // eax@4
  int v14; // ecx@11
  char v15; // dl@20
  int v16; // eax@20
  int v17; // ecx@22
  int v18; // edi@24
  int v19; // eax@24
  unsigned int v20; // ecx@24
  int v21; // edi@24
  char v22; // cl@24
  int v23; // edx@25
  int v24; // edi@25
  unsigned int v25; // ecx@25
  int v26; // esi@27
  int v27; // edi@27
  unsigned int v28; // ecx@27
  int v29; // edi@28
  int v30; // eax@35
  int v31; // eax@40
  char v32; // dl@52
  int v33; // eax@52
  unsigned int v34; // ecx@56
  int v35; // edi@56
  int v36; // esi@56
  int v37; // edi@56
  int v38; // esi@56
  char v39; // cl@56
  int v40; // eax@57
  int v41; // edi@57
  int v42; // esi@57
  unsigned int v43; // ecx@57
  int v44; // eax@59
  int v45; // edi@59
  const void *v46; // esi@59
  unsigned int v47; // ecx@59
  int v48; // edi@60
  const void *v49; // esi@60

  dword_537B3C = (int)&a1->headersAndImageData[idx];
  dword_537B40 = (int)((char *)a1->headersAndImageData + *(_DWORD *)(dword_537B3C + 9));
  dword_537B2C = offX + *(_WORD *)dword_537B3C;
  dword_537B5C = a2->width;
  dword_537B20 = offY + *(_WORD *)(dword_537B3C + 2);
  dword_537B28 = dword_537B2C + *(_BYTE *)(dword_537B20 + a12);
  dword_537B24 = height + zero2 - 1;
  dword_537B4C = zero1 + width - 1;
  dword_537B34 = (int)&a2->contents[dword_537B20 * dword_537B5C];
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *(_BYTE *)dword_537B40;
        dword_537B58 = v12;
        ++dword_537B40;
        if ( (char)v12 < 0 )
          break;
        if ( dword_537B58 )
        {
          if ( *(_BYTE *)(dword_537B20 + a12) != 127 )
          {
            if ( zero2 <= dword_537B20 )
            {
              if ( dword_537B24 >= dword_537B20 )
              {
                v32 = dword_537B58;
                v33 = dword_537B58 + dword_537B28;
                if ( zero1 < dword_537B58 + dword_537B28 )
                {
                  if ( dword_537B28 <= dword_537B4C )
                  {
                    if ( dword_537B28 < zero1 )
                    {
                      if ( dword_537B4C < v33 )
                      {
                        v48 = zero1 + dword_537B34;
                        v49 = (const void *)(dword_537B40 - dword_537B28 + zero1);
                        memcpy((void *)(zero1 + dword_537B34), v49, 4 * (width >> 2));
                        v38 = (int)((char *)v49 + 4 * (width >> 2));
                        v37 = v48 + 4 * (width >> 2);
                        v39 = width;
                      }
                      else
                      {
                        v44 = dword_537B58 + dword_537B28 - zero1;
                        v45 = zero1 + dword_537B34;
                        v46 = (const void *)(dword_537B40 - dword_537B28 + zero1);
                        v47 = (unsigned int)(dword_537B58 + dword_537B28 - zero1) >> 2;
                        memcpy((void *)(zero1 + dword_537B34), v46, 4 * v47);
                        v38 = (int)((char *)v46 + 4 * v47);
                        v37 = v45 + 4 * v47;
                        v39 = v44;
                      }
                    }
                    else if ( dword_537B4C < v33 )
                    {
                      v40 = dword_537B4C - dword_537B28 + 1;
                      v41 = dword_537B28 + dword_537B34;
                      v42 = dword_537B40;
                      v43 = (unsigned int)(dword_537B4C - dword_537B28 + 1) >> 2;
                      memcpy((void *)(dword_537B28 + dword_537B34), (const void *)dword_537B40, 4 * v43);
                      v38 = v42 + 4 * v43;
                      v37 = v41 + 4 * v43;
                      v39 = v40;
                    }
                    else
                    {
                      v34 = (unsigned int)dword_537B58 >> 2;
                      v35 = dword_537B28 + dword_537B34;
                      v36 = dword_537B40;
                      memcpy(
                        (void *)(dword_537B28 + dword_537B34),
                        (const void *)dword_537B40,
                        4 * ((unsigned int)dword_537B58 >> 2));
                      v38 = v36 + 4 * v34;
                      v37 = v35 + 4 * v34;
                      v39 = v32;
                    }
                    memcpy((void *)v37, (const void *)v38, v39 & 3);
                  }
                }
              }
            }
          }
          dword_537B28 += dword_537B58;
          dword_537B40 += dword_537B58;
        }
        else
        {
          dword_537B28 = dword_537B2C + *(_BYTE *)(dword_537B20 + a12);
          dword_537B34 += dword_537B5C;
          ++dword_537B20;
        }
      }
      if ( !(v12 & 0x40) )
        break;
      if ( dword_537B58 & 0x3F )
      {
        if ( dword_537B58 == 193 )
          dword_537B58 = *(_BYTE *)dword_537B40++;
        else
          dword_537B58 &= 0x3Fu;
        byte_537B38 = *(_BYTE *)dword_537B40++;
LABEL_17:
        if ( *(_BYTE *)(dword_537B20 + a12) != 127 )
        {
          if ( zero2 <= dword_537B20 )
          {
            if ( dword_537B24 >= dword_537B20 )
            {
              v15 = dword_537B58;
              v16 = dword_537B58 + dword_537B28;
              if ( zero1 < dword_537B58 + dword_537B28 )
              {
                if ( dword_537B28 <= dword_537B4C )
                {
                  HIWORD(v17) = HIWORD(dword_537B4C);
                  if ( dword_537B28 < zero1 )
                  {
                    if ( dword_537B4C < v16 )
                    {
                      LOBYTE(v17) = byte_537B38;
                      v29 = zero1 + dword_537B34;
                      BYTE1(v17) = byte_537B38;
                      v19 = v17 << 16;
                      LOWORD(v19) = v17;
                      memset32((void *)(zero1 + dword_537B34), v19, width >> 2);
                      v21 = v29 + 4 * (width >> 2);
                      v22 = width;
                    }
                    else
                    {
                      v26 = dword_537B58 + dword_537B28 - zero1;
                      LOBYTE(v17) = byte_537B38;
                      BYTE1(v17) = byte_537B38;
                      v27 = zero1 + dword_537B34;
                      v19 = v17 << 16;
                      LOWORD(v19) = v17;
                      v28 = (unsigned int)(dword_537B58 + dword_537B28 - zero1) >> 2;
                      memset32((void *)(zero1 + dword_537B34), v19, v28);
                      v21 = v27 + 4 * v28;
                      v22 = v26;
                    }
                  }
                  else if ( dword_537B4C < v16 )
                  {
                    v23 = dword_537B4C - dword_537B28 + 1;
                    LOBYTE(v17) = byte_537B38;
                    BYTE1(v17) = byte_537B38;
                    v19 = v17 << 16;
                    LOWORD(v19) = v17;
                    v24 = dword_537B34 + dword_537B28;
                    v25 = (unsigned int)(dword_537B4C - dword_537B28 + 1) >> 2;
                    memset32((void *)(dword_537B34 + dword_537B28), v19, v25);
                    v21 = v24 + 4 * v25;
                    v22 = v23;
                  }
                  else
                  {
                    LOBYTE(v17) = byte_537B38;
                    v18 = dword_537B28 + dword_537B34;
                    BYTE1(v17) = byte_537B38;
                    v19 = v17 << 16;
                    LOWORD(v19) = v17;
                    v20 = (unsigned int)dword_537B58 >> 2;
                    memset32((void *)(dword_537B28 + dword_537B34), v19, (unsigned int)dword_537B58 >> 2);
                    v21 = v18 + 4 * v20;
                    v22 = v15;
                  }
                  memset((void *)v21, v19, v22 & 3);
                }
              }
            }
          }
        }
        dword_537B28 += dword_537B58;
      }
      else
      {
        v14 = *(_BYTE *)dword_537B40;
        dword_537B58 = v14;
        ++dword_537B40;
        if ( v14 & 3 )
          dword_537B44 = v14 & 3;
        else
          dword_537B44 = *(_BYTE *)dword_537B40++;
        dword_537B48 = dword_537B44;
        if ( a11 && dword_537B58 & 0x80 )
        {
          byte_537B38 = a11;
          dword_537B58 = dword_537B44;
          goto LABEL_17;
        }
        if ( dword_537B58 & 0x40 )
        {
          dword_537B30 = (int)((char *)uDimPal + 64 * (dword_537B58 & 0x3C));
          if ( *(_BYTE *)(dword_537B20 + a12) != 127 )
          {
            if ( zero2 <= dword_537B20 )
            {
              if ( dword_537B24 >= dword_537B20 )
              {
                v30 = dword_537B44 + dword_537B28;
                if ( zero1 < dword_537B44 + dword_537B28 )
                {
                  if ( dword_537B28 <= dword_537B4C )
                  {
                    if ( dword_537B28 < zero1 )
                    {
                      if ( dword_537B4C < v30 )
                        dword_537B44 = width;
                      else
                        dword_537B44 += dword_537B28 - zero1;
                      v31 = zero1 + dword_537B34;
                    }
                    else
                    {
                      if ( dword_537B4C < v30 )
                        dword_537B44 = dword_537B4C - dword_537B28 + 1;
                      v31 = dword_537B34 + dword_537B28;
                    }
                    dword_537B54 = 0;
                    for ( dword_537B50 = v31; dword_537B44 > dword_537B54; ++dword_537B54 )
                    {
                      *(_BYTE *)dword_537B50 = *(_BYTE *)(*(_BYTE *)dword_537B50 + dword_537B30);
                      ++dword_537B50;
                    }
                  }
                }
              }
            }
          }
        }
        dword_537B28 += dword_537B48;
      }
    }
    result = v12 & 0x3F;
    if ( !(v12 & 0x3F) )
      return result;
    dword_537B28 += result;
  }
}
// 537B20: using guessed type int dword_537B20;
// 537B24: using guessed type int dword_537B24;
// 537B28: using guessed type int dword_537B28;
// 537B2C: using guessed type int dword_537B2C;
// 537B30: using guessed type int dword_537B30;
// 537B34: using guessed type int dword_537B34;
// 537B38: using guessed type char byte_537B38;
// 537B3C: using guessed type int dword_537B3C;
// 537B40: using guessed type int dword_537B40;
// 537B44: using guessed type int dword_537B44;
// 537B48: using guessed type int dword_537B48;
// 537B4C: using guessed type int dword_537B4C;
// 537B50: using guessed type int dword_537B50;
// 537B54: using guessed type int dword_537B54;
// 537B58: using guessed type int dword_537B58;
// 537B5C: using guessed type int dword_537B5C;

//----- (004DDCC0) --------------------------------------------------------
int __fastcall FlipMonoIconToBitmap(int a1, int a2, int a3, int a4, int a5, char a6, signed int a7, int a8, int a9, int a10, int a11)
{
  int v11; // edi@1
  int v12; // ecx@1
  int v13; // esi@1
  int v14; // eax@1
  int v15; // edi@1
  int v16; // eax@1
  int v17; // ebx@1
  int v18; // edi@1
  int v19; // eax@1
  int v20; // eax@5
  int v21; // esi@5
  int v22; // ecx@9
  int v23; // esi@9
  int result; // eax@10
  int v25; // edx@10
  int v26; // edx@11
  unsigned int v27; // ebp@15
  int v28; // eax@15
  int v29; // edi@15
  int v30; // eax@18
  int v31; // ecx@20
  int v32; // [sp+10h] [bp-4h]@9

  v11 = *(_DWORD *)(a1 + 18);
  v12 = *(_WORD *)(13 * a5 + v11 + 4);
  v13 = 13 * a5 + v11;
  v14 = v11 + *(_DWORD *)(13 * a5 + v11 + 9);
  dword_537B64 = v13;
  v15 = *(_WORD *)v13;
  dword_537B7C = v14;
  v16 = a3 - v15 - v12;
  v17 = *(_WORD *)(v13 + 2);
  v18 = a3 - v15 + 1;
  v19 = v16 + 1;
  dword_537B68 = v19;
  dword_537B6C = v18 - 1;
  dword_537B70 = v18 - 1;
  dword_537B60 = v17 + a4;
  if ( !a7 )
    goto LABEL_9;
  if ( a8 > v19 || a8 + a10 < v18 || dword_537B60 < a9 )
  {
    v21 = a11;
    goto LABEL_8;
  }
  v20 = dword_537B60 + *(_WORD *)(v13 + 6);
  v21 = a11;
  if ( v20 > a11 + a9 )
  {
LABEL_8:
    a7 = 1;
    dword_537B80 = a8 + a10 - 1;
    dword_537B84 = a9 + v21 - 1;
    goto LABEL_9;
  }
  a7 = 0;
LABEL_9:
  v22 = *(_DWORD *)(a2 + 22);
  v23 = v22 + *(_WORD *)(a2 + 18) * dword_537B60;
  v32 = *(_WORD *)(a2 + 18);
  while ( 1 )
  {
    while ( 1 )
    {
      result = dword_537B7C + 1;
      dword_537B7C = result;
      v25 = *(_BYTE *)(result - 1);
      if ( (char)v25 < 0 )
        break;
      dword_537B78 = *(_BYTE *)(result - 1);
      if ( v25 )
      {
        if ( !a7 )
        {
          v27 = v25;
          BYTE1(v22) = a6;
          LOBYTE(v22) = a6;
          v28 = v22 << 16;
          LOWORD(v28) = v22;
          v29 = dword_537B70 - v25 + v23 + 1;
LABEL_23:
          memset32((void *)v29, v28, v27 >> 2);
          memset((void *)(v29 + 4 * (v27 >> 2)), v28, v27 & 3);
          HIWORD(v22) = 0;
          goto LABEL_24;
        }
        HIWORD(v22) = HIWORD(dword_537B60);
        if ( dword_537B60 >= a9 )
        {
          if ( dword_537B60 <= dword_537B84 )
          {
            v27 = v25;
            HIWORD(v22) = HIWORD(a8);
            v30 = dword_537B70 - v25 + 1;
            if ( a8 <= v30 )
            {
              HIWORD(v22) = HIWORD(dword_537B70);
              if ( dword_537B70 <= dword_537B80 )
              {
                HIWORD(v31) = HIWORD(a8);
                if ( a8 > v30 )
                {
                  v27 = dword_537B70 - a8 + 1;
                  BYTE1(v31) = a6;
                  LOBYTE(v31) = a6;
                  v29 = v23 + a8;
                  v28 = v31 << 16;
                  LOWORD(v28) = v31;
                }
                else
                {
                  BYTE1(v31) = a6;
                  LOBYTE(v31) = a6;
                  v28 = v31 << 16;
                  LOWORD(v28) = v31;
                  v29 = dword_537B70 - v25 + v23 + 1;
                }
                goto LABEL_23;
              }
            }
          }
        }
LABEL_24:
        dword_537B78 = v25;
        dword_537B70 -= v25;
      }
      else
      {
        HIWORD(v22) = HIWORD(dword_537B6C);
        v23 += v32;
        dword_537B70 = dword_537B6C;
        ++dword_537B60;
      }
    }
    dword_537B74 = v23;
    dword_537B78 = v25;
    v26 = v25 & 0x7F;
    if ( !v26 )
      return result;
    dword_537B70 -= v26;
  }
}
// 537B60: using guessed type int dword_537B60;
// 537B64: using guessed type int dword_537B64;
// 537B68: using guessed type int dword_537B68;
// 537B6C: using guessed type int dword_537B6C;
// 537B70: using guessed type int dword_537B70;
// 537B74: using guessed type int dword_537B74;
// 537B78: using guessed type int dword_537B78;
// 537B7C: using guessed type int dword_537B7C;
// 537B80: using guessed type int dword_537B80;
// 537B84: using guessed type int dword_537B84;

//----- (004DDF30) --------------------------------------------------------
unsigned int __cdecl _fpmath()
{
  unsigned int result; // eax@1

  _cfltcvt_init_0();
  _adjust_fdiv = _ms_p5_mp_test_fdiv();
  result = _setdefaultprecision();
  __asm { fnclex }
  return result;
}
// 520B2C: using guessed type int _adjust_fdiv;

//----- (004DEFC0) --------------------------------------------------------
double __cdecl sin(double a1)
{
  JUMPOUT(unknown_libname_31);
}
// 4E0BFB: using guessed type double unknown_libname_31();

//----- (004DEFCA) --------------------------------------------------------
double __cdecl cos(double a1)
{
  JUMPOUT(loc_4DEFC5);
}
// 4DEFC5: using guessed type int loc_4DEFC5();

//----- (004E0ACA) --------------------------------------------------------
double __usercall cintrinexit<st0>(int a1<ebp>, double result<st0>)
{
  __int16 v2; // fps@2
  char v6; // al@2
  __int16 v7; // ax@11
  int v8; // ebx@18

  if ( __fastflag )
    return result;
  UNDEF(v2);
  *(double *)(a1 - 720) = result;
  v6 = *(_BYTE *)(a1 - 144);
  if ( !v6 )
    goto LABEL_7;
  if ( v6 != -1 && v6 != -2 )
  {
    if ( !v6 )
      return result;
    *(_DWORD *)(a1 - 142) = v6;
    goto LABEL_18;
  }
  v7 = *(_WORD *)(a1 - 714) & 0x7FF0;
  if ( v7 )
  {
    if ( v7 != 32752 )
    {
LABEL_7:
      if ( *(_WORD *)(a1 - 164) & 0x20 || !(v2 & 0x20) )
        return result;
      *(_DWORD *)(a1 - 142) = 8;
      goto LABEL_18;
    }
    *(_DWORD *)(a1 - 142) = 3;
    if ( fabs(result) > maxdouble1 )
      result = result * maxdouble2;
  }
  else
  {
    *(_DWORD *)(a1 - 142) = 4;
    if ( fabs(result) < mindouble1 )
      result = result * 0.0;
  }
LABEL_18:
  v8 = *(_DWORD *)(a1 - 148) + 1;
  *(_DWORD *)(a1 - 138) = v8;
  if ( !(*(_BYTE *)(a1 - 712) & 1) )
  {
    *(_DWORD *)(a1 - 134) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 - 134 + 4) = *(_DWORD *)(a1 + 12);
    if ( *(_BYTE *)(v8 + 12) != 1 )
    {
      *(_DWORD *)(a1 - 126) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 - 126 + 4) = *(_DWORD *)(a1 + 20);
    }
  }
  *(double *)(a1 - 118) = result;
  _87except(*(_BYTE *)(*(_DWORD *)(a1 - 148) + 14), a1 - 142, a1 - 164);
  return *(double *)(a1 - 118);
}
// 4E4A00: using guessed type _DWORD __cdecl _87except(_DWORD, _DWORD, _DWORD);
// 520B28: using guessed type int __fastflag;

//----- (004E16E0) --------------------------------------------------------
int __cdecl sub_4E16E0()
{
  return 0;
}

//----- (004E46F0) --------------------------------------------------------
int __cdecl __initstdio()
{
  FILE *v0; // ecx@8
  signed int v1; // eax@8
  int v2; // esi@10
  unsigned int v3; // edx@10
  int result; // eax@11

  if ( _nstream )
  {
    if ( (signed int)_nstream < 20 )
      _nstream = 20;
  }
  else
  {
    _nstream = 512;
  }
  __piob = (int)calloc(_nstream, 4);
  if ( !__piob )
  {
    _nstream = 20;
    __piob = (int)calloc(20, 4);
    if ( !__piob )
      _amsg_exit(26);
  }
  v0 = _iob;
  v1 = 0;
  do
  {
    v1 += 4;
    *(_DWORD *)(__piob + v1 - 4) = v0;
    ++v0;
  }
  while ( v1 < 80 );
  v2 = 0;
  v3 = (unsigned int)&unk_521848;
  do
  {
    result = *(_DWORD *)(*(int *)((char *)__pioinfo + ((v2 & 0xFFFFFFE7) >> 3)) + 36 * (v2 & 0x1F));
    if ( result == -1 || !result )
      *(_DWORD *)v3 = -1;
    v3 += 32;
    ++v2;
  }
  while ( v3 < (unsigned int)&unk_5218A8 );
  return result;
}
// 537E0C: using guessed type int __piob;
// 538E20: using guessed type int __pioinfo[];

//----- (004E5130) --------------------------------------------------------
int __cdecl _ld12tof(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_521AF0);
}
// 4E4F60: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (004E5150) --------------------------------------------------------
void __cdecl abort()
{
  int v0; // [sp+4h] [bp+4h]@0
  int v1; // [sp+8h] [bp+8h]@0

  _ld12cvt(v0, v1, &unk_521B08);
}
// 4E4F60: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (004E5170) --------------------------------------------------------
int __cdecl sub_4E5170(int a1, int a2)
{
  char v3; // [sp+0h] [bp-10h]@1
  char v4; // [sp+4h] [bp-Ch]@1

  __strgtold12(&v4, &v3, a2, 0, 0, 0, 0);
  return _ld12tof((int)&v4, a1);
}
// 4E8500: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004E51B0) --------------------------------------------------------
int __cdecl _atodbl(_CRT_DOUBLE *Result, char *Str)
{
  int result; // eax@1
  char v3; // [sp+0h] [bp-10h]@1
  char v4; // [sp+4h] [bp-Ch]@1

  __strgtold12(&v4, &v3, Str, 0, 0, 0, 0);
  abort();
  return result;
}
// 4E8500: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004E60B0) --------------------------------------------------------
signed int __cdecl sub_4E60B0()
{
  const CHAR *v0; // edi@1
  BOOL v1; // esi@4
  BOOL v2; // ebp@4
  LPVOID v3; // eax@4
  const CHAR *v4; // ecx@8
  signed int v5; // eax@8
  char *v6; // ebx@13
  char v7; // dl@14
  signed int v8; // eax@15
  BOOL v9; // ecx@19
  signed int v10; // eax@19
  int v11; // eax@21
  char *v12; // ebx@23
  char v13; // dl@24
  signed int v14; // eax@25
  int v15; // edx@26
  signed int result; // eax@33
  BOOL lpWideCharStr; // [sp+10h] [bp-18h]@1
  struct _cpinfo CPInfo; // [sp+14h] [bp-14h]@10

  v0 = 0;
  lpWideCharStr = 0;
  if ( !Locale )
  {
    _pctype = &_ctype[1];
    off_520FE4 = &_ctype[1];
    free((BOOL)dword_521B34);
    free((BOOL)dword_521B38);
    result = 0;
    dword_521B34 = 0;
    dword_521B38 = 0;
    return result;
  }
  if ( !__lc_codepage && __getlocaleinfo(0, (unsigned __int16)word_521B4C, 0xBu, (int)&__lc_codepage) )
  {
    v1 = CPInfo.MaxCharSize;
    v2 = CPInfo.MaxCharSize;
LABEL_35:
    free(v1);
    free(v2);
    free((BOOL)v0);
    free(lpWideCharStr);
    return 1;
  }
  v1 = (BOOL)malloc(0x202u);
  v2 = (BOOL)malloc(0x202u);
  v0 = (const CHAR *)malloc(0x101u);
  v3 = malloc(0x202u);
  lpWideCharStr = (BOOL)v3;
  if ( !v1 )
    goto LABEL_35;
  if ( !v2 )
    goto LABEL_35;
  if ( !v0 )
    goto LABEL_35;
  if ( !v3 )
    goto LABEL_35;
  v4 = v0;
  v5 = 0;
  do
    *v4++ = v5++;
  while ( v5 < 256 );
  if ( !GetCPInfo(__lc_codepage, &CPInfo) || CPInfo.MaxCharSize > 2 )
    goto LABEL_35;
  __mb_cur_max = (unsigned __int16)CPInfo.MaxCharSize;
  if ( (signed int)(unsigned __int16)CPInfo.MaxCharSize > 1 )
  {
    v6 = (char *)CPInfo.LeadByte;
    if ( CPInfo.LeadByte[0] )
    {
      do
      {
        v7 = v6[1];
        if ( !v7 )
          break;
        v8 = (unsigned __int8)*v6;
        if ( (unsigned __int8)v7 >= v8 )
        {
          do
            v0[v8++] = 0;
          while ( (unsigned __int8)v6[1] >= v8 );
        }
        v6 += 2;
      }
      while ( *v6 );
    }
  }
  if ( !__crtGetStringTypeA(1u, v0, 256, (LPWORD)(v1 + 2), 0, 0) )
    goto LABEL_35;
  *(_WORD *)v1 = 0;
  v9 = lpWideCharStr;
  v10 = 0;
  do
  {
    *(_WORD *)v9 = v10;
    v9 += 2;
    ++v10;
  }
  while ( v10 < 256 );
  __crtGetStringTypeW(1u, (LPCWSTR)lpWideCharStr, 256, (WORD *)(v2 + 2), 0, 0);
  if ( !v11 )
    goto LABEL_35;
  *(_WORD *)v2 = 0;
  if ( __mb_cur_max > 1 )
  {
    v12 = (char *)CPInfo.LeadByte;
    if ( CPInfo.LeadByte[0] )
    {
      do
      {
        v13 = v12[1];
        if ( !v13 )
          break;
        v14 = (unsigned __int8)*v12;
        if ( (unsigned __int8)v13 >= v14 )
        {
          v15 = v1 + 2 * v14 + 2;
          do
          {
            *(_WORD *)v15 = -32768;
            v15 += 2;
            ++v14;
          }
          while ( (unsigned __int8)v12[1] >= v14 );
        }
        v12 += 2;
      }
      while ( *v12 );
    }
  }
  _pctype = (unsigned __int16 *)(v1 + 2);
  off_520FE4 = (void *)(v2 + 2);
  if ( dword_521B34 )
    free((BOOL)dword_521B34);
  dword_521B34 = (void *)v1;
  if ( dword_521B38 )
    free((BOOL)dword_521B38);
  dword_521B38 = (void *)v2;
  free((BOOL)v0);
  free(lpWideCharStr);
  return 0;
}
// 520FE4: using guessed type void *off_520FE4;

//----- (004E6360) --------------------------------------------------------
int __cdecl sub_4E6360()
{
  return 0;
}

//----- (004E8200) --------------------------------------------------------
int __cdecl _matherr(struct _exception *a1)
{
  return 0;
}

#error "There were 8 decompilation failure(s) on 1426 function(s)"
