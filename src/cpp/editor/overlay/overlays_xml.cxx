// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "overlays_xml.hxx"

// overlay_t
// 

const overlay_t::tiles_sequence& overlay_t::
tiles () const
{
  return this->tiles_;
}

overlay_t::tiles_sequence& overlay_t::
tiles ()
{
  return this->tiles_;
}

void overlay_t::
tiles (const tiles_sequence& s)
{
  this->tiles_ = s;
}

const overlay_t::animatedTiles_sequence& overlay_t::
animatedTiles () const
{
  return this->animatedTiles_;
}

overlay_t::animatedTiles_sequence& overlay_t::
animatedTiles ()
{
  return this->animatedTiles_;
}

void overlay_t::
animatedTiles (const animatedTiles_sequence& s)
{
  this->animatedTiles_ = s;
}

const overlay_t::coveredNonObstructed_sequence& overlay_t::
coveredNonObstructed () const
{
  return this->coveredNonObstructed_;
}

overlay_t::coveredNonObstructed_sequence& overlay_t::
coveredNonObstructed ()
{
  return this->coveredNonObstructed_;
}

void overlay_t::
coveredNonObstructed (const coveredNonObstructed_sequence& s)
{
  this->coveredNonObstructed_ = s;
}

const overlay_t::shadows_sequence& overlay_t::
shadows () const
{
  return this->shadows_;
}

overlay_t::shadows_sequence& overlay_t::
shadows ()
{
  return this->shadows_;
}

void overlay_t::
shadows (const shadows_sequence& s)
{
  this->shadows_ = s;
}

const overlay_t::validTerrain_sequence& overlay_t::
validTerrain () const
{
  return this->validTerrain_;
}

overlay_t::validTerrain_sequence& overlay_t::
validTerrain ()
{
  return this->validTerrain_;
}

void overlay_t::
validTerrain (const validTerrain_sequence& s)
{
  this->validTerrain_ = s;
}

const overlay_t::idx_type& overlay_t::
idx () const
{
  return this->idx_.get ();
}

overlay_t::idx_type& overlay_t::
idx ()
{
  return this->idx_.get ();
}

void overlay_t::
idx (const idx_type& x)
{
  this->idx_.set (x);
}

const overlay_t::idx2_type& overlay_t::
idx2 () const
{
  return this->idx2_.get ();
}

overlay_t::idx2_type& overlay_t::
idx2 ()
{
  return this->idx2_.get ();
}

void overlay_t::
idx2 (const idx2_type& x)
{
  this->idx2_.set (x);
}

const overlay_t::ordinal_type& overlay_t::
ordinal () const
{
  return this->ordinal_.get ();
}

overlay_t::ordinal_type& overlay_t::
ordinal ()
{
  return this->ordinal_.get ();
}

void overlay_t::
ordinal (const ordinal_type& x)
{
  this->ordinal_.set (x);
}

const overlay_t::tileset_type& overlay_t::
tileset () const
{
  return this->tileset_.get ();
}

overlay_t::tileset_type& overlay_t::
tileset ()
{
  return this->tileset_.get ();
}

void overlay_t::
tileset (const tileset_type& x)
{
  this->tileset_.set (x);
}

void overlay_t::
tileset (::std::auto_ptr< tileset_type > x)
{
  this->tileset_.set (x);
}

const overlay_t::category_type& overlay_t::
category () const
{
  return this->category_.get ();
}

overlay_t::category_type& overlay_t::
category ()
{
  return this->category_.get ();
}

void overlay_t::
category (const category_type& x)
{
  this->category_.set (x);
}

void overlay_t::
category (::std::auto_ptr< category_type > x)
{
  this->category_.set (x);
}

const overlay_t::color_type& overlay_t::
color () const
{
  return this->color_.get ();
}

overlay_t::color_type& overlay_t::
color ()
{
  return this->color_.get ();
}

void overlay_t::
color (const color_type& x)
{
  this->color_.set (x);
}

void overlay_t::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const overlay_t::color_type& overlay_t::
color_default_value ()
{
  return color_default_value_;
}

const overlay_t::animationLength_type& overlay_t::
animationLength () const
{
  return this->animationLength_.get ();
}

overlay_t::animationLength_type& overlay_t::
animationLength ()
{
  return this->animationLength_.get ();
}

void overlay_t::
animationLength (const animationLength_type& x)
{
  this->animationLength_.set (x);
}

overlay_t::animationLength_type overlay_t::
animationLength_default_value ()
{
  return animationLength_type (0);
}


// terrain_mask_t
// 


// terrain_t
// 

terrain_t::
terrain_t (value v)
: ::xml_schema::string (_xsd_terrain_t_literals_[v])
{
}

terrain_t::
terrain_t (const char* v)
: ::xml_schema::string (v)
{
}

terrain_t::
terrain_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

terrain_t::
terrain_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

terrain_t::
terrain_t (const terrain_t& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

terrain_t& terrain_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_terrain_t_literals_[v]);

  return *this;
}


// player_color_t
// 

player_color_t::
player_color_t (value v)
: ::xml_schema::string (_xsd_player_color_t_literals_[v])
{
}

player_color_t::
player_color_t (const char* v)
: ::xml_schema::string (v)
{
}

player_color_t::
player_color_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

player_color_t::
player_color_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

player_color_t::
player_color_t (const player_color_t& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

player_color_t& player_color_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_player_color_t_literals_[v]);

  return *this;
}


// tileset_t
// 

tileset_t::
tileset_t (value v)
: ::xml_schema::string (_xsd_tileset_t_literals_[v])
{
}

tileset_t::
tileset_t (const char* v)
: ::xml_schema::string (v)
{
}

tileset_t::
tileset_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

tileset_t::
tileset_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

tileset_t::
tileset_t (const tileset_t& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

tileset_t& tileset_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_tileset_t_literals_[v]);

  return *this;
}


// category_t
// 

category_t::
category_t (value v)
: ::xml_schema::string (_xsd_category_t_literals_[v])
{
}

category_t::
category_t (const char* v)
: ::xml_schema::string (v)
{
}

category_t::
category_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

category_t::
category_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

category_t::
category_t (const category_t& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

category_t& category_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_category_t_literals_[v]);

  return *this;
}


// location_t
// 

location_t::
location_t (value v)
: ::xml_schema::string (_xsd_location_t_literals_[v])
{
}

location_t::
location_t (const char* v)
: ::xml_schema::string (v)
{
}

location_t::
location_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

location_t::
location_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

location_t::
location_t (const location_t& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

location_t& location_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_location_t_literals_[v]);

  return *this;
}


// overlays
// 

const overlays::overlay_sequence& overlays::
overlay () const
{
  return this->overlay_;
}

overlays::overlay_sequence& overlays::
overlay ()
{
  return this->overlay_;
}

void overlays::
overlay (const overlay_sequence& s)
{
  this->overlay_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// overlay_t
//

const overlay_t::color_type overlay_t::color_default_value_ (
  "PLAYER_BLUE");

overlay_t::
overlay_t (const idx_type& idx,
           const idx2_type& idx2,
           const ordinal_type& ordinal,
           const tileset_type& tileset,
           const category_type& category)
: ::xml_schema::type (),
  tiles_ (::xml_schema::flags (), this),
  animatedTiles_ (::xml_schema::flags (), this),
  coveredNonObstructed_ (::xml_schema::flags (), this),
  shadows_ (::xml_schema::flags (), this),
  validTerrain_ (::xml_schema::flags (), this),
  idx_ (idx, ::xml_schema::flags (), this),
  idx2_ (idx2, ::xml_schema::flags (), this),
  ordinal_ (ordinal, ::xml_schema::flags (), this),
  tileset_ (tileset, ::xml_schema::flags (), this),
  category_ (category, ::xml_schema::flags (), this),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  animationLength_ (animationLength_default_value (), ::xml_schema::flags (), this)
{
}

overlay_t::
overlay_t (const overlay_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tiles_ (x.tiles_, f, this),
  animatedTiles_ (x.animatedTiles_, f, this),
  coveredNonObstructed_ (x.coveredNonObstructed_, f, this),
  shadows_ (x.shadows_, f, this),
  validTerrain_ (x.validTerrain_, f, this),
  idx_ (x.idx_, f, this),
  idx2_ (x.idx2_, f, this),
  ordinal_ (x.ordinal_, f, this),
  tileset_ (x.tileset_, f, this),
  category_ (x.category_, f, this),
  color_ (x.color_, f, this),
  animationLength_ (x.animationLength_, f, this)
{
}

overlay_t::
overlay_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tiles_ (f, this),
  animatedTiles_ (f, this),
  coveredNonObstructed_ (f, this),
  shadows_ (f, this),
  validTerrain_ (f, this),
  idx_ (f, this),
  idx2_ (f, this),
  ordinal_ (f, this),
  tileset_ (f, this),
  category_ (f, this),
  color_ (f, this),
  animationLength_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void overlay_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tiles
    //
    if (n.name () == "tiles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiles_type > r (
        tiles_traits::create (i, f, this));

      this->tiles_.push_back (r);
      continue;
    }

    // animatedTiles
    //
    if (n.name () == "animatedTiles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< animatedTiles_type > r (
        animatedTiles_traits::create (i, f, this));

      this->animatedTiles_.push_back (r);
      continue;
    }

    // coveredNonObstructed
    //
    if (n.name () == "coveredNonObstructed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coveredNonObstructed_type > r (
        coveredNonObstructed_traits::create (i, f, this));

      this->coveredNonObstructed_.push_back (r);
      continue;
    }

    // shadows
    //
    if (n.name () == "shadows" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shadows_type > r (
        shadows_traits::create (i, f, this));

      this->shadows_.push_back (r);
      continue;
    }

    // validTerrain
    //
    if (n.name () == "validTerrain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< validTerrain_type > r (
        validTerrain_traits::create (i, f, this));

      this->validTerrain_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "idx" && n.namespace_ ().empty ())
    {
      this->idx_.set (idx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "idx2" && n.namespace_ ().empty ())
    {
      this->idx2_.set (idx2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ordinal" && n.namespace_ ().empty ())
    {
      this->ordinal_.set (ordinal_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "tileset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tileset_type > r (
        tileset_traits::create (i, f, this));

      this->tileset_.set (r);
      continue;
    }

    if (n.name () == "category" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< category_type > r (
        category_traits::create (i, f, this));

      this->category_.set (r);
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color_.set (r);
      continue;
    }

    if (n.name () == "animationLength" && n.namespace_ ().empty ())
    {
      this->animationLength_.set (animationLength_traits::create (i, f, this));
      continue;
    }
  }

  if (!idx_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "idx",
      "");
  }

  if (!idx2_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "idx2",
      "");
  }

  if (!ordinal_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ordinal",
      "");
  }

  if (!tileset_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "tileset",
      "");
  }

  if (!category_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "category",
      "");
  }

  if (!color_.present ())
  {
    this->color_.set (color_default_value ());
  }

  if (!animationLength_.present ())
  {
    this->animationLength_.set (animationLength_default_value ());
  }
}

overlay_t* overlay_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class overlay_t (*this, f, c);
}

overlay_t::
~overlay_t ()
{
}

// terrain_mask_t
//

terrain_mask_t::
terrain_mask_t ()
: ::xml_schema::type ()
{
}

terrain_mask_t::
terrain_mask_t (const terrain_mask_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

terrain_mask_t::
terrain_mask_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

terrain_mask_t::
terrain_mask_t (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

terrain_mask_t::
terrain_mask_t (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

terrain_mask_t* terrain_mask_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class terrain_mask_t (*this, f, c);
}

terrain_mask_t::
~terrain_mask_t ()
{
}

// terrain_t
//

terrain_t::
terrain_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_terrain_t_convert ();
}

terrain_t::
terrain_t (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_terrain_t_convert ();
}

terrain_t::
terrain_t (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_terrain_t_convert ();
}

terrain_t* terrain_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class terrain_t (*this, f, c);
}

terrain_t::value terrain_t::
_xsd_terrain_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_terrain_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_terrain_t_indexes_,
                    _xsd_terrain_t_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_terrain_t_indexes_ + 9 || _xsd_terrain_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const terrain_t::
_xsd_terrain_t_literals_[9] =
{
  "TERRAIN_WATER",
  "TERRAIN_GRASS",
  "TERRAIN_SNOW",
  "TERRAIN_SWAMP",
  "TERRAIN_LAVA",
  "TERRAIN_DESERT",
  "TERRAIN_DIRT",
  "TERRAIN_WASTELAND",
  "TERRAIN_SAND"
};

const terrain_t::value terrain_t::
_xsd_terrain_t_indexes_[9] =
{
  ::terrain_t::TERRAIN_DESERT,
  ::terrain_t::TERRAIN_DIRT,
  ::terrain_t::TERRAIN_GRASS,
  ::terrain_t::TERRAIN_LAVA,
  ::terrain_t::TERRAIN_SAND,
  ::terrain_t::TERRAIN_SNOW,
  ::terrain_t::TERRAIN_SWAMP,
  ::terrain_t::TERRAIN_WASTELAND,
  ::terrain_t::TERRAIN_WATER
};

// player_color_t
//

player_color_t::
player_color_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_player_color_t_convert ();
}

player_color_t::
player_color_t (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_player_color_t_convert ();
}

player_color_t::
player_color_t (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_player_color_t_convert ();
}

player_color_t* player_color_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class player_color_t (*this, f, c);
}

player_color_t::value player_color_t::
_xsd_player_color_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_player_color_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_player_color_t_indexes_,
                    _xsd_player_color_t_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_player_color_t_indexes_ + 6 || _xsd_player_color_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const player_color_t::
_xsd_player_color_t_literals_[6] =
{
  "PLAYER_BLUE",
  "PLAYER_GREEN",
  "PLAYER_YELLOW",
  "PLAYER_RED",
  "PLAYER_ORANGE",
  "PLAYER_PURPLE"
};

const player_color_t::value player_color_t::
_xsd_player_color_t_indexes_[6] =
{
  ::player_color_t::PLAYER_BLUE,
  ::player_color_t::PLAYER_GREEN,
  ::player_color_t::PLAYER_ORANGE,
  ::player_color_t::PLAYER_PURPLE,
  ::player_color_t::PLAYER_RED,
  ::player_color_t::PLAYER_YELLOW
};

// tileset_t
//

tileset_t::
tileset_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_tileset_t_convert ();
}

tileset_t::
tileset_t (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_tileset_t_convert ();
}

tileset_t::
tileset_t (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_tileset_t_convert ();
}

tileset_t* tileset_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tileset_t (*this, f, c);
}

tileset_t::value tileset_t::
_xsd_tileset_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tileset_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_tileset_t_indexes_,
                    _xsd_tileset_t_indexes_ + 52,
                    *this,
                    c));

  if (i == _xsd_tileset_t_indexes_ + 52 || _xsd_tileset_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const tileset_t::
_xsd_tileset_t_literals_[52] =
{
  "TILESET_HAUNTED",
  "TILESET_ARTIFACT",
  "TILESET_MONSTER",
  "TILESET_ARTIFACT_TAKEN",
  "TILESET_FLAG",
  "TILESET_RESOURCE_DISPLAY",
  "TILESET_HOURGLASS",
  "TILESET_ROUTE",
  "TILESET_STONBACK",
  "TILESET_MONSTER_ANIMATION",
  "TILESET_HERO",
  "TILESET_SNOW_MOUNTAIN",
  "TILESET_SWAMP_MOUNTAIN",
  "TILESET_LAVA_MOUNTAIN",
  "TILESET_DESERT_MOUNTAIN",
  "TILESET_DIRT_MOUNTAIN",
  "TILESET_MOUNTAIN_MULTIPLE",
  "TILESET_EXTRA_OVERLAY",
  "TILESET_ROAD",
  "TILESET_MOUNTAIN_CRACKED",
  "TILESET_MOUNTAIN_GRASS",
  "TILESET_TREE_JUNGLE",
  "TILESET_TREE_EVIL",
  "TILESET_OBJ_TOWN",
  "TILESET_TOWN_TERRAIN",
  "TILESET_TOWN_SHADOW",
  "TILESET_TOWN_RANDOM",
  "TILESET_OBJECT_EXTRA",
  "TILESET_OBJECT_WATER_2",
  "TILESET_OBJECT_MULTIPLE_2",
  "TILESET_OBJECT_TREE_SNOW",
  "TILESET_OBJECT_TREE_FIR",
  "TILESET_OBJECT_TREE_FALL",
  "TILESET_OBJECT_STREAM",
  "TILESET_OBJECT_RESOURCE",
  "TILESET_OBJECT_DUMMY",
  "TILESET_OBJECT_GRASS_2",
  "TILESET_OBJECT_TREE_DECIDUOUS",
  "TILESET_OBJECT_WATER",
  "TILESET_OBJECT_GRASS",
  "TILESET_OBJECT_SNOW",
  "TILESET_OBJECT_SWAMP",
  "TILESET_OBJECT_LAVA",
  "TILESET_OBJECT_DESERT",
  "TILESET_OBJECT_DIRT",
  "TILESET_OBJECT_CRACKED",
  "TILESET_OBJECT_LAVA_3",
  "TILESET_OBJECT_MULTIPLE",
  "TILESET_OBJECT_LAVA_2",
  "TILESET_OBJECT_EXPANSION_1",
  "TILESET_OBJECT_EXPANSION_2",
  "TILESET_OBJECT_EXPANSION_3"
};

const tileset_t::value tileset_t::
_xsd_tileset_t_indexes_[52] =
{
  ::tileset_t::TILESET_ARTIFACT,
  ::tileset_t::TILESET_ARTIFACT_TAKEN,
  ::tileset_t::TILESET_DESERT_MOUNTAIN,
  ::tileset_t::TILESET_DIRT_MOUNTAIN,
  ::tileset_t::TILESET_EXTRA_OVERLAY,
  ::tileset_t::TILESET_FLAG,
  ::tileset_t::TILESET_HAUNTED,
  ::tileset_t::TILESET_HERO,
  ::tileset_t::TILESET_HOURGLASS,
  ::tileset_t::TILESET_LAVA_MOUNTAIN,
  ::tileset_t::TILESET_MONSTER,
  ::tileset_t::TILESET_MONSTER_ANIMATION,
  ::tileset_t::TILESET_MOUNTAIN_CRACKED,
  ::tileset_t::TILESET_MOUNTAIN_GRASS,
  ::tileset_t::TILESET_MOUNTAIN_MULTIPLE,
  ::tileset_t::TILESET_OBJECT_CRACKED,
  ::tileset_t::TILESET_OBJECT_DESERT,
  ::tileset_t::TILESET_OBJECT_DIRT,
  ::tileset_t::TILESET_OBJECT_DUMMY,
  ::tileset_t::TILESET_OBJECT_EXPANSION_1,
  ::tileset_t::TILESET_OBJECT_EXPANSION_2,
  ::tileset_t::TILESET_OBJECT_EXPANSION_3,
  ::tileset_t::TILESET_OBJECT_EXTRA,
  ::tileset_t::TILESET_OBJECT_GRASS,
  ::tileset_t::TILESET_OBJECT_GRASS_2,
  ::tileset_t::TILESET_OBJECT_LAVA,
  ::tileset_t::TILESET_OBJECT_LAVA_2,
  ::tileset_t::TILESET_OBJECT_LAVA_3,
  ::tileset_t::TILESET_OBJECT_MULTIPLE,
  ::tileset_t::TILESET_OBJECT_MULTIPLE_2,
  ::tileset_t::TILESET_OBJECT_RESOURCE,
  ::tileset_t::TILESET_OBJECT_SNOW,
  ::tileset_t::TILESET_OBJECT_STREAM,
  ::tileset_t::TILESET_OBJECT_SWAMP,
  ::tileset_t::TILESET_OBJECT_TREE_DECIDUOUS,
  ::tileset_t::TILESET_OBJECT_TREE_FALL,
  ::tileset_t::TILESET_OBJECT_TREE_FIR,
  ::tileset_t::TILESET_OBJECT_TREE_SNOW,
  ::tileset_t::TILESET_OBJECT_WATER,
  ::tileset_t::TILESET_OBJECT_WATER_2,
  ::tileset_t::TILESET_OBJ_TOWN,
  ::tileset_t::TILESET_RESOURCE_DISPLAY,
  ::tileset_t::TILESET_ROAD,
  ::tileset_t::TILESET_ROUTE,
  ::tileset_t::TILESET_SNOW_MOUNTAIN,
  ::tileset_t::TILESET_STONBACK,
  ::tileset_t::TILESET_SWAMP_MOUNTAIN,
  ::tileset_t::TILESET_TOWN_RANDOM,
  ::tileset_t::TILESET_TOWN_SHADOW,
  ::tileset_t::TILESET_TOWN_TERRAIN,
  ::tileset_t::TILESET_TREE_EVIL,
  ::tileset_t::TILESET_TREE_JUNGLE
};

// category_t
//

category_t::
category_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_category_t_convert ();
}

category_t::
category_t (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_category_t_convert ();
}

category_t::
category_t (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_category_t_convert ();
}

category_t* category_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class category_t (*this, f, c);
}

category_t::value category_t::
_xsd_category_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_category_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_category_t_indexes_,
                    _xsd_category_t_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_category_t_indexes_ + 7 || _xsd_category_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const category_t::
_xsd_category_t_literals_[7] =
{
  "CATEGORY_TERRAIN",
  "CATEGORY_TREASURE",
  "CATEGORY_CREATURE",
  "CATEGORY_ARTIFACT",
  "CATEGORY_TOWN",
  "CATEGORY_BUILTIN",
  "CATEGORY_HERO"
};

const category_t::value category_t::
_xsd_category_t_indexes_[7] =
{
  ::category_t::CATEGORY_ARTIFACT,
  ::category_t::CATEGORY_BUILTIN,
  ::category_t::CATEGORY_CREATURE,
  ::category_t::CATEGORY_HERO,
  ::category_t::CATEGORY_TERRAIN,
  ::category_t::CATEGORY_TOWN,
  ::category_t::CATEGORY_TREASURE
};

// location_t
//

location_t::
location_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_location_t_convert ();
}

location_t::
location_t (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_location_t_convert ();
}

location_t::
location_t (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_location_t_convert ();
}

location_t* location_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class location_t (*this, f, c);
}

location_t::value location_t::
_xsd_location_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_location_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_location_t_indexes_,
                    _xsd_location_t_indexes_ + 119,
                    *this,
                    c));

  if (i == _xsd_location_t_indexes_ + 119 || _xsd_location_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const location_t::
_xsd_location_t_literals_[119] =
{
  "LOCATION_ALCHEMIST_LAB",
  "LOCATION_SIGN",
  "LOCATION_BUOY",
  "LOCATION_SKELETON",
  "LOCATION_DAEMON_CAVE",
  "LOCATION_TREASURE_CHEST",
  "LOCATION_FAERIE_RING",
  "LOCATION_CAMPFIRE",
  "LOCATION_FOUNTAIN",
  "LOCATION_GAZEBO",
  "LOCATION_ANCIENT_LAMP",
  "LOCATION_GRAVEYARD",
  "LOCATION_ARCHERS_HOUSE",
  "LOCATION_GOBLIN_HUT",
  "LOCATION_DWARF_COTTAGE",
  "LOCATION_PEASANT_HUT",
  "LOCATION_LOG_CABIN",
  "LOCATION_ROAD",
  "LOCATION_EVENT",
  "LOCATION_DRAGON_CITY",
  "LOCATION_LIGHTHOUSE",
  "LOCATION_WATERWHEEL",
  "LOCATION_MINE",
  "LOCATION_ARMY_CAMP",
  "LOCATION_OBELISK",
  "LOCATION_OASIS",
  "LOCATION_RESOURCE",
  "LOCATION_SAWMILL",
  "LOCATION_ORACLE",
  "LOCATION_SHRINE_FIRST",
  "LOCATION_SHIPWRECK",
  "LOCATION_SEA_CHEST",
  "LOCATION_DESRT_TENT",
  "LOCATION_TOWN",
  "LOCATION_STONE_LITHS",
  "LOCATION_WAGON_CAMP",
  "LOCATION_WELL",
  "LOCATION_WHIRLPOOL",
  "LOCATION_WINDMILL",
  "LOCATION_ARTIFACT",
  "LOCATION_HERO",
  "LOCATION_BOAT",
  "LOCATION_RANDOM_ARTIFACT",
  "LOCATION_RANDOM_RESOURCE",
  "LOCATION_RANDOM_MONSTER",
  "LOCATION_RANDOM_TOWN",
  "LOCATION_RANDOM_CASTLE",
  "LOCATION_RANDOM_MONSTER_WEAK",
  "LOCATION_RANDOM_MONSTER_MEDIUM",
  "LOCATION_RANDOM_MONSTER_STRONG",
  "LOCATION_RANDOM_MONSTER_VERY_STRONG",
  "LOCATION_RANDOM_HERO",
  "LOCATION_NOTHING_SPECIAL",
  "LOCATION_WATCH_TOWER",
  "LOCATION_TREE_HOUSE",
  "LOCATION_TREE_CITY",
  "LOCATION_RUINS",
  "LOCATION_FORT",
  "LOCATION_TRADING_POST",
  "LOCATION_ABANDONED_MINE",
  "LOCATION_DWARF_CABIN",
  "LOCATION_STANDING_STONES",
  "LOCATION_IDOL",
  "LOCATION_TREE_OF_KNOWLEDGE",
  "LOCATION_WITCH_DOCTORS_HUT",
  "LOCATION_TEMPLE",
  "LOCATION_HILL_FORT",
  "LOCATION_HALFLING_HOLE",
  "LOCATION_MERCENARY_CAMP",
  "LOCATION_SHRINE_SECOND_ORDER",
  "LOCATION_SHRINE_THIRD_ORDER",
  "LOCATION_PYRAMID",
  "LOCATION_CITY_OF_DEAD",
  "LOCATION_EXCAVATION",
  "LOCATION_SPHINX",
  "LOCATION_WAGON",
  "LOCATION_TAR_PIT",
  "LOCATION_ARTESIAN_SPRING",
  "LOCATION_TROLL_BRIDGE",
  "LOCATION_WATERING_HOLE",
  "LOCATION_WITCH_HUT",
  "LOCATION_XANADU",
  "LOCATION_CAVE",
  "LOCATION_LEAN_TO",
  "LOCATION_MAGELLANS_MAPS",
  "LOCATION_FLOTSAM",
  "LOCATION_DERELICT_SHIP",
  "LOCATION_SHIPWRECK_SURVIVOR",
  "LOCATION_BOTTLE",
  "LOCATION_MAGIC_WELL",
  "LOCATION_MAGIC_GARDEN",
  "LOCATION_OBSERVATION_TOWER",
  "LOCATION_FREEMANS_FOUNDRY",
  "LOCATION_STREAM",
  "LOCATION_TREES",
  "LOCATION_MOUNTAINS",
  "LOCATION_VOLCANO",
  "LOCATION_FLOWERS",
  "LOCATION_ROCK",
  "LOCATION_LAKE",
  "LOCATION_MANDRAKE",
  "LOCATION_DEAD_TREE",
  "LOCATION_STUMP",
  "LOCATION_CRATER",
  "LOCATION_CACTUS",
  "LOCATION_MOUND",
  "LOCATION_DUNE",
  "LOCATION_LAVA_POOL",
  "LOCATION_SHRUB",
  "LOCATION_HOLE",
  "LOCATION_OUTCROPPING",
  "LOCATION_RANDOM_ARTIFACT_TREASURE",
  "LOCATION_RANDOM_ARTIFACT_MINOR",
  "LOCATION_RANDOM_ARTIFACT_MAJOR",
  "LOCATION_BARRIER",
  "LOCATION_TRAVELLER_TENT",
  "LOCATION_EXPANSION_DWELLING",
  "LOCATION_ALCHEMIST_TOWER",
  "LOCATION_JAIL"
};

const location_t::value location_t::
_xsd_location_t_indexes_[119] =
{
  ::location_t::LOCATION_ABANDONED_MINE,
  ::location_t::LOCATION_ALCHEMIST_LAB,
  ::location_t::LOCATION_ALCHEMIST_TOWER,
  ::location_t::LOCATION_ANCIENT_LAMP,
  ::location_t::LOCATION_ARCHERS_HOUSE,
  ::location_t::LOCATION_ARMY_CAMP,
  ::location_t::LOCATION_ARTESIAN_SPRING,
  ::location_t::LOCATION_ARTIFACT,
  ::location_t::LOCATION_BARRIER,
  ::location_t::LOCATION_BOAT,
  ::location_t::LOCATION_BOTTLE,
  ::location_t::LOCATION_BUOY,
  ::location_t::LOCATION_CACTUS,
  ::location_t::LOCATION_CAMPFIRE,
  ::location_t::LOCATION_CAVE,
  ::location_t::LOCATION_CITY_OF_DEAD,
  ::location_t::LOCATION_CRATER,
  ::location_t::LOCATION_DAEMON_CAVE,
  ::location_t::LOCATION_DEAD_TREE,
  ::location_t::LOCATION_DERELICT_SHIP,
  ::location_t::LOCATION_DESRT_TENT,
  ::location_t::LOCATION_DRAGON_CITY,
  ::location_t::LOCATION_DUNE,
  ::location_t::LOCATION_DWARF_CABIN,
  ::location_t::LOCATION_DWARF_COTTAGE,
  ::location_t::LOCATION_EVENT,
  ::location_t::LOCATION_EXCAVATION,
  ::location_t::LOCATION_EXPANSION_DWELLING,
  ::location_t::LOCATION_FAERIE_RING,
  ::location_t::LOCATION_FLOTSAM,
  ::location_t::LOCATION_FLOWERS,
  ::location_t::LOCATION_FORT,
  ::location_t::LOCATION_FOUNTAIN,
  ::location_t::LOCATION_FREEMANS_FOUNDRY,
  ::location_t::LOCATION_GAZEBO,
  ::location_t::LOCATION_GOBLIN_HUT,
  ::location_t::LOCATION_GRAVEYARD,
  ::location_t::LOCATION_HALFLING_HOLE,
  ::location_t::LOCATION_HERO,
  ::location_t::LOCATION_HILL_FORT,
  ::location_t::LOCATION_HOLE,
  ::location_t::LOCATION_IDOL,
  ::location_t::LOCATION_JAIL,
  ::location_t::LOCATION_LAKE,
  ::location_t::LOCATION_LAVA_POOL,
  ::location_t::LOCATION_LEAN_TO,
  ::location_t::LOCATION_LIGHTHOUSE,
  ::location_t::LOCATION_LOG_CABIN,
  ::location_t::LOCATION_MAGELLANS_MAPS,
  ::location_t::LOCATION_MAGIC_GARDEN,
  ::location_t::LOCATION_MAGIC_WELL,
  ::location_t::LOCATION_MANDRAKE,
  ::location_t::LOCATION_MERCENARY_CAMP,
  ::location_t::LOCATION_MINE,
  ::location_t::LOCATION_MOUND,
  ::location_t::LOCATION_MOUNTAINS,
  ::location_t::LOCATION_NOTHING_SPECIAL,
  ::location_t::LOCATION_OASIS,
  ::location_t::LOCATION_OBELISK,
  ::location_t::LOCATION_OBSERVATION_TOWER,
  ::location_t::LOCATION_ORACLE,
  ::location_t::LOCATION_OUTCROPPING,
  ::location_t::LOCATION_PEASANT_HUT,
  ::location_t::LOCATION_PYRAMID,
  ::location_t::LOCATION_RANDOM_ARTIFACT,
  ::location_t::LOCATION_RANDOM_ARTIFACT_MAJOR,
  ::location_t::LOCATION_RANDOM_ARTIFACT_MINOR,
  ::location_t::LOCATION_RANDOM_ARTIFACT_TREASURE,
  ::location_t::LOCATION_RANDOM_CASTLE,
  ::location_t::LOCATION_RANDOM_HERO,
  ::location_t::LOCATION_RANDOM_MONSTER,
  ::location_t::LOCATION_RANDOM_MONSTER_MEDIUM,
  ::location_t::LOCATION_RANDOM_MONSTER_STRONG,
  ::location_t::LOCATION_RANDOM_MONSTER_VERY_STRONG,
  ::location_t::LOCATION_RANDOM_MONSTER_WEAK,
  ::location_t::LOCATION_RANDOM_RESOURCE,
  ::location_t::LOCATION_RANDOM_TOWN,
  ::location_t::LOCATION_RESOURCE,
  ::location_t::LOCATION_ROAD,
  ::location_t::LOCATION_ROCK,
  ::location_t::LOCATION_RUINS,
  ::location_t::LOCATION_SAWMILL,
  ::location_t::LOCATION_SEA_CHEST,
  ::location_t::LOCATION_SHIPWRECK,
  ::location_t::LOCATION_SHIPWRECK_SURVIVOR,
  ::location_t::LOCATION_SHRINE_FIRST,
  ::location_t::LOCATION_SHRINE_SECOND_ORDER,
  ::location_t::LOCATION_SHRINE_THIRD_ORDER,
  ::location_t::LOCATION_SHRUB,
  ::location_t::LOCATION_SIGN,
  ::location_t::LOCATION_SKELETON,
  ::location_t::LOCATION_SPHINX,
  ::location_t::LOCATION_STANDING_STONES,
  ::location_t::LOCATION_STONE_LITHS,
  ::location_t::LOCATION_STREAM,
  ::location_t::LOCATION_STUMP,
  ::location_t::LOCATION_TAR_PIT,
  ::location_t::LOCATION_TEMPLE,
  ::location_t::LOCATION_TOWN,
  ::location_t::LOCATION_TRADING_POST,
  ::location_t::LOCATION_TRAVELLER_TENT,
  ::location_t::LOCATION_TREASURE_CHEST,
  ::location_t::LOCATION_TREES,
  ::location_t::LOCATION_TREE_CITY,
  ::location_t::LOCATION_TREE_HOUSE,
  ::location_t::LOCATION_TREE_OF_KNOWLEDGE,
  ::location_t::LOCATION_TROLL_BRIDGE,
  ::location_t::LOCATION_VOLCANO,
  ::location_t::LOCATION_WAGON,
  ::location_t::LOCATION_WAGON_CAMP,
  ::location_t::LOCATION_WATCH_TOWER,
  ::location_t::LOCATION_WATERING_HOLE,
  ::location_t::LOCATION_WATERWHEEL,
  ::location_t::LOCATION_WELL,
  ::location_t::LOCATION_WHIRLPOOL,
  ::location_t::LOCATION_WINDMILL,
  ::location_t::LOCATION_WITCH_DOCTORS_HUT,
  ::location_t::LOCATION_WITCH_HUT,
  ::location_t::LOCATION_XANADU
};

// overlays
//

overlays::
overlays ()
: ::xml_schema::type (),
  overlay_ (::xml_schema::flags (), this)
{
}

overlays::
overlays (const overlays& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  overlay_ (x.overlay_, f, this)
{
}

overlays::
overlays (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  overlay_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void overlays::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // overlay
    //
    if (n.name () == "overlay" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< overlay_type > r (
        overlay_traits::create (i, f, this));

      this->overlay_.push_back (r);
      continue;
    }

    break;
  }
}

overlays* overlays::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class overlays (*this, f, c);
}

overlays::
~overlays ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::overlays_ (isrc, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::overlays_ (isrc, h, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::overlays_ (isrc, h, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::overlays_ (isrc, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::overlays_ (isrc, h, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::overlays_ (isrc, h, f, p);
}

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::overlays > r (
    ::overlays_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::overlays >
overlays_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::overlays > r (
      ::overlays_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "overlays" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::overlays > r (
      ::xsd::cxx::tree::traits< ::overlays, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "overlays",
    "");
}

::std::auto_ptr< ::overlays >
overlays_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "overlays" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::overlays > r (
      ::xsd::cxx::tree::traits< ::overlays, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "overlays",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

