// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef OVERLAYS_XML_HXX
#define OVERLAYS_XML_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class overlay_t;
class terrain_mask_t;
class terrain_t;
class player_color_t;
class tileset_t;
class category_t;
class location_t;
class overlays;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class overlay_t: public ::xml_schema::type
{
  public:
  // tiles
  // 
  typedef ::xml_schema::string tiles_type;
  typedef ::xsd::cxx::tree::sequence< tiles_type > tiles_sequence;
  typedef tiles_sequence::iterator tiles_iterator;
  typedef tiles_sequence::const_iterator tiles_const_iterator;
  typedef ::xsd::cxx::tree::traits< tiles_type, char > tiles_traits;

  const tiles_sequence&
  tiles () const;

  tiles_sequence&
  tiles ();

  void
  tiles (const tiles_sequence& s);

  // animatedTiles
  // 
  typedef ::xml_schema::string animatedTiles_type;
  typedef ::xsd::cxx::tree::sequence< animatedTiles_type > animatedTiles_sequence;
  typedef animatedTiles_sequence::iterator animatedTiles_iterator;
  typedef animatedTiles_sequence::const_iterator animatedTiles_const_iterator;
  typedef ::xsd::cxx::tree::traits< animatedTiles_type, char > animatedTiles_traits;

  const animatedTiles_sequence&
  animatedTiles () const;

  animatedTiles_sequence&
  animatedTiles ();

  void
  animatedTiles (const animatedTiles_sequence& s);

  // coveredNonObstructed
  // 
  typedef ::xml_schema::string coveredNonObstructed_type;
  typedef ::xsd::cxx::tree::sequence< coveredNonObstructed_type > coveredNonObstructed_sequence;
  typedef coveredNonObstructed_sequence::iterator coveredNonObstructed_iterator;
  typedef coveredNonObstructed_sequence::const_iterator coveredNonObstructed_const_iterator;
  typedef ::xsd::cxx::tree::traits< coveredNonObstructed_type, char > coveredNonObstructed_traits;

  const coveredNonObstructed_sequence&
  coveredNonObstructed () const;

  coveredNonObstructed_sequence&
  coveredNonObstructed ();

  void
  coveredNonObstructed (const coveredNonObstructed_sequence& s);

  // shadows
  // 
  typedef ::xml_schema::string shadows_type;
  typedef ::xsd::cxx::tree::sequence< shadows_type > shadows_sequence;
  typedef shadows_sequence::iterator shadows_iterator;
  typedef shadows_sequence::const_iterator shadows_const_iterator;
  typedef ::xsd::cxx::tree::traits< shadows_type, char > shadows_traits;

  const shadows_sequence&
  shadows () const;

  shadows_sequence&
  shadows ();

  void
  shadows (const shadows_sequence& s);

  // validTerrain
  // 
  typedef ::terrain_t validTerrain_type;
  typedef ::xsd::cxx::tree::sequence< validTerrain_type > validTerrain_sequence;
  typedef validTerrain_sequence::iterator validTerrain_iterator;
  typedef validTerrain_sequence::const_iterator validTerrain_const_iterator;
  typedef ::xsd::cxx::tree::traits< validTerrain_type, char > validTerrain_traits;

  const validTerrain_sequence&
  validTerrain () const;

  validTerrain_sequence&
  validTerrain ();

  void
  validTerrain (const validTerrain_sequence& s);

  // idx
  // 
  typedef ::xml_schema::int_ idx_type;
  typedef ::xsd::cxx::tree::traits< idx_type, char > idx_traits;

  const idx_type&
  idx () const;

  idx_type&
  idx ();

  void
  idx (const idx_type& x);

  // idx2
  // 
  typedef ::xml_schema::int_ idx2_type;
  typedef ::xsd::cxx::tree::traits< idx2_type, char > idx2_traits;

  const idx2_type&
  idx2 () const;

  idx2_type&
  idx2 ();

  void
  idx2 (const idx2_type& x);

  // ordinal
  // 
  typedef ::xml_schema::int_ ordinal_type;
  typedef ::xsd::cxx::tree::traits< ordinal_type, char > ordinal_traits;

  const ordinal_type&
  ordinal () const;

  ordinal_type&
  ordinal ();

  void
  ordinal (const ordinal_type& x);

  // tileset
  // 
  typedef ::tileset_t tileset_type;
  typedef ::xsd::cxx::tree::traits< tileset_type, char > tileset_traits;

  const tileset_type&
  tileset () const;

  tileset_type&
  tileset ();

  void
  tileset (const tileset_type& x);

  void
  tileset (::std::auto_ptr< tileset_type > p);

  // category
  // 
  typedef ::category_t category_type;
  typedef ::xsd::cxx::tree::traits< category_type, char > category_traits;

  const category_type&
  category () const;

  category_type&
  category ();

  void
  category (const category_type& x);

  void
  category (::std::auto_ptr< category_type > p);

  // color
  // 
  typedef ::player_color_t color_type;
  typedef ::xsd::cxx::tree::traits< color_type, char > color_traits;

  const color_type&
  color () const;

  color_type&
  color ();

  void
  color (const color_type& x);

  void
  color (::std::auto_ptr< color_type > p);

  static const color_type&
  color_default_value ();

  // animationLength
  // 
  typedef ::xml_schema::int_ animationLength_type;
  typedef ::xsd::cxx::tree::traits< animationLength_type, char > animationLength_traits;

  const animationLength_type&
  animationLength () const;

  animationLength_type&
  animationLength ();

  void
  animationLength (const animationLength_type& x);

  static animationLength_type
  animationLength_default_value ();

  // Constructors.
  //
  overlay_t (const idx_type&,
             const idx2_type&,
             const ordinal_type&,
             const tileset_type&,
             const category_type&);

  overlay_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  overlay_t (const overlay_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual overlay_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~overlay_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  tiles_sequence tiles_;
  animatedTiles_sequence animatedTiles_;
  coveredNonObstructed_sequence coveredNonObstructed_;
  shadows_sequence shadows_;
  validTerrain_sequence validTerrain_;
  ::xsd::cxx::tree::one< idx_type > idx_;
  ::xsd::cxx::tree::one< idx2_type > idx2_;
  ::xsd::cxx::tree::one< ordinal_type > ordinal_;
  ::xsd::cxx::tree::one< tileset_type > tileset_;
  ::xsd::cxx::tree::one< category_type > category_;
  ::xsd::cxx::tree::one< color_type > color_;
  static const color_type color_default_value_;
  ::xsd::cxx::tree::one< animationLength_type > animationLength_;
};

class terrain_mask_t: public ::xml_schema::type
{
  public:
  // Constructors.
  //
  terrain_mask_t ();

  terrain_mask_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  terrain_mask_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  terrain_mask_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  terrain_mask_t (const terrain_mask_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual terrain_mask_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~terrain_mask_t ();
};

class terrain_t: public ::xml_schema::string
{
  public:
  enum value
  {
    TERRAIN_WATER,
    TERRAIN_GRASS,
    TERRAIN_SNOW,
    TERRAIN_SWAMP,
    TERRAIN_LAVA,
    TERRAIN_DESERT,
    TERRAIN_DIRT,
    TERRAIN_WASTELAND,
    TERRAIN_SAND
  };

  terrain_t (value v);

  terrain_t (const char* v);

  terrain_t (const ::std::string& v);

  terrain_t (const ::xml_schema::string& v);

  terrain_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  terrain_t (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  terrain_t (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  terrain_t (const terrain_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual terrain_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  terrain_t&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_terrain_t_convert ();
  }

  protected:
  value
  _xsd_terrain_t_convert () const;

  public:
  static const char* const _xsd_terrain_t_literals_[9];
  static const value _xsd_terrain_t_indexes_[9];
};

class player_color_t: public ::xml_schema::string
{
  public:
  enum value
  {
    PLAYER_BLUE,
    PLAYER_GREEN,
    PLAYER_YELLOW,
    PLAYER_RED,
    PLAYER_ORANGE,
    PLAYER_PURPLE
  };

  player_color_t (value v);

  player_color_t (const char* v);

  player_color_t (const ::std::string& v);

  player_color_t (const ::xml_schema::string& v);

  player_color_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  player_color_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  player_color_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  player_color_t (const player_color_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual player_color_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  player_color_t&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_player_color_t_convert ();
  }

  protected:
  value
  _xsd_player_color_t_convert () const;

  public:
  static const char* const _xsd_player_color_t_literals_[6];
  static const value _xsd_player_color_t_indexes_[6];
};

class tileset_t: public ::xml_schema::string
{
  public:
  enum value
  {
    TILESET_HAUNTED,
    TILESET_ARTIFACT,
    TILESET_MONSTER,
    TILESET_ARTIFACT_TAKEN,
    TILESET_FLAG,
    TILESET_RESOURCE_DISPLAY,
    TILESET_HOURGLASS,
    TILESET_ROUTE,
    TILESET_STONBACK,
    TILESET_MONSTER_ANIMATION,
    TILESET_HERO,
    TILESET_SNOW_MOUNTAIN,
    TILESET_SWAMP_MOUNTAIN,
    TILESET_LAVA_MOUNTAIN,
    TILESET_DESERT_MOUNTAIN,
    TILESET_DIRT_MOUNTAIN,
    TILESET_MOUNTAIN_MULTIPLE,
    TILESET_EXTRA_OVERLAY,
    TILESET_ROAD,
    TILESET_MOUNTAIN_CRACKED,
    TILESET_MOUNTAIN_GRASS,
    TILESET_TREE_JUNGLE,
    TILESET_TREE_EVIL,
    TILESET_OBJ_TOWN,
    TILESET_TOWN_TERRAIN,
    TILESET_TOWN_SHADOW,
    TILESET_TOWN_RANDOM,
    TILESET_OBJECT_EXTRA,
    TILESET_OBJECT_WATER_2,
    TILESET_OBJECT_MULTIPLE_2,
    TILESET_OBJECT_TREE_SNOW,
    TILESET_OBJECT_TREE_FIR,
    TILESET_OBJECT_TREE_FALL,
    TILESET_OBJECT_STREAM,
    TILESET_OBJECT_RESOURCE,
    TILESET_OBJECT_DUMMY,
    TILESET_OBJECT_GRASS_2,
    TILESET_OBJECT_TREE_DECIDUOUS,
    TILESET_OBJECT_WATER,
    TILESET_OBJECT_GRASS,
    TILESET_OBJECT_SNOW,
    TILESET_OBJECT_SWAMP,
    TILESET_OBJECT_LAVA,
    TILESET_OBJECT_DESERT,
    TILESET_OBJECT_DIRT,
    TILESET_OBJECT_CRACKED,
    TILESET_OBJECT_LAVA_3,
    TILESET_OBJECT_MULTIPLE,
    TILESET_OBJECT_LAVA_2,
    TILESET_OBJECT_EXPANSION_1,
    TILESET_OBJECT_EXPANSION_2,
    TILESET_OBJECT_EXPANSION_3
  };

  tileset_t (value v);

  tileset_t (const char* v);

  tileset_t (const ::std::string& v);

  tileset_t (const ::xml_schema::string& v);

  tileset_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  tileset_t (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  tileset_t (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  tileset_t (const tileset_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual tileset_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  tileset_t&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_tileset_t_convert ();
  }

  protected:
  value
  _xsd_tileset_t_convert () const;

  public:
  static const char* const _xsd_tileset_t_literals_[52];
  static const value _xsd_tileset_t_indexes_[52];
};

class category_t: public ::xml_schema::string
{
  public:
  enum value
  {
    CATEGORY_TERRAIN,
    CATEGORY_TREASURE,
    CATEGORY_CREATURE,
    CATEGORY_ARTIFACT,
    CATEGORY_TOWN,
    CATEGORY_BUILTIN,
    CATEGORY_HERO
  };

  category_t (value v);

  category_t (const char* v);

  category_t (const ::std::string& v);

  category_t (const ::xml_schema::string& v);

  category_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  category_t (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  category_t (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  category_t (const category_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual category_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  category_t&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_category_t_convert ();
  }

  protected:
  value
  _xsd_category_t_convert () const;

  public:
  static const char* const _xsd_category_t_literals_[7];
  static const value _xsd_category_t_indexes_[7];
};

class location_t: public ::xml_schema::string
{
  public:
  enum value
  {
    LOCATION_ALCHEMIST_LAB,
    LOCATION_SIGN,
    LOCATION_BUOY,
    LOCATION_SKELETON,
    LOCATION_DAEMON_CAVE,
    LOCATION_TREASURE_CHEST,
    LOCATION_FAERIE_RING,
    LOCATION_CAMPFIRE,
    LOCATION_FOUNTAIN,
    LOCATION_GAZEBO,
    LOCATION_ANCIENT_LAMP,
    LOCATION_GRAVEYARD,
    LOCATION_ARCHERS_HOUSE,
    LOCATION_GOBLIN_HUT,
    LOCATION_DWARF_COTTAGE,
    LOCATION_PEASANT_HUT,
    LOCATION_LOG_CABIN,
    LOCATION_ROAD,
    LOCATION_EVENT,
    LOCATION_DRAGON_CITY,
    LOCATION_LIGHTHOUSE,
    LOCATION_WATERWHEEL,
    LOCATION_MINE,
    LOCATION_ARMY_CAMP,
    LOCATION_OBELISK,
    LOCATION_OASIS,
    LOCATION_RESOURCE,
    LOCATION_SAWMILL,
    LOCATION_ORACLE,
    LOCATION_SHRINE_FIRST,
    LOCATION_SHIPWRECK,
    LOCATION_SEA_CHEST,
    LOCATION_DESRT_TENT,
    LOCATION_TOWN,
    LOCATION_STONE_LITHS,
    LOCATION_WAGON_CAMP,
    LOCATION_WELL,
    LOCATION_WHIRLPOOL,
    LOCATION_WINDMILL,
    LOCATION_ARTIFACT,
    LOCATION_HERO,
    LOCATION_BOAT,
    LOCATION_RANDOM_ARTIFACT,
    LOCATION_RANDOM_RESOURCE,
    LOCATION_RANDOM_MONSTER,
    LOCATION_RANDOM_TOWN,
    LOCATION_RANDOM_CASTLE,
    LOCATION_RANDOM_MONSTER_WEAK,
    LOCATION_RANDOM_MONSTER_MEDIUM,
    LOCATION_RANDOM_MONSTER_STRONG,
    LOCATION_RANDOM_MONSTER_VERY_STRONG,
    LOCATION_RANDOM_HERO,
    LOCATION_NOTHING_SPECIAL,
    LOCATION_WATCH_TOWER,
    LOCATION_TREE_HOUSE,
    LOCATION_TREE_CITY,
    LOCATION_RUINS,
    LOCATION_FORT,
    LOCATION_TRADING_POST,
    LOCATION_ABANDONED_MINE,
    LOCATION_DWARF_CABIN,
    LOCATION_STANDING_STONES,
    LOCATION_IDOL,
    LOCATION_TREE_OF_KNOWLEDGE,
    LOCATION_WITCH_DOCTORS_HUT,
    LOCATION_TEMPLE,
    LOCATION_HILL_FORT,
    LOCATION_HALFLING_HOLE,
    LOCATION_MERCENARY_CAMP,
    LOCATION_SHRINE_SECOND_ORDER,
    LOCATION_SHRINE_THIRD_ORDER,
    LOCATION_PYRAMID,
    LOCATION_CITY_OF_DEAD,
    LOCATION_EXCAVATION,
    LOCATION_SPHINX,
    LOCATION_WAGON,
    LOCATION_TAR_PIT,
    LOCATION_ARTESIAN_SPRING,
    LOCATION_TROLL_BRIDGE,
    LOCATION_WATERING_HOLE,
    LOCATION_WITCH_HUT,
    LOCATION_XANADU,
    LOCATION_CAVE,
    LOCATION_LEAN_TO,
    LOCATION_MAGELLANS_MAPS,
    LOCATION_FLOTSAM,
    LOCATION_DERELICT_SHIP,
    LOCATION_SHIPWRECK_SURVIVOR,
    LOCATION_BOTTLE,
    LOCATION_MAGIC_WELL,
    LOCATION_MAGIC_GARDEN,
    LOCATION_OBSERVATION_TOWER,
    LOCATION_FREEMANS_FOUNDRY,
    LOCATION_STREAM,
    LOCATION_TREES,
    LOCATION_MOUNTAINS,
    LOCATION_VOLCANO,
    LOCATION_FLOWERS,
    LOCATION_ROCK,
    LOCATION_LAKE,
    LOCATION_MANDRAKE,
    LOCATION_DEAD_TREE,
    LOCATION_STUMP,
    LOCATION_CRATER,
    LOCATION_CACTUS,
    LOCATION_MOUND,
    LOCATION_DUNE,
    LOCATION_LAVA_POOL,
    LOCATION_SHRUB,
    LOCATION_HOLE,
    LOCATION_OUTCROPPING,
    LOCATION_RANDOM_ARTIFACT_TREASURE,
    LOCATION_RANDOM_ARTIFACT_MINOR,
    LOCATION_RANDOM_ARTIFACT_MAJOR,
    LOCATION_BARRIER,
    LOCATION_TRAVELLER_TENT,
    LOCATION_EXPANSION_DWELLING,
    LOCATION_ALCHEMIST_TOWER,
    LOCATION_JAIL
  };

  location_t (value v);

  location_t (const char* v);

  location_t (const ::std::string& v);

  location_t (const ::xml_schema::string& v);

  location_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  location_t (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  location_t (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  location_t (const location_t& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual location_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  location_t&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_location_t_convert ();
  }

  protected:
  value
  _xsd_location_t_convert () const;

  public:
  static const char* const _xsd_location_t_literals_[119];
  static const value _xsd_location_t_indexes_[119];
};

class overlays: public ::xml_schema::type
{
  public:
  // overlay
  // 
  typedef ::overlay_t overlay_type;
  typedef ::xsd::cxx::tree::sequence< overlay_type > overlay_sequence;
  typedef overlay_sequence::iterator overlay_iterator;
  typedef overlay_sequence::const_iterator overlay_const_iterator;
  typedef ::xsd::cxx::tree::traits< overlay_type, char > overlay_traits;

  const overlay_sequence&
  overlay () const;

  overlay_sequence&
  overlay ();

  void
  overlay (const overlay_sequence& s);

  // Constructors.
  //
  overlays ();

  overlays (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  overlays (const overlays& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual overlays*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~overlays ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  overlay_sequence overlay_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::overlays >
overlays_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::overlays >
overlays_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // OVERLAYS_XML_HXX
