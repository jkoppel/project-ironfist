#include "base.h"
#include "game/game.h"
#include "xbrz/xbrz_indexed.h"

#include <iostream>
#include <map>

extern int iMainWinScreenWidth;
extern int iMainWinScreenHeight;
extern int gbEnlargeScreenBlit; //BOOL
extern void* hwndApp;
extern void* lpInitWin;
extern int bShowIt; //BOOL
extern int gbAllBlack; //BOOL
extern void* hpalApp;
//extern HPALETTE hpalApp;
extern void* hdcImage;
extern void* gbmOldMonoBitmap;
extern int giLimitUpdMinX;
extern class mouseManager* gpMouseManager;

extern "C" int __stdcall thunk_WinGRecommendDIBFormat(BITMAPINFO*);
extern "C" int __stdcall thunk_WinGCreateDC(void);
extern "C" HBITMAP __stdcall thunk_WinGCreateBitmap(HDC, BITMAPINFO*, void**);

extern void __fastcall InitializePalette();

extern DWORD dword_530418;

extern struct _IMAGE screenImage;


static bool draw_mask_0 = true;
static bool draw_mask_1 = true;
static bool draw_mask_2 = true;
static bool draw_mask_3 = true;
static bool draw_mask_4 = true;
static bool draw_mask_5 = true;
static bool draw_mask_6 = true;

int __fastcall KeyboardMessageHandler_orig(void *, unsigned int, unsigned int, long);
int __fastcall KeyboardMessageHandler(void *a1, unsigned int a2, unsigned int a3, long a4)
	{
	const int KEYCODE_KEY_1 = 49;
	const int KEYCODE_KEY_2 = 50;
	const int KEYCODE_KEY_3 = 51;
	const int KEYCODE_KEY_4 = 52;
	const int KEYCODE_KEY_5 = 53;
	const int KEYCODE_KEY_6 = 54;
	const int KEYCODE_KEY_7 = 55;
	/*
	if(evt->eventCode == INPUT_KEYDOWN_EVENT_CODE)
	{
	if(evt->xCoordOrKeycode == 88 && evt->inputTypeBitmask & 3)
	heroWindowManager::ScreenShot(gpWindowManager);
	*/
	//1 == 49
	tag_message *evt; // esi@5
					  //evt = &gpInputManager->inputInstances[gpInputManager->currentInfoField];

					  //if(evt->eventCode == INPUT_KEYDOWN_EVENT_CODE)
	if(a2 & 1)
		{
		if(a3 == KEYCODE_KEY_1)
			draw_mask_0 = !draw_mask_0;
		if(a3 == KEYCODE_KEY_2)
			draw_mask_1 = !draw_mask_1;
		if(a3 == KEYCODE_KEY_3)
			draw_mask_2 = !draw_mask_2;
		if(a3 == KEYCODE_KEY_4)
			draw_mask_3 = !draw_mask_3;
		if(a3 == KEYCODE_KEY_5)
			draw_mask_4 = !draw_mask_4;
		if(a3 == KEYCODE_KEY_6)
			draw_mask_5 = !draw_mask_5;
		if(a3 == KEYCODE_KEY_7)
			draw_mask_6 = !draw_mask_6;
		}
	return KeyboardMessageHandler_orig(a1, a2, a3, a4);
	}


int __fastcall WGAppPaint_orig(void *, void *);
int __fastcall WGAppPaint(void* thisptr, void* ptr2)
	{
	HDC v2; // [sp+Ch] [bp-78h]@2
	HWND hWnd; // [sp+10h] [bp-74h]@1
	struct tagPAINTSTRUCT Paint; // [sp+20h] [bp-64h]@2
	int v5; // [sp+60h] [bp-24h]@2
	int v6; // [sp+64h] [bp-20h]@2
	int v7; // [sp+68h] [bp-1Ch]@2
	char v8; // [sp+70h] [bp-14h]@1
	struct tagRECT Rect; // [sp+74h] [bp-10h]@2

	extern void* hpalApp;
	//extern HPALETTE hpalApp;
	extern void* hdcImage;
	extern int giScrollX;
	extern int giScrollY;
	hWnd = (HWND)thisptr;
	v8 = 0;
	if(draw_mask_0)
		return WGAppPaint_orig(thisptr, ptr2);

	//return 1;
	///////////////
	if(lpInitWin)
		{
		//InvalidateRect(hWnd, &Rect, false);
		v2 = BeginPaint(hWnd, &Paint);
		SelectPalette(v2, (HPALETTE)hpalApp, 0);
		RealizePalette(v2);
		GetClientRect(hWnd, &Rect);

		v7 = Rect.right - Rect.left;
		v5 = 0 / iMainWinScreenWidth;
		v6 = 0 / iMainWinScreenHeight;
		//extern DWORD dword_519704;
		extern int giScrollX;
		extern int giScrollY;
		if(giScrollX)
			v5 += giScrollX;
		if(giScrollY)
			v6 += giScrollY;
		//++dword_519704;
		//_thunk_WinGStretchBlt@40
		if(iMainWinScreenWidth != 640 || iMainWinScreenHeight != 480)
			{
			//thunk_WinGStretchBlt(
			//_thunk_WinGStretchBlt_impl(
			int sz = Rect.bottom - Rect.top;

			//WinGStretchBlt_impl(
			//	(int)v2,
			//	///v2,
			//	0,
			//	0,
			//	v7,
			//	Rect.bottom - Rect.top,
			//	(int)hdcImage,
			//	//(HDC)hdcImage,
			//	v5,
			//	v6,
			//	640 * v7 / iMainWinScreenWidth,
			//	480 * (Rect.bottom - Rect.top) / iMainWinScreenHeight);

			static HDC buffer_hdc = nullptr;
			static HBITMAP buffer_bmp = nullptr;
			//static uint32_t* buffer = nullptr;
			static BITMAP bm1;
			static BITMAP bm2;
			if(!buffer_hdc)
				{
				HBITMAP screenbmp = (HBITMAP)GetCurrentObject((HDC)hdcImage, OBJ_BITMAP);
				GetObject(screenbmp, sizeof(BITMAP), &bm1);
				std::cout << bm1.bmWidth << ", " << bm1.bmWidthBytes << "\n";

				buffer_hdc = CreateCompatibleDC((HDC)hdcImage);
				buffer_bmp = CreateCompatibleBitmap((HDC)hdcImage, 1280, -960);
				SelectObject(buffer_hdc, buffer_bmp);
				//buffer = new uint32_t[1280 * 960 * 3];
				//int res = GetDIBits((HDC)hdcImage, )

				GetObject(buffer_bmp, sizeof(BITMAP), &bm2);
				std::cout << bm2.bmWidth << ", " << bm2.bmWidthBytes << "\n";
				}
			//float factor = .25;
			//bitmap* screen = gpWindowManager->screenBuffer;
			//if(!draw_mask_5)
			//	{

			//	//xbrz::nearestNeighborScale((const uint32_t*)screen->contents,
			//	//						   (int)screen->width * factor, (int)screen->height * factor,
			//	//						   (uint32_t*)buffer->contents,
			//	//						   (int)buffer->width * factor, (int)buffer->height * factor);

			//	////memcpy(screen->contents, buffer->contents, 480 * 480 );
			//	//memcpy(screen->contents, screen->contents + 480, 480 * 480);

			//	}
			//int mode = GetStretchBltMode((HDC)hdcImage);
			/*struct _PALETTE {
			WORD        palVersion;
			WORD        palNumEntries;
			_Field_size_opt_(palNumEntries) PALETTEENTRY        palPalEntry[1];
			};*/
			//extern struct LogicalPalette;
			//LOGPALETTE curpal = *(LOGPALETTE*)&LogicalPalette;
			SetStretchBltMode((HDC)hdcImage, COLORONCOLOR);
			SetStretchBltMode(buffer_hdc, COLORONCOLOR);
			//BOOL res = BitBlt(buffer_hdc, 0, 0, 800, 480, (HDC)hdcImage, 0, 0, SRCCOPY);

			if(draw_mask_1)
				StretchBlt(buffer_hdc, 0, 0, 1280, 960, (HDC)hdcImage, 0, 0, 640, 480, SRCCOPY);
			bitmap* screen = gpWindowManager->screenBuffer;

			static uint32_t* srcbuf = new uint32_t[800 * 480];
			static uint32_t* dstbuf = new uint32_t[1280 * 960];

			if(draw_mask_2)
				xbrz::nearestNeighborScale((uint8_t*)bm1.bmBits, 640, 480, (uint8_t*)bm2.bmBits, 1280, 960);

			int pos = 0;
			//if(!draw_mask_7)
			//	{
			//	BITMAP bm;
			//	GetObject(buffer_bmp, sizeof(BITMAP), &bm);
			//	//xbrz::scale(2, (const uint32_t*)screen->contents, (uint32_t*)bm.bmBits, 500, 400);
			//	xbrz::nearestNeighborScale((const uint32_t*)screen->contents, 320, 240, (uint32_t*)bm.bmBits, 640, 480);
			//	/*for(int y = 0; y < 960; y++)
			//		for(int x = 0; x < 1280; x++)
			//			{
			//			COLORREF c = dstbuf[pos++];
			//			SetPixel(buffer_hdc, x, y, c);
			//			}*/
			//	}

			static const unsigned char colors[] = { 0x00,0xff,0xff,0xff,0x96,0xff,0xff,0x64,0xff,0xff,0x32,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0xb4,0x00,0xff,0x00,0xff,0x00,0xc9,0xc9,0xff,0xb9,0xb9,0xff,0xfc,0xfc,0xfc,0xf0,0xf0,0xf0,0xe8,0xe8,0xe8,0xdc,0xdc,0xdc,0xd4,0xd4,0xd4,0xc8,0xc8,0xc8,0xc0,0xc0,0xc0,0xb4,0xb4,0xb4,0xac,0xac,0xac,0xa4,0xa4,0xa4,0x98,0x98,0x98,0x90,0x90,0x90,0x84,0x84,0x84,0x7c,0x7c,0x7c,0x70,0x70,0x70,0x68,0x68,0x68,0x5c,0x5c,0x5c,0x54,0x54,0x54,0x48,0x48,0x48,0x40,0x40,0x40,0x38,0x38,0x38,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x18,0x18,0x18,0x10,0x10,0x10,0x04,0x04,0x04,0x00,0x00,0x00,0xfc,0xec,0xdc,0xf0,0xdc,0xc8,0xe8,0xd0,0xb8,0xe0,0xc4,0xa8,0xd8,0xb8,0x98,0xd0,0xa8,0x88,0xc8,0xa0,0x78,0xc0,0x94,0x6c,0xb8,0x88,0x60,0xac,0x7c,0x54,0xa4,0x70,0x48,0x9c,0x68,0x3c,0x94,0x60,0x34,0x8c,0x54,0x2c,0x84,0x4c,0x20,0x7c,0x44,0x1c,0x74,0x3c,0x14,0x68,0x34,0x10,0x60,0x30,0x0c,0x58,0x28,0x08,0x50,0x24,0x04,0x48,0x1c,0x04,0x3c,0x18,0x00,0x34,0x14,0x00,0x2c,0x10,0x00,0x24,0x0c,0x00,0xc0,0xcc,0xfc,0xac,0xb8,0xf0,0x98,0xa8,0xe8,0x88,0x98,0xe0,0x78,0x88,0xd8,0x68,0x78,0xd0,0x58,0x68,0xc4,0x4c,0x58,0xbc,0x40,0x4c,0xb4,0x34,0x40,0xac,0x28,0x34,0xa4,0x20,0x30,0x98,0x1c,0x28,0x90,0x14,0x24,0x88,0x10,0x20,0x80,0x0c,0x1c,0x78,0x08,0x18,0x70,0x04,0x14,0x64,0x04,0x14,0x5c,0x00,0x10,0x54,0x00,0x0c,0x4c,0x00,0x0c,0x44,0xac,0xe0,0x9c,0x9c,0xd4,0x8c,0x90,0xcc,0x80,0x80,0xc0,0x70,0x74,0xb8,0x64,0x68,0xb0,0x5c,0x5c,0xa4,0x50,0x50,0x9c,0x44,0x48,0x90,0x3c,0x3c,0x88,0x30,0x34,0x7c,0x28,0x2c,0x74,0x24,0x24,0x6c,0x1c,0x20,0x64,0x18,0x18,0x5c,0x14,0x14,0x54,0x0c,0x0c,0x4c,0x08,0x08,0x40,0x04,0x04,0x38,0x04,0x04,0x30,0x00,0x00,0x28,0x00,0x00,0x20,0x00,0x00,0x18,0x00,0xfc,0xf4,0xd0,0xf8,0xe8,0xac,0xf4,0xe0,0x8c,0xf0,0xdc,0x6c,0xec,0xd4,0x50,0xe8,0xcc,0x34,0xe4,0xc8,0x14,0xe0,0xc4,0x00,0xd8,0xbc,0x20,0xd0,0xb0,0x1c,0xc8,0xa0,0x18,0xbc,0x98,0x18,0xb4,0x8c,0x18,0xa8,0x7c,0x14,0x9c,0x70,0x10,0x94,0x64,0x0c,0x88,0x58,0x0c,0x7c,0x4c,0x08,0x74,0x44,0x08,0x68,0x3c,0x00,0x60,0x30,0x00,0x54,0x28,0x00,0x4c,0x20,0x00,0xe4,0xcc,0xf8,0xd8,0xbc,0xec,0xc8,0xa8,0xe4,0xc0,0x9c,0xd8,0xb4,0x8c,0xd0,0xa8,0x7c,0xc4,0x9c,0x70,0xbc,0x90,0x64,0xb4,0x84,0x58,0xa8,0x78,0x4c,0xa0,0x70,0x44,0x94,0x64,0x38,0x8c,0x5c,0x30,0x80,0x50,0x28,0x78,0x48,0x20,0x6c,0x40,0x18,0x64,0x38,0x14,0x5c,0x2c,0x08,0x50,0x20,0x04,0x44,0x18,0x00,0x38,0x10,0x00,0x2c,0xb4,0xf4,0xfc,0xa8,0xe8,0xf0,0xa0,0xe0,0xe8,0x94,0xd8,0xe0,0x88,0xcc,0xd4,0x80,0xc4,0xcc,0x78,0xb8,0xc4,0x70,0xb0,0xbc,0x64,0xa8,0xb0,0x5c,0x9c,0xa8,0x58,0x94,0xa0,0x50,0x8c,0x94,0x48,0x80,0x8c,0x40,0x74,0x80,0x38,0x68,0x74,0x30,0x60,0x6c,0x28,0x54,0x60,0x20,0x4c,0x58,0x1c,0x40,0x4c,0x14,0x38,0x40,0x10,0x2c,0x38,0x0c,0x24,0x2c,0x08,0x1c,0x24,0xfc,0xe4,0xe4,0xf4,0xd0,0xd0,0xf0,0xbc,0xbc,0xe8,0xac,0xac,0xe4,0x9c,0x9c,0xdc,0x8c,0x8c,0xd8,0x7c,0x7c,0xd0,0x6c,0x6c,0xcc,0x5c,0x5c,0xc4,0x50,0x50,0xc0,0x44,0x44,0xbc,0x38,0x38,0xb8,0x2c,0x2c,0xb4,0x24,0x24,0xa8,0x20,0x20,0x9c,0x18,0x18,0x90,0x10,0x10,0x84,0x0c,0x0c,0x78,0x08,0x08,0x6c,0x04,0x04,0x60,0x00,0x00,0x54,0x00,0x00,0x48,0x00,0x00,0xfc,0xe4,0x9c,0xf8,0xd8,0x8c,0xf4,0xd0,0x7c,0xf0,0xc4,0x70,0xec,0xb8,0x60,0xe8,0xac,0x50,0xe4,0xa0,0x44,0xe0,0x90,0x38,0xe0,0x84,0x2c,0xcc,0x74,0x20,0xb8,0x64,0x18,0xa4,0x58,0x10,0x94,0x48,0x08,0x80,0x3c,0x04,0x6c,0x30,0x00,0x5c,0x28,0x00,0xfc,0x58,0x0c,0xdc,0x34,0x04,0xc0,0x14,0x00,0xa4,0x00,0x00,0xfc,0xfc,0x00,0xfc,0xcc,0x00,0xc0,0x8c,0x00,0x8c,0x48,0x00,0xa4,0xd0,0x00,0x94,0xbc,0x00,0x84,0xac,0x00,0x78,0x9c,0x04,0x68,0x8c,0x04,0x5c,0x78,0x04,0x4c,0x68,0x04,0x40,0x58,0x04,0x34,0x48,0x04,0x28,0x78,0xd0,0x18,0x68,0xc4,0x04,0x48,0xb4,0x00,0x38,0xac,0x0c,0x54,0xbc,0x00,0x38,0xac,0x00,0x40,0xb4,0x84,0xe0,0xfc,0x00,0x98,0xfc,0x00,0x50,0xe4,0x00,0x00,0xa4,0x8c,0x8c,0xbc,0x70,0x70,0x9c,0x54,0x54,0x7c,0x3c,0x3c,0x5c,0xa9,0xa9,0xff,0x99,0x99,0xff,0x89,0x89,0xff,0x79,0x79,0xff,0x69,0x69,0xff,0x59,0x59,0xff,0x49,0x49,0xff,0x39,0x39,0xff,0x29,0x29,0xff,0x19,0x19,0xff };

			std::map<unsigned int, unsigned char> reverse_palette;
			//uint32_t* color_table = (uint32_t*)colors;

			if(!draw_mask_6)
				{
				//xbrz::nearestNeighborScale((uint8_t*)bm1.bmBits, 800, 480, (uint8_t*)bm2.bmBits, 1600, 960);
				pos = 0;
				//for(int y = 0; y < 480; y++)
				//	for(int x = 0; x < 800; x++)
				RECT AdjustedRect;
				//AdjustedRect.left = (Rect.left * 800) / iMainWinScreenWidth;
				//AdjustedRect.right = (Rect.right * 800) / iMainWinScreenWidth;
				//AdjustedRect.top = (Rect.top * 480) / iMainWinScreenHeight;
				//AdjustedRect.bottom = (Rect.bottom * 480) / iMainWinScreenHeight;
				//for(int y = AdjustedRect.top; y < AdjustedRect.bottom; y++)
				//	for(int x = AdjustedRect.left; x < AdjustedRect.right; x++)
				for(int y = 0; y < 480 / 4; y++)
					for(int x = 0; x < 640 / 4; x++)
						{
						//COLORREF c = GetPixel((HDC)hdcImage, x, y);
						unsigned char palettized_color = ((unsigned char*)bm1.bmBits)[y * bm1.bmWidthBytes + x];
						unsigned char r = colors[palettized_color * 3 + 0];
						unsigned char g = colors[palettized_color * 3 + 1];
						unsigned char b = colors[palettized_color * 3 + 2];
						uint32_t c = (b << 8 * 2) | (g << 8) | r;

						reverse_palette[c] = palettized_color;
						pos = y * 480 + x;
						srcbuf[pos] = c;
						//SetPixel(buffer_hdc, x, y, c);
						}
				//xbrz::nearestNeighborScale(srcbuf, 800, 480, dstbuf, 1600, 960);
				xbrz::ScalerCfg cfg;
				cfg.equalColorTolerance_ = 0;
				xbrz::scale(2, srcbuf, dstbuf, 640, 480, cfg);
				//xbrz::scale(2, srcbuf, dstbuf, Rect.right - Rect.left, Rect.top - Rect.bottom);

				pos = 0;

				//for(int y = AdjustedRect.top*2; y < AdjustedRect.bottom*2; y++)
				//	for(int x = AdjustedRect.left*2; x < AdjustedRect.right*2; x++)
				for(int y = 0; y < 960 / 4; y++)
					for(int x = 0; x < 1280 / 4; x++)
						{
						//uint32_t c = dstbuf[pos];
						//((unsigned char*)bm2.bmBits)[pos++] = reverse_palette[c];
						pos = y * 960 + x;
						COLORREF c = dstbuf[pos];
						SetPixel(buffer_hdc, x, y, c);
						}
				}

			if(iMainWinScreenWidth != 800 || iMainWinScreenHeight != 600)
				{
				//int old_blt_mode = SetStretchBltMode(v2, HALFTONE);
				int old_blt_mode = SetStretchBltMode(v2, COLORONCOLOR);

				StretchBlt(
					(HDC)v2,
					///v2,
					0,
					0,
					v7,
					Rect.bottom - Rect.top,
					(HDC)buffer_hdc,
					//(HDC)hdcImage,
					v5,
					v6,
					1280 * v7 / iMainWinScreenWidth,
					960 * (Rect.bottom - Rect.top) / iMainWinScreenHeight,
					SRCCOPY);
				SetStretchBltMode(v2, old_blt_mode);
				}
			else
				{
				v7 = Paint.rcPaint.right - (unsigned __int16)(Paint.rcPaint.left & 0xFFFC) + 1;
				BitBlt(
					(HDC)v2,
					Paint.rcPaint.left & 0xFFFC,
					Paint.rcPaint.top,
					v7,
					Paint.rcPaint.bottom - Paint.rcPaint.top + 1,
					(HDC)buffer_hdc,
					//(HDC)hdcImage,
					giScrollX + (unsigned __int16)(Paint.rcPaint.left & 0xFFFC),
					giScrollY + Paint.rcPaint.top,
					SRCCOPY);
				}

			}
		else
			{
			v7 = Paint.rcPaint.right - (unsigned __int16)(Paint.rcPaint.left & 0xFFFC) + 1;
			BitBlt(
				(HDC)v2,
				Paint.rcPaint.left & 0xFFFC,
				Paint.rcPaint.top,
				v7,
				Paint.rcPaint.bottom - Paint.rcPaint.top + 1,
				(HDC)hdcImage,
				giScrollX + (unsigned __int16)(Paint.rcPaint.left & 0xFFFC),
				giScrollY + Paint.rcPaint.top,
				SRCCOPY);
			}
		EndPaint(hWnd, &Paint);
		}
	//return WGAppPaint_orig(thisptr, ptr2);
	return 1;
	}
