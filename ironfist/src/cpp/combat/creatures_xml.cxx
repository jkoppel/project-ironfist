// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "creatures_xml.hxx"

// creatures_t
// 

const creatures_t::creature_sequence& creatures_t::
creature () const
{
  return this->creature_;
}

creatures_t::creature_sequence& creatures_t::
creature ()
{
  return this->creature_;
}

void creatures_t::
creature (const creature_sequence& s)
{
  this->creature_ = s;
}


// damage_t
// 

const damage_t::minimum_type& damage_t::
minimum () const
{
  return this->minimum_.get ();
}

damage_t::minimum_type& damage_t::
minimum ()
{
  return this->minimum_.get ();
}

void damage_t::
minimum (const minimum_type& x)
{
  this->minimum_.set (x);
}

const damage_t::maximum_type& damage_t::
maximum () const
{
  return this->maximum_.get ();
}

damage_t::maximum_type& damage_t::
maximum ()
{
  return this->maximum_.get ();
}

void damage_t::
maximum (const maximum_type& x)
{
  this->maximum_.set (x);
}


// random_spawn_t
// 

const random_spawn_t::minimum_type& random_spawn_t::
minimum () const
{
  return this->minimum_.get ();
}

random_spawn_t::minimum_type& random_spawn_t::
minimum ()
{
  return this->minimum_.get ();
}

void random_spawn_t::
minimum (const minimum_type& x)
{
  this->minimum_.set (x);
}

const random_spawn_t::maximum_type& random_spawn_t::
maximum () const
{
  return this->maximum_.get ();
}

random_spawn_t::maximum_type& random_spawn_t::
maximum ()
{
  return this->maximum_.get ();
}

void random_spawn_t::
maximum (const maximum_type& x)
{
  this->maximum_.set (x);
}


// creature_attribute_t
// 

const creature_attribute_t::name_type& creature_attribute_t::
name () const
{
  return this->name_.get ();
}

creature_attribute_t::name_type& creature_attribute_t::
name ()
{
  return this->name_.get ();
}

void creature_attribute_t::
name (const name_type& x)
{
  this->name_.set (x);
}

void creature_attribute_t::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// creature_t
// 

const creature_t::damage_sequence& creature_t::
damage () const
{
  return this->damage_;
}

creature_t::damage_sequence& creature_t::
damage ()
{
  return this->damage_;
}

void creature_t::
damage (const damage_sequence& s)
{
  this->damage_ = s;
}

const creature_t::random_spawn_sequence& creature_t::
random_spawn () const
{
  return this->random_spawn_;
}

creature_t::random_spawn_sequence& creature_t::
random_spawn ()
{
  return this->random_spawn_;
}

void creature_t::
random_spawn (const random_spawn_sequence& s)
{
  this->random_spawn_ = s;
}

const creature_t::creature_attribute_sequence& creature_t::
creature_attribute () const
{
  return this->creature_attribute_;
}

creature_t::creature_attribute_sequence& creature_t::
creature_attribute ()
{
  return this->creature_attribute_;
}

void creature_t::
creature_attribute (const creature_attribute_sequence& s)
{
  this->creature_attribute_ = s;
}

const creature_t::id_type& creature_t::
id () const
{
  return this->id_.get ();
}

creature_t::id_type& creature_t::
id ()
{
  return this->id_.get ();
}

void creature_t::
id (const id_type& x)
{
  this->id_.set (x);
}

const creature_t::name_singular_type& creature_t::
name_singular () const
{
  return this->name_singular_.get ();
}

creature_t::name_singular_type& creature_t::
name_singular ()
{
  return this->name_singular_.get ();
}

void creature_t::
name_singular (const name_singular_type& x)
{
  this->name_singular_.set (x);
}

void creature_t::
name_singular (::std::auto_ptr< name_singular_type > x)
{
  this->name_singular_.set (x);
}

const creature_t::name_plural_type& creature_t::
name_plural () const
{
  return this->name_plural_.get ();
}

creature_t::name_plural_type& creature_t::
name_plural ()
{
  return this->name_plural_.get ();
}

void creature_t::
name_plural (const name_plural_type& x)
{
  this->name_plural_.set (x);
}

void creature_t::
name_plural (::std::auto_ptr< name_plural_type > x)
{
  this->name_plural_.set (x);
}

const creature_t::icn_type& creature_t::
icn () const
{
  return this->icn_.get ();
}

creature_t::icn_type& creature_t::
icn ()
{
  return this->icn_.get ();
}

void creature_t::
icn (const icn_type& x)
{
  this->icn_.set (x);
}

void creature_t::
icn (::std::auto_ptr< icn_type > x)
{
  this->icn_.set (x);
}

const creature_t::frm_type& creature_t::
frm () const
{
  return this->frm_.get ();
}

creature_t::frm_type& creature_t::
frm ()
{
  return this->frm_.get ();
}

void creature_t::
frm (const frm_type& x)
{
  this->frm_.set (x);
}

void creature_t::
frm (::std::auto_ptr< frm_type > x)
{
  this->frm_.set (x);
}

const creature_t::cost_type& creature_t::
cost () const
{
  return this->cost_.get ();
}

creature_t::cost_type& creature_t::
cost ()
{
  return this->cost_.get ();
}

void creature_t::
cost (const cost_type& x)
{
  this->cost_.set (x);
}

const creature_t::fight_value_type& creature_t::
fight_value () const
{
  return this->fight_value_.get ();
}

creature_t::fight_value_type& creature_t::
fight_value ()
{
  return this->fight_value_.get ();
}

void creature_t::
fight_value (const fight_value_type& x)
{
  this->fight_value_.set (x);
}

const creature_t::fight_value_aux_type& creature_t::
fight_value_aux () const
{
  return this->fight_value_aux_.get ();
}

creature_t::fight_value_aux_type& creature_t::
fight_value_aux ()
{
  return this->fight_value_aux_.get ();
}

void creature_t::
fight_value_aux (const fight_value_aux_type& x)
{
  this->fight_value_aux_.set (x);
}

const creature_t::growth_type& creature_t::
growth () const
{
  return this->growth_.get ();
}

creature_t::growth_type& creature_t::
growth ()
{
  return this->growth_.get ();
}

void creature_t::
growth (const growth_type& x)
{
  this->growth_.set (x);
}

const creature_t::hp_type& creature_t::
hp () const
{
  return this->hp_.get ();
}

creature_t::hp_type& creature_t::
hp ()
{
  return this->hp_.get ();
}

void creature_t::
hp (const hp_type& x)
{
  this->hp_.set (x);
}

const creature_t::faction_type& creature_t::
faction () const
{
  return this->faction_.get ();
}

creature_t::faction_type& creature_t::
faction ()
{
  return this->faction_.get ();
}

void creature_t::
faction (const faction_type& x)
{
  this->faction_.set (x);
}

const creature_t::speed_type& creature_t::
speed () const
{
  return this->speed_.get ();
}

creature_t::speed_type& creature_t::
speed ()
{
  return this->speed_.get ();
}

void creature_t::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

const creature_t::attack_type& creature_t::
attack () const
{
  return this->attack_.get ();
}

creature_t::attack_type& creature_t::
attack ()
{
  return this->attack_.get ();
}

void creature_t::
attack (const attack_type& x)
{
  this->attack_.set (x);
}

const creature_t::defense_type& creature_t::
defense () const
{
  return this->defense_.get ();
}

creature_t::defense_type& creature_t::
defense ()
{
  return this->defense_.get ();
}

void creature_t::
defense (const defense_type& x)
{
  this->defense_.set (x);
}

const creature_t::shots_type& creature_t::
shots () const
{
  return this->shots_.get ();
}

creature_t::shots_type& creature_t::
shots ()
{
  return this->shots_.get ();
}

void creature_t::
shots (const shots_type& x)
{
  this->shots_.set (x);
}

const creature_t::short_name_type& creature_t::
short_name () const
{
  return this->short_name_.get ();
}

creature_t::short_name_type& creature_t::
short_name ()
{
  return this->short_name_.get ();
}

void creature_t::
short_name (const short_name_type& x)
{
  this->short_name_.set (x);
}

void creature_t::
short_name (::std::auto_ptr< short_name_type > x)
{
  this->short_name_.set (x);
}

const creature_t::secondary_cost_id_type& creature_t::
secondary_cost_id () const {
	return this->secondary_cost_id_.get();
}

creature_t::secondary_cost_id_type& creature_t::
secondary_cost_id () {
	return this->secondary_cost_id_.get();
}

void creature_t::
secondary_cost_id (const secondary_cost_id_type& x) {
	this->secondary_cost_id_.set(x);
}

void creature_t::
secondary_cost_id (::std::auto_ptr< secondary_cost_id_type > x) {
	this->secondary_cost_id_.set(x);
}

const creature_t::secondary_cost_type& creature_t::
secondary_cost() const {
	return this->secondary_cost_.get();
}

creature_t::secondary_cost_type& creature_t::
secondary_cost() {
	return this->secondary_cost_.get();
}

void creature_t::
secondary_cost(const secondary_cost_type& x) {
	this->secondary_cost_.set(x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// creatures_t
//

creatures_t::
creatures_t ()
: ::xml_schema::type (),
  creature_ (::xml_schema::flags (), this)
{
}

creatures_t::
creatures_t (const creatures_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  creature_ (x.creature_, f, this)
{
}

creatures_t::
creatures_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  creature_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void creatures_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // creature
    //
    if (n.name () == "creature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creature_type > r (
        creature_traits::create (i, f, this));

      this->creature_.push_back (r);
      continue;
    }

    break;
  }
}

creatures_t* creatures_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class creatures_t (*this, f, c);
}

creatures_t::
~creatures_t ()
{
}

// damage_t
//

damage_t::
damage_t (const minimum_type& minimum,
          const maximum_type& maximum)
: ::xml_schema::type (),
  minimum_ (minimum, ::xml_schema::flags (), this),
  maximum_ (maximum, ::xml_schema::flags (), this)
{
}

damage_t::
damage_t (const damage_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minimum_ (x.minimum_, f, this),
  maximum_ (x.maximum_, f, this)
{
}

damage_t::
damage_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minimum_ (f, this),
  maximum_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void damage_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "minimum" && n.namespace_ ().empty ())
    {
      this->minimum_.set (minimum_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maximum" && n.namespace_ ().empty ())
    {
      this->maximum_.set (maximum_traits::create (i, f, this));
      continue;
    }
  }

  if (!minimum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "minimum",
      "");
  }

  if (!maximum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "maximum",
      "");
  }
}

damage_t* damage_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class damage_t (*this, f, c);
}

damage_t::
~damage_t ()
{
}

// random_spawn_t
//

random_spawn_t::
random_spawn_t (const minimum_type& minimum,
                const maximum_type& maximum)
: ::xml_schema::type (),
  minimum_ (minimum, ::xml_schema::flags (), this),
  maximum_ (maximum, ::xml_schema::flags (), this)
{
}

random_spawn_t::
random_spawn_t (const random_spawn_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minimum_ (x.minimum_, f, this),
  maximum_ (x.maximum_, f, this)
{
}

random_spawn_t::
random_spawn_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minimum_ (f, this),
  maximum_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void random_spawn_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "minimum" && n.namespace_ ().empty ())
    {
      this->minimum_.set (minimum_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "maximum" && n.namespace_ ().empty ())
    {
      this->maximum_.set (maximum_traits::create (i, f, this));
      continue;
    }
  }

  if (!minimum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "minimum",
      "");
  }

  if (!maximum_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "maximum",
      "");
  }
}

random_spawn_t* random_spawn_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class random_spawn_t (*this, f, c);
}

random_spawn_t::
~random_spawn_t ()
{
}

// creature_attribute_t
//

creature_attribute_t::
creature_attribute_t (const name_type& name)
: ::xml_schema::type (),
  name_ (name, ::xml_schema::flags (), this)
{
}

creature_attribute_t::
creature_attribute_t (const creature_attribute_t& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

creature_attribute_t::
creature_attribute_t (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void creature_attribute_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name_.set (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

creature_attribute_t* creature_attribute_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class creature_attribute_t (*this, f, c);
}

creature_attribute_t::
~creature_attribute_t ()
{
}

// creature_t
//

creature_t::
creature_t(const id_type& id,
	const name_singular_type& name_singular,
	const name_plural_type& name_plural,
	const icn_type& icn,
	const frm_type& frm,
	const cost_type& cost,
	const fight_value_type& fight_value,
	const fight_value_aux_type& fight_value_aux,
	const growth_type& growth,
	const hp_type& hp,
	const faction_type& faction,
	const speed_type& speed,
	const attack_type& attack,
	const defense_type& defense,
	const shots_type& shots,
	const short_name_type& short_name,
	const secondary_cost_id_type& secondary_cost_id,
	const secondary_cost_type& secondary_cost)
	: ::xml_schema::type(),
	damage_(::xml_schema::flags(), this),
	random_spawn_(::xml_schema::flags(), this),
	creature_attribute_(::xml_schema::flags(), this),
	id_(id, ::xml_schema::flags(), this),
	name_singular_(name_singular, ::xml_schema::flags(), this),
	name_plural_(name_plural, ::xml_schema::flags(), this),
	icn_(icn, ::xml_schema::flags(), this),
	frm_(frm, ::xml_schema::flags(), this),
	cost_(cost, ::xml_schema::flags(), this),
	fight_value_(fight_value, ::xml_schema::flags(), this),
	fight_value_aux_(fight_value_aux, ::xml_schema::flags(), this),
	growth_(growth, ::xml_schema::flags(), this),
	hp_(hp, ::xml_schema::flags(), this),
	faction_(faction, ::xml_schema::flags(), this),
	speed_(speed, ::xml_schema::flags(), this),
	attack_(attack, ::xml_schema::flags(), this),
	defense_(defense, ::xml_schema::flags(), this),
	shots_(shots, ::xml_schema::flags(), this),
	short_name_(short_name, ::xml_schema::flags(), this),
	secondary_cost_id_(secondary_cost_id, ::xml_schema::flags(), this),
	secondary_cost_(secondary_cost, ::xml_schema::flags(), this)
{
}

creature_t::
creature_t(const creature_t& x,
	::xml_schema::flags f,
	::xml_schema::container* c)
	: ::xml_schema::type(x, f, c),
	damage_(x.damage_, f, this),
	random_spawn_(x.random_spawn_, f, this),
	creature_attribute_(x.creature_attribute_, f, this),
	id_(x.id_, f, this),
	name_singular_(x.name_singular_, f, this),
	name_plural_(x.name_plural_, f, this),
	icn_(x.icn_, f, this),
	frm_(x.frm_, f, this),
	cost_(x.cost_, f, this),
	fight_value_(x.fight_value_, f, this),
	fight_value_aux_(x.fight_value_aux_, f, this),
	growth_(x.growth_, f, this),
	hp_(x.hp_, f, this),
	faction_(x.faction_, f, this),
	speed_(x.speed_, f, this),
	attack_(x.attack_, f, this),
	defense_(x.defense_, f, this),
	shots_(x.shots_, f, this),
	short_name_(x.short_name_, f, this),
	secondary_cost_id_(x.secondary_cost_id_, f, this),
	secondary_cost_(x.secondary_cost_, f, this)
{
}

creature_t::
creature_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  damage_ (f, this),
  random_spawn_ (f, this),
  creature_attribute_ (f, this),
  id_ (f, this),
  name_singular_ (f, this),
  name_plural_ (f, this),
  icn_ (f, this),
  frm_ (f, this),
  cost_ (f, this),
  fight_value_ (f, this),
  fight_value_aux_ (f, this),
  growth_ (f, this),
  hp_ (f, this),
  faction_ (f, this),
  speed_ (f, this),
  attack_ (f, this),
  defense_ (f, this),
  shots_ (f, this),
  short_name_ (f, this),
  secondary_cost_id_ (f, this),
  secondary_cost_(f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void creature_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // damage
    //
    if (n.name () == "damage" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< damage_type > r (
        damage_traits::create (i, f, this));

      this->damage_.push_back (r);
      continue;
    }

    // random-spawn
    //
    if (n.name () == "random-spawn" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< random_spawn_type > r (
        random_spawn_traits::create (i, f, this));

      this->random_spawn_.push_back (r);
      continue;
    }

    // creature-attribute
    //
    if (n.name () == "creature-attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creature_attribute_type > r (
        creature_attribute_traits::create (i, f, this));

      this->creature_attribute_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "name-singular" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_singular_type > r (
        name_singular_traits::create (i, f, this));

      this->name_singular_.set (r);
      continue;
    }

    if (n.name () == "name-plural" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_plural_type > r (
        name_plural_traits::create (i, f, this));

      this->name_plural_.set (r);
      continue;
    }

    if (n.name () == "icn" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< icn_type > r (
        icn_traits::create (i, f, this));

      this->icn_.set (r);
      continue;
    }

    if (n.name () == "frm" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< frm_type > r (
        frm_traits::create (i, f, this));

      this->frm_.set (r);
      continue;
    }

    if (n.name () == "cost" && n.namespace_ ().empty ())
    {
      this->cost_.set (cost_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fight-value" && n.namespace_ ().empty ())
    {
      this->fight_value_.set (fight_value_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fight-value-aux" && n.namespace_ ().empty ())
    {
      this->fight_value_aux_.set (fight_value_aux_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "growth" && n.namespace_ ().empty ())
    {
      this->growth_.set (growth_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "hp" && n.namespace_ ().empty ())
    {
      this->hp_.set (hp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "faction" && n.namespace_ ().empty ())
    {
      this->faction_.set (faction_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      this->speed_.set (speed_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "attack" && n.namespace_ ().empty ())
    {
      this->attack_.set (attack_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "defense" && n.namespace_ ().empty ())
    {
      this->defense_.set (defense_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shots" && n.namespace_ ().empty ())
    {
      this->shots_.set (shots_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "short-name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< short_name_type > r (
        short_name_traits::create (i, f, this));

      this->short_name_.set (r);
      continue;
    }
	if (n.name() == "secondary_cost_id" && n.namespace_().empty())
	{
		::std::auto_ptr< secondary_cost_id_type > r(
		  secondary_cost_id_traits::create(i, f, this));

		this->secondary_cost_id_.set (r);
		continue;
	}
	if (n.name() == "secondary_cost" && n.namespace_().empty())
	{
		this->secondary_cost_.set(secondary_cost_traits::create(i, f, this));
		continue;
	}
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!name_singular_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name-singular",
      "");
  }

  if (!name_plural_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name-plural",
      "");
  }

  if (!icn_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "icn",
      "");
  }

  if (!frm_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frm",
      "");
  }

  if (!cost_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cost",
      "");
  }

  if (!fight_value_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fight-value",
      "");
  }

  if (!fight_value_aux_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fight-value-aux",
      "");
  }

  if (!growth_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "growth",
      "");
  }

  if (!hp_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "hp",
      "");
  }

  if (!faction_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "faction",
      "");
  }

  if (!speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "speed",
      "");
  }

  if (!attack_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "attack",
      "");
  }

  if (!defense_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "defense",
      "");
  }

  if (!shots_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "shots",
      "");
  }

  if (!short_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "short-name",
      "");
  }
}

creature_t* creature_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class creature_t (*this, f, c);
}

creature_t::
~creature_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::creatures_t >
creatures (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creatures (isrc, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creatures (isrc, h, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creatures (isrc, h, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creatures (isrc, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creatures (isrc, h, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creatures (isrc, h, f, p);
}

::std::auto_ptr< ::creatures_t >
creatures (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creatures_t > r (
    ::creatures (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creatures_t >
creatures (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::creatures_t > r (
      ::creatures (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "creatures" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creatures_t > r (
      ::xsd::cxx::tree::traits< ::creatures_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creatures",
    "");
}

::std::auto_ptr< ::creatures_t >
creatures (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "creatures" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creatures_t > r (
      ::xsd::cxx::tree::traits< ::creatures_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creatures",
    "");
}

::std::auto_ptr< ::creature_t >
creature (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature (isrc, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature (isrc, h, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature (isrc, h, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature (isrc, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature (isrc, h, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature (isrc, h, f, p);
}

::std::auto_ptr< ::creature_t >
creature (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_t > r (
    ::creature (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_t >
creature (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::creature_t > r (
      ::creature (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "creature" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creature_t > r (
      ::xsd::cxx::tree::traits< ::creature_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creature",
    "");
}

::std::auto_ptr< ::creature_t >
creature (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "creature" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creature_t > r (
      ::xsd::cxx::tree::traits< ::creature_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creature",
    "");
}

::std::auto_ptr< ::damage_t >
damage (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::damage (isrc, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::damage (isrc, h, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::damage (isrc, h, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::damage (isrc, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::damage (isrc, h, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::damage (isrc, h, f, p);
}

::std::auto_ptr< ::damage_t >
damage (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::damage_t > r (
    ::damage (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::damage_t >
damage (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::damage_t > r (
      ::damage (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "damage" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::damage_t > r (
      ::xsd::cxx::tree::traits< ::damage_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "damage",
    "");
}

::std::auto_ptr< ::damage_t >
damage (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "damage" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::damage_t > r (
      ::xsd::cxx::tree::traits< ::damage_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "damage",
    "");
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::random_spawn (isrc, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::random_spawn (isrc, h, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::random_spawn (isrc, h, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::random_spawn (isrc, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::random_spawn (isrc, h, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::random_spawn (isrc, h, f, p);
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::random_spawn_t > r (
    ::random_spawn (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::random_spawn_t > r (
      ::random_spawn (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "random-spawn" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::random_spawn_t > r (
      ::xsd::cxx::tree::traits< ::random_spawn_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "random-spawn",
    "");
}

::std::auto_ptr< ::random_spawn_t >
random_spawn (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "random-spawn" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::random_spawn_t > r (
      ::xsd::cxx::tree::traits< ::random_spawn_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "random-spawn",
    "");
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature_attribute (isrc, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature_attribute (isrc, h, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::creature_attribute (isrc, h, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature_attribute (isrc, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature_attribute (isrc, h, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::creature_attribute (isrc, h, f, p);
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::creature_attribute_t > r (
    ::creature_attribute (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::creature_attribute_t > r (
      ::creature_attribute (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "creature-attribute" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creature_attribute_t > r (
      ::xsd::cxx::tree::traits< ::creature_attribute_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creature-attribute",
    "");
}

::std::auto_ptr< ::creature_attribute_t >
creature_attribute (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "creature-attribute" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::creature_attribute_t > r (
      ::xsd::cxx::tree::traits< ::creature_attribute_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "creature-attribute",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

